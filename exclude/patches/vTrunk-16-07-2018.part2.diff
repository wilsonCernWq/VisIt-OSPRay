diff --git a/CMakeLists.txt b/CMakeLists.txt
index a2b91e962..59214668f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -426,6 +426,9 @@
 #    icons. Previously, this resulted in a couple of invalid symbolic links
 #    ending up in the distribution file.
 #
+#    Qi WU, Sat Jun 10 22:21:27 MST 2018
+#    I added support to find OSPRay
+#
 #****************************************************************************/
 
 CMAKE_MINIMUM_REQUIRED(VERSION 3.8 FATAL_ERROR)
@@ -694,8 +697,8 @@ SET(CXX_TEST_PATH ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
 # configure options
 #-----------------------------------------------------------------------------
 OPTION(VISIT_PARALLEL "Build VisIt's parallel compute engine." OFF)
-
 OPTION(VISIT_SLIVR    "Build VisIt with support for the SLIVR volume rendering library." ON)
+OPTION(VISIT_OSPRAY   "Build VisIt with support for the OSPRay volume rendering library." OFF)
 OPTION(VISIT_STATIC   "Build VisIt statically." OFF)
 IF(VISIT_STATIC)
     ADD_DEFINITIONS(-DVISIT_STATIC)
@@ -871,6 +874,11 @@ VISIT_3RDPARTY_VAR(ZLIB_DIR      "Path containing the zlib library's include and
 VISIT_3RDPARTY_VAR(MOAB_DIR      "Path containing the MOAB library's include and lib")
 VISIT_3RDPARTY_VAR(MOAB_MPI_DIR  "Path containing the parallel MOAB library's include and lib")
 
+VISIT_3RDPARTY_VAR(OSPRAY_DIR    "Path containing the OSPRay library's include and lib")
+VISIT_3RDPARTY_VAR(EMBREE_ROOT   "Path containing the embree library's include and lib")
+VISIT_3RDPARTY_VAR(ISPC_ROOT     "Path containing the ISPC library's include and lib")
+VISIT_3RDPARTY_VAR(TBB_ROOT      "Path containing the TBB library's include and lib")
+
 #-----------------------------------------------------------------------------
 # Read the version
 #-----------------------------------------------------------------------------
@@ -1154,11 +1162,33 @@ ELSE(VISIT_THREAD)
     MESSAGE(STATUS "Threading for VisIt: OFF")
 ENDIF(VISIT_THREAD)
 
+# Enable OSPRay for VisIt
 IF(VISIT_OSPRAY)
+    # setup variables 
+    SET(OSPRAY_USE_EXTERNAL_EMBREE ON)
+    SET(ospray_DIR ${OSPRAY_DIR})
+    SET(embree_DIR ${EMBREE_ROOT})
+    SET(ISPC_EXECUTABLE ${ISPC_ROOT})
+    IF(NOT DEFINED TBB_ROOT)
+      SET(TBB_ROOT ${VISIT_TBB_ROOT})
+    ENDIF(NOT DEFINED TBB_ROOT)     
+    FIND_PACKAGE(ospray REQUIRED)
+    # setup ospray
     ADD_DEFINITIONS(-DVISIT_OSPRAY)
-    MESSAGE(STATUS "OSPRAY for VisIt: ON")
+    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIR})
+    LINK_DIRECTORIES(${VISIT_OSPRAY_DIR}/../..)
+    # additional module library
+    SET(OSPRAY_LIBRARIES
+      ${OSPRAY_LIBRARIES}
+      ${LIBRARY_PATH_PREFIX}ospray_module_ispc${LIBRARY_SUFFIX}
+      ${LIBRARY_PATH_PREFIX}ospray_module_visit${LIBRARY_SUFFIX}
+      ${LIBRARY_PATH_PREFIX}ospray_module_visit_common${LIBRARY_SUFFIX})
+    # debug
+    MESSAGE(STATUS "OSPRAY_INCLUDE_DIR: " ${OSPRAY_INCLUDE_DIR})
+    MESSAGE(STATUS "OSPRAY_LIBRARIES: " ${OSPRAY_LIBRARIES})
+    MESSAGE(STATUS "OSPRay for VisIt: ON")
 ELSE(VISIT_OSPRAY)
-    MESSAGE(STATUS "OSPRAY for VisIt: OFF")
+    MESSAGE(STATUS "OSPRay for VisIt: OFF")
 ENDIF(VISIT_OSPRAY)
 
 #-----------------------------------------------------------------------------
diff --git a/avt/Filters/CMakeLists.txt b/avt/Filters/CMakeLists.txt
index e0f4d336e..e01be9754 100644
--- a/avt/Filters/CMakeLists.txt
+++ b/avt/Filters/CMakeLists.txt
@@ -131,14 +131,42 @@ avtWorldSpaceToImageSpaceTransform.C
 avtXRayFilter.C
 )
 
-if (VISIT_SLIVR)
-    list(APPEND AVTFILTERS_SOURCES
-         avtImgCommunicator.C
+IF(VISIT_SLIVR)
+    LIST(APPEND AVTFILTERS_SOURCES
+         avtSLIVRCommon.C
+         avtSLIVRImageCompositor.C
          avtSLIVRRayTracer.C
          avtSLIVRSamplePointExtractor.C
          avtSLIVRVoxelExtractor.C)
-    add_definitions(-DVISIT_SLIVR)
-endif()
+    ADD_DEFINITIONS(-DVISIT_SLIVR)
+ENDIF()
+
+IF(VISIT_OSPRAY)
+    LIST(APPEND AVTFILTERS_SOURCES
+         avtOSPRayCommon.C
+         avtOSPRayImageCompositor.C
+         avtOSPRayRayTracer.C
+         avtOSPRaySamplePointExtractor.C
+         avtOSPRayVoxelExtractor.C
+	 )
+    ADD_DEFINITIONS(-DVISIT_OSPRAY)
+    IF(ICET_FOUND)
+        # If we have Ice-T then add -DHAVE_ICET to the compilation flags.
+        # We need to link with OpenGL on Mac when we have IceT.
+        IF(APPLE)
+            SET(ICET_OPENGL ${OPENGL_gl_LIBRARY})
+        ENDIF(APPLE)
+        # Link icet libraries using absolute pathes
+	SET(ICET_FULLPATH_LIB ${ICET_OPENGL})
+	FOREACH(X ${ICET_LIB})
+	    LIST(APPEND ICET_FULLPATH_LIB "${ICET_LIBRARY_DIR}/${X}")
+	ENDFOREACH()
+        # Other setups
+        INCLUDE_DIRECTORIES(${ICET_INCLUDE_DIR})
+        LINK_DIRECTORIES(${ICET_LIBRARY_DIR})
+        ADD_DEFINITIONS(-DVISIT_OSPRAY_ICET)
+    ENDIF()
+ENDIF()
 
 INCLUDE_DIRECTORIES(
 ${CMAKE_CURRENT_SOURCE_DIR}
@@ -178,11 +206,23 @@ ENDIF()
 #********************************* SERIAL ************************************
 ADD_LIBRARY(avtfilters_ser ${AVTFILTERS_SOURCES})
 TARGET_LINK_LIBRARIES(avtfilters_ser visitcommon lightweight_visit_vtk visit_vtk avtmath avtview avtpipeline_ser avtdatabase_ser avtdbatts ${EAVL_LIB} ${VISIT_VTKM_LIB} vtkFiltersModeling)
+IF(VISIT_OSPRAY) 
+    TARGET_LINK_LIBRARIES(avtfilters_ser ${OSPRAY_LIBRARIES})
+    IF(ICET_FOUND)
+        TARGET_LINK_LIBRARIES(avtfilters_ser ${ICET_FULLPATH_LIB})
+    ENDIF()
+ENDIF() 
 VISIT_INSTALL_TARGETS(avtfilters_ser)
 
 #********************************* PARALLEL **********************************
 IF(VISIT_PARALLEL)
     ADD_PARALLEL_LIBRARY(avtfilters_par ${AVTFILTERS_SOURCES})
     TARGET_LINK_LIBRARIES(avtfilters_par visitcommon lightweight_visit_vtk visit_vtk avtmath avtview avtpipeline_par avtdatabase_par avtdbatts ${EAVL_LIB} ${VISIT_VTKM_LIB} vtkFiltersModeling)
+    IF(VISIT_OSPRAY) 
+        TARGET_LINK_LIBRARIES(avtfilters_par ${OSPRAY_LIBRARIES})
+        IF(ICET_FOUND)
+            TARGET_LINK_LIBRARIES(avtfilters_par ${ICET_FULLPATH_LIB})
+        ENDIF()
+    ENDIF()
     VISIT_INSTALL_TARGETS(avtfilters_par)
 ENDIF(VISIT_PARALLEL)
diff --git a/avt/Filters/avtOSPRayCommon.C b/avt/Filters/avtOSPRayCommon.C
new file mode 100644
index 000000000..8b8b1befc
--- /dev/null
+++ b/avt/Filters/avtOSPRayCommon.C
@@ -0,0 +1,1099 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2017, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+#include <avtOSPRayCommon.h>
+
+#include <avtParallel.h>
+#include <avtMemory.h>
+
+#include <DebugStream.h>
+#include <StackTimer.h>
+#include <TimingsManager.h>
+#include <ImproperUseException.h>
+
+#include <vtkCamera.h>
+#include <vtkMatrix4x4.h>
+
+#include <ospray/ospray.h>
+#include <ospray/visit/VisItModuleCommon.h>
+#include <ospray/visit/VisItExtraLibraries.h>
+#include <ospray/visit/VisItImageComposite.h>
+#include <ospray/ospcommon/vec.h>
+#include <cmath>
+#include <vector>
+
+#ifdef __unix__
+# include <unistd.h>
+#endif
+
+static bool CheckThreadedBlend_MetaData() {
+    bool use = true;
+    const char* env_use = std::getenv("OSPRAY_SERIAL_BLEND");
+    if (env_use) { use = atoi(env_use) <= 0; }
+    return use;
+}
+
+static bool UseThreadedBlend_MetaData = CheckThreadedBlend_MetaData();
+
+std::ostream *ospray::osp_out = (ospray::visit::CheckVerbose()) ?
+    &std::cout : &DebugStream::Stream5();
+std::ostream *ospray::osp_err = (ospray::visit::CheckVerbose()) ?
+    &std::cerr : &DebugStream::Stream1();
+
+// ***************************************************************************
+//
+// OSPRay
+//
+// ***************************************************************************
+
+using namespace ospcommon;
+
+namespace ospray {
+  namespace visit {
+    
+    template<typename T> 
+    void ospray_check(const T& obj, const std::string s) {
+      if (!obj) { 
+        if (CheckVerbose()) {
+          std::cerr << s << " is invalid" << std::endl; 
+        }
+        throw std::runtime_error(s + " is invalid");
+      }
+    }
+    
+    // =====================================================================//
+    //
+    // =====================================================================//
+    struct Color { float R,G,B,A; };
+
+    // =====================================================================//
+    //
+    // =====================================================================//
+    TransferFunction::TransferFunction(TransferFunctionCore& other)
+      : Manipulator<CoreType, OSPType>(other) {}
+    void TransferFunction::Set(const void *_table,
+                               const unsigned int size, 
+                               const double datamin, 
+                               const double datamax) 
+    {
+      // initialize it once
+      if (!core->init) 
+      {
+        ospray_rm(core->self);
+        core->self = ospNewTransferFunction("piecewise_linear");
+        ospray_check(core->self, "transfer function");
+        core->init = true;
+      }
+      // create OSP data
+      const Color* table = reinterpret_cast<const Color*>(_table);
+      std::vector<vec3f> cdata;
+      std::vector<float> odata;
+      for (unsigned int i = 0; i < size; ++i)
+      {
+        cdata.emplace_back(table[i].R, table[i].G, table[i].B);
+        odata.emplace_back(table[i].A);
+      }
+      OSPData osp_cdata = ospNewData(cdata.size(), OSP_FLOAT3, cdata.data());
+      OSPData osp_odata = ospNewData(odata.size(), OSP_FLOAT,  odata.data());
+      ospray_check(osp_cdata,"TFN color data");
+      ospray_check(osp_odata,"TFN opacity data");
+      // commit
+      ospSetData(core->self, "colors",    osp_cdata);
+      ospSetData(core->self, "opacities", osp_odata);
+      ospSet2f(core->self, "valueRange", datamin, datamax);
+      ospCommit(core->self);
+      // cleanup
+      ospray_rm(osp_cdata);
+      ospray_rm(osp_odata);
+    }
+
+    // =====================================================================//
+    //
+    // =====================================================================//
+    Camera::Camera(CameraCore& other) 
+      : Manipulator<CoreType, OSPType>(other) {}
+    void Camera::Set(const bool ortho,
+                     const double camera_p[3], 
+                     const double camera_f[3], 
+                     const double camera_u[3], 
+                     const double fovy,
+                     const double pan_ratio[2],
+                     const double zoom_ratio,
+                     const double near_clip,
+                     const double canvas_size[2],
+                     const int screen_size[2], /* overall screen size */
+                     const int tile_extents[4] /*      tile size      */)
+    {
+      // create camera
+      if (!core->init || (ortho != core->orthographic))
+      {
+        core->orthographic = ortho;
+        ospray_rm(core->self);
+        core->self = core->orthographic ? 
+          ospNewCamera("orthographic") : 
+          ospNewCamera("perspective");
+        ospray_check(core->self, "camera");
+        core->init = true;
+      }
+      // compute camera
+      core->zoom = zoom_ratio;
+      core->pan[0] = pan_ratio[0];
+      core->pan[1] = pan_ratio[1];
+      core->screenSize[0] = screen_size[0];
+      core->screenSize[1] = screen_size[1];
+      // commit
+      ospSet1f(core->self, "nearClip", near_clip);
+      ospSet3f(core->self, "pos", 
+               camera_p[0], 
+               camera_p[1], 
+               camera_p[2]);
+      ospSet3f(core->self, "dir", 
+               camera_f[0] - camera_p[0], 
+               camera_f[1] - camera_p[1], 
+               camera_f[2] - camera_p[2]);
+      ospSet3f(core->self, "up",
+               camera_u[0],
+               camera_u[1], 
+               camera_u[2]);
+      ospSet1f(core->self, "aspect", 
+               static_cast<double>(screen_size[0]) /
+               static_cast<double>(screen_size[1]));
+      if (!ortho)
+        ospSet1f(core->self, "fovy", fovy / core->zoom);
+      else
+        ospSet1f(core->self, "height", canvas_size[1]);
+      SetScreen(tile_extents[0], tile_extents[1],
+                tile_extents[2], tile_extents[3]);
+    }
+    void Camera::SetScreen(const double xMin, const double xMax,
+                           const double yMin, const double yMax) 
+    {
+      core->windowExts[0] = std::max(static_cast<int>(std::round(xMin)), 0);
+      core->windowExts[1] = std::min(static_cast<int>(std::round(xMax)), 
+                                     core->screenSize[0]);
+      core->windowExts[2] = std::max(static_cast<int>(std::round(yMin)), 0);
+      core->windowExts[3] = std::min(static_cast<int>(std::round(yMax)), 
+                                     core->screenSize[1]);
+      const double r_xl = xMin/core->screenSize[0] - core->pan[0];
+      const double r_yl = yMin/core->screenSize[1] - core->pan[1];
+      const double r_xu = xMax/core->screenSize[0] - core->pan[0];
+      const double r_yu = yMax/core->screenSize[1] - core->pan[1];
+      ospSet2f(core->self, "imageStart", r_xl, r_yl);
+      ospSet2f(core->self, "imageEnd",   r_xu, r_yu);
+      ospCommit(core->self);
+    }
+
+    // =====================================================================//
+    //
+    // =====================================================================//
+    Light::Light(LightCore& other) 
+      : Manipulator<CoreType, OSPType>(other) {}
+    void Light::Set(const bool ambient, const double i, 
+                    const double c, const double* d)
+    {
+      Set(ambient, i, c, c, c, d);
+    }
+    void Light::Set(const bool ambient, const double i, 
+                    const double cr, const double cg, const double cb,
+                    const double* d)
+    {
+      const double c[3] = {cr, cg, cb};
+      Set(ambient, i, c, d);
+    }
+    void Light::Set(const bool ambient, const double i, 
+                    const double c[3], const double* d)
+    {
+      // create light
+      if (!core->init || ambient != core->isAmbient) {
+        ospray_rm(core->self);
+        core->self = ospNewLight2("scivis", "distant");
+        ospray_check(core->self, "light");
+        ospSet1i(core->self, "isVisible", 0);
+        ospSet1f(core->self, "angularDiameter", 0.53f);
+        core->init = true;
+      }
+      // commit light
+      ospSet1f(core->self, "intensity", i);
+      ospSet3f(core->self, "color", c[0], c[1], c[2]);
+      if (!ambient) {
+        ospSet3f(core->self, "direction", d[0], d[1], d[2]);
+      }
+      ospCommit(core->self);
+    }
+
+    // =====================================================================//
+    //
+    // =====================================================================//
+    Renderer::Renderer(RendererCore& other) 
+      : Manipulator<CoreType, OSPType>(other) {}
+    void Renderer::Init()
+    {
+      if (!core->init) {
+        ospray_rm(core->self);
+        core->self = ospNewRenderer("scivis");
+        ospray_check(core->self, "SCIVIS Renderer");
+        core->init = true;
+      }
+    }
+    void Renderer::ResetLights()
+    {
+      if (!core->init) { Init(); }
+      ospray_rm(core->lightData);
+      core->lightList.clear();
+    }
+    Light Renderer::AddLight()
+    {
+      core->lightList.emplace_back();
+      return Light(core->lightList.back());
+    }
+    void Renderer::FinalizeLights()
+    {
+      std::vector<OSPLight> osp_light_list;
+      for (auto& l : core->lightList) { osp_light_list.emplace_back(*l); }
+      ospray_rm(core->lightData);
+      core->lightData = ospNewData(osp_light_list.size(), OSP_OBJECT, 
+                                   osp_light_list.data());
+      ospray_check(core->lightData, "light list");
+    }
+    void Renderer::Set(const int aoSamples, const int spp, 
+                       const bool oneSidedLighting,
+                       const bool shadowsEnabled,
+                       const bool aoTransparencyEnabled)
+    {
+      if (!core->init) { Init(); }   
+      ospSet1i(core->self, "aoSamples", aoSamples);
+      ospSet1i(core->self, "spp", spp);
+      ospSet1i(core->self, "oneSidedLighting", oneSidedLighting);
+      ospSet1i(core->self, "shadowsEnabled", shadowsEnabled);
+      ospSet1i(core->self, "aoTransparencyEnabled", aoTransparencyEnabled);
+      ospSetData(core->self, "lights", core->lightData);
+      ospCommit(core->self);
+    }
+    void Renderer::Set(OSPCamera osp_camera)
+    {
+      if (!core->init) { Init(); }
+      ospSetObject(core->self, "camera", osp_camera);
+      ospCommit(core->self);
+    }
+    void Renderer::Set(OSPModel osp_world)
+    {
+      if (!core->init) { Init(); }
+      ospSetObject(core->self, "model", osp_world);
+      ospCommit(core->self);
+    }
+    
+    // =====================================================================//
+    //
+    // =====================================================================//
+    Model::Model(ModelCore& other)
+      : Manipulator<CoreType, OSPType>(other) {}
+    void Model::Reset()
+    {
+      core->init = false;
+    }
+    void Model::Init()
+    {
+      if (!core->init) {
+        ospray_rm(core->self);
+        core->self = ospNewModel();
+        ospray_check(core->self, "Model");
+        core->init = true;
+      }
+    }
+    void Model::Set(OSPVolume volume)
+    {
+      if (!core->init) { Init(); }
+      ospAddVolume(core->self, volume);
+      ospCommit(core->self);
+    }
+
+    // =====================================================================//
+    //
+    // =====================================================================//
+    Volume::Volume(VolumeCore& other)
+      : Manipulator<CoreType, OSPType>(other) {}
+    bool Volume::Init(const std::string volume_type, 
+                      const OSPDataType data_type, 
+                      const std::string data_char,
+                      const size_t data_size, 
+                      const void* data_ptr,
+		      const bool use_grid_accelerator)
+    {
+      if (!core->init || 
+          volume_type != core->volumeType ||
+          data_type   != core->dataType   ||
+          data_size   != core->dataSize   ||
+          data_ptr    != core->dataPtr    ||
+	  use_grid_accelerator != core->useGridAccelerator)
+	  
+      {
+        core->volumeType = volume_type;
+        core->dataType = data_type;
+        core->dataSize = data_size;
+        core->dataPtr  = data_ptr;
+	core->useGridAccelerator = use_grid_accelerator;
+        ospray_rm(core->self);
+        core->self = ospNewVolume(volume_type.c_str());
+        ospray_check(core->self, volume_type);
+        if (volume_type == "visit_shared_structured_volume" ||
+            volume_type == "shared_structured_volume") 
+        {
+          OSPData osp_data = ospNewData(data_size, data_type,
+                                        data_ptr, OSP_DATA_SHARED_BUFFER);
+          ospSetString(core->self, "voxelType", data_char.c_str());
+          ospSetData(core->self, "voxelData", osp_data);
+          ospray_rm(osp_data);
+        }
+	// TODO: there is a bug inside the module_visit, therefore we cannot enable grid
+	//       accelerator currently
+	ospSet1i(core->self, "useGridAccelerator", /*(int)use_grid_accelerator*/false);
+        core->init = true;
+        return true;
+      }
+      return false;
+    }
+    void Volume::Set(const bool adaptiveSampling,
+                     const bool preIntegration, 
+                     const bool singleShade, 
+                     const bool gradientShadingEnabled, 
+                     const double samplingRate, 
+                     const double Ks, const double Ns,
+                     const double *X, const double *Y, const double *Z, 
+                     const int nX, const int nY, const int nZ,
+                     const double dbox[6], const double cbox[6], 
+                     const osp::vec3f& global_upper,
+                     const osp::vec3f& global_lower,
+                     const osp::vec3f& scale,
+                     OSPTransferFunction tfn)
+    {
+      const vec3i dims(nX, nY, nZ);
+      const vec3f data_lower(vec3f(dbox[0], dbox[1], dbox[2]) * (const vec3f&)scale);
+      const vec3f data_upper(vec3f(dbox[3], dbox[4], dbox[5]) * (const vec3f&)scale);
+      const vec3f clip_lower(vec3f(cbox[0], cbox[1], cbox[2]) * (const vec3f&)scale);
+      const vec3f clip_upper(vec3f(cbox[3], cbox[4], cbox[5]) * (const vec3f&)scale);
+      const vec3f spacing = (data_upper - data_lower)/((const vec3f)dims - 1.0f);
+      ospSetVec3f(core->self, "volumeGlobalBoundingBoxLower", 
+                  (const osp::vec3f&) global_upper);
+      ospSetVec3f(core->self, "volumeGlobalBoundingBoxUpper",
+                  (const osp::vec3f&) global_lower);
+      ospSetVec3f(core->self, "volumeClippingBoxLower", (const osp::vec3f&)clip_lower);
+      ospSetVec3f(core->self, "volumeClippingBoxUpper", (const osp::vec3f&)clip_upper);
+      ospSetVec3f(core->self, "gridSpacing", (const osp::vec3f&)spacing);
+      ospSetVec3f(core->self, "gridOrigin",  (const osp::vec3f&)data_lower);
+      ospSetVec3i(core->self, "dimensions",  (const osp::vec3i&)dims);
+      ospSet1f(core->self, "samplingRate", samplingRate);
+      ospSet3f(core->self, "Ks", Ks, Ks, Ks);
+      ospSet1f(core->self, "Ns", Ns);
+      ospSet1i(core->self, "gradientShadingEnabled", (int)gradientShadingEnabled);
+      ospSet1i(core->self, "adaptiveSampling", (int)adaptiveSampling);
+      ospSet1i(core->self, "preIntegration", (int)preIntegration);
+      ospSet1i(core->self, "singleShade", (int)singleShade);
+      ospSetObject(core->self, "transferFunction", tfn);
+      ospCommit(core->self);
+    }  
+
+  // =====================================================================//
+  //
+  // =====================================================================//
+  FrameBuffer::FrameBuffer(FrameBufferCore& other)
+    : Manipulator<CoreType, OSPType>(other) {}
+  void FrameBuffer::Render(const int tile_w, const int tile_h,
+                           const int tile_x, const int tile_y,
+                           const int    global_stride, 
+                           const float* global_depth,
+                           OSPRenderer renderer,
+                           float*& dest)
+  {
+    const vec2i fb_size(tile_w, tile_h);
+    // prepare the maxDepthDexture
+    {
+      // The reason I use round(r * (N-1)) instead of floor(r * N) is that
+      // during the composition phase, there will be a wired offset between
+      // rendered image and the background, which is about one pixel in size.
+      // Using round(r * (N - 1)) can remove the problem
+      std::vector<float> local_depth(tile_w * tile_h);
+      for (int i = 0; i < tile_w; ++i) {
+        for (int j = 0; j < tile_h; ++j) {
+          local_depth[i + j * tile_w] = 
+            global_depth[tile_x + i + (tile_y + j) * global_stride];
+        }
+      }
+      OSPTexture2D maxDepthTexture
+        = ospNewTexture2D((const osp::vec2i&)fb_size, OSP_TEXTURE_R32F,
+                          local_depth.data(), OSP_TEXTURE_FILTER_NEAREST);    
+      ospCommit(maxDepthTexture);
+      ospSetObject(renderer, "maxDepthTexture", maxDepthTexture);
+      ospCommit(renderer);
+      ospray_rm(maxDepthTexture);
+    }    
+    // do the rendering
+    // ALWAYS create a new framebuffer
+    {
+      ospray_rm(core->self);
+      core->self = 
+        ospNewFrameBuffer((const osp::vec2i&)fb_size, OSP_FB_RGBA32F, OSP_FB_COLOR);
+      ospray_check(core->self, "framebuffer");
+      ospRenderFrame(core->self, renderer, OSP_FB_COLOR);
+      const float* image = (float*)ospMapFrameBuffer(core->self, OSP_FB_COLOR);
+      std::copy(image, image + (tile_w * tile_h) * 4, dest);
+      ospUnmapFrameBuffer(image, core->self);
+      ospray_rm(core->self);      
+    }
+  }
+
+  
+};
+};
+
+static void OSPContext_ErrorFunc(OSPError, const char* msg)
+{ 
+    osperr << "#osp: (rank " << PAR_Rank() << ")" << msg; 
+}
+static void OSPContext_StatusFunc(const char* msg)
+{ 
+    osperr << "#osp: (rank " << PAR_Rank() << ")" << msg; 
+}
+
+static bool ospray_initialized = false;
+
+void ospray::InitOSP(int numThreads) 
+{   
+    if (!ospray_initialized) 
+    {
+#ifdef __unix__
+        // check hostname
+        char hname[200];
+        gethostname(hname, 200);
+        ospout << "[ospray] on host >> " << hname << "<<" << std::endl;;
+#endif
+        // load ospray device
+        ospout << "[ospray] Initialize OSPRay" << std::endl;	
+        OSPDevice device = ospGetCurrentDevice();
+	// check if ospray has been initialized already
+        if (!device) {
+	    ospout << "[ospray] device not found, creating one" << std::endl;
+            device = ospNewDevice("default"); 
+            if (DebugStream::Level5()) { 
+                ospout << "[ospray] --> debug mode" << std::endl;
+                ospDeviceSet1i(device, "debug", 0);
+            }	
+            if (numThreads > 0) {
+                ospout << "[ospray] --> numThreads: " << numThreads 
+                       << std::endl;
+                ospDeviceSet1i(device, "numThreads", numThreads);
+            }
+            ospDeviceSetErrorFunc(device, OSPContext_ErrorFunc);
+            ospDeviceSetStatusFunc(device, OSPContext_StatusFunc);
+            ospDeviceCommit(device);
+            ospSetCurrentDevice(device);
+        }
+        // load ospray module
+        OSPError err = ospLoadModule("visit");
+        if (err != OSP_NO_ERROR) {
+	    osperr << "[Error] can't load visit module" << std::endl;
+        }
+        ospray_initialized = true;
+    }
+}
+
+void ospray::Finalize()
+{
+}
+
+// ***************************************************************************
+//
+// OSPRay::Context
+//
+// ***************************************************************************
+
+void ospray::Context::InitPatch(const int patchID)
+{
+    if (patches.find(patchID) == patches.end()) {
+        patches[patchID] = ospray::Patch();
+    }
+}
+void ospray::Context::SetBackgroundBuffer(const unsigned char* color, 
+					  const float* depth, 
+					  const int size[2])
+{
+    bgColorBuffer = color;
+    bgDepthBuffer = depth;
+    bgSize[0] = size[0];
+    bgSize[1] = size[1];
+}
+void ospray::Context::SetupPatch(const int patchID,
+				 const int vtk_type,
+				 const size_t data_size, 
+				 const void* data_ptr,
+				 const double *X,
+				 const double *Y,
+				 const double *Z, 
+				 const int nX, const int nY, const int nZ,
+				 const double dbox[6], const double cbox[6])
+    
+{
+    std::string str_type;
+    OSPDataType osp_type;
+    CheckVolumeFormat(vtk_type, str_type, osp_type);
+    Volume volume(patches[patchID].volume);
+    volume.Init("visit_shared_structured_volume",
+		osp_type, str_type, data_size, data_ptr,
+		useGridAccelerator);
+    volume.Set(adaptiveSampling,
+               preIntegration,
+               singleShade,
+               gradientShadingEnabled,
+               samplingRate, 
+               Ks, Ns,
+               X, Y, Z, nX, nY, nZ,
+               dbox, cbox,
+               osp::vec3f{(float)gbbox[0],(float)gbbox[1],(float)gbbox[2]},
+               osp::vec3f{(float)gbbox[3],(float)gbbox[4],(float)gbbox[5]},
+               osp::vec3f{(float)scale[0],(float)scale[1],(float)scale[2]},
+               tfn);    
+    Model model(patches[patchID].model);
+    model.Reset();
+    model.Init();
+    model.Set(patches[patchID].volume);
+}
+void ospray::Context::RenderPatch(const int patchID,
+				  const float xMin, const float xMax, 
+				  const float yMin, const float yMax,
+				  const int tile_w, const int tile_h,
+				  float*& dest)
+{
+    Camera      cam(camera);
+    Renderer    ren(renderer);
+    FrameBuffer fb(patches[patchID].fb);
+    cam.SetScreen(xMin, xMax, yMin, yMax);
+    ren.Set(patches[patchID].model);
+    ren.Set(camera);
+    fb.Render(tile_w, tile_h,
+              cam.GetWindowExts(0),
+              cam.GetWindowExts(2),
+              bgSize[0],
+              bgDepthBuffer,
+              renderer, dest);
+}
+
+// ***************************************************************************
+//
+//  Extra Functions Defined here
+//
+// ***************************************************************************
+
+void
+ospray::CheckMemoryHere(const std::string& message, std::string debugN)
+{
+    if (debugN.compare("ospout") == 0) {	
+        ospray::CheckMemoryHere(message, *osp_out);
+    }
+    else if (debugN.compare("debug5") == 0) {
+        if (DebugStream::Level5()) {
+            ospray::CheckMemoryHere(message, DebugStream::Stream5());
+        }       
+    }
+    else if (debugN.compare("debug4") == 0) {
+        if (DebugStream::Level4()) {
+            ospray::CheckMemoryHere(message, DebugStream::Stream4());
+        }       
+    }
+    else if (debugN.compare("debug3") == 0) {
+        if (DebugStream::Level3()) {
+            ospray::CheckMemoryHere(message, DebugStream::Stream3());
+        }       
+    }
+    else if (debugN.compare("debug2") == 0) {
+        if (DebugStream::Level2()) {
+            ospray::CheckMemoryHere(message, DebugStream::Stream2());
+        }       
+    }
+    else if (debugN.compare("debug1") == 0) {
+        if (DebugStream::Level1()) {
+            ospray::CheckMemoryHere(message, DebugStream::Stream1());
+        }       
+    }
+}
+
+void
+ospray::CheckMemoryHere(const std::string& message, std::ostream& out)
+{
+    unsigned long m_size, m_rss;
+    avtMemory::GetMemorySize(m_size, m_rss);
+    out << message << std::endl << "\t"
+        << " Rank " << PAR_Rank()
+        << " Memory use begin " << m_size 
+        << " rss " << m_rss/(1024*1024) << " (MB)"
+        << std::endl;
+}
+
+void
+ospray::CheckVolumeFormat(const int dt,
+			  std::string& str_type,
+			  OSPDataType& osp_type)
+{
+    if (dt == VTK_UNSIGNED_CHAR) {
+	str_type = "uchar";
+	osp_type = OSP_UCHAR;
+    } else if (dt == VTK_SHORT) {
+	str_type = "short";
+	osp_type = OSP_SHORT;
+    } else if (dt == VTK_UNSIGNED_SHORT) {
+	str_type = "ushort";
+	osp_type = OSP_USHORT;
+    } else if (dt == VTK_FLOAT) {
+	str_type = "float";
+	osp_type = OSP_FLOAT;
+    } else if (dt == VTK_DOUBLE) {
+	str_type = "double";
+	osp_type = OSP_DOUBLE;
+    } else {
+	ospray::Exception("Unsupported ospray volume type.");
+    }
+    ospout << "[ospray] data type " << str_type << std::endl;
+}
+
+void
+ospray::ComputeProjections(const avtViewInfo &view, 
+			   const double      &aspect,
+			   const double      &old_near_plane,
+			   const double      &old_far_plane,
+			   const double       data_scale[3],
+			   const double       data_bound[6],
+			   const int          screen_size[2],
+			   vtkMatrix4x4 *model_to_screen_transform, 
+			   vtkMatrix4x4 *screen_to_model_transform, 
+			   vtkMatrix4x4 *screen_to_camera_transform,
+			   double        canvas_size[2],
+    			   int           rendering_extents[4]) 
+{
+    //----------------------------------------------------------------------//
+    // see avt/View/avtViewInfo::SetCameraFromView
+    //----------------------------------------------------------------------//
+    /* view.SetCameraFromView(vtkcamera); */
+    vtkCamera *vtkcamera = vtkCamera::New();
+    vtkcamera->SetViewAngle(view.viewAngle);
+    vtkcamera->SetEyeAngle(view.eyeAngle);
+    if (view.setScale)
+    {
+        vtkcamera->SetParallelScale(view.parallelScale);
+    }
+    vtkcamera->SetParallelProjection(view.orthographic ? 1 : 0);
+    vtkcamera->SetViewShear(view.shear[0],view.shear[1],view.shear[2]);
+    vtkcamera->SetFocalPoint(view.focus);
+    vtkcamera->SetPosition(view.camera);
+    vtkcamera->SetViewUp(view.viewUp);
+    vtkcamera->SetFocalDisk(view.imageZoom);
+    vtkcamera->Zoom(view.imageZoom);
+    // here we have to use the old near/far planes
+    vtkcamera->SetClippingRange(old_near_plane, old_far_plane);
+    // here we dont want to move window center ?
+    //vtkcamera->SetWindowCenter(2.0*view.imagePan[0], 2.0*view.imagePan[1]);
+    //----------------------------------------------------------------------//
+    // compute matrix
+    //----------------------------------------------------------------------//
+    vtkMatrix4x4 *matMVPS =
+	vtkcamera->GetModelViewTransformMatrix();
+    vtkMatrix4x4 *matProj = 
+	vtkcamera->GetProjectionTransformMatrix(aspect, -1, 1);    
+    vtkMatrix4x4::Multiply4x4(matProj, matMVPS,
+			      model_to_screen_transform);
+    vtkMatrix4x4::Invert(model_to_screen_transform,
+			 screen_to_model_transform);
+    vtkMatrix4x4::Invert(matProj,
+			 screen_to_camera_transform);
+    //----------------------------------------------------------------------//
+    // compute canvas size (parallel scale)
+    //----------------------------------------------------------------------//
+    if (!view.orthographic)
+    {
+    	canvas_size[0] = 2.0 * old_near_plane / matProj->GetElement(0, 0);
+    	canvas_size[1] = 2.0 * old_near_plane / matProj->GetElement(1, 1);
+    }
+    else
+    {
+    	canvas_size[0] = 2.0 / matProj->GetElement(0, 0);
+    	canvas_size[1] = 2.0 / matProj->GetElement(1, 1);
+    }
+    //----------------------------------------------------------------------//
+    // cleanup
+    //----------------------------------------------------------------------//
+    vtkcamera->Delete();
+    //----------------------------------------------------------------------//
+    // get the renderable region
+    //----------------------------------------------------------------------//
+    double depths[2];
+    ospray::ProjectWorldToScreenCube(data_bound,
+				     screen_size[0], screen_size[1], 
+				     view.imagePan, view.imageZoom,
+				     model_to_screen_transform,
+				     rendering_extents, depths);
+    rendering_extents[0] = std::max(rendering_extents[0], 0);
+    rendering_extents[2] = std::max(rendering_extents[2], 0);
+    rendering_extents[1] = std::min(1+rendering_extents[1], screen_size[0]);
+    rendering_extents[3] = std::min(1+rendering_extents[3], screen_size[1]);
+}
+
+double
+ospray::ProjectWorldToScreen(const double worldCoord[3], 
+			     const int screenWidth, 
+			     const int screenHeight,
+			     const double panPercentage[2], 
+			     const double imageZoom,
+			     vtkMatrix4x4 *mvp, int screenCoord[2])
+{
+    // world space coordinate in homogeneous coordinate
+    double worldHCoord[4] = {worldCoord[0],worldCoord[1],worldCoord[2],1.0};
+    // world to clip space (-1 ~ 1)
+    double clipHCoord[4];
+    mvp->MultiplyPoint(worldHCoord, clipHCoord);
+    // check error
+    if (clipHCoord[3] == 0.0)
+    {
+        std::cerr << "world coordinates: (" 
+                  << worldHCoord[0] << ", " 
+                  << worldHCoord[1] << ", " 
+                  << worldHCoord[2] << ", " 
+                  << worldHCoord[3] << ")" << std::endl
+                  << "clip space coordinate: ("
+                  << clipHCoord[0] << ", " 
+                  << clipHCoord[1] << ", " 
+                  << clipHCoord[2] << ", "
+                  << clipHCoord[3] << std::endl
+		  << "Matrix: " << *mvp << std::endl;
+	ospray::Exception("Zero Division During Projection.");
+    }
+    // screen coordinates (int integer)
+    screenCoord[0] =
+	round((clipHCoord[0] / clipHCoord[3] + 1) * screenWidth  * 0.5) +
+	round(screenWidth  * panPercentage[0]);
+    screenCoord[1] =
+	round((clipHCoord[1] / clipHCoord[3] + 1) * screenHeight * 0.5) +
+	round(screenHeight * panPercentage[1]); 
+    // return point depth
+    return clipHCoord[2]/clipHCoord[3];
+}
+
+void
+ospray::ProjectScreenToWorld(const int screenCoord[2], const double z,
+                             const int screenWidth, const int screenHeight, 
+                             const double panPercentage[2], 
+                             const double imageZoom,
+                             vtkMatrix4x4 *imvp, double worldCoord[3])
+{
+    // remove panning
+    const int x = screenCoord[0] - round(screenWidth*panPercentage[0]);
+    const int y = screenCoord[1] - round(screenHeight*panPercentage[1]);   
+    // do projection
+    double worldHCoord[4] = {0,0,0,1};
+    double clipHCoord[4] = {
+        (x - screenWidth  / 2.0) / (screenWidth  / 2.0),
+        (y - screenHeight / 2.0) / (screenHeight / 2.0), z, 1.0};
+    imvp->MultiplyPoint(clipHCoord, worldHCoord);
+    // check error
+    if (worldHCoord[3] == 0) {
+        std::cerr << "world coordinates: (" 
+                  << worldHCoord[0] << ", " 
+                  << worldHCoord[1] << ", " 
+                  << worldHCoord[2] << ", " 
+                  << worldHCoord[3] << ")" << std::endl
+                  << "clip space coordinate: ("
+                  << clipHCoord[0] << ", " 
+                  << clipHCoord[1] << ", " 
+                  << clipHCoord[2] << ", "
+                  << clipHCoord[3] << std::endl
+		  << "Matrix: " << *imvp << std::endl;
+	ospray::Exception("Zero Division During Projection.");
+    }    
+    // normalize world space coordinate	
+    worldCoord[0] = worldHCoord[0]/worldHCoord[3];
+    worldCoord[1] = worldHCoord[1]/worldHCoord[3];
+    worldCoord[2] = worldHCoord[2]/worldHCoord[3];
+}
+
+void
+ospray::ProjectScreenToCamera(const int screenCoord[2], const double z,
+                              const int screenWidth, const int screenHeight, 
+                              vtkMatrix4x4 *imvp, double cameraCoord[3])
+{
+    // remove panning
+    const int x = screenCoord[0];
+    const int y = screenCoord[1];
+    // do projection
+    double cameraHCoord[4] = {0,0,0,1};
+    double clipHCoord[4] = {
+        (x - screenWidth /2.0)/(screenWidth /2.0),
+        (y - screenHeight/2.0)/(screenHeight/2.0), z, 1.0};
+    imvp->MultiplyPoint(clipHCoord, cameraHCoord);
+    // check error
+    if (cameraHCoord[3] == 0) {
+        std::cerr << "world coordinates: (" 
+                  << cameraHCoord[0] << ", " 
+                  << cameraHCoord[1] << ", " 
+                  << cameraHCoord[2] << ", " 
+                  << cameraHCoord[3] << ")" << std::endl
+                  << "clip space coordinate: ("
+                  << clipHCoord[0] << ", " 
+                  << clipHCoord[1] << ", " 
+                  << clipHCoord[2] << ", "
+                  << clipHCoord[3] << std::endl
+		  << "Matrix: " << *imvp << std::endl;
+	ospray::Exception("Zero Division During Projection.");
+    }
+    // normalize world space coordinate	
+    cameraCoord[0] = cameraHCoord[0]/cameraHCoord[3];
+    cameraCoord[1] = cameraHCoord[1]/cameraHCoord[3];
+    cameraCoord[2] = cameraHCoord[2]/cameraHCoord[3];
+}
+
+void
+ospray::ProjectWorldToScreenCube(const double cube[6],
+                                 const int screenWidth, 
+                                 const int screenHeight, 
+                                 const double panPercentage[2], 
+                                 const double imageZoom,
+                                 vtkMatrix4x4 *mvp, 
+                                 int screenExtents[4], 
+                                 double depthExtents[2])
+{
+    int xMin = std::numeric_limits<int>::max();
+    int xMax = std::numeric_limits<int>::min();
+    int yMin = std::numeric_limits<int>::max();
+    int yMax = std::numeric_limits<int>::min();
+    double zMin = std::numeric_limits<double>::max();
+    double zMax = std::numeric_limits<double>::min();
+
+    float coordinates[8][3];
+    coordinates[0][0] = cube[0];   
+    coordinates[0][1] = cube[2];   
+    coordinates[0][2] = cube[4];	
+
+    coordinates[1][0] = cube[1];   
+    coordinates[1][1] = cube[2];   
+    coordinates[1][2] = cube[4];	
+
+    coordinates[2][0] = cube[1];  
+    coordinates[2][1] = cube[3];
+    coordinates[2][2] = cube[4];	
+
+    coordinates[3][0] = cube[0]; 
+    coordinates[3][1] = cube[3]; 
+    coordinates[3][2] = cube[4];
+
+    coordinates[4][0] = cube[0];
+    coordinates[4][1] = cube[2];
+    coordinates[4][2] = cube[5];
+
+    coordinates[5][0] = cube[1]; 
+    coordinates[5][1] = cube[2]; 
+    coordinates[5][2] = cube[5];	
+
+    coordinates[6][0] = cube[1]; 
+    coordinates[6][1] = cube[3];
+    coordinates[6][2] = cube[5];
+
+    coordinates[7][0] = cube[0]; 
+    coordinates[7][1] = cube[3]; 
+    coordinates[7][2] = cube[5];
+
+    double worldCoord[3];
+    int screenCoord[2]; double depth;
+    for (int i=0; i<8; i++)
+    {
+        worldCoord[0] = coordinates[i][0];
+        worldCoord[1] = coordinates[i][1];
+        worldCoord[2] = coordinates[i][2];
+        depth = ProjectWorldToScreen(worldCoord, screenWidth, screenHeight, 
+				     panPercentage, imageZoom, mvp,
+				     screenCoord);
+        // clamp values
+        screenCoord[0] = CLAMP(screenCoord[0], 0, screenWidth);
+        screenCoord[1] = CLAMP(screenCoord[1], 0, screenHeight);
+        screenExtents[0] = xMin = std::min(xMin, screenCoord[0]);
+        screenExtents[1] = xMax = std::max(xMax, screenCoord[0]);
+        screenExtents[2] = yMin = std::min(yMin, screenCoord[1]);
+        screenExtents[3] = yMax = std::max(yMax, screenCoord[1]);
+        depthExtents[0] = zMin = std::min(zMin, depth);
+        depthExtents[1] = zMax = std::max(zMax, depth);
+    }
+}
+
+void
+ospray::CompositeBackground(int screen[2],
+                            int compositedImageExtents[4],
+                            int compositedImageWidth,
+                            int compositedImageHeight,
+                            float *compositedImageBuffer,
+                            unsigned char *opaqueImageColor,
+                            float         *opaqueImageDepth,
+                            unsigned char *&imgFinal)
+{
+    if (UseThreadedBlend_MetaData) {
+        visit::CompositeBackground(screen,
+				   compositedImageExtents,
+				   compositedImageWidth,
+				   compositedImageHeight,
+				   compositedImageBuffer,
+				   opaqueImageColor,
+				   opaqueImageDepth,
+				   imgFinal);
+	return;
+    } 
+    for (int y = 0; y < screen[1]; y++)
+    {
+	for (int x = 0; x < screen[0]; x++)
+	{
+	    int indexScreen     = y * screen[0] + x;
+	    int indexComposited =
+		(y - compositedImageExtents[2]) * compositedImageWidth +
+		(x - compositedImageExtents[0]);
+
+	    bool insideComposited = 
+		((x >= compositedImageExtents[0] && 
+		  x < compositedImageExtents[1]) &&
+		 (y >= compositedImageExtents[2] && 
+		  y < compositedImageExtents[3]));
+
+	    if (insideComposited)
+	    {
+		if (compositedImageBuffer[indexComposited*4 + 3] == 0)
+		{
+		    // No data from rendering here! - Good
+		    imgFinal[indexScreen * 3 + 0] = 
+			opaqueImageColor[indexScreen * 3 + 0];
+		    imgFinal[indexScreen * 3 + 1] = 
+			opaqueImageColor[indexScreen * 3 + 1];
+		    imgFinal[indexScreen * 3 + 2] = 
+			opaqueImageColor[indexScreen * 3 + 2];
+		}
+		else
+		{
+		    // Volume in front
+		    float alpha = 
+			(1.0 - compositedImageBuffer[indexComposited * 4 + 3]);
+		    imgFinal[indexScreen * 3 + 0] = 
+			CLAMP(opaqueImageColor[indexScreen * 3 + 0] * alpha +
+			      compositedImageBuffer[indexComposited * 4 + 0] *
+			      255.f,
+			      0.f, 255.f);
+		    imgFinal[indexScreen * 3 + 1] = 
+			CLAMP(opaqueImageColor[indexScreen * 3 + 1] * alpha +
+			      compositedImageBuffer[indexComposited * 4 + 1] *
+			      255.f,
+			      0.f, 255.f);
+		    imgFinal[indexScreen * 3 + 2] =
+			CLAMP(opaqueImageColor[indexScreen * 3 + 2] * alpha +
+			      compositedImageBuffer[indexComposited * 4 + 2] *
+			      255.f,
+			      0.f, 255.f);
+		}
+	    }
+	    else
+	    {
+		// Outside bounding box: Use the background : Good
+		imgFinal[indexScreen * 3 + 0] = 
+		    opaqueImageColor[indexScreen * 3 + 0];
+		imgFinal[indexScreen * 3 + 1] =
+		    opaqueImageColor[indexScreen * 3 + 1];
+		imgFinal[indexScreen * 3 + 2] =
+		    opaqueImageColor[indexScreen * 3 + 2];
+	    }
+	}
+    }
+}
+
+void
+ospray::WriteArrayToPPM(std::string filename, const float * image,
+                        int dimX, int dimY)
+{
+    std::ofstream outputFile((filename+ ".ppm").c_str(), 
+                             std::ios::out | std::ios::binary);
+    outputFile <<  "P6\n" << dimX << "\n" << dimY << "\n" << 255 << "\n"; 
+    for (int y=dimY-1; y>=0; --y)
+    {
+        for (int x=0; x<dimX; ++x)
+        {
+            int index = (y * dimX + x)*4;
+            char color[3];
+            float alpha = image[index + 3];
+            color[0] = CLAMP(image[index + 0]*alpha, 0.0f, 1.0f) * 255;
+            color[1] = CLAMP(image[index + 1]*alpha, 0.0f, 1.0f) * 255;
+            color[2] = CLAMP(image[index + 2]*alpha, 0.0f, 1.0f) * 255;
+            outputFile.write(color,3);
+        }
+    } 
+    outputFile.close();
+}
+
+void
+ospray::WriteArrayToPPM(std::string filename,  const unsigned char *image, 
+                        int dimX, int dimY)
+{
+    std::ofstream outputFile((filename+ ".ppm").c_str(), 
+                             std::ios::out | std::ios::binary);
+    outputFile <<  "P6\n" << dimX << "\n" << dimY << "\n" << 255 << "\n"; 
+    for (int y=dimY-1; y>=0; --y)
+    {
+        outputFile.write(reinterpret_cast<const char*>(&image[y * dimX * 3]), 
+                         dimX * 3);
+    } 
+    outputFile.close();
+}
+
+void
+ospray::WriteArrayGrayToPPM(std::string filename, const float* image, 
+                            int dimX, int dimY)
+{
+    std::ofstream outputFile((filename+ ".ppm").c_str(), 
+                             std::ios::out | std::ios::binary);
+    outputFile <<  "P6\n" << dimX << "\n" << dimY << "\n" << 255 << "\n"; 
+    for (int y=dimY-1; y>=0; --y)
+    {
+        for (int x=0; x<dimX; ++x)
+        {
+            int index = (y * dimX + x);
+            char var = CLAMP(image[index], 0.f, 1.f) * 255;
+            char color[3];
+            color[0] = var;
+            color[1] = var;
+            color[2] = var;
+            outputFile.write(color,3);
+        }
+    } 
+    outputFile.close();
+}
diff --git a/avt/Filters/avtOSPRayCommon.h b/avt/Filters/avtOSPRayCommon.h
new file mode 100644
index 000000000..25ec09ee9
--- /dev/null
+++ b/avt/Filters/avtOSPRayCommon.h
@@ -0,0 +1,724 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2017, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef VISIT_OSPRAY /* make sure VISIT_OSPRAY is defined */
+# error "VISIT_OSPRAY is not defined but ospray is used"
+#endif
+
+#ifndef AVT_OSPRAY_COMMON_H
+#define AVT_OSPRAY_COMMON_H
+
+#include <ospray/ospray.h>
+#include <string>
+#include <vector>
+#include <map>
+
+namespace ospray {
+namespace visit {
+  
+    /** 
+     * Helper Functions
+     */
+    template<typename T> void ospray_rm(T& obj) {
+        if (!obj) { ospRelease(obj); obj = NULL; }
+    }
+  
+    /**
+     * Abstraction of an object
+     */
+    template<typename T> struct Object {
+        bool init;
+        T    self;
+        Object() : init(false), self(NULL) {}
+        virtual ~Object() { ospray_rm(self); init = false; }
+        T operator*() { return self; }
+    };
+  
+    /**
+     * Transfer Function Wrapper
+     */
+    struct TransferFunctionCore : public Object<OSPTransferFunction> {
+    TransferFunctionCore() : Object<OSPTransferFunction>() {}
+    };
+
+    /**
+     * Camera Wrapper
+     */
+    struct CameraCore : public Object<OSPCamera> {
+        bool   orthographic;
+        int    windowExts[4];
+        int    screenSize[2];
+        double pan[2]; // pan ratio [0, 1]
+        double zoom;   // zoom factor
+        CameraCore() : Object<OSPCamera>() {
+            orthographic = false;
+            windowExts[0] = windowExts[1] = 0;
+            windowExts[2] = windowExts[3] = 0;
+            screenSize[0] = screenSize[1] = 0;
+            pan[0] = pan[1] = 0.0;
+            zoom = 1.0;
+        }
+    };
+
+    /**
+     * Light Wrapper
+     */
+    struct LightCore : public Object<OSPLight> {
+        bool isAmbient;
+        LightCore() : Object<OSPLight>() {
+            isAmbient = false;
+        }
+    };  
+
+    /**
+     * Renderer Wrapper
+     */
+    struct RendererCore : public Object<OSPRenderer> {
+        OSPData                lightData;
+        std::vector<LightCore> lightList;
+    RendererCore() : Object<OSPRenderer>() {
+            lightData = NULL;
+        }
+        ~RendererCore() { ospray_rm(lightData); }
+    };
+
+    /**
+     * Model Wrapper
+     */
+    struct ModelCore : public Object<OSPModel> {
+        ModelCore() : Object<OSPModel>() {}
+    };
+
+    /**
+     * Volume Wrapper
+     */
+    struct VolumeCore : public Object<OSPVolume> {
+        std::string volumeType;
+        OSPDataType dataType;
+        size_t      dataSize;
+        const void* dataPtr;
+	bool useGridAccelerator;
+        VolumeCore() : Object<OSPVolume>() {
+            volumeType = "";
+            dataType = OSP_UCHAR; /* just give it a value */
+            dataSize = 0;
+            dataPtr  = NULL;
+	    useGridAccelerator = false;
+        }
+    };
+  
+    /**
+     * Framebuffer Wrapper
+     */
+    struct FrameBufferCore : public Object<OSPFrameBuffer> {
+        FrameBufferCore() : Object<OSPFrameBuffer>() {}
+    };
+
+    /**
+     * Now we define a PatchCore
+     */
+    struct Patch {
+        VolumeCore      volume;
+        ModelCore       model;
+        FrameBufferCore fb;
+    };
+
+    /**
+     * And a ContextCore
+     */
+    struct ContextCore {
+        // data
+        std::string varname;
+        std::map<int, Patch> patches;
+        CameraCore           camera;
+        RendererCore         renderer;
+        TransferFunctionCore tfn;
+        // flags
+        bool oneSidedLighting;       /* renderer */
+        bool shadowsEnabled;         /* renderer */
+        bool aoTransparencyEnabled;  /* renderer */
+        bool useGridAccelerator;     /*  volume  */
+        bool adaptiveSampling;       /*  volume  */
+        bool preIntegration;         /*  volume  */
+        bool singleShade;            /*  volume  */
+        bool gradientShadingEnabled; /*  volume  */
+        // other parameters
+        double Ks;
+        double Ns;
+        double samplingRate;
+        int aoSamples;
+        int spp;
+        double scale[3];
+        double gbbox[6];
+        // (shared, dont delete here)
+        const unsigned char *bgColorBuffer;  // backplatte color channel
+        const float         *bgDepthBuffer;  // backplatte depth channel 
+        int                  bgSize[2];      // channel buffer size
+        ContextCore() {
+            varname = "";
+            oneSidedLighting       = false;
+            shadowsEnabled         = false;
+            aoTransparencyEnabled  = false;
+            useGridAccelerator     = false;
+            adaptiveSampling       = false;
+            preIntegration         = false;
+            singleShade            = false;
+            gradientShadingEnabled = false;
+            Ks = 1.0; Ns = 20;
+            samplingRate = 3.0;
+            aoSamples = 0;
+            spp = 1;
+            scale[0] = scale[1] = scale[2] = 1.f;
+            gbbox[0] = gbbox[1] = gbbox[2] = 0.f;
+            gbbox[3] = gbbox[4] = gbbox[5] = 0.f;
+            bgSize[0] = bgSize[1] = 0;
+        }
+    };
+
+};
+};
+
+// ***************************************************************************
+//  Struct:  OSPVisItContext
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ***************************************************************************
+
+typedef ospray::visit::ContextCore OSPVisItContext;
+namespace ospray {
+    void InitOSP(int numThreads = 0);
+    void Finalize();
+    struct Context : public ospray::visit::ContextCore {
+    public:
+	void SetBackgroundBuffer(const unsigned char* color,
+				 const float* depth, const int size[2]);
+	void SetSpecular(const double& k, const double& n) { Ks = k; Ns = n; }
+	void SetScaleAndDataBounds(const double v[3], const double d[6])
+	{
+	    scale[0] = v[0]; scale[1] = v[1]; scale[2] = v[2];
+	    gbbox[0] = d[0] * scale[0];
+	    gbbox[3] = d[1] * scale[0];
+	    gbbox[1] = d[2] * scale[1];
+	    gbbox[4] = d[3] * scale[1];
+	    gbbox[2] = d[4] * scale[2];
+	    gbbox[5] = d[5] * scale[2];
+	}	
+	void SetSamplingRate(const double& v) { samplingRate = v; }
+	void SetAoSamples(const int v) { aoSamples = v; } 
+	void SetSpp(const int v) { spp = v; }
+	void SetOneSidedLighting(bool v) { oneSidedLighting = v; }
+	void SetShadowsEnabled(bool v) { shadowsEnabled = v; }
+	void SetAoTransparencyEnabled(bool v) { aoTransparencyEnabled = v; }
+	void SetUseGridAccelerator(bool v) { useGridAccelerator = v; }
+	void SetAdaptiveSampling(bool v) { adaptiveSampling = v; }
+	void SetPreIntegration(bool v) { preIntegration = v; }
+	void SetSingleShade(bool v) { singleShade = v; }
+	void SetGradientShadingEnabled(bool v) { gradientShadingEnabled = v; }
+	void SetVariableName(const std::string& str) { varname = str; }
+	const std::string& GetVariableName() const { return varname; }
+	void InitPatch(const int patchID);
+	void SetupPatch(const int patchID, const int vtk_type,
+			const size_t data_size, const void* data_ptr,
+			const double *X, const double *Y, const double *Z, 
+			const int nX, const int nY, const int nZ,
+			const double dbox[6], const double cbox[6]);
+	void RenderPatch(const int patchID,
+			 const float xMin, const float xMax, 
+			 const float yMin, const float yMax,
+			 const int tile_w, const int tile_h,
+			 float*& dest); 
+    };
+};
+
+#endif//AVT_OSPRAY_COMMON_H
+
+// ***************************************************************************
+//
+//
+//
+//  Extra Functions Defined here
+//
+//
+//
+// ***************************************************************************
+
+#ifndef VISIT_OSPRAY_CONTEXT_ONLY
+
+#ifndef AVT_OSPRAY_COMMON_EXTRA_H
+#define AVT_OSPRAY_COMMON_EXTRA_H
+
+#include <avtParallel.h>
+#include <avtViewInfo.h>
+#include <avtCallback.h>
+
+#include <DebugStream.h>
+#include <StackTimer.h>
+#include <TimingsManager.h>
+#include <ImproperUseException.h>
+
+#include <vtkType.h>
+#include <vtkMatrix4x4.h>
+
+#include <ospray/ospray.h>
+#include <ospray/visit/VisItModuleCommon.h>
+#include <ospray/visit/VisItExtraLibraries.h>
+#include <ospray/visit/VisItImageComposite.h>
+
+#include <cmath>
+#include <cstdlib>
+#include <iostream>
+#include <limits>
+#include <stdio.h>
+
+#ifndef CLAMP
+# define CLAMP(x, l, h) (x > l ? x < h ? x : h : l)
+#endif
+#ifndef M_MIN
+# define M_MIN(x, r) (x < r ? x : r)
+#endif
+#ifndef M_MAX
+# define M_MAX(x, r) (x > r ? x : r)
+#endif
+
+// ostreams customized for ospray
+#ifdef ospout
+#undef ospout
+#endif
+#define ospout                                                      \
+    if (!ospray::visit::CheckVerbose() && !DebugStream::Level5()) ; \
+    else (*ospray::osp_out)
+#ifdef osperr
+#undef osperr
+#endif
+#define osperr                                                      \
+    if (!ospray::visit::CheckVerbose() && !DebugStream::Level1()) ; \
+    else (*ospray::osp_err)
+namespace ospray {
+    extern std::ostream *osp_out;
+    extern std::ostream *osp_err;
+    //////////////////////////////////////////////////////
+    //                                                  //
+    // Those function has to be inline, otherwise we    //
+    // need to link this library to other components    //
+    // manually                                         //
+    //                                                  //
+    //////////////////////////////////////////////////////
+};
+
+// ***************************************************************************
+//  Namespace:  ospray
+//
+//  Purpose:
+//    
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ***************************************************************************
+
+namespace ospray {
+
+    namespace visit {
+
+        template<typename _CoreType, typename _OSPType> struct Manipulator {
+        protected:
+            typedef _CoreType CoreType;
+            typedef _OSPType  OSPType;
+            _CoreType *core;
+        public:
+            Manipulator(_CoreType& other) : core{&other} {}
+            _OSPType   operator* () { return *(*core); }
+            _CoreType* operator->() { return &(*core); }
+        };
+  
+        /**
+         * Transfer Function Wrapper
+         */
+        struct TransferFunction
+            : public Manipulator<TransferFunctionCore, OSPTransferFunction>
+        {
+        public:
+            TransferFunction(CoreType& other);
+            void Set(const void *table, const unsigned int size,
+                     const double datamin, const double datamax);      
+        };
+
+        /**
+         * Camera Wrapper
+         */
+        struct Camera
+            : public Manipulator<CameraCore, OSPCamera>
+        {
+        public:
+            Camera(CameraCore& other);
+            double GetWindowExts(const int i) const { 
+                return core->windowExts[i]; 
+            }
+            void Set(const bool ortho,
+                     const double camera_p[3], 
+                     const double camera_f[3], 
+                     const double camera_u[3], 
+                     const double fovy, 
+                     const double pan_ratio[2],
+                     const double zoom_ratio,
+                     const double near_clip,
+                     const double canvas_size[2],
+                     const int screen_size[2],
+                     const int tile_extents[4]);
+            void SetScreen(const double xMin, const double xMax,
+                           const double yMin, const double yMax);
+        };
+
+        /**
+         * Light Wrapper
+         */
+        struct Light
+            : public Manipulator<LightCore, OSPLight>
+        {
+        public:
+            Light(LightCore& other);
+            void Set(const bool ambient, const double i, 
+                     const double c, const double* d = NULL);
+            void Set(const bool ambient, const double i, 
+                     const double cr, const double cg, const double cb,
+                     const double* d = NULL);
+            void Set(const bool ambient, const double i, 
+                     const double c[3], const double* d = NULL);
+        };
+
+        /**
+         * Volume Wrapper
+         */
+        struct Volume 
+            : public Manipulator<VolumeCore, OSPVolume>
+        {
+        public:
+            Volume(VolumeCore& other);
+            bool Init(const std::string volume_type, 
+                      const OSPDataType data_type, 
+                      const std::string data_char,
+                      const size_t data_size, 
+                      const void* data_ptr,
+		      const bool use_grid_accelerator);
+            void Set(const bool adaptiveSampling,
+                     const bool preIntegration, 
+                     const bool singleShade, 
+                     const bool gradientShadingEnabled,
+                     const double samplingRate, 
+                     const double Ks, const double Ns,
+                     const double *X, const double *Y, const double *Z, 
+                     const int nX, const int nY, const int nZ,
+                     const double dbox[6], const double cbox[6], 
+                     const osp::vec3f& global_upper,
+                     const osp::vec3f& global_lower,
+                     const osp::vec3f& scale,
+                     OSPTransferFunction tfn);
+            void Set(const bool adaptiveSampling,
+                     const bool preIntegration, 
+                     const bool singleShade, 
+                     const bool gradientShadingEnabled, 
+                     const double samplingRate, 
+                     const double Ks, const double Ns,
+                     const double *X, const double *Y, const double *Z, 
+                     const int nX, const int nY, const int nZ,
+                     const double dbox[6], const double cbox[6], 
+                     const osp::vec3f& global_upper,
+                     const osp::vec3f& global_lower,
+                     const osp::vec3f& scale,
+                     TransferFunction tfn)
+            {
+                Set(adaptiveSampling,
+                    preIntegration, singleShade, 
+                    gradientShadingEnabled, samplingRate, 
+                    Ks, Ns, X, Y, Z, nX, nY, nZ,
+                    dbox, cbox, global_upper, global_lower, scale,
+                    *tfn);    
+            }
+
+            static void ComputeGhostBounds(bool bound[6], 
+                                           const unsigned char *ghosts, 
+                                           const int gnX, 
+                                           const int gnY, 
+                                           const int gnZ);
+        };
+
+        /**
+         * Model Wrapper
+         */
+        struct Model
+            : public Manipulator<ModelCore, OSPModel>
+        {
+        public:
+            Model(ModelCore& other);
+            void Reset();
+            void Init();
+            void Set(OSPVolume osp_volume);
+            void Set(Volume volume) { Set(*volume); }
+        };
+
+        /**
+         * Renderer Wrapper
+         */
+        struct Renderer
+            : public Manipulator<RendererCore, OSPRenderer>
+        {
+        public:
+            Renderer(RendererCore& other);
+            void  Init();
+            void  ResetLights();
+            Light AddLight();
+            void  FinalizeLights();
+            void  Set(const int aoSamples, const int spp, 
+                      const bool oneSidedLighting,
+                      const bool shadowsEnabled,
+                      const bool aoTransparencyEnabled);
+            void  Set(OSPCamera osp_camera);
+            void  Set(Camera        camera) { Set(*camera); }
+            void  Set(OSPModel   osp_world);
+            void  Set(Model          world) { Set(*world);  }
+        };
+
+
+        /**
+         * FrameBuffer Wrapper
+         */
+        struct FrameBuffer
+            : public Manipulator<FrameBufferCore, OSPFrameBuffer>
+        {
+        public:
+            FrameBuffer(FrameBufferCore& other);
+            void Render(const int tile_w, const int tile_h,
+                        const int tile_x, const int tile_y,
+                        const int global_stride, 
+                        const float* global_depth,
+                        OSPRenderer renderer,
+                        float*& dest);
+            void Render(const int tile_w, const int tile_h,
+                        const int tile_x, const int tile_y,
+                        const int global_stride, 
+                        const float* global_depth,
+                        Renderer renderer,
+                        float*& dest)
+            {
+                Render(tile_w, tile_h, tile_x, tile_y,
+                       global_stride, global_depth,
+                       *renderer, dest);
+            }
+
+        };
+    };
+
+    typedef ospray::visit::TransferFunction TransferFunction;
+    typedef ospray::visit::Camera Camera;
+    typedef ospray::visit::Renderer Renderer;
+    typedef ospray::visit::Volume Volume;
+    typedef ospray::visit::Model Model;
+    typedef ospray::visit::FrameBuffer FrameBuffer;
+    typedef ospray::visit::Patch Patch;
+        
+    // ***********************************************************************
+    //  Struct:  ImgMetaData
+    //
+    //  Purpose:
+    //    Holds information about patches but not the image 
+    //
+    //  Programmer:  
+    //  Creation:   
+    //
+    // ***********************************************************************
+
+    struct ImgMetaData
+    {
+        int procId;       // processor that produced the patch
+        int patchNumber;  // id of the patch on that processor
+        int destProcId;   // destination proc where this patch gets composited
+        int inUse;        // whether the patch is composed locally or not
+        int dims[2];      // height, width
+        int screen_ll[2]; // (lower left)  position in the final image
+        int screen_ur[2]; // (upper right)
+        float avg_z;      // camera space depth of the patch (average)
+        float eye_z;      // camera space z
+        float clip_z;     // clip space z
+    };
+
+    // ***********************************************************************
+    //  Struct:  ImgData
+    //
+    //  Purpose:
+    //    Holds the image data generated
+    //
+    //  Programmer:  
+    //  Creation:    
+    //
+    // ***********************************************************************
+    
+    struct ImgData
+    {
+        // acts as a key
+        int procId;        // processor that produced the patch
+        int patchNumber;   // id of the patch on that processor
+        float *imagePatch; // the image data - RGBA
+        ImgData() { imagePatch = NULL; }
+        bool operator==(const ImgData &a) {
+            return (patchNumber == a.patchNumber);
+        }
+    };
+
+    // ***********************************************************************
+    //
+    //  Helper Functions
+    //
+    // ***********************************************************************
+        
+    void CheckMemoryHere(const std::string& message, 
+                         std::string debugN = "debug5");
+    void CheckMemoryHere(const std::string& message, 
+                         std::ostream& out);
+
+    typedef int timestamp;
+    inline void CheckSectionStart(const std::string& c,
+                                  const std::string& f,
+                                  timestamp& timingDetail,
+                                  const std::string& str) 
+    {
+        debug5 << c << "::" << f << " " << str << " Start" << std::endl;
+        timingDetail = visitTimer->StartTimer();	    
+    }
+    
+    inline void CheckSectionStop(const std::string& c,
+                                 const std::string& f, 
+                                 timestamp& timingDetail,
+                                 const std::string& str) 
+    {
+        visitTimer->StopTimer(timingDetail, 
+                              (c + "::" + f + " " + str).c_str());
+        ospray::CheckMemoryHere(("[" + c + "]" + " " + f + " " + str).c_str(),
+                                "debug5");
+        debug5 << c << "::" << f << " " << str << " Done" << std::endl;
+    }
+
+    inline void Exception(const std::string str)
+    {
+        std::cerr << str << std::endl;
+        debug1    << str << std::endl;
+        EXCEPTION1(ImproperUseException, str.c_str());
+	avtCallback::SetRenderingException(str);
+    }
+
+    inline void Warning(const std::string str)
+    {
+	avtCallback::IssueWarning(str.c_str());
+    }
+    void CheckVolumeFormat(const int dt,
+                           std::string& str_type,
+                           OSPDataType& osp_type);
+
+    void ComputeProjections(const avtViewInfo &view, 
+                            const double      &aspect,
+                            const double      &old_near_plane,
+                            const double      &old_far_plane,
+                            const double       data_scale[3],
+                            const double       data_bound[6],
+                            const int          screen_size[2],
+                            vtkMatrix4x4 *model_to_screen_transform, 
+                            vtkMatrix4x4 *screen_to_model_transform, 
+                            vtkMatrix4x4 *screen_to_camera_transform,
+                            double        canvas_size[2],
+                            int           rendering_extents[4]);
+
+    double ProjectWorldToScreen
+        (const double worldCoord[3], 
+         const int screenWidth, const int screenHeight,	 
+         const double panPercentage[2], const double imageZoom,
+         vtkMatrix4x4 *mvp, int screenCoord[2]);
+    
+    void ProjectScreenToWorld
+        (const int screenCoord[2], const double z,
+         const int screenWidth, const int screenHeight, 
+         const double panPercentage[2], const double imageZoom,
+         vtkMatrix4x4 *imvp, double worldCoord[3]);
+
+    void ProjectScreenToCamera
+        (const int screenCoord[2], const double z,
+         const int screenWidth, const int screenHeight,
+         vtkMatrix4x4 *imvp, double cameraCoord[3]);
+
+    inline void ProjectScreenToWorld
+        (const int x, const int y, const double z,
+         const int screenWidth, const int screenHeight, 
+         const double panPercentage[2], const double imageZoom,
+         vtkMatrix4x4 *imvp, double worldCoord[3]) 
+    {
+        int screen_coord[2] = {x, y};
+        ProjectScreenToWorld(screen_coord, z, screenWidth, screenHeight, 
+                             panPercentage, imageZoom, imvp, worldCoord);
+    }
+
+    void ProjectWorldToScreenCube
+        (const double cube[6], const int screenWidth, const int screenHeight, 
+         const double panPercentage[2], const double imageZoom, 
+         vtkMatrix4x4 *mvp,int screenExtents[4], double depthExtents[2]);
+
+    void CompositeBackground(int screen[2],
+                             int compositedImageExtents[4],
+                             int compositedImageWidth,
+                             int compositedImageHeight,
+                             float *compositedImageBuffer,
+                             unsigned char *opaqueImageColor,
+                             float         *opaqueImageDepth,
+                             unsigned char *&imgFinal);
+    
+    void WriteArrayToPPM
+        (std::string, const float *image, int dimX, int dimY);
+
+    void WriteArrayToPPM
+        (std::string, const unsigned char *image, int dimX, int dimY);
+
+    void WriteArrayGrayToPPM
+        (std::string, const float * image, int dimX, int dimY);
+};
+
+#endif//AVT_OSPRAY_COMMON_EXTRA_H
+
+#endif//VISIT_OSPRAY_CONTEXT_ONLY
+
diff --git a/avt/Filters/avtOSPRayImageCompositor.C b/avt/Filters/avtOSPRayImageCompositor.C
new file mode 100644
index 000000000..f4635ff1e
--- /dev/null
+++ b/avt/Filters/avtOSPRayImageCompositor.C
@@ -0,0 +1,2394 @@
+/*****************************************************************************
+ *
+ * Copyright (c) 2000 - 2017, Lawrence Livermore National Security, LLC
+ * Produced at the Lawrence Livermore National Laboratory
+ * LLNL-CODE-442911
+ * All rights reserved.
+ *
+ * This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+ * full copyright notice is contained in the file COPYRIGHT located at the root
+ * of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+ *
+ * Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  - Redistributions of  source code must  retain the above  copyright notice,
+ *    this list of conditions and the disclaimer below.
+ *  - Redistributions in binary form must reproduce the above copyright notice,
+ *    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+ *    documentation and/or other materials provided with the distribution.
+ *  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+ * ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+ * LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+ * DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+ * LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+ * OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ *****************************************************************************/
+
+// ************************************************************************ //
+//                        avtOSPRayImageCompositor.C                         //
+// ************************************************************************ //
+
+#include <avtOSPRayImageCompositor.h>
+
+#ifdef PARALLEL
+#  ifdef VISIT_OSPRAY_ICET
+#    include <IceT.h>
+#    include <IceTMPI.h>
+#  endif
+#endif
+
+#include <cmath>
+#include <ctime>
+#include <cstdio>
+#include <cstring>
+#include <cstdlib>
+#include <limits>
+#include <fstream>
+#include <algorithm>
+#include <set>
+
+#if defined (_MSC_VER) && (_MSC_VER < 1800) && !defined(round)
+inline double round(double x) {return (x-floor(x))>0.5?ceil(x):floor(x);}
+#endif
+
+enum blendDirection {FRONT_TO_BACK = 0, BACK_TO_FRONT = 1};
+
+// ***************************************************************************
+// Threaded Blending
+// ***************************************************************************
+
+bool CheckThreadedBlend_Communicator()
+{
+    bool use = true;
+    const char* env_use = std::getenv("OSPRAY_SERIAL_BLEND");
+    if (env_use) { 
+	use = atoi(env_use) <= 0; 
+    }
+    return use;
+}
+static bool UseThreadedBlend_Communicator = CheckThreadedBlend_Communicator();
+
+// ***************************************************************************
+//  Class: avtOSPRayIC_IceT
+// ***************************************************************************
+
+class avtOSPRayIC_IceT : public avtOSPRayIC_Implementation
+{
+public:
+    avtOSPRayIC_IceT(int mpiSize, int mpiRank);
+    ~avtOSPRayIC_IceT();
+    void Init(int, int);
+    void SetTile(const float*, const int*, const float&);
+    void Composite(float*&);
+    static bool Valid();
+private:
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    //---------------------------------------
+    IceTInt          screen[2];
+    IceTContext      context, prevContext;
+    IceTCommunicator comm;
+    IceTInt          MPISize;
+    IceTInt          MPIRank;
+    IceTImage        result;    
+    //---------------------------------------
+    static const bool       usage;
+    static const IceTDouble identity[16];
+    static const IceTFloat  bgColor[4];
+    static const IceTEnum   strategy;
+    //---------------------------------------
+    static const float* imgData;
+    static int          imgMeta[4];
+    //---------------------------------------
+    static bool     CheckUsage();
+    static IceTEnum CheckStrategy();
+    static void DrawCallback(const IceTDouble*, const IceTDouble*,  
+                             const IceTFloat*, const IceTInt*, 
+                             IceTImage img);
+#endif
+};
+
+/*! static functions */
+bool avtOSPRayIC_IceT::Valid() { 
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    return usage;
+#else
+    return false;
+#endif
+}
+
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+const bool avtOSPRayIC_IceT::usage =
+    avtOSPRayIC_IceT::CheckUsage(); 
+bool avtOSPRayIC_IceT::CheckUsage()
+{
+    bool use_icet = false;
+    const char* env_use_icet = std::getenv("OSPRAY_USE_ICET");
+    if (env_use_icet) { 
+	use_icet = atoi(env_use_icet) > 0; 
+    }
+    return use_icet;
+}
+const IceTDouble avtOSPRayIC_IceT::identity[16] = 
+    {
+        IceTDouble(1.0), IceTDouble(0.0), IceTDouble(0.0), IceTDouble(0.0),
+        IceTDouble(0.0), IceTDouble(1.0), IceTDouble(0.0), IceTDouble(0.0),
+        IceTDouble(0.0), IceTDouble(0.0), IceTDouble(1.0), IceTDouble(0.0),
+        IceTDouble(0.0), IceTDouble(0.0), IceTDouble(0.0), IceTDouble(1.0)
+    };
+const IceTFloat avtOSPRayIC_IceT::bgColor[4] = 
+    {
+        IceTFloat(0.0f), IceTFloat(0.0f), IceTFloat(0.0f), IceTFloat(0.0f)
+    };
+const float*   avtOSPRayIC_IceT::imgData = NULL;
+int            avtOSPRayIC_IceT::imgMeta[4] = {0,0,0,0};
+const IceTEnum avtOSPRayIC_IceT::strategy =
+    avtOSPRayIC_IceT::CheckStrategy();
+IceTEnum       avtOSPRayIC_IceT::CheckStrategy() 
+{
+    if (avtOSPRayIC_IceT::Valid()) {
+        IceTEnum ret;
+        int strategy = 3;
+        const char* env_icet_strategy = std::getenv("OSPRAY_ICET_STRATEGY");
+        if (env_icet_strategy) { strategy = atoi(env_icet_strategy); }
+        switch (strategy) {
+        case 0:
+            ret = ICET_STRATEGY_REDUCE;
+            break;
+        case 1:
+            ret = ICET_SINGLE_IMAGE_STRATEGY_TREE;
+            break;
+        case 2:
+            ret = ICET_SINGLE_IMAGE_STRATEGY_RADIXK;
+            break;
+        default:
+            ret = ICET_SINGLE_IMAGE_STRATEGY_BSWAP;
+            break;
+        }
+        return ret;
+    }
+    else {
+        return false;
+    }
+}
+#endif
+
+/*! regular member functions */
+avtOSPRayIC_IceT::avtOSPRayIC_IceT(int mpiSize, int mpiRank)
+    : avtOSPRayIC_Implementation(mpiSize, mpiRank)
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    MPISize = IceTInt(mpiSize);
+    MPIRank = IceTInt(mpiRank);
+    prevContext = icetGetContext();
+    comm = icetCreateMPICommunicator(VISIT_MPI_COMM);
+    context = icetCreateContext(comm);
+    icetDestroyMPICommunicator(comm);
+    // debug
+    if (avtOSPRayIC_IceT::Valid() && mpiRank == 0) {
+        switch (avtOSPRayIC_IceT::strategy) {
+        case 0:
+            ospout << "[avtOSPRayIC_IceT] Strategy Reduce" << std::endl;
+            break;
+        case 1:
+            ospout << "[avtOSPRayIC_IceT] Strategy Tree" << std::endl;
+            break;
+        case 2:
+            ospout << "[avtOSPRayIC_IceT] Strategy Radix-k" << std::endl;
+            break;
+        default:
+            ospout << "[avtOSPRayIC_IceT] Strategy BSwap" << std::endl;
+            break;
+        }
+    }
+#endif
+}
+
+avtOSPRayIC_IceT::~avtOSPRayIC_IceT()
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    icetDestroyContext(context);
+    icetSetContext(prevContext);
+#endif
+}
+
+void avtOSPRayIC_IceT::Init(int W, int H)
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    
+    if (MPIRank == 0) {
+        ospout << "avtOSPRayIC_IceT::Init Start";
+    }
+    //
+    // Initialization
+    //
+    screen[0] = W;
+    screen[1] = H;
+    //
+    // Setup IceT parameters
+    //
+    if (/*ospray::CheckVerbose()*/ false /*|| DebugStream::Level5()*/) {
+        icetDiagnostics(ICET_DIAG_FULL);
+    }
+    icetCompositeMode(ICET_COMPOSITE_MODE_BLEND);
+    icetSetColorFormat(ICET_IMAGE_COLOR_RGBA_FLOAT);
+    icetSetDepthFormat(ICET_IMAGE_DEPTH_NONE);
+    icetEnable(ICET_ORDERED_COMPOSITE);
+    icetDisable(ICET_INTERLACE_IMAGES);
+    //
+    // Safety
+    //
+    MPI_Barrier(MPI_COMM_WORLD);
+    if (MPIRank == 0) {
+        ospout << " ... Done" << std::endl;
+    }
+#endif
+}
+
+void avtOSPRayIC_IceT::SetTile(const float* d, 
+                                   const int*   e, /* xmin, xmax, ymin, ymax */
+                                   const float& z)
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    //
+    // Gather depths
+    //
+    if (MPIRank == 0) {
+        ospout << "avtOSPRayIC_IceT::SetTile Gather Depth";
+    }
+    std::vector<float>   all_depths(MPISize);
+    std::vector<IceTInt> all_orders(MPISize);
+    MPI_Allgather(&z, 1, MPI_FLOAT, all_depths.data(), 1, 
+                  MPI_FLOAT, MPI_COMM_WORLD);
+    if (MPIRank == 0) { ospout << " ... Done" << std::endl; }
+    //
+    // Sort depths in compositing order
+    //
+    if (MPIRank == 0) {
+        ospout << "avtOSPRayIC_IceT::SetTile Sort Depths";
+    }
+    std::multimap<float,int> ordered_depths;
+    for (int i = 0; i < MPISize; i++) {
+        ordered_depths.insert(std::pair<float, int>(all_depths[i], i));      
+    }
+    int i = 0;
+    for (std::multimap<float,int>::iterator it = ordered_depths.begin(); 
+	 it != ordered_depths.end(); ++it) {
+        all_orders[i] = (*it).second;
+        i++;
+    }
+    icetCompositeOrder(all_orders.data());
+    if (MPIRank == 0) { ospout << " ... Done" << std::endl; }
+    //
+    // Set IceT Tile Information
+    //
+    icetResetTiles();
+    icetAddTile(0, 0, screen[0], screen[1], 0);
+    icetPhysicalRenderSize(screen[0], screen[1]);
+    //
+    // Composite Stratagy
+    //
+    if (strategy == ICET_STRATEGY_REDUCE) {
+	icetStrategy(ICET_STRATEGY_REDUCE);
+    } else {	
+	icetStrategy(ICET_STRATEGY_SEQUENTIAL);
+	icetSingleImageStrategy(strategy);
+    }
+    //
+    // Bounding Box
+    //
+    icetBoundingBoxf(((float) e[0]   /(screen[0]-1) - 0.5f) * 2.f,
+    	             ((float)(e[1]-1)/(screen[0]-1) - 0.5f) * 2.f,
+		     ((float) e[2]   /(screen[1]-1) - 0.5f) * 2.f,
+		     ((float)(e[3]-1)/(screen[1]-1) - 0.5f) * 2.f,
+    		     0.0, 0.0);
+    //
+    // Compose
+    //
+    avtOSPRayIC_IceT::imgData = d;
+    avtOSPRayIC_IceT::imgMeta[0] = e[0];
+    avtOSPRayIC_IceT::imgMeta[1] = e[2];
+    avtOSPRayIC_IceT::imgMeta[2] = e[1] - e[0];
+    avtOSPRayIC_IceT::imgMeta[3] = e[3] - e[2];
+    icetDrawCallback(DrawCallback);
+#endif
+}
+
+void avtOSPRayIC_IceT::Composite(float*& output)
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    if (MPIRank == 0) { ospout << "avtOSPRayIC_IceT::Composite"; }
+    result = icetDrawFrame(identity, identity, bgColor);
+    if (MPIRank == 0) { ospout << " ... Done" << std::endl; }
+    if (MPIRank == 0) {
+	icetImageCopyColorf(result, output, ICET_IMAGE_COLOR_RGBA_FLOAT);
+    }
+#endif
+}
+
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+void avtOSPRayIC_IceT::DrawCallback(const IceTDouble*,
+					const IceTDouble*, 
+					const IceTFloat*, 
+					const IceTInt*,
+					IceTImage img) 
+{
+    float *o = icetImageGetColorf(img);
+    const int outputStride = icetImageGetWidth(img);
+    for (int j = 0; j < imgMeta[3]; ++j) {	
+	for (int i = 0; i < imgMeta[2]; ++i) {
+	    const int gIdx = 
+		i + imgMeta[0] + (j + imgMeta[1]) * outputStride;
+	    const int lIdx = i + j * imgMeta[2];
+	    o[4 * gIdx + 0] = imgData[4 * lIdx + 0];
+	    o[4 * gIdx + 1] = imgData[4 * lIdx + 1];
+	    o[4 * gIdx + 2] = imgData[4 * lIdx + 2];
+	    o[4 * gIdx + 3] = imgData[4 * lIdx + 3];
+	}
+    }
+}
+#endif
+
+// ***************************************************************************
+//  End Class: avtOSPRayIC_IceT
+// ***************************************************************************
+
+
+// ***************************************************************************
+//  Begin Class: avtOSPRayIC_OneNode
+// ***************************************************************************
+
+struct MetaData_OneNode {
+    int id;         // id of the patch on that processor
+    int dims[2];    // height, width
+    int extents[4]; // (lower left) (upper right)
+    float z;        // camera space depth of the patch (average)
+};
+
+class avtOSPRayIC_OneNode : public avtOSPRayIC_Implementation
+{
+private:
+    std::vector<MetaData_OneNode> allPatchMeta;
+    std::vector<const float*>     allPatchData;
+    int fullExtents[4];
+
+    static bool Predicate(MetaData_OneNode const& before,
+                          MetaData_OneNode const& after);
+public:
+    avtOSPRayIC_OneNode(int mpiSize, int mpiRank);
+    ~avtOSPRayIC_OneNode();
+    void Init(int, int);
+    void SetTile(const float*, const int*, const float&);
+    void Composite(float*&);
+    static bool Valid();
+};
+
+bool avtOSPRayIC_OneNode::Valid() { return true; };
+bool avtOSPRayIC_OneNode::Predicate(MetaData_OneNode const& before,
+                                        MetaData_OneNode const& after)
+{ return before.z > after.z; }
+
+avtOSPRayIC_OneNode::avtOSPRayIC_OneNode(int mpiSize, int mpiRank)
+    : avtOSPRayIC_Implementation(mpiSize, mpiRank)
+{
+}
+
+avtOSPRayIC_OneNode::~avtOSPRayIC_OneNode()
+{
+    allPatchMeta.clear();
+    allPatchData.clear();
+};
+
+void avtOSPRayIC_OneNode::Init(int W, int H)
+{
+    fullExtents[0] = 0;
+    fullExtents[1] = W;
+    fullExtents[2] = 0;
+    fullExtents[3] = H;
+};
+
+void avtOSPRayIC_OneNode::SetTile(const float* d,
+                                      /* xmin, xmax, ymin, ymax */ 
+                                      const int*   e,
+                                      const float& z)
+{
+    MetaData_OneNode m;
+    m.id = allPatchMeta.size();
+    m.dims[0] = e[1] - e[0];
+    m.dims[1] = e[3] - e[2];
+    m.extents[0] = e[0];
+    m.extents[1] = e[1];
+    m.extents[2] = e[2];
+    m.extents[3] = e[3];
+    m.z = z;
+    allPatchMeta.push_back(m);
+    allPatchData.push_back(d);
+}
+
+void avtOSPRayIC_OneNode::Composite(float*& output)
+{
+    // Sort with the largest z first
+    std::sort(allPatchMeta.begin(), allPatchMeta.end(),
+              &(avtOSPRayIC_OneNode::Predicate));
+    for (int i=0; i<allPatchMeta.size(); i++) {
+      MetaData_OneNode m = allPatchMeta[i];
+      avtOSPRayImageCompositor::BlendBackToFront(allPatchData[m.id],
+                                                m.extents,
+                                                output, 
+                                                fullExtents);
+    }
+}
+
+// ***************************************************************************
+//  End Class: avtOSPRayIC_OneNode
+// ***************************************************************************
+
+
+// ***************************************************************************
+//  Begin Class: avtOSPRayIC_Serial
+// ***************************************************************************
+
+// class avtOSPRayIC_Serial : public avtOSPRayIC_Implementation
+// {
+// public:
+//     avtOSPRayIC_Serial(int mpiSize, int mpiRank);
+//     ~avtOSPRayIC_Serial();
+//     void Init(int, int);
+//     void SetTile(const float*, const int*, const float&);
+//     void Composite(float*&);
+//     static bool Valid();
+// };
+
+// bool avtOSPRayIC_Serial::Valid() { return true; };
+
+// ***************************************************************************
+//  End Class: avtOSPRayIC_Serial
+// ***************************************************************************
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::avtOSPRayImageCompositor
+//
+//  Purpose: Constructor
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+avtOSPRayImageCompositor::avtOSPRayImageCompositor()
+{
+#ifdef PARALLEL
+    MPI_Comm_size(VISIT_MPI_COMM, &mpiSize);
+    MPI_Comm_rank(VISIT_MPI_COMM, &mpiRank);
+#else
+    mpiSize = 1;
+    mpiRank = 0;
+#endif
+    finalImage = NULL;
+    compositor = NULL;
+    // debug
+    if (mpiRank == 0) {
+        if (!UseThreadedBlend_Communicator) {
+            ospout << "[avtOSPRayImageCompositor] "
+                   << "Not Using Multi-Threading for Blending"
+                   << std::endl;
+        } else {
+            ospout << "[avtOSPRayImageCompositor] "
+                   << "Using Multi-Threading for Blending"
+                   << std::endl;
+        }
+        if (!avtOSPRayIC_IceT::Valid()) {
+            ospout << "[avtOSPRayImageCompositor] "
+                   << "Not Using IceT for Image Compositing"
+                   << std::endl;
+        } else {
+            ospout << "[avtOSPRayImageCompositor] "
+                   << "Using IceT for Image Compositing"
+                   << std::endl;
+        }
+    }
+    //////////////////////////////////////////////////////////////////////////
+    intermediateImageExtents[0] = intermediateImageExtents[1] = 0.0;
+    intermediateImageExtents[2] = intermediateImageExtents[3] = 0.0;
+    intermediateImageBBox[0] = intermediateImageBBox[1] = 0.0;
+    intermediateImageBBox[2] = intermediateImageBBox[3] = 0.0;
+    totalPatches = 0;
+    intermediateImage = NULL;
+    //////////////////////////////////////////////////////////////////////////
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::~avtOSPRayImageCompositor
+//
+//  Purpose:
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+avtOSPRayImageCompositor::~avtOSPRayImageCompositor()
+{
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendFrontToBack
+//
+//  Purpose:
+//      Blends tow patches in a front to back manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendFrontToBack(const float *srcImage,
+					       const int srcExtents[4],
+					       const int blendExtents[4], 
+					       float *&dstImage,
+					       const int dstExtents[4])
+{
+    if (UseThreadedBlend_Communicator) {
+      ospray::visit::BlendFrontToBack(blendExtents,
+				srcExtents,
+				srcImage,
+				dstExtents,
+				dstImage);
+    } else {
+        // image sizes
+        const int srcX = srcExtents[1] - srcExtents[0];
+        const int srcY = srcExtents[3] - srcExtents[2];
+        const int dstX = dstExtents[1] - dstExtents[0];
+        const int dstY = dstExtents[3] - dstExtents[2];
+        // determin the region to blend
+        const int startX = 
+            std::max(std::max(blendExtents[0], srcExtents[0]), dstExtents[0]);
+        const int startY = 
+            std::max(std::max(blendExtents[2], srcExtents[2]), dstExtents[2]);
+        const int endX = 
+            std::min(std::min(blendExtents[1], srcExtents[1]), dstExtents[1]);
+        const int endY = 
+            std::min(std::min(blendExtents[3], srcExtents[3]), dstExtents[3]);
+    
+        for (int y = startY; y < endY; ++y) {
+            for (int x = startX; x < endX; ++x) {
+                // get indices
+                int srcIndex = (srcX*(y-srcExtents[2]) + x-srcExtents[0])*4;
+                int dstIndex = (dstX*(y-dstExtents[2]) + x-dstExtents[0])*4;
+
+                // front to back compositing
+                if (dstImage[dstIndex + 3] < 1.0f) {
+                    float trans = 1.0f - dstImage[dstIndex + 3];
+                    dstImage[dstIndex+0] = 
+                        CLAMP(srcImage[srcIndex+0] * trans + 
+                              dstImage[dstIndex+0],
+                              0.0f, 1.0f);
+                    dstImage[dstIndex+1] = 
+                        CLAMP(srcImage[srcIndex+1] * trans + 
+                              dstImage[dstIndex+1],
+                              0.0f, 1.0f);
+                    dstImage[dstIndex+2] = 
+                        CLAMP(srcImage[srcIndex+2] * trans + 
+                              dstImage[dstIndex+2],
+                              0.0f, 1.0f);
+                    dstImage[dstIndex+3] = 
+                        CLAMP(srcImage[srcIndex+3] * trans + 
+                              dstImage[dstIndex+3],
+                              0.0f, 1.0f);
+                }
+            }
+        }
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendBackToFront
+//
+//  Purpose:
+//      Blends tow patches in a back to front manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendBackToFront(const float *srcImage,
+					       const int srcExtents[4],
+					       const int blendExtents[4], 
+					       float *&dstImage,
+					       const int dstExtents[4])
+{
+    if (UseThreadedBlend_Communicator) {
+      ospray::visit::BlendBackToFront(blendExtents,
+	                        srcExtents,
+	                        srcImage,
+	                        dstExtents,
+	                        dstImage);
+    } else {
+        // image sizes
+        const int srcX = srcExtents[1] - srcExtents[0];
+        const int srcY = srcExtents[3] - srcExtents[2];
+        const int dstX = dstExtents[1] - dstExtents[0];
+        const int dstY = dstExtents[3] - dstExtents[2];
+        // determin the region to blend
+        const int startX = 
+            std::max(std::max(blendExtents[0], srcExtents[0]), dstExtents[0]);
+        const int startY = 
+            std::max(std::max(blendExtents[2], srcExtents[2]), dstExtents[2]);
+        const int endX = 
+            std::min(std::min(blendExtents[1], srcExtents[1]), dstExtents[1]);
+        const int endY = 
+            std::min(std::min(blendExtents[3], srcExtents[3]), dstExtents[3]);
+    
+        for (int y = startY; y < endY; ++y) {
+            for (int x = startX; x < endX; ++x) {
+                // get indices
+                int srcIndex = (srcX*(y-srcExtents[2]) + x-srcExtents[0])*4;
+                int dstIndex = (dstX*(y-dstExtents[2]) + x-dstExtents[0])*4;
+                // back to front compositing	    
+                float trans = 1.0f - srcImage[srcIndex + 3];
+                dstImage[dstIndex+0] = 
+                    CLAMP(dstImage[dstIndex+0] * trans + srcImage[srcIndex+0],
+                          0.0f, 1.0f);
+                dstImage[dstIndex+1] = 
+                    CLAMP(dstImage[dstIndex+1] * trans + srcImage[srcIndex+1],
+                          0.0f, 1.0f);
+                dstImage[dstIndex+2] = 
+                    CLAMP(dstImage[dstIndex+2] * trans + srcImage[srcIndex+2],
+                          0.0f, 1.0f);
+                dstImage[dstIndex+3] = 
+                    CLAMP(dstImage[dstIndex+3] * trans + srcImage[srcIndex+3],
+                          0.0f, 1.0f);
+            }
+        }
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendFrontToBack
+//
+//  Purpose:
+//      Blends tow patches in a front to back manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendFrontToBack(const float * srcImage,
+					       const int srcExtents[4], 
+					       float *& dstImage,
+					       const int dstExtents[4])
+{
+    BlendFrontToBack(srcImage, srcExtents, srcExtents, dstImage, dstExtents);
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendBackToFront
+//
+//  Purpose:
+//      Blends tow patches in a back to front manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendBackToFront(const float * srcImage,
+					       const int srcExtents[4], 
+					       float *& dstImage, 
+					       const int dstExtents[4])
+{
+    BlendBackToFront(srcImage, srcExtents, srcExtents, dstImage, dstExtents);
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::Barrier
+//
+//  Purpose:
+//    Barrier, useful for debugging
+//
+//  Programmer: Pascal Grosset
+//  Creation: July 2013
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtOSPRayImageCompositor::Barrier() {
+#ifdef PARALLEL
+    MPI_Barrier(MPI_COMM_WORLD);
+#endif
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::ColorImage
+//
+//  Purpose:
+//       Fills a 4 channel image with a specific color
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtOSPRayImageCompositor::ColorImage(float *&srcImage,
+					 const int widthSrc,
+					 const int heightSrc,
+					 const float color[4])
+{
+    for (int i = 0; i < heightSrc * widthSrc; ++i) {
+	const int srcIndex = 4 * i;
+	srcImage[srcIndex+0] = color[0];
+	srcImage[srcIndex+1] = color[1];
+	srcImage[srcIndex+2] = color[2];
+	srcImage[srcIndex+3] = color[3];
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::PlaceImage
+//
+//  Purpose:
+//      Puts srcImage into dstImage
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtOSPRayImageCompositor::PlaceImage(const float *srcImage,
+					 const int srcExtents[4], 
+					 float *&dstImage,
+					 const int dstExtents[4])
+{
+    const int srcX = srcExtents[1] - srcExtents[0];
+    const int srcY = srcExtents[3] - srcExtents[2];
+    const int dstX = dstExtents[1] - dstExtents[0];
+    const int dstY = dstExtents[3] - dstExtents[2];
+    const int startingX = std::max(srcExtents[0], dstExtents[0]);
+    const int startingY = std::max(srcExtents[2], dstExtents[2]);
+    const int endingX = std::min(srcExtents[1], dstExtents[1]);
+    const int endingY = std::min(srcExtents[3], dstExtents[3]);
+    
+    for (int y = startingY; y < endingY; ++y) {
+	for (int x = startingX; x < endingX; ++x) {
+	    // index in the sub-image
+	    const int srcIndex = 
+		(srcX * (y-srcExtents[2]) + x-srcExtents[0]) * 4; 
+	    // index in the larger buffer
+	    const int dstIndex = 
+		(dstX * (y-dstExtents[2]) + x-dstExtents[0]) * 4;
+	    dstImage[dstIndex+0] = srcImage[srcIndex+0];
+	    dstImage[dstIndex+1] = srcImage[srcIndex+1];
+	    dstImage[dstIndex+2] = srcImage[srcIndex+2];
+	    dstImage[dstIndex+3] = srcImage[srcIndex+3];
+	}
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendWithBackground
+//
+//  Purpose:
+//      Blends _image with the backgroundColor
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendWithBackground(float *&image,
+						  const int extents[4],
+						  const float bgColor[4])
+{
+    const int pixelSize = (extents[3]-extents[2]) * (extents[1]-extents[0]);
+    // estimated potential speedup: 2.240
+    for (int i = 0; i < pixelSize; ++i)
+        {
+            const int   idx = i * 4;
+            const float alpha = (1.0 - image[idx+3]);
+            image[idx+0] = bgColor[0] * alpha + image[idx+0];
+            image[idx+1] = bgColor[1] * alpha + image[idx+1];
+            image[idx+2] = bgColor[2] * alpha + image[idx+2];
+            image[idx+3] = bgColor[3] * alpha + image[idx+3];
+        }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::IceT
+//
+//  Purpose:
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+//  Modifications:
+//
+// **************************************************************************
+
+bool avtOSPRayImageCompositor::IceTValid() 
+{
+    return avtOSPRayIC_IceT::Valid(); 
+}
+
+void avtOSPRayImageCompositor::IceTInit(int W, int H)
+{
+    if (!avtOSPRayIC_IceT::Valid()) {
+        std::cerr << "ERROR: IceT compositor is not valid. "
+		  << "Probably IceT is not compiled with VisIt"
+		  << std::endl;
+	ospray::Exception("ERROR: IceT compositor is not valid. "
+                          "Probably IceT is not compiled with VisIt");
+	return;
+    }
+    if (compositor) delete compositor;
+    compositor = new avtOSPRayIC_IceT(mpiSize, mpiRank);
+    compositor->Init(W, H);
+}
+
+void avtOSPRayImageCompositor::IceTSetTile(const float* d, 
+					  const int*   e,
+	                                  const float& z)
+{
+    ospray::timestamp timingDetail;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+			     "IceTSetTile", timingDetail,
+			     "IceT Setup Image Tile");
+    //---------------------------------------------------------------------//
+    compositor->SetTile(d, e, z);
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+			    "IceTSetTile", timingDetail,
+			    "IceT Setup Image Tile");
+    //---------------------------------------------------------------------//
+}
+
+void avtOSPRayImageCompositor::IceTComposite(float*& output)
+{
+    ospray::timestamp timingDetail;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+			     "IceTComposite", timingDetail,
+			     "IceT Image Composition");
+    //---------------------------------------------------------------------//
+    compositor->Composite(output);
+    if (compositor != NULL) { delete compositor; }
+    compositor = NULL;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+			    "IceTComposite", timingDetail,
+			    "IceT Image Composition");
+    //---------------------------------------------------------------------//
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::OneNode
+//
+//  Purpose:
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+//  Modifications:
+//
+// **************************************************************************
+
+bool avtOSPRayImageCompositor::OneNodeValid()
+{
+    return avtOSPRayIC_OneNode::Valid();    
+}
+void avtOSPRayImageCompositor::OneNodeInit(int W, int H)
+{
+    if (compositor) delete compositor;
+    compositor = new avtOSPRayIC_OneNode(mpiSize, mpiRank);
+    compositor->Init(W, H);    
+}
+void avtOSPRayImageCompositor::OneNodeSetTile(const float* d,
+                                             const int*   e, 
+                                             const float& z)
+{
+    compositor->SetTile(d, e, z);
+}
+void avtOSPRayImageCompositor::OneNodeComposite(float*& output)
+{
+    compositor->Composite(output);
+    if (compositor != NULL) { delete compositor; }
+    compositor = NULL;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::UpdateBoundingBox
+//
+//  Purpose:
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void
+avtOSPRayImageCompositor::UpdateBoundingBox(int currentBoundingBox[4],
+					   const int imageExtents[4])
+{
+    if ((currentBoundingBox[0] == 0 && currentBoundingBox[1] == 0) && 
+	(currentBoundingBox[2] == 0 && currentBoundingBox[3] == 0)) {
+        currentBoundingBox[0]=imageExtents[0];
+        currentBoundingBox[1]=imageExtents[1];
+        currentBoundingBox[2]=imageExtents[2];
+        currentBoundingBox[3]=imageExtents[3];
+        return;
+    }
+
+    if (imageExtents[0] < currentBoundingBox[0])
+        { currentBoundingBox[0] = imageExtents[0]; }
+
+    if (imageExtents[2] < currentBoundingBox[2])
+        { currentBoundingBox[2] = imageExtents[2]; }
+
+    if (imageExtents[1] > currentBoundingBox[1])
+        { currentBoundingBox[1] = imageExtents[1]; }
+
+    if (imageExtents[3] > currentBoundingBox[3])
+        { currentBoundingBox[3] = imageExtents[3]; }
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::GatherDepthAtRoot
+//
+//  Purpose:
+//      Used by Serial Direct Send
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void
+avtOSPRayImageCompositor::GatherDepthAtRoot(const int numlocalPatches,
+					   const float *localPatchesDepth,
+					   int &totalPatches,
+					   int *&patchCountPerRank,
+					   float *&allPatchesDepth)
+{
+#ifdef PARALLEL
+    // Get how many patches are coming from each MPI rank
+    totalPatches = 0;
+    int *patchesOffset = NULL;
+
+    if (mpiRank == 0) // root!
+        { patchCountPerRank = new int[mpiSize](); }
+
+    // reference
+    // https://www.mpich.org/static/docs/v3.1/www3/MPI_Gather.html
+    MPI_Gather(&numlocalPatches, /* send buffer */
+	       1, /* send count */
+	       MPI_INT, 
+	       patchCountPerRank, /* address of receive buffer (root) */
+	       1, /* number of elements for any single receive (root) */
+	       MPI_INT, 
+	       0, /* rank of receiving process (integer) */
+	       MPI_COMM_WORLD); /* communicator (handle) */
+
+    // gather number of patch group
+    if (mpiRank == 0)
+        {
+            patchesOffset = new int[mpiSize]();
+            patchesOffset[0] = 0; // a bit redundant
+
+            for (int i=0; i<mpiSize; i++)
+                {
+                    totalPatches += patchCountPerRank[i];
+                    if (i == 0)
+                        { patchesOffset[i] = 0; }
+                    else
+                        {
+                            patchesOffset[i] = 
+                                patchesOffset[i-1] + patchCountPerRank[i-1]; 
+                        }
+                }
+	
+            // allocate only at root
+            allPatchesDepth = new float[totalPatches];
+        }
+
+    // Gathers into specified locations from all processes in a group
+    MPI_Gatherv(localPatchesDepth, numlocalPatches, MPI_FLOAT, 
+		allPatchesDepth, /* receive all depth */
+		patchCountPerRank, patchesOffset, MPI_FLOAT, 
+		0, MPI_COMM_WORLD);
+
+    // Cleanup
+    if (mpiRank == 0 && patchesOffset != NULL)
+        { delete [] patchesOffset; }
+    patchesOffset = NULL;
+#endif
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::SerialDirectSend
+//
+//  Purpose:
+//      A very simple compositing that we can fall back to if parallel direct
+//      send is buggy.
+//      Works with convex patches though
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void
+avtOSPRayImageCompositor::SerialDirectSend(int localNumPatches,
+					  float *localPatchesDepth, 
+					  int *extents,
+					  float *imgData,
+					  float bgColor[4],
+					  int width, int height)
+{
+#ifdef PARALLEL
+    //
+    // Message
+    //
+    //debug5 << "-- Serial Direct Send --" << std::endl;
+
+    float *recvImage = NULL;
+    int tags[2] = {5781, 5782};
+    //
+    // Retrieve depth info through MPI
+    //
+    int    totalPatches; // total number of patches
+    int   *totalPatchCountsPerRank = NULL;
+    float *totalPatchDepths = NULL;
+    GatherDepthAtRoot(localNumPatches,
+		      localPatchesDepth,
+		      totalPatches, 
+		      totalPatchCountsPerRank,
+		      totalPatchDepths);
+    //
+    //
+    //
+    if (mpiRank == 0)
+        {
+            // Root
+            int srcSize[2] = {width, height};
+            int srcPos[2]  = {0, 0};
+            int dstSize[2], dstPos[2];
+
+            // Sort patches we will receive
+            std::multimap<float,int> sortedPatches;
+
+            int patchId = 0;
+            for (int i=0; i<mpiSize; i++) {
+                for (int j=0; j<totalPatchCountsPerRank[i]; j++) {
+                    sortedPatches.insert
+                        (std::make_pair(totalPatchDepths[patchId++],i));
+                }
+            }
+
+            // Create space for buffers
+            int recvParams[4]; // minX, maxX, minY, maxY
+            int imgExtents[4] = {0,width,0,height};
+
+            recvImage = new float[width*height*4]();
+            finalImage = new float[width*height*4]();
+	
+            int localIndex = 0;
+
+            // Compositing
+            for (std::multimap<float,int>::iterator it = sortedPatches.begin(); 
+                 it != sortedPatches.end(); ++it)
+                {
+                    int rank = (*it).second;
+                    if (rank != mpiRank)
+                        {
+                            // recv image info
+                            MPI_Recv(recvParams, 4, MPI_INT, rank, 
+                                     tags[0], MPI_COMM_WORLD, MPI_STATUS_IGNORE); 
+                            // recv image
+                            MPI_Recv(recvImage, width*height*4, MPI_FLOAT, rank,
+                                     tags[1],  MPI_COMM_WORLD, MPI_STATUS_IGNORE);
+                            dstPos[0]  = dstPos[0];                     
+                            dstPos[1]  = dstPos[1];
+                            dstSize[0] = recvParams[2]-recvParams[0];   
+                            dstSize[1] = recvParams[3]-recvParams[1];
+                        }
+                    else
+                        {
+                            // It's local
+                            recvParams[0] = extents[ localIndex*4 + 0];
+                            recvParams[1] = extents[ localIndex*4 + 1];
+                            recvParams[2] = extents[ localIndex*4 + 2];
+                            recvParams[3] = extents[ localIndex*4 + 3];
+                            recvImage = &imgData[ localIndex*(width*height*4) ];
+                            localIndex++;
+                        }
+                    BlendFrontToBack(recvImage, recvParams, finalImage, imgExtents);
+                }
+            BlendWithBackground(finalImage, imgExtents, bgColor);
+        }
+    else
+        {
+            // Sender
+            for (int i=0; i<localNumPatches; i++)
+                {
+                    int imgSize = 
+                        (extents[i*4 + 1] - extents[i*4 + 0]) *
+                        (extents[i*4 + 3] - extents[i*4 + 2]) * 4;	    
+                    if (imgSize > 0)
+                        {
+                            MPI_Send(&extents[i*4],
+                                     4, MPI_INT, 0, tags[0], MPI_COMM_WORLD);
+                            MPI_Send(&imgData[i*(width*height*4)], 
+                                     imgSize, MPI_FLOAT, 0, tags[1], MPI_COMM_WORLD);
+                        }
+                }
+        }
+
+    // Cleanup
+    if (totalPatchDepths != NULL)
+	delete []totalPatchDepths;
+
+    if (totalPatchCountsPerRank != NULL)
+        delete []totalPatchCountsPerRank;
+
+    if (recvImage != NULL)
+        delete []recvImage;
+
+    recvImage = NULL;
+    totalPatchCountsPerRank = NULL;
+    totalPatchDepths = NULL;
+#endif
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::regionAllocation
+//
+//  Purpose:
+//      Arbitrarily allocates regions to MPI ranks
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void
+avtOSPRayImageCompositor::RegionAllocation(int *& regions)
+{
+    regions = new int[mpiSize];
+    // Initial allocation: partition for section rank
+    for (int i=0; i<mpiSize; i++) { regions[i] = i; }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::parallelDirectSend
+//
+//  Purpose:
+//      Parallel Direct Send rendering that can blend convex patches from each
+//      MPI rank. However, since we are not guaranteed to have convex patches.
+//      It's not used.
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtOSPRayImageCompositor::parallelDirectSend(float *imgData,
+					    int imgExtents[4],
+					    int region[],
+					    int numRegions,
+					    int tags[2],
+					    int fullImageExtents[4])
+{
+#ifdef PARALLEL
+    //
+    // Determine position in region (myPositionInRegion)
+    int width  = fullImageExtents[1]-fullImageExtents[0];
+    int height = fullImageExtents[3]-fullImageExtents[2];
+
+    //debug5 << "fullImageExtents: " << fullImageExtents[0] << ", " << fullImageExtents[1] << "   " << fullImageExtents[2] << ", " << fullImageExtents[3] << endl;
+
+    compositingDone = false;
+    int myPositionInRegion = -1;
+    bool inRegion = true;
+    std::vector<int> regionVector(region, region+numRegions);
+    std::vector<int>::iterator it = std::find(regionVector.begin(),
+					      regionVector.end(),
+					      mpiRank);
+
+    if (it == regionVector.end())
+        {
+            inRegion = false;
+            //debug5 << mpiRank << " ~ SHOULD NOT HAPPEN: Not found " << mpiRank <<  " !!!" << std::endl;
+        }
+    else
+        myPositionInRegion = it - regionVector.begin();
+
+    //
+    // Region boundaries
+    int regionHeight = height/numRegions;
+    int lastRegionHeight = height - regionHeight*(numRegions-1);
+
+    // Extents of my region
+    int myStartingHeight =
+	fullImageExtents[2] +
+	myPositionInRegion *
+	regionHeight;
+    int myEndingHeight = myStartingHeight + regionHeight;
+    if (myPositionInRegion == numRegions-1)
+        myEndingHeight = fullImageExtents[3];
+
+    int myRegionHeight = myEndingHeight-myStartingHeight;
+
+    // Size of one buffer
+    int sizeOneBuffer = std::max(regionHeight,lastRegionHeight) * width * 4;
+
+    //debug5 << "myPositionInRegion: " << myPositionInRegion << std::endl;
+    //debug5 << "My extents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
+    //debug5 << "myRegionHeight: " << myRegionHeight << "  lastRegionHeight: " << lastRegionHeight << " regionHeight: " << regionHeight << "  myStartingHeight: " << myStartingHeight << "  myEndingHeight: " << myEndingHeight << std::endl;
+
+
+    //
+    // MPI Async
+
+    // Recv
+    MPI_Request *recvMetaRq = new MPI_Request[ numRegions-1 ];
+    MPI_Request *recvImageRq = new MPI_Request[ numRegions-1 ];
+
+    MPI_Status *recvMetaSt = new MPI_Status[ numRegions-1 ];
+    MPI_Status *recvImageSt = new MPI_Status[ numRegions-1 ];
+
+    // Send
+    MPI_Request *sendMetaRq = new MPI_Request[ numRegions-1 ];
+    MPI_Request *sendImageRq = new MPI_Request[ numRegions-1 ];
+
+    MPI_Status *sendMetaSt = new MPI_Status[ numRegions-1 ];
+    MPI_Status *sendImageSt = new MPI_Status[ numRegions-1 ];
+
+
+    //
+    // Create Buffers
+
+    // Create buffer for receiving images
+    float *recvDataBuffer;
+    recvDataBuffer = new float[ sizeOneBuffer * numRegions];
+
+    // Create buffer for receiving messages
+    std::vector<int> msgBuffer;
+    msgBuffer.clear();
+    msgBuffer.resize(5 * numRegions);
+
+    // Create buffer for sending messages
+    int *sendExtents = new int[numRegions*5];
+
+    //
+    // Async Recv
+    if (inRegion)
+        {
+            int recvCount=0;
+            for (int i=0; i<numRegions; i++)
+                {
+                    if ( regionVector[i] == mpiRank )
+                        continue;
+
+                    int src = regionVector[i];
+                    MPI_Irecv(&msgBuffer[i*5],                              5, MPI_INT,   src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvCount] );
+                    MPI_Irecv(&recvDataBuffer[i*sizeOneBuffer], sizeOneBuffer, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+                    recvCount++;
+                }
+        }
+
+    //debug5 << "Async Recv setup done " << std::endl;
+
+    //
+    // Async Send
+    int sendCount = 0;
+    int sendingOffset;
+    for (int i=0; i<numRegions; i++)
+        {
+            int regionStart, regionEnd, imgSize, dest;
+            dest = regionVector[i];
+
+            if ( dest == mpiRank )
+                continue;
+
+            regionStart = i*regionHeight;
+            regionEnd = regionStart + regionHeight;
+            if (i == numRegions-1) // the last one in region
+                regionEnd = height;
+
+            int startingYExtents = fullImageExtents[2] + regionStart;
+            int endingYExtents = fullImageExtents[2] + regionEnd;
+
+            //debug5 << "startingYExtents: " << startingYExtents <<"   endingYExtents: " << endingYExtents <<  std::endl;
+
+            if (startingYExtents < imgExtents[2])
+                startingYExtents = imgExtents[2];
+
+            if (endingYExtents > imgExtents[3])
+                endingYExtents = imgExtents[3];
+
+            bool hasData = true;
+            if (endingYExtents - startingYExtents <= 0 || imgExtents[1]-imgExtents[0] <= 0)
+                {
+                    hasData = false;
+
+                    sendingOffset = 0;
+                    imgSize = sendExtents[i*5 + 0] = sendExtents[i*5 + 1] = sendExtents[i*5 + 2] = sendExtents[i*5 + 3] =  sendExtents[i*5 + 4] = 0;
+                }
+            else
+                {
+                    imgSize = (endingYExtents-startingYExtents) * (imgExtents[1]-imgExtents[0]) * 4;
+                    sendingOffset = (startingYExtents-imgExtents[2]) * (imgExtents[1]-imgExtents[0]) * 4;
+
+                    sendExtents[i*5 + 0] = imgExtents[0];
+                    sendExtents[i*5 + 1] = imgExtents[1];
+                    sendExtents[i*5 + 2] = startingYExtents;
+                    sendExtents[i*5 + 3] = endingYExtents;
+                    sendExtents[i*5 + 4] = 0;
+                }
+
+            //std::cout << mpiRank << " ~ i: " << i << "   regionVector[index]: " << regionVector[index] << "  extents: " <<  sendExtents[index*5 + 0] << ", " << sendExtents[index*5 + 1]  << ", " << sendExtents[index*5 + 2] << ", " << sendExtents[index*5 + 3] << "  sending ... " << std::endl;
+            MPI_Isend(&sendExtents[i*5],             5,   MPI_INT, dest, tags[0], MPI_COMM_WORLD, &sendMetaRq[sendCount]);
+            MPI_Isend(&imgData[sendingOffset], imgSize, MPI_FLOAT, dest, tags[1], MPI_COMM_WORLD, &sendImageRq[sendCount]);
+
+            //debug5 << "dest: " << dest <<"   sendExtents: " << sendExtents[i*5 +0] << ", " << sendExtents[i*5 +1] << "    " << sendExtents[i*5 +2] << ", " << sendExtents[i*5 +3] << std::endl << std::endl;
+
+            sendCount++;
+        }
+
+    //debug5 << "Async Recv" << std::endl;
+
+    //
+    // Create buffer for region
+    intermediateImageExtents[0] = fullImageExtents[0];  intermediateImageExtents[1] = fullImageExtents[1];
+    intermediateImageExtents[2] = myStartingHeight;     intermediateImageExtents[3] = myEndingHeight;
+
+    intermediateImage = new float[width * (myEndingHeight-myStartingHeight) * 4]();
+
+    int recvImageExtents[4];
+    float *recvImageData;
+
+    //
+    // Blend
+    int numBlends = 0;
+    int countBlend = 0;
+
+    intermediateImageBBox[0] = intermediateImageBBox[2] = 0;
+    intermediateImageBBox[1] = intermediateImageBBox[3] = 0;
+
+    if (inRegion)
+        {
+            for (int i=0; i<numRegions; i++)
+                {
+                    int index = i;
+
+                    //debug5 << "regionVector[" << i << "] " << regionVector[index] << std::endl;
+
+                    if (regionVector[index] == mpiRank)
+                        {
+                            int startingYExtents = myStartingHeight;
+                            int endingYExtents = myEndingHeight;
+
+                            if (startingYExtents < imgExtents[2])
+                                startingYExtents = imgExtents[2];
+
+                            if (endingYExtents > imgExtents[3])
+                                endingYExtents = imgExtents[3];
+
+
+                            bool hasData = true;
+                            if (endingYExtents - startingYExtents <= 0)
+                                {
+                                    hasData = false;
+                                    endingYExtents = startingYExtents = 0;
+                                }
+
+                            if (hasData == true)
+                                {
+                                    int extentsSectionRecv[4];
+                                    extentsSectionRecv[0] = imgExtents[0];
+                                    extentsSectionRecv[1] = imgExtents[1];
+                                    extentsSectionRecv[2] = startingYExtents;
+                                    extentsSectionRecv[3] = endingYExtents;
+
+                                    BlendFrontToBack(imgData, imgExtents, extentsSectionRecv, intermediateImage, intermediateImageExtents);
+
+                                    UpdateBoundingBox(intermediateImageBBox, extentsSectionRecv);
+                                    numBlends++;
+                                }
+                        }
+                    else
+                        {
+                            MPI_Wait(&recvMetaRq[countBlend], &recvMetaSt[countBlend]);
+
+                            for (int j=0; j<4; j++)
+                                recvImageExtents[j] = msgBuffer[index*5 + j];
+
+                            bool hasData =  false;
+                            if (recvImageExtents[1]-recvImageExtents[0] > 0 && recvImageExtents[3]-recvImageExtents[2] > 0)
+                                {
+                                    hasData = true;
+                                    MPI_Wait(&recvImageRq[countBlend], &recvImageSt[countBlend]);
+                                    recvImageData = &recvDataBuffer[index*sizeOneBuffer];
+                                }
+
+                            if (hasData)
+                                {
+
+                                    BlendFrontToBack(recvImageData, recvImageExtents, intermediateImage, intermediateImageExtents);
+
+                                    UpdateBoundingBox(intermediateImageBBox, recvImageExtents);
+                                    numBlends++;
+                                }
+
+                            countBlend++;
+                        }
+                }
+        }
+    else
+        compositingDone = true;
+
+    //debug5 << "PDS blending done" << std::endl;
+
+    msgBuffer.clear();
+
+
+    if (recvDataBuffer != NULL)
+        delete []recvDataBuffer;
+    recvDataBuffer = NULL;
+
+
+    if (numBlends == 0)
+        intermediateImageBBox[0]=intermediateImageBBox[1]=intermediateImageBBox[2]=intermediateImageBBox[3] = 0;
+
+    delete []recvMetaRq;
+    delete []recvImageRq;
+    delete []recvMetaSt;
+    delete []recvImageSt;
+
+    delete []sendMetaRq;
+    delete []sendImageRq;
+    delete []sendMetaSt;
+    delete []sendImageSt;
+
+    recvMetaRq = NULL;
+    recvImageRq = NULL;
+    recvMetaSt = NULL;
+    recvImageSt = NULL;
+
+    sendMetaRq = NULL;
+    sendImageRq = NULL;
+    sendMetaSt = NULL;
+    sendImageSt = NULL;
+#endif
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::findRegionsForPatch
+//
+//  Purpose:
+//      Needed by Parallel Direct Send to determine the regions a patch will overlap
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+int
+avtOSPRayImageCompositor::findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to)
+{
+    from = to = 0;
+    if (patchExtents[1]-patchExtents[0] <=0 || patchExtents[3]-patchExtents[2] <=0)
+        return 0;
+
+    if ( patchExtents[0] > screenProjectedExtents[1])
+        return 0;
+
+    if ( patchExtents[1] < screenProjectedExtents[0])
+        return 0;
+
+    if ( patchExtents[2] > screenProjectedExtents[3])
+        return 0;
+
+    if ( patchExtents[3] < screenProjectedExtents[2])
+        return 0;
+
+
+    // find from
+    for (int i=numRegions-1; i>=0; i--)
+        if ( patchExtents[2] >= getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
+            {
+                from = i;
+                break;
+            }
+    
+
+    // find to
+    for (int i=numRegions-1; i>=0; i--)
+        if ( patchExtents[3] > getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
+            {
+                to = i;
+                break;
+            }
+
+    return ( std::max( (to - from) + 1, 0) );
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::computeRegionExtents
+//
+//  Purpose:
+//      Compute extents for each region
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtOSPRayImageCompositor::computeRegionExtents(int numRanks, int height)
+{
+    //debug5 << "computeRegionExtents height " << height << std::endl;
+
+    int regionHeight = round((float)height/numRanks);
+    regularRegionSize = regionHeight;
+    maxRegionHeight = 0;
+    regionRankExtents.resize(numRanks*3);
+    for (int i=0; i<numRanks; i++)
+        {
+            int startRegionExtents, endRegionExtents, _currentRegionHeight;
+
+            startRegionExtents = CLAMP(regionHeight * i, 0, height);
+            endRegionExtents = CLAMP(regionHeight * i + regionHeight, 0, height);
+
+            if ( i == numRanks -1 )
+                if ( endRegionExtents < height )
+                    endRegionExtents = height;
+
+            _currentRegionHeight = CLAMP(endRegionExtents-startRegionExtents, 0, height);
+            maxRegionHeight = std::max(maxRegionHeight, _currentRegionHeight);
+
+            regionRankExtents[i*3+0] = startRegionExtents;
+            regionRankExtents[i*3+1] = endRegionExtents;
+            regionRankExtents[i*3+2] = _currentRegionHeight;
+
+            //debug5 << i << " : (start, end, region): " << startRegionExtents << ", " << endRegionExtents << ", " << _currentRegionHeight << std::endl;
+        }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::ParallelDirectSendManyPatches
+//
+//  Purpose:
+//      Parallel Direct Send rendering that can blend individual patches
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+int
+avtOSPRayImageCompositor::ParallelDirectSendManyPatches
+(const std::multimap<int, ospray::ImgData> &imgDataHashMap, 
+ const std::vector<ospray::ImgMetaData>    &imageMetaPatchVector, 
+ int numPatches,
+ int *region,
+ int numRegions, 
+ int tags[2],
+ int fullImageExtents[4])
+{
+    int myRegionHeight = 0;
+#ifdef PARALLEL
+
+    //
+    // Some Initializations
+    //
+    //debug5 << "Parallel Direct Send" << endl;
+    ospray::timestamp timingDetail;
+    for (int i=0; i<4; i++)
+        {
+            intermediateImageExtents[i] = 0;
+            intermediateImageBBox[i] = 0;
+        }
+
+
+    //
+    // Find My Position in Regions
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Find My position in Regions");
+    //---------------------------------------------------------------------//
+    compositingDone = false;
+    int myPositionInRegion = -1;
+    bool inRegion = true;
+    std::vector<int> regionVector(region, region+numRegions);
+    const std::vector<int>::const_iterator it = 
+	std::find(regionVector.begin(),
+		  regionVector.end(), 
+		  mpiRank);
+    if (it == regionVector.end())
+        {
+            inRegion = false;
+            //ospout << mpiRank << " ~ SHOULD NOT HAPPEN!!!!: Not found " 
+            //       << mpiRank <<  " !!!" << std::endl;
+        }
+    else 
+        {
+            myPositionInRegion = it - regionVector.begin();
+        }
+    int width =  fullImageExtents[1]-fullImageExtents[0];
+    int height = fullImageExtents[3]-fullImageExtents[2];
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Find My position in Regions");
+    //ospout << mpiRank << " ~ myPositionInRegion: " 
+    //       << myPositionInRegion << ", numRanks: " << mpiSize << std::endl;
+    //ospout << "width: " << width << ", height : " << height 
+    //       << " | fullImageExtents: "
+    //       << fullImageExtents[0] << ", " 
+    //       << fullImageExtents[1] << ", " 
+    //       << fullImageExtents[2] << ", "
+    //       << fullImageExtents[3] << std::endl;
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Compute Region Boundaries
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Compute Region Boundaries");
+    //---------------------------------------------------------------------//
+    computeRegionExtents(mpiSize, height); // ?
+    int myStartingHeight = getScreenRegionStart
+	(myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
+    int myEndingHeight   = getScreenRegionEnd
+	(myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
+    myRegionHeight = CLAMP((myEndingHeight-myStartingHeight), 0, height);
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Compute Region Boundaries");
+    // ospout << "myStartingHeight: " << myStartingHeight << ", "
+    //        << "myEndingHeight: "   << myEndingHeight   << ", "
+    //	      << "myRegionHeight: "   << myRegionHeight   << std::endl;
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Size of one buffer
+    //
+    int sizeOneBuffer = getMaxRegionHeight() * width * 4;
+
+
+    //
+    // Determine How Many Patches and Pixel to Send to Each Region
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Determine How Many Patches and Pixel to Send "
+                              "to Each Region");
+    //---------------------------------------------------------------------//
+    std::vector<int> numPatchesPerRegion;
+    std::vector<int> areaPerRegion;
+    std::set<int> numOfRegions;
+    numPatchesPerRegion.resize(numRegions);
+    areaPerRegion.resize(numRegions);
+
+    // 2D array: extents for each partition
+    std::vector < std::vector<float> > extentsPerPartiton;
+    for (int i=0; i<numRegions; i++) { 
+	extentsPerPartiton.push_back(std::vector<float>()); 
+    }
+    // ospout << "Parallel Direct Send ~ numPatches " << numPatches << endl;
+    int totalSendBufferSize = 0;
+    for (int i=0; i<numPatches; i++)
+        {
+            int _patchExtents[4];
+            ospray::ImgMetaData temp;
+            temp = imageMetaPatchVector.at(i);
+            _patchExtents[0]=temp.screen_ll[0];   // minX
+            _patchExtents[1]=temp.screen_ur[0];   // maxX
+            _patchExtents[2]=temp.screen_ll[1];   // minY
+            _patchExtents[3]=temp.screen_ur[1];   // maxY
+            const std::multimap<int, ospray::ImgData>::const_iterator it = 
+                imgDataHashMap.find( i );
+            int from, to;
+            int numRegionIntescection = findRegionsForPatch(_patchExtents, 
+                                                            fullImageExtents,
+                                                            numRegions, 
+                                                            from, to);
+            if (numRegionIntescection <= 0) continue;
+            // ospout << "\nParallel Direct Send ~ patch " << i 
+            //        << "  from:" << from << "  to:" << to 
+            //        << "  numPatches: " << numPatches 
+            //        << "   _patchExtents: " 
+            //        << _patchExtents[0] << ", " 
+            //        << _patchExtents[1] << ", " 
+            //        << _patchExtents[2] << ", " 
+            //        << _patchExtents[3] 
+            //        << ", fullImageExtents[2]: " << fullImageExtents[2] 
+            //        << ", numRegions: " <<  numRegions 
+            //        << ", totalSendBufferSize: " << totalSendBufferSize << endl;
+            for (int j=from; j<=to; j++) numPatchesPerRegion[j]++;
+            for (int partition=from; partition<=to; partition++)
+                {
+                    int _extentsYStart = std::max( _patchExtents[2], getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) );
+                    int _extentsYEnd   = std::min( _patchExtents[3], getScreenRegionEnd(  partition, fullImageExtents[2], fullImageExtents[3]) );
+                    int _area = (_extentsYEnd-_extentsYStart)*(_patchExtents[1]-_patchExtents[0]);
+                    areaPerRegion[partition] += _area;
+                    totalSendBufferSize += _area;
+                    //debug5 << "_patchExtents[2]: " << _patchExtents[2] << ", region start: " << getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) <<  ", _extentsYStart: " << _extentsYStart<< endl;
+                    //debug5 << "_patchExtents[3]: " << _patchExtents[3] << ", region end: " << getScreenRegionEnd(partition, fullImageExtents[2], fullImageExtents[3]) << ", _extentsYEnd: " << _extentsYEnd << endl;
+                    //debug5 << "_area " << _area << endl;
+                    extentsPerPartiton[partition].push_back(i);
+                    extentsPerPartiton[partition].push_back(_patchExtents[0]);
+                    extentsPerPartiton[partition].push_back(_patchExtents[1]);
+                    extentsPerPartiton[partition].push_back(_extentsYStart);
+                    extentsPerPartiton[partition].push_back(_extentsYEnd);
+                    extentsPerPartiton[partition].push_back(temp.eye_z);
+                    numOfRegions.insert(partition);
+                }
+        }
+    totalSendBufferSize *= 4;                           // to account for RGBA
+    int numRegionsWithData = numOfRegions.size();
+    //debug5 << "\nParallel Direct Send ~ creating buffers" << endl;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Determine How Many Patches and Pixel to Send "
+                             "to Each Region");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Copy the Data for Each Region for Each Patch
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Copy the Data for Each Region for Each Patch");
+    //---------------------------------------------------------------------//
+    // Create buffer
+    float *sendDataBuffer = new float[totalSendBufferSize];     // contains all the data arranged by region
+    int   *sendDataBufferSize = new int[numRegionsWithData]();
+    int   *sendDataBufferOffsets = new int[numRegionsWithData]();
+    int   *sendBuffer = new int[numRegions*2]();
+    int regionWithDataCount = 0;
+    int numRegionsToSend = 0;
+    // Populate the buffer with data
+    int dataSendBufferOffset = 0;
+    for (int i=0; i<numRegions; i++)
+        {
+            int _dataSize = 0;
+            //ospout << "Region: " << i << "  size: " << extentsPerPartiton[i].size() << std::endl;
+            for (int j=0; j<extentsPerPartiton[i].size(); j+=6)
+                {
+                    int _patchID = extentsPerPartiton[i][j + 0];
+                    const std::multimap<int, ospray::ImgData>::const_iterator it = imgDataHashMap.find( _patchID );
+
+                    int _width = (extentsPerPartiton[i][j+2] - extentsPerPartiton[i][j+1]);
+                    int _bufferSize = _width * (extentsPerPartiton[i][j+4] - extentsPerPartiton[i][j+3]) * 4;
+                    int _dataOffset = extentsPerPartiton[i][j+3] - imageMetaPatchVector[_patchID].screen_ll[1];
+
+                    memcpy(&sendDataBuffer[dataSendBufferOffset], &(((*it).second).imagePatch[_width * _dataOffset * 4]), _bufferSize*sizeof(float) );
+
+                    dataSendBufferOffset += _bufferSize;
+                    _dataSize += _bufferSize;
+                }
+
+            if (_dataSize != 0){
+                sendDataBufferSize[regionWithDataCount] = _dataSize;
+
+                regionWithDataCount ++;
+                if (regionWithDataCount != numRegionsWithData)
+                    sendDataBufferOffsets[regionWithDataCount] = sendDataBufferOffsets[regionWithDataCount-1] + sendDataBufferSize[regionWithDataCount-1];
+
+                if (regionVector[i] != mpiRank)
+                    numRegionsToSend++;
+            }
+
+            sendBuffer[i*2+0] = numPatchesPerRegion[i];
+            sendBuffer[i*2+1] = areaPerRegion[i];
+
+            //ospout << "Region: " << i << "  numPatchesPerRegion: " << sendBuffer[i*2+0] << ", sendBuffer[i*2+1]: " << sendBuffer[i*2+1] << std::endl;
+        }
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Copy the Data for Each Region for Each Patch");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Exchange Information about Size to Recv
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Exchange Information about Size to Recv");
+    //---------------------------------------------------------------------//
+    int *recvInfoATABuffer = new int[numRegions*2]();
+    MPI_Alltoall(sendBuffer, 2, MPI_INT,  recvInfoATABuffer, 2, MPI_INT, MPI_COMM_WORLD);
+    delete []sendBuffer;
+    sendBuffer = NULL;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Exchange Information about Size to Recv");
+    //ospout << "Parallel Direct Send ~ Exchange information about size to recv" << endl;
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Calculate Buffer Size Needed
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Calculate Buffer Size Needed");
+    //---------------------------------------------------------------------//
+    int infoBufferSize = 0;
+    int dataBufferSize = 0;
+    int numRegionsToRecvFrom = 0;
+    for (int i=0; i<numRegions; i++)
+        {
+            infoBufferSize += recvInfoATABuffer[i*2 + 0];   // number of patches per region
+            dataBufferSize += recvInfoATABuffer[i*2 + 1];   // area per region
+            //ospout << "From: " << i << ", #patches: " << recvInfoATABuffer[i*2 + 0] << ", " << recvInfoATABuffer[i*2 + 1] << std::endl;
+            if (i == mpiRank) continue;
+            if (recvInfoATABuffer[i*2 + 0] != 0)
+                numRegionsToRecvFrom++;
+        }
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Calculate Buffer Size Needed");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Create Structure for MPI Async send/recv
+    //
+    // Send
+    MPI_Request *sendMetaRq = new MPI_Request[ numRegionsToSend ];
+    MPI_Status *sendMetaSt = new MPI_Status[ numRegionsToSend ];
+    MPI_Request *sendImageRq = new MPI_Request[ numRegionsToSend ];
+    MPI_Status *sendImageSt = new MPI_Status[ numRegionsToSend ];
+    // Recv
+    MPI_Request *recvMetaRq = NULL;
+    MPI_Status *recvMetaSt = NULL;
+    MPI_Request *recvImageRq = NULL;
+    MPI_Status *recvImageSt = NULL;
+    // counters
+    int recvInfoCount = 0;
+    int offsetMeta = 0;
+    int offsetData = 0;
+
+
+    //
+    // Create Recv Buffers
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Create Recv Buffers");
+    //---------------------------------------------------------------------//
+    float *recvInfoBuffer = new float[infoBufferSize*6];  // 6 - passing 6 parameters for each patch
+    float *recvDataBuffer =  new float[dataBufferSize*4]; // 4 - to account for RGBA
+
+    //debug5 << "infoBufferSize: " << infoBufferSize << ", dataBufferSize: " << dataBufferSize << std::endl;
+    if (myRegionHeight != 0)
+        {
+            // Recv
+            recvMetaRq = new MPI_Request[ numRegionsToRecvFrom ];
+            recvMetaSt = new MPI_Status[ numRegionsToRecvFrom ];
+
+            recvImageRq = new MPI_Request[ numRegionsToRecvFrom ];
+            recvImageSt = new MPI_Status[ numRegionsToRecvFrom ];
+
+            // Async Recv for info
+            for (int i=0; i<numRegions; i++)
+                {
+                    if (recvInfoATABuffer[i*2 + 0] == 0)
+                        continue;
+
+                    if ( regionVector[i] == mpiRank )
+                        continue;
+
+                    int src = regionVector[i];
+                    MPI_Irecv(&recvInfoBuffer[offsetMeta], recvInfoATABuffer[i*2 + 0]*6, MPI_FLOAT, src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvInfoCount] );
+                    MPI_Irecv(&recvDataBuffer[offsetData], recvInfoATABuffer[i*2 + 1]*4, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvInfoCount] );
+
+                    offsetMeta += recvInfoATABuffer[i*2 + 0]*6;
+                    offsetData += recvInfoATABuffer[i*2 + 1]*4;
+                    recvInfoCount++;
+                }
+            //ospout << "Async recv setup - numRegionsToRecvFrom: " << numRegionsToRecvFrom << "   recvInfoCount: " << recvInfoCount << endl;
+        }
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Create Recv Buffers");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Async Send
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Async Send");
+    //---------------------------------------------------------------------//
+    int offset = 0;
+    int sendCount = 0;
+    int mpiSendCount = 0;
+    for (int i=0; i<numRegions; i++) {
+            if ( extentsPerPartiton[i].size() != 0 ) {
+                    if ( regionVector[i] == mpiRank )
+                        {
+                            memcpy( &recvInfoBuffer[offsetMeta], &extentsPerPartiton[i][0], extentsPerPartiton[i].size()*sizeof(float) );
+                            memcpy( &recvDataBuffer[offsetData], &sendDataBuffer[offset],   sendDataBufferSize[ sendCount ]*sizeof(float) );
+
+                            offset += sendDataBufferSize[sendCount];
+                            sendCount++;
+                        }
+                    else
+                        {
+                            MPI_Isend(&extentsPerPartiton[i][0],  extentsPerPartiton[i].size(),  MPI_FLOAT, region[i], tags[0], MPI_COMM_WORLD, &sendMetaRq[mpiSendCount]);
+                            MPI_Isend(&sendDataBuffer[offset], sendDataBufferSize[ sendCount ], MPI_FLOAT, region[i], tags[1], MPI_COMM_WORLD, &sendImageRq[mpiSendCount]);
+
+                            offset += sendDataBufferSize[sendCount];
+                            sendCount++;
+                            mpiSendCount++;
+                        }
+                }
+        }
+
+    //ospout << "Asyn send setup done ~ numRegionsToSend: " << numRegionsToSend << "  mpiSendCount: " << mpiSendCount << endl;
+
+    if (myRegionHeight != 0)
+        {
+            //debug5 << "MPI_Waitall ..." << std::endl;
+            MPI_Waitall(recvInfoCount, recvImageRq, recvImageSt);   // Means that we have reveived everything!
+
+            //debug5 << "MAPI_WAITALL done!" << std::endl;
+
+            if (recvInfoATABuffer != NULL)
+                delete []recvInfoATABuffer;
+            recvInfoATABuffer = NULL;
+
+            //debug5 << "Sorting..." << std::endl;
+
+            //
+            // Sort the data
+            std::multimap<float,int> patchData;
+            std::vector<int> patchOffset;
+            patchOffset.push_back(0);
+            for (int i=0; i<infoBufferSize; i++)
+                {
+                    patchData.insert( std::pair<float,int> (recvInfoBuffer[i*6 + 5],i));
+                    int _patchSize = (recvInfoBuffer[i*6 + 4]-recvInfoBuffer[i*6 + 3]) * (recvInfoBuffer[i*6 + 2]-recvInfoBuffer[i*6 + 1]) * 4;
+                    int _offset = patchOffset[i] + _patchSize;
+
+                    if (i != infoBufferSize-1)
+                        patchOffset.push_back(_offset);
+                }
+
+            //
+            // Create buffer for current region
+            intermediateImageBBox[0] = intermediateImageExtents[0] = fullImageExtents[0];
+            intermediateImageBBox[1] = intermediateImageExtents[1] = fullImageExtents[1];
+            intermediateImageBBox[2] = intermediateImageExtents[2] = myStartingHeight;
+            intermediateImageBBox[3] = intermediateImageExtents[3] = myEndingHeight;
+            intermediateImage = new float[width * (myEndingHeight - myStartingHeight) * 4]();
+            //debug5 << "intermediate image size " << width << ", " << (myEndingHeight - myStartingHeight) << std::endl;
+
+            //
+            // Blend
+            int numBlends = 0;
+            for (std::multimap<float,int>::iterator it=patchData.begin(); it!=patchData.end(); ++it)
+                {
+                    int _id = (*it).second;
+                    int _extents[4];
+                    _extents[0] = recvInfoBuffer[_id*6 + 1];
+                    _extents[1] = recvInfoBuffer[_id*6 + 2];
+                    _extents[2] = recvInfoBuffer[_id*6 + 3];
+                    _extents[3] = recvInfoBuffer[_id*6 + 4];
+                    BlendFrontToBack(&recvDataBuffer[patchOffset[_id]], _extents, _extents, intermediateImage, intermediateImageExtents);
+                    numBlends++;
+                }
+
+            if (numBlends == 0) {
+                intermediateImageBBox[0]=intermediateImageBBox[1]=intermediateImageBBox[2]=intermediateImageBBox[3] = 0;
+            }
+        }
+
+    MPI_Waitall(numRegionsToSend, sendImageRq, sendImageSt);   // Means that we have sent everything!
+
+    if (myRegionHeight == 0) compositingDone = true;
+
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Async Send");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Cleanup
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Cleanup");
+    //---------------------------------------------------------------------//
+    if (sendDataBuffer != NULL)
+	delete []sendDataBuffer;
+    sendDataBuffer = NULL;
+
+    if (sendDataBufferSize != NULL)
+	delete []sendDataBufferSize;
+    sendDataBufferSize = NULL;
+
+    if (sendDataBufferOffsets != NULL)
+	delete []sendDataBufferOffsets;
+    sendDataBufferOffsets = NULL;
+
+
+    if (sendMetaRq != NULL)
+	delete []sendMetaRq;
+
+    if (sendImageRq != NULL)
+	delete []sendImageRq;
+
+    if (sendMetaSt != NULL)
+	delete []sendMetaSt;
+
+    if (sendImageSt != NULL)
+	delete []sendImageSt;
+
+    sendMetaRq = NULL;
+    sendImageRq = NULL;
+    sendMetaSt = NULL;
+    sendImageSt = NULL;
+
+    if (myRegionHeight != 0)
+        {
+            if (recvInfoBuffer != NULL)
+                delete []recvInfoBuffer;
+            recvInfoBuffer = NULL;
+
+            if (recvDataBuffer != NULL)
+                delete []recvDataBuffer;
+            recvDataBuffer = NULL;
+
+            if (recvMetaRq != NULL)
+                delete []recvMetaRq;
+
+            if (recvMetaSt != NULL)
+                delete []recvMetaSt;
+
+            if (recvImageRq != NULL)
+                delete []recvImageRq;
+
+            if (recvImageSt != NULL)
+                delete []recvImageSt;
+
+            recvMetaRq = NULL;
+            recvImageRq = NULL;
+            recvMetaSt = NULL;
+            recvImageSt = NULL;
+        }
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Cleanup");
+    //ospout << "All Parallel Direct Send is Done" << std::endl;
+    //---------------------------------------------------------------------//
+#endif
+    return myRegionHeight;
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::gatherImages
+//
+//  Purpose:
+//      Gather images from Parallel Direct Send
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtOSPRayImageCompositor::gatherImages(int regionGather[], int totalNumRanks, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight)
+{
+#ifdef PARALLEL
+    //debug5 << "gatherImages starting... totalNumRanks: " << totalNumRanks << ", compositingDone: " << compositingDone
+    //	   << ", imgExtents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
+
+    for (int i=0; i<4; i++)
+	finalImageExtents[i] = finalBB[i] = 0;
+
+    if (mpiRank == 0)
+        {
+            int width =  fullImageExtents[1]-fullImageExtents[0];
+            int height = fullImageExtents[3]-fullImageExtents[2];
+
+            //debug5 << "Gather Images at 0, final size: " << fullImageExtents[1]-fullImageExtents[0] << " x " << fullImageExtents[3]-fullImageExtents[2] << std::endl;
+
+            //
+            // Receive at root/display node!
+            finalImage = new float[width*height*4];
+            finalImageExtents[0] = fullImageExtents[0];
+            finalImageExtents[1] = fullImageExtents[1];
+            finalImageExtents[2] = fullImageExtents[2];
+            finalImageExtents[3] = fullImageExtents[3];
+
+            int numRegionsWithData = 0;
+            int numToRecv = 0;
+            for (int i=0; i<totalNumRanks; i++)
+                {
+                    if (getRegionSize(i) != 0)
+                        numRegionsWithData++;
+                }
+            numToRecv = numRegionsWithData;
+
+            // remove itself from the recv
+            if (getRegionSize(mpiRank) != 0) 
+                numToRecv--;
+
+
+            //
+            // Create buffers for async reciving
+            MPI_Request *recvImageRq = new MPI_Request[ numToRecv ];
+            MPI_Status  *recvImageSt = new MPI_Status[ numToRecv ];
+
+            int lastBufferSize    = getRegionSize(totalNumRanks-1) * width * 4;
+            int regularBufferSize = regularRegionSize * width * 4;
+
+            //debug5 << "numToRecv: " << numToRecv << ", numRegionsWithData: " << numRegionsWithData << std::endl;
+            //debug5 << "regularBufferSize: " << regularBufferSize << ", lastBufferSize: " << lastBufferSize << std::endl;
+
+            // Async Recv
+            int recvCount=0;
+            for (int i=0; i<numRegionsWithData; i++)
+                {
+                    int src = regionGather[i];
+
+                    if (src == mpiRank)
+                        continue;
+
+                    if (i == totalNumRanks-1)
+                        {
+                            if (lastBufferSize != 0)
+                                {
+                                    MPI_Irecv(&finalImage[i*regularBufferSize], lastBufferSize,     MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+                                }
+                        }
+                    else
+                        MPI_Irecv(&finalImage[i*regularBufferSize], regularBufferSize,  MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+			
+
+                    //debug5 << i << " ~ recvCount: " << recvCount << std::endl;
+                    recvCount++;
+                }
+
+            if (compositingDone == false)   // If root has data for the final image
+                PlaceImage(inputImg, imgExtents, finalImage, finalImageExtents);
+
+            MPI_Waitall(numToRecv, recvImageRq, recvImageSt);
+            compositingDone = true;
+
+            delete []recvImageRq;
+            recvImageRq = NULL;
+            delete []recvImageSt;
+            recvImageSt = NULL;
+        }
+    else
+        {
+            if (compositingDone == false)   
+                {
+                    int imgSize = (imgExtents[1]-imgExtents[0]) * (imgExtents[3]-imgExtents[2]) * 4;
+                    //debug5 << "imgSize: " << imgSize << std::endl;
+
+                    MPI_Send(inputImg, imgSize, MPI_FLOAT, 0, tag, MPI_COMM_WORLD);
+                    compositingDone = true;
+                }
+        }
+
+#endif
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::getcompositedImage
+//
+//  Purpose:
+//      Returns the whole image if needed
+//
+//  Programmer: Pascal Grosset
+//  Creation: July 2013
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtOSPRayImageCompositor::getcompositedImage
+(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage)
+{
+    for (int i=0; i< imgBufferHeight; i++) {
+        for (int j=0; j<imgBufferWidth; j++) {
+            int bufferIndex = (imgBufferWidth*4*i) + (j*4);
+            int wholeImgIndex = (imgBufferWidth*3*i) + (j*3);
+            wholeImage[wholeImgIndex+0] = (finalImage[bufferIndex+0] ) * 255;
+            wholeImage[wholeImgIndex+1] = (finalImage[bufferIndex+1] ) * 255;
+            wholeImage[wholeImgIndex+2] = (finalImage[bufferIndex+2] ) * 255;
+        }
+    }
+    if (finalImage != NULL)
+        { delete []finalImage; }
+    finalImage = NULL;
+}
diff --git a/avt/Filters/avtOSPRayImageCompositor.h b/avt/Filters/avtOSPRayImageCompositor.h
new file mode 100644
index 000000000..d165fecf4
--- /dev/null
+++ b/avt/Filters/avtOSPRayImageCompositor.h
@@ -0,0 +1,267 @@
+/*****************************************************************************
+ *
+ * Copyright (c) 2000 - 2017, Lawrence Livermore National Security, LLC
+ * Produced at the Lawrence Livermore National Laboratory
+ * LLNL-CODE-442911
+ * All rights reserved.
+ *
+ * This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+ * full copyright notice is contained in the file COPYRIGHT located at the root
+ * of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+ *
+ * Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  - Redistributions of  source code must  retain the above  copyright notice,
+ *    this list of conditions and the disclaimer below.
+ *  - Redistributions in binary form must reproduce the above copyright notice,
+ *    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+ *    documentation and/or other materials provided with the distribution.
+ *  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+ * ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+ * LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+ * DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+ * LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+ * OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ *****************************************************************************/
+
+// *************************************************************************//
+//                          avtOSPRayImageCompositor.h                       //
+// *************************************************************************//
+
+#ifndef AVT_OSPRAY_IMG_COMMUNICATOR_H
+#define AVT_OSPRAY_IMG_COMMUNICATOR_H
+
+#include <avtOSPRayCommon.h>
+
+#include <string>
+#include <vector>
+#include <map>
+#include <algorithm>
+#include <utility>
+
+#ifdef PARALLEL
+# include <mpi.h>
+#endif
+
+// ***************************************************************************
+//  Class: avtOSPRayImageCompositor
+//
+//  Purpose:
+//      Does the composition for Ray casting: OSPRay
+//
+//  Programmer: Pascal Grosset
+//  Creation:   Spetember 20, 2013
+//
+// ***************************************************************************
+
+class avtOSPRayIC_Implementation
+{
+ public:
+    avtOSPRayIC_Implementation(int mpiSize, int mpiRank) {};
+    virtual ~avtOSPRayIC_Implementation() {};
+    virtual void Init (int W, int H) = 0;
+    virtual void SetTile (const float* data, 
+			  const int* extents, 
+			  const float& depth) = 0;
+    virtual void Composite (float*& output) = 0;
+};
+
+// ***************************************************************************
+//  Class: avtOSPRayImageCompositor
+//
+//  Purpose:
+//      Does the composition for Ray casting: SLIVR
+//
+//  Programmer: Pascal Grosset
+//  Creation:   Spetember 20, 2013
+//
+// ***************************************************************************
+
+class avtOSPRayImageCompositor
+{ 
+ public:    
+    avtOSPRayImageCompositor();
+    ~avtOSPRayImageCompositor();
+
+    virtual const char *GetType(void)
+    { return "avtOSPRayImageCompositor"; }
+    virtual const char *GetDescription(void) 
+    { return "Doing compositing for ray casting OSPRay"; }
+
+    float* GetFinalImageBuffer () { return finalImage; }
+    int GetParSize ()             { return mpiSize;   }
+    int GetParRank ()             { return mpiRank;   }
+
+    // Those functions can be static
+    static void BlendFrontToBack(const float *, const int srcExtents[4],
+				 const int blendExtents[4], 
+				 float *&, const int dstExtents[4]);
+    static void BlendBackToFront(const float *, const int srcExtents[4], 
+				 const int blendExtents[4], 
+				 float *&, const int dstExtents[4]);
+    static void BlendFrontToBack(const float *, const int srcExtents[4], 
+				 float *&, const int dstExtents[4]);
+    static void BlendBackToFront(const float *, const int srcExtents[4], 
+				 float *&, const int dstExtents[4]);
+    void Barrier();
+
+ private:
+    //----------------------------------------------------------------------//
+    static void ColorImage(float *&, const int, const int, 
+			   const float color[4]);
+    static void PlaceImage(const float *, const int srcExtents[4], 
+			   float *&, const int dstExtents[4]);
+    static void BlendWithBackground(float *&, const int extents[4],
+				    const float bgColor[4]);
+ public:
+    //----------------------------------------------------------------------//
+    // Different Algorithms
+    //----------------------------------------------------------------------//
+
+    //----------------------------------------------------------------------//
+    // IceT: (export OSPRAY_USE_ICET=1)
+    //   Use IceT for compositing. This method only supports the case where 
+    //   each rank produces only one tile.
+    // Algorithms:
+    //   Reduce
+    //   Binary Swap
+    //    
+    //----------------------------------------------------------------------//
+    bool IceTValid();
+    void IceTInit(int W, int H);
+    void IceTSetTile(const float*, const int*, const float&);
+    void IceTComposite(float*&);
+
+    //----------------------------------------------------------------------//
+    // OneNode
+    //   There is only one VisIt process
+    //----------------------------------------------------------------------//
+    bool OneNodeValid();
+    void OneNodeInit(int W, int H);
+    void OneNodeSetTile(const float*, const int*, const float&);
+    void OneNodeComposite(float*&);
+
+    //----------------------------------------------------------------------//
+    // Serial
+    //----------------------------------------------------------------------//
+    //bool SerialValid();
+    //void SerialInit(int W, int H);
+    //void SerialSetTile(const float*, const int*, const float&);
+    //void SerialComposite(float*&);
+
+ private:
+    // Basic MPI information
+    int mpiSize; // total number of processes (# of ranks)
+    int mpiRank; // my rank id
+    // TODO this communicator shouldnt be in charge of this variable
+    // Final image is here
+    float *finalImage;
+    // Image Compisition Implementation
+    avtOSPRayIC_Implementation* compositor;
+
+
+
+
+
+
+
+
+
+
+
+
+
+    // CLEAN UP BELOW
+ private:
+    //----------------------------------------------------------------------//
+    void UpdateBoundingBox(int currentBoundingBox[4], 
+                           const int imageExtents[4]);
+    //----------------------------------------------------------------------//
+
+    //----------------------------------------------------------------------//
+    // Both currently unused but good for simple testing
+    //----------------------------------------------------------------------//
+ private:
+    void GatherDepthAtRoot(const int, const float *, int &, int *&, float *&);
+ public:
+    void SerialDirectSend
+	(int, float*, int*, float*, float bgColor[4], int, int);
+
+    //----------------------------------------------------------------------//
+    // Parallel Direct Send
+    //----------------------------------------------------------------------//
+ public:
+    void RegionAllocation(int *&);
+    int  ParallelDirectSendManyPatches
+	(const std::multimap<int, ospray::ImgData>&,
+	 const std::vector<ospray::ImgMetaData>&,
+	 int, int*, int, int tags[2], int fullImageExtents[4]);
+
+ private:
+    ///--------------------------------------
+    // flags for patch
+    int totalPatches;
+    bool compositingDone;
+
+    // image sizing for compositing
+    int maxRegionHeight;
+    int regularRegionSize;
+    std::vector<int> regionRankExtents;
+
+    //----------------------------------------------------------------------//
+      
+    void computeRegionExtents(int numRanks, int height);
+	
+    int getRegularRegionSize(){ return regularRegionSize; } 
+    int getRegionStart(int region){ return regionRankExtents[region*3+0]; }
+    int getRegionEnd(int region){ return regionRankExtents[region*3+1]; }
+    int getRegionSize(int region){ return regionRankExtents[region*3+2]; }
+    int getMaxRegionHeight(){ return maxRegionHeight; }
+	
+    int getScreenRegionStart(int region, int screenImgMinY, int screenImgMaxY)
+    {
+	return CLAMP(getRegionStart(region)+screenImgMinY, 
+		     screenImgMinY, screenImgMaxY); 
+    }
+    int getScreenRegionEnd(int region, int screenImgMinY, int screenImgMaxY)
+    {
+	return CLAMP(getRegionEnd(region)+screenImgMinY, 
+		     screenImgMinY, screenImgMaxY); 
+    }
+
+ public:
+    //----------------------------------------------------------------------//
+
+    void getcompositedImage(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage);  // get the final composited image
+
+
+    int findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to);
+
+
+    void parallelDirectSend(float *imgData, int imgExtents[4], int region[], int numRegions, int tags[2], int fullImageExtents[4]);	
+    void gatherImages(int regionGather[], int numToRecv, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight);
+
+ public:
+    // TODO: Remove all public fields
+    int finalImageExtents[4];
+    int finalBB[4];
+    float *intermediateImage; // Intermediate image, e.g. in parallel direct send
+    int intermediateImageExtents[4];
+    int intermediateImageBBox[4];
+
+
+};
+
+#endif//AVT_OSPRAY_IMG_COMMUNICATOR_H
diff --git a/avt/Filters/avtOSPRayRayTracer.C b/avt/Filters/avtOSPRayRayTracer.C
new file mode 100644
index 000000000..75cf43aee
--- /dev/null
+++ b/avt/Filters/avtOSPRayRayTracer.C
@@ -0,0 +1,781 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                       avtOSPRayRayTracer.C                                //
+// ************************************************************************* //
+
+#include <avtOSPRayRayTracer.h>
+
+#include <visit-config.h>
+
+#include <avtDataset.h>
+#include <avtImage.h>
+#include <avtParallel.h>
+#include <avtRayCompositer.h>
+#include <avtOSPRaySamplePointExtractor.h>
+#include <avtWorldSpaceToImageSpaceTransform.h>
+
+#include <DebugStream.h>
+#include <ImproperUseException.h>
+#include <TimingsManager.h>
+#include <StackTimer.h>
+
+#include <vtkImageData.h>
+#include <vtkMatrix4x4.h>
+
+#include <vector>
+
+using     std::vector;
+
+bool OSPRaySortImgMetaDataByDepth(ospray::ImgMetaData const& before, 
+                                  ospray::ImgMetaData const& after)
+{ return before.avg_z > after.avg_z; }
+bool OSPRaySortImgMetaDataByEyeSpaceDepth(ospray::ImgMetaData const& before,
+                                          ospray::ImgMetaData const& after)
+{ return before.eye_z > after.eye_z; }
+
+// ****************************************************************************
+//  Method: avtOSPRayRayTracer constructor
+//
+//  Programmer: Hank Childs
+//  Creation:   November 27, 2000
+//
+//  Modifications:
+//    Brad Whitlock, Wed Dec 5 11:19:29 PDT 2001
+//    Added gradient backgrounds.
+//
+//    Hank Childs, Mon Jan 16 11:11:47 PST 2006
+//    Added kernel based sampling.
+//
+//    Pascal Grosset, Fri Sep 20 2013
+//    Added ray casting slivr & trilinear interpolation
+//
+//    Qi WU, Wed Jun 20 2018
+//    Added support for raycasting ospray
+//
+// ****************************************************************************
+
+avtOSPRayRayTracer::avtOSPRayRayTracer() : avtRayTracerBase()
+{
+    gradientShadingEnabled = false;
+    shadowsEnabled = false;
+    useGridAccelerator = false;
+    preIntegration = false;
+    singleShade = false;
+    oneSidedLighting = false;
+    aoTransparencyEnabled = false;
+    spp = 1;
+    aoSamples = 0;
+    aoDistance = 1e6;
+    samplingRate = 3.0;
+    minContribution = 0.001;
+    
+    materialProperties[0] = 0.4;
+    materialProperties[1] = 0.75;
+    materialProperties[2] = 0.0;
+    materialProperties[3] = 15.0;
+
+    ospray_core = NULL;
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRayRayTracer destructor
+//
+//  Purpose:
+//      Defines the destructor.  Note: this should not be inlined in the header
+//      because it causes problems for certain compilers.
+//
+//  Programmer: Hank Childs
+//  Creation:   February 5, 2004
+//
+// ****************************************************************************
+
+avtOSPRayRayTracer::~avtOSPRayRayTracer()
+{
+    ;
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRayRayTracer::Execute
+//
+//  Purpose:
+//      Executes the ray tracer.  
+//      This means:
+//      - Put the input mesh through a transform so it is in camera space.
+//      - Get the sample points.
+//      - Communicate the sample points (parallel only).
+//      - Composite the sample points along rays.
+//      - Communicate the pixels from each ray (parallel only).
+//      - Output the image.
+//
+//  Programmer: Hank Childs
+//  Creation:   November 27, 2000
+//
+//  Modifications:
+//
+//    Hank Childs, Fri Jan 26 17:00:07 PST 2001
+//    Added support for parallel ray tracing.
+//
+//    Hank Childs, Sat Jan 27 15:09:34 PST 2001
+//    Added support for sending cells when doing parallel ray tracing.
+//
+//    Hank Childs, Sun Mar  4 21:50:36 PST 2001
+//    Added image partition to aid parallel modules in minimizing
+//    communication by dynamically assigning the partitions.
+//
+//    Eric Brugger, Mon Nov  5 13:47:19 PST 2001
+//    Modified to always compile the timing code.
+//
+//    Brad Whitlock, Wed Dec 5 10:57:56 PDT 2001
+//    Added code to set the gradient background colors, background mode in
+//    the ray compositer.
+//
+//    Kathleen Bonnell, Tue Apr 30 12:34:54 PDT 2002  
+//    Use new version of CopyTo. 
+//
+//    Hank Childs, Fri Sep 13 12:04:04 PDT 2002
+//    Reverse arguments for CopyTo (we weren't sending in the input correctly).
+//
+//    Hank Childs, Fri Nov 19 13:47:20 PST 2004
+//    Added option to have sampling of rectilinear grids done efficiently
+//    by sample point extractor by not converting grid into image space.
+//
+//    Hank Childs, Thu Dec  2 09:26:28 PST 2004
+//    No longer tighten clipping planes ['5699].
+//
+//    Hank Childs, Thu Dec  9 17:15:44 PST 2004
+//    Cast rays in tiles for big images ['1948].
+//
+//    Hank Childs, Sun Mar 13 11:16:20 PST 2005
+//    Fix memory leak.
+//
+//    Hank Childs, Tue Mar 29 16:19:19 PST 2005
+//    If the image is large, force divisions of 512x512, even if we should
+//    theoretically have enough memory to cover it.
+//
+//    Hank Childs, Mon Jan 16 11:11:47 PST 2006
+//    Add support for kernel based sampling.
+//
+//    Hank Childs, Thu May 31 22:36:32 PDT 2007
+//    Remove code for setting number of variables for processors that don't
+//    have data, since that is now handled by the avtSamplePointExtractor's
+//    base class.
+//
+//    Hank Childs, Wed Dec 24 09:46:56 PST 2008
+//    Add code to convert the z-buffer of the background to the w-buffer.
+//    This is being done so the samples lie more evenly.
+//
+//    Hank Childs, Wed Dec 24 14:16:04 PST 2008
+//    Automatically tighten the clipping planes so we utilize our samples
+//    more effectively.
+//
+//    Hank Childs, Fri Jan  9 14:17:10 PST 2009
+//    Have each ray be randomly jittered forward or backwards along its
+//    direction.
+//
+//    Hank Childs, Tue Jan 13 14:26:44 PST 2009
+//    Fix oversight where parallel volume rendering was not being jittered.
+//
+//    Hank Childs, Sun Jan 24 15:35:50 PST 2010
+//    Automatically use the kernel based resampling for point data.
+//
+//    Pascal Grosset & Manasa Prasad, Fri Aug 20 2016
+//    Add the ray casting OSPRay code
+//
+//    Qi WU, Tue Aug 8 2017
+//    Fix camera matrices multiplication order for ray casting OSPRay
+//    Also fixed panning for ray casting OSPRay
+//
+//    Qi WU, Wed Jun 20 2018
+//    Added support for raycasting ospray
+//
+// ****************************************************************************
+
+void
+avtOSPRayRayTracer::Execute()
+{
+    //======================================================================//
+    // Initialization and Debug
+    //======================================================================//
+    // check memory in the beginning
+    ospout << "[avrRayTracer] entering execute" << std::endl;
+    ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute", "ospout");    
+
+    // initialize current time
+    StackTimer t0("Ray Tracing");
+
+    //======================================================================//
+    // Start of original pipeline
+    //======================================================================//
+    bool parallelOn = (imgComm.GetParSize() == 1) ? false : true;
+    /* dont need rayfoo for ospray */
+    /*
+    if (rayfoo == NULL)
+    {
+        debug1 << "Never set ray function for ray tracer." << endl;
+        EXCEPTION0(ImproperUseException);
+    }
+    */
+
+    //
+    // First we need to transform all of domains into camera space.
+    //
+    double aspect = 1.;
+    if (screen[1] > 0)
+    {
+        aspect = (double)screen[0] / (double)screen[1];
+    }
+
+    double scale[3] = {1,1,1};
+    vtkMatrix4x4 *transform = vtkMatrix4x4::New();
+    avtWorldSpaceToImageSpaceTransform::CalculateTransform(view, transform,
+                                                           scale, aspect);
+    double newNearPlane, newFarPlane, oldNearPlane, oldFarPlane;
+    TightenClippingPlanes(view, transform, newNearPlane, newFarPlane);
+    oldNearPlane = view.nearPlane;  oldFarPlane  = view.farPlane;
+    view.nearPlane = newNearPlane;  view.farPlane  = newFarPlane;
+    transform->Delete();
+
+    avtWorldSpaceToImageSpaceTransform trans(view, aspect);
+    trans.SetInput(GetInput());
+    trans.SetPassThruRectilinearGrids(true);
+
+    //======================================================================//
+    // Compute Projection
+    //======================================================================//
+    vtkImageData  *opaqueImageVTK =
+	opaqueImage->GetImage().GetImageVTK();
+    unsigned char *opaqueImageData =
+	(unsigned char *)opaqueImageVTK->GetScalarPointer(0, 0, 0);;
+    float         *opaqueImageZB =
+	opaqueImage->GetImage().GetZBuffer();
+    std::vector<float> opaqueImageDepth(screen[0] * screen[1], oldFarPlane);
+    vtkMatrix4x4  *model_to_screen_transform = vtkMatrix4x4::New();
+    vtkMatrix4x4  *screen_to_model_transform = vtkMatrix4x4::New();
+    vtkMatrix4x4  *screen_to_camera_transform = vtkMatrix4x4::New();
+    int            renderingExtents[4];
+    double         sceneSize[2];
+    double         dbounds[6];  // Extents of the volume in world coordinates
+    {
+	GetSpatialExtents(dbounds);
+	ospray::ComputeProjections(view, aspect, oldNearPlane, oldFarPlane,
+				   scale, dbounds, screen,
+				   model_to_screen_transform, 
+				   screen_to_model_transform, 
+				   screen_to_camera_transform,
+				   sceneSize, renderingExtents);
+	for (int y = 0; y < screen[1]; ++y) {
+	    for (int x = 0; x < screen[0]; ++x) {
+		int index = x + y * screen[0];
+		int    screenCoord[2] = {x, y};
+		double screenDepth = opaqueImageZB[index] * 2 - 1;
+		double worldCoord[3];
+		ospray::ProjectScreenToCamera
+		    (screenCoord, screenDepth, 
+		     screen[0], screen[1],
+		     screen_to_camera_transform, 
+		     worldCoord);
+		opaqueImageDepth[index] = -worldCoord[2];
+	    }
+	}
+	// Debug
+	ospout << "[avtOSPRayRayTracer] avtViewInfo settings: " << endl
+	       << "\tcamera: "
+	       << view.camera[0] << ", " 
+	       << view.camera[1] << ", " 
+	       << view.camera[2] << std::endl
+	       << "\tfocus: "
+	       << view.focus[0] << ", " 
+	       << view.focus[1] << ", " 
+	       << view.focus[2] << std::endl
+	       << "\tviewUp: "    
+	       << view.viewUp[0] << ", " 
+	       << view.viewUp[1] << ", " 
+	       << view.viewUp[2] << std::endl
+	       << "\tviewAngle: " << view.viewAngle << std::endl
+	       << "\teyeAngle:  " << view.eyeAngle  << std::endl
+	       << "\tparallelScale: " << view.parallelScale  << std::endl
+	       << "\tsetScale: " << view.setScale << std::endl
+	       << "\tnearPlane: " << view.nearPlane << std::endl
+	       << "\tfarPlane:  " << view.farPlane  << std::endl
+	       << "\timagePan[0]: " << view.imagePan[0] << std::endl 
+	       << "\timagePan[1]: " << view.imagePan[1] << std::endl
+	       << "\timageZoom:   " << view.imageZoom   << std::endl
+	       << "\torthographic: " << view.orthographic << std::endl
+	       << "\tshear[0]: " << view.shear[0] << std::endl
+	       << "\tshear[1]: " << view.shear[1] << std::endl
+	       << "\tshear[2]: " << view.shear[2] << std::endl;
+	ospout << "[avtOSPRayRayTracer] other settings " << std::endl
+	       << "\toldNearPlane: " << oldNearPlane
+	       << std::endl
+	       << "\toldFarPlane:  " << oldFarPlane
+	       << std::endl
+	       << "\taspect: " << aspect << std::endl
+	       << "\tscale:    " 
+	       << scale[0] << " " 
+	       << scale[1] << " " 
+	       << scale[2] << " " << std::endl;
+	ospout << "[avtOSPRayRayTracer] sceneSize: " 
+	       << sceneSize[0] << " " 
+	       << sceneSize[1] << std::endl;
+	ospout << "[avtOSPRayRayTracer] screen: " 
+	       << screen[0] << " " << screen[1] << std::endl;
+	ospout << "[avtOSPRayRayTracer] data bounds: "
+	       << dbounds[0] << " " << dbounds[1] << std::endl
+	       << "               data bounds  "
+	       << dbounds[2] << " " << dbounds[3] << std::endl
+	       << "               data bounds  "
+	       << dbounds[4] << " " << dbounds[5] << std::endl;
+	ospout << "[avtOSPRayRayTracer] rendering extents: " 
+	       << renderingExtents[0] << " " << renderingExtents[1]
+	       << std::endl
+	       << "               rendering extents: "
+	       << renderingExtents[2] << " " << renderingExtents[3]
+	       << std::endl;
+	ospout << "[avtOSPRayRayTracer] full image size: " 
+	       << renderingExtents[1] - renderingExtents[0] << " "
+	       << renderingExtents[3] - renderingExtents[2] << std::endl;
+	ospout << "[avtOSPRayRayTracer] model_to_screen_transform: " 
+	       << *model_to_screen_transform << std::endl;
+	ospout << "[avtOSPRayRayTracer] screen_to_model_transform: " 
+	       << *screen_to_model_transform << std::endl;
+	ospout << "[avtOSPRayRayTracer] screen_to_camera_transform: " 
+	       << *screen_to_camera_transform << std::endl;
+
+    }
+    
+    //===================================================================//
+    // ospray stuffs
+    //===================================================================//
+    ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute before ospray", 
+                            "ospout");    
+
+    ospray::InitOSP(); // initialize ospray
+    ospray::Context* ospray = (ospray::Context*)ospray_core;
+
+    ospray->SetVariableName(activeVariable);    
+    ospray->SetBackgroundBuffer(opaqueImageData, opaqueImageDepth.data(),
+				screen);
+
+    ospray->SetAdaptiveSampling(false);
+    ospray->SetAoSamples(aoSamples); 
+    ospray->SetSpp(spp);
+    ospray->SetOneSidedLighting(oneSidedLighting);
+    ospray->SetShadowsEnabled(shadowsEnabled);
+    ospray->SetAoTransparencyEnabled(aoTransparencyEnabled);
+    ospray->SetUseGridAccelerator(useGridAccelerator);
+    ospray->SetPreIntegration(preIntegration);
+    ospray->SetSingleShade(singleShade);
+    ospray->SetGradientShadingEnabled(gradientShadingEnabled);
+    ospray->SetSamplingRate(samplingRate);
+    ospray->SetScaleAndDataBounds(scale, dbounds);
+    ospray->SetSpecular(materialProperties[2], materialProperties[3]);    
+    
+    ospout << "[avrRayTracer] make ospray camera" << std::endl;
+    ospray::Camera cam(ospray->camera);
+    cam.Set(view.orthographic, view.camera, view.focus, view.viewUp,
+	    view.viewAngle, view.imagePan, view.imageZoom, oldNearPlane,
+	    sceneSize, screen, renderingExtents);
+
+    ospout << "[avrRayTracer] make ospray transfer function" << std::endl;
+    ospray::TransferFunction tfn(ospray->tfn);
+    tfn.Set(transferFn1D->GetTableFloat(),
+	    transferFn1D->GetNumberOfTableEntries(),
+	    transferFn1D->GetMin(),
+	    transferFn1D->GetMax());
+    
+    ospout << "[avrRayTracer] make ospray renderer" << std::endl;
+    ospray::Renderer ren(ospray->renderer);
+    ren.Init();
+    ren.ResetLights();
+    double light_scale = gradientShadingEnabled ? 0.9 : 1.0;
+    ren.AddLight().Set(true,  materialProperties[0], light_scale); // ambient 
+    ren.AddLight().Set(false, materialProperties[1], light_scale,
+		       viewDirection);
+    ren.AddLight().Set(false, 1.5, light_scale,
+		       viewDirection); 
+    for (int i = 0; i < 8; ++i) { // in VisIt there are only 8 lights
+        const LightAttributes& la = lightList.GetLight(i);
+        if (la.GetEnabledFlag()) {
+            if (la.GetType() == LightAttributes::Ambient) {
+                ren.AddLight().Set(true, la.GetBrightness(),
+                                   (double)la.GetColor().Red() / 255.0,
+                                   (double)la.GetColor().Green() / 255.0,
+                                   (double)la.GetColor().Blue() / 255.0);
+            } else {
+                ren.AddLight().Set(false, la.GetBrightness(),
+                                   (double)la.GetColor().Red() / 255.0,
+                                   (double)la.GetColor().Green() / 255.0,
+                                   (double)la.GetColor().Blue() / 255.0,
+                                   la.GetDirection());        
+
+            }          
+        }
+    }    
+    ren.FinalizeLights();
+    ren.Set(0, 1, false, false, false);
+    ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute after ospray",
+                            "ospout");    
+
+    //===================================================================//
+    // continuation of previous pipeline
+    //===================================================================//
+    //
+    // Extract all of the samples from the dataset.
+    //
+    avtOSPRaySamplePointExtractor extractor(screen[0], screen[1],
+					    samplesPerRay);
+
+    extractor.SetJittering(true);
+    extractor.SetTransferFn(transferFn1D);
+    extractor.SetInput(trans.GetOutput());
+    extractor.SetOSPRay(ospray_core);
+    extractor.SetViewInfo(view);
+    extractor.SetSamplingRate(samplingRate); 
+    extractor.SetRenderingExtents(renderingExtents); // rendered region
+    extractor.SetMVPMatrix(model_to_screen_transform);
+    
+    //
+    // For curvilinear and unstructured meshes, it makes sense to convert the
+    // cells to image space.  But for rectilinear meshes, it is not the
+    // most efficient strategy.  So set some flags here that allow the
+    // extractor to do the extraction in world space.
+    //
+    {
+        trans.SetPassThruRectilinearGrids(true);
+        extractor.SetRectilinearGridsAreInWorldSpace(true, view, aspect);
+    }
+
+    //===================================================================//
+    // Qi debug
+    //===================================================================//
+    ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute "
+                            "raytracing setup done",
+                            "ospout");
+
+    
+    //===================================================================//
+    // Execute rendering
+    //===================================================================//
+    {
+        StackTimer t1("AllPatchRendering");
+        extractor.Update(GetGeneralContract());
+    }
+    
+    /*
+    avtDataObject_p samples = extractor.GetOutput();
+    // Only required to force an update 
+    // Need to find a way to get rid of that!!!!
+    avtRayCompositer rc(rayfoo);
+    rc.SetInput(samples);
+    avtImage_p image  = rc.GetTypedOutput();
+    image->Update(GetGeneralContract());     
+    */
+
+    //===================================================================//
+    // Image Compositing
+    //===================================================================//
+    // Initialization
+    int timingIdx;
+    float *compositedData = NULL;
+    int compositedW, compositedH;
+    int compositedExtents[4];
+    // Debug
+    int numPatches = extractor.GetImgPatchSize();
+    ospout << "[avtOSPRayRayTracer] Total num of patches " 
+           << numPatches << std::endl;
+    for (int i=0; i<numPatches; i++) {
+        ospray::ImgMetaData currImgMeta = extractor.GetImgMetaPatch(i);
+        ospout << "[avtOSPRayRayTracer] Rank " << PAR_Rank() << " "
+               << "Idx " << i << " (" << currImgMeta.patchNumber << ") " 
+               << " depth " << currImgMeta.eye_z << std::endl
+               << "current patch size = " 
+               << currImgMeta.dims[0] << ", " 
+               << currImgMeta.dims[1] << std::endl
+               << "current patch starting" 
+               << " X = " << currImgMeta.screen_ll[0] 
+               << " Y = " << currImgMeta.screen_ll[1] << std::endl
+               << "current patch ending" 
+               << " X = " << currImgMeta.screen_ur[0] 
+               << " Y = " << currImgMeta.screen_ur[1] << std::endl;
+    }
+    //-------------------------------------------------------------------//
+    // IceT: If each rank has only one patch, we use IceT to composite
+    //-------------------------------------------------------------------//
+    if (imgComm.IceTValid() && extractor.GetImgPatchSize() == 1) {
+        //---------------------------------------------------------------//
+        // Setup Local Tile
+        ospray::ImgMetaData currMeta = extractor.GetImgMetaPatch(0);
+        ospray::ImgData     currData;
+        currData.imagePatch = NULL;
+        extractor.GetAndDelImgData /* do shallow copy inside */
+            (currMeta.patchNumber, currData);
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // First Composition
+        if (PAR_Size() > 1) { 
+            compositedW = renderingExtents[1] - renderingExtents[0];
+            compositedH = renderingExtents[3] - renderingExtents[2];
+            compositedExtents[0] = renderingExtents[0];
+            compositedExtents[1] = renderingExtents[1];
+            compositedExtents[2] = renderingExtents[2];
+            compositedExtents[3] = renderingExtents[3];
+            if (PAR_Rank() == 0) {
+                compositedData = 
+                    new float[4 * compositedW * compositedH]();
+            }
+            int currExtents[4] = 
+                {std::max(currMeta.screen_ll[0]-renderingExtents[0], 0), 
+                 std::min(currMeta.screen_ur[0]-renderingExtents[0], 
+                          compositedW), 
+                 std::max(currMeta.screen_ll[1]-renderingExtents[2], 0),
+                 std::min(currMeta.screen_ur[1]-renderingExtents[2],
+                          compositedH)};
+            imgComm.IceTInit(compositedW, compositedH);
+            imgComm.IceTSetTile(currData.imagePatch, 
+                                currExtents,
+                                currMeta.eye_z);
+            imgComm.IceTComposite(compositedData);
+            if (currData.imagePatch != NULL) {
+                delete[] currData.imagePatch;
+                currData.imagePatch = NULL;
+            }
+        } else {
+            compositedW = currMeta.dims[0];
+            compositedH = currMeta.dims[1];
+            compositedExtents[0] = renderingExtents[0];
+            compositedExtents[1] = renderingExtents[0] + compositedW;
+            compositedExtents[2] = renderingExtents[2];
+            compositedExtents[3] = renderingExtents[2] + compositedH;
+            compositedData = currData.imagePatch;
+            currData.imagePatch = NULL;
+        }
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Memory
+        ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute "
+                                "IceT Compositing Done", 
+                                "ospout");
+        //---------------------------------------------------------------//
+    }
+    //-------------------------------------------------------------------//
+    // SERIAL: Image Composition
+    //-------------------------------------------------------------------//
+    else if (parallelOn == false) {
+        //---------------------------------------------------------------//
+        // Get the Metadata for All Patches
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Serial-Composite: Get the Metadata for "
+                                  "All Patches");
+        // contains the metadata to composite the image
+        std::vector<ospray::ImgMetaData> allPatchMeta;
+        std::vector<ospray::ImgData>     allPatchData;
+        // get the number of patches
+        int numPatches = extractor.GetImgPatchSize();
+        for (int i=0; i<numPatches; i++)
+        {
+            allPatchMeta.push_back(extractor.GetImgMetaPatch(i));
+        }
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Serial-Composite: Get the Metadata for "
+                                 "All Patches");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Sort with the Largest z First
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Serial-Composite: Sort with the Largest "
+                                  "z First");
+        std::sort(allPatchMeta.begin(), allPatchMeta.end(), 
+                  &OSPRaySortImgMetaDataByEyeSpaceDepth);
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Serial-Composite: Sort with the Largest "
+                                 "z First");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Blend Images
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Serial-Composite: Blend Images");
+        compositedW = renderingExtents[1] - renderingExtents[0];
+        compositedH = renderingExtents[3] - renderingExtents[2];
+        compositedExtents[0] = renderingExtents[0];
+        compositedExtents[1] = renderingExtents[0] + compositedW;
+        compositedExtents[2] = renderingExtents[2];
+        compositedExtents[3] = renderingExtents[2] + compositedH;	    
+        if (PAR_Rank() == 0) {
+            compositedData = new float[compositedW * compositedH * 4]();
+        }
+        for (int i=0; i<numPatches; i++)
+        {
+            ospray::ImgMetaData currImgMeta = allPatchMeta[i];
+            ospray::ImgData     currImgData;
+            currImgData.imagePatch = NULL;
+            extractor.GetAndDelImgData /* do shallow copy inside */
+                (currImgMeta.patchNumber, currImgData);
+            const float* currData = currImgData.imagePatch;
+            const int currExtents[4] = 
+                {currImgMeta.screen_ll[0], currImgMeta.screen_ur[0], 
+                 currImgMeta.screen_ll[1], currImgMeta.screen_ur[1]};
+            avtOSPRayImageCompositor::BlendBackToFront(currData,
+                                                       currExtents,
+                                                       compositedData, 
+                                                       compositedExtents);
+            if (currImgData.imagePatch != NULL) {
+                delete[] currImgData.imagePatch;
+            }
+            currImgData.imagePatch = NULL;
+        }
+        allPatchMeta.clear();
+        allPatchData.clear();
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Serial-Composite: Blend Images");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Memory
+        ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute "
+                                "Sequential Compositing Done", 
+                                "ospout");
+        //---------------------------------------------------------------//
+    } 
+    //-------------------------------------------------------------------//
+    // PARALLEL: Customized Parallel Direct Send Method
+    //-------------------------------------------------------------------//
+    else { 
+        //---------------------------------------------------------------//
+        // Parallel Direct Send
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Parallel-Composite: "
+                                  "Parallel Direct Send");
+        int tags[2] = {1081, 1681};
+        int tagGather = 2681;
+        int *regions = NULL;
+        imgComm.RegionAllocation(regions);
+        int myRegionHeight =
+            imgComm.ParallelDirectSendManyPatches
+            (extractor.imgDataHashMap, extractor.imageMetaPatchVector,
+             numPatches, regions, imgComm.GetParSize(), tags, 
+             renderingExtents);
+        imgComm.gatherImages(regions, imgComm.GetParSize(), 
+                             imgComm.intermediateImage, 
+                             imgComm.intermediateImageExtents, 
+                             imgComm.intermediateImageExtents, 
+                             tagGather, renderingExtents, myRegionHeight);
+
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Parallel-Composite: "
+                                 "Parallel Direct Send");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Some Cleanup
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Parallel-Composite: Some Cleanup");
+        if (regions != NULL)
+            delete [] regions;
+        regions = NULL;
+        if (imgComm.intermediateImage != NULL)
+            delete [] imgComm.intermediateImage;
+        imgComm.intermediateImage = NULL;		
+        imgComm.Barrier();
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Parallel-Composite: Some Cleanup");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Setup for Final Composition
+        compositedW = 
+            imgComm.finalImageExtents[1] -
+            imgComm.finalImageExtents[0];
+        compositedH = 
+            imgComm.finalImageExtents[3] -
+            imgComm.finalImageExtents[2];
+        compositedExtents[0] = imgComm.finalImageExtents[0];
+        compositedExtents[1] = imgComm.finalImageExtents[1];
+        compositedExtents[2] = imgComm.finalImageExtents[2];
+        compositedExtents[3] = imgComm.finalImageExtents[3];
+        if (PAR_Rank() == 0) {
+            compositedData = imgComm.GetFinalImageBuffer();
+        }
+        //--------------------------------------------------------------//
+        //--------------------------------------------------------------//
+        // Memory
+        ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute "
+                                "Parallel Compositing Done", 
+                                "ospout");
+        //--------------------------------------------------------------//
+    }	
+
+    ///////////////////////////////////////////////////////////////////
+    //
+    // Final Composition for Displaying
+    //
+    ///////////////////////////////////////////////////////////////////
+    if (PAR_Rank() == 0) {
+        avtImage_p finalImage = new avtImage(this);
+        vtkImageData *finalVTKImage = 
+            avtImageRepresentation::NewImage(screen[0], screen[1]);
+        finalImage->GetImage() = finalVTKImage;
+        unsigned char *finalImageBuffer = 
+            finalImage->GetImage().GetRGBBuffer();
+        ospray::CompositeBackground(screen,
+                                    compositedExtents,
+                                    compositedW,
+                                    compositedH,
+                                    compositedData,
+                                    opaqueImageData,
+                                    opaqueImageZB,
+                                    finalImageBuffer);
+        finalVTKImage->Delete();
+        SetOutput(finalImage);
+    }
+    if (compositedData != NULL) { 
+        delete [] compositedData;
+    }
+    compositedData = NULL; 
+    ospout << "[avtOSPRayRayTracer] Raycasting OSPRay is Done !" << std::endl;
+
+    ///////////////////////////////////////////////////////////////////
+    //
+    // Clean up
+    //
+    ///////////////////////////////////////////////////////////////////
+    screen_to_model_transform->Delete();
+    model_to_screen_transform->Delete();
+    screen_to_camera_transform->Delete();
+    ospray::Finalize();
+}
diff --git a/avt/Filters/avtOSPRayRayTracer.h b/avt/Filters/avtOSPRayRayTracer.h
new file mode 100644
index 000000000..63ca7ae0e
--- /dev/null
+++ b/avt/Filters/avtOSPRayRayTracer.h
@@ -0,0 +1,162 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                           avtOSPRayRayTracer.h                            //
+// ************************************************************************* //
+
+#ifndef AVT_OSPRAY_RAY_TRACER_H
+#define AVT_OSPRAY_RAY_TRACER_H
+
+#include <filters_exports.h>
+
+#include <avtRayTracerBase.h>
+#include <avtOSPRayCommon.h>
+#include <avtOSPRayImageCompositor.h>
+#include <LightList.h>
+
+class   vtkMatrix4x4;
+
+// ****************************************************************************
+//  Class: avtOSPRayRayTracer
+//
+//  Purpose:
+//      Performs ray tracing, taking in a dataset as a source and has an
+//      image as an output.
+//
+//  Programmer: Hank Childs
+//  Creation:   November 27, 2000
+//
+//  Modifications:
+//
+//    Hank Childs, Mon Jan  8 16:52:26 PST 2001
+//    Added "Get" functions.
+//
+//    Hank Childs, Sat Feb  3 20:37:01 PST 2001
+//    Removed pixelizer and added mechanism to change background color.
+//
+//    Hank Childs, Tue Feb 13 15:15:50 PST 2001
+//    Added ability to insert an opaque image into the rendering.
+//
+//    Brad Whitlock, Wed Dec 5 11:13:18 PDT 2001
+//    Added gradient backgrounds.
+//
+//    Hank Childs, Thu Feb  5 17:11:06 PST 2004
+//    Moved inlined destructor definition to .C file because certain compilers
+//    have problems with them.
+//
+//    Hank Childs, Sun Dec  4 18:00:55 PST 2005
+//    Add method that estimates number of stages.
+//
+//    Hank Childs, Mon Jan 16 11:11:47 PST 2006
+//    Add support for kernel based sampling.
+//
+//    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
+//    Added support for rectilinear grids with an inherent transform.
+//
+//    Hank Childs, Wed Dec 24 14:17:03 PST 2008
+//    Add method TightenClippingPlanes.
+//
+//    Pascal Grosset, Fri Sep 20 2013
+//    Added ray casting slivr & trilinear interpolation
+//
+//    Qi Wu, Sun Jul 1 2018
+//    Added support for ospray volume rendering.
+//
+// ****************************************************************************
+
+class AVTFILTERS_API avtOSPRayRayTracer : public avtRayTracerBase
+{
+public:
+    avtOSPRayRayTracer();
+    virtual              ~avtOSPRayRayTracer();
+
+    virtual const char   *GetType(void)      { return "avtOSPRayRayTracer"; };
+    virtual const char   *GetDescription(void) 
+                                             { return "OSPRay Ray tracing"; };
+
+    void SetActiveVariable(const char* s)             { activeVariable = s; };
+    void SetLightInfo(const LightList& l)                  { lightList = l; };
+    void SetOSPRay(OSPVisItContext *ptr)               { ospray_core = ptr; };
+
+    void SetLighting(bool l)                  { gradientShadingEnabled = l; };
+    void SetShadowsEnabled(bool l)                    { shadowsEnabled = l; };
+    void SetUseGridAccelerator(bool l)            { useGridAccelerator = l; };
+    void SetPreIntegration(bool l)                    { preIntegration = l; };
+    void SetSingleShade(bool l)                          { singleShade = l; };
+    void SetOneSidedLighting(bool l)                { oneSidedLighting = l; };
+    void SetAoTransparencyEnabled(bool l)      { aoTransparencyEnabled = l; };
+
+    void SetAoSamples(int v)                               { aoSamples = v; };
+    void SetSpp(int v)                                           { spp = v; };
+    
+    void SetAoDistance(double v)                          { aoDistance = v; };
+    void SetSamplingRate(double v)                      { samplingRate = v; };
+    void SetMinContribution(double v)                { minContribution = v; };
+    
+    void SetMatProperties(double v[4]) 
+                    { for (int i=0; i<4; i++) materialProperties[i] = v[i]; };
+    void SetViewDirection(double v[3])
+                         { for (int i=0; i<3; i++) viewDirection[i] = v[i]; };
+protected:
+    virtual void             Execute(void);
+
+    const char*              activeVariable;
+    LightList                lightList;
+    OSPVisItContext         *ospray_core;
+
+    bool                     gradientShadingEnabled;
+    bool                     shadowsEnabled;
+    bool                     useGridAccelerator;
+    bool                     preIntegration;
+    bool                     singleShade;
+    bool                     oneSidedLighting;
+    bool                     aoTransparencyEnabled;
+    int                      spp;
+    int                      aoSamples;
+    double                   aoDistance;
+    double                   samplingRate;
+    double                   minContribution;
+    
+    double                   materialProperties[4];
+    double                   viewDirection[3];
+
+    avtOSPRayImageCompositor imgComm;
+};
+
+#endif
diff --git a/avt/Filters/avtOSPRaySamplePointExtractor.C b/avt/Filters/avtOSPRaySamplePointExtractor.C
new file mode 100644
index 000000000..72a86349a
--- /dev/null
+++ b/avt/Filters/avtOSPRaySamplePointExtractor.C
@@ -0,0 +1,574 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                    avtOSPRaySamplePointExtractor.C                        //
+// ************************************************************************* //
+
+#include <avtOSPRaySamplePointExtractor.h>
+
+#include <float.h>
+
+#include <vtkCellData.h>
+#include <vtkDataSet.h>
+#include <vtkPointData.h>
+#include <vtkPoints.h>
+#include <vtkUnsignedCharArray.h>
+#include <vtkIdList.h>
+#include <vtkRectilinearGrid.h>
+
+#include <avtCellList.h>
+#include <avtOSPRayVoxelExtractor.h>
+#include <avtParallel.h>
+#include <avtSamplePoints.h>
+#include <avtVolume.h>
+
+#include <DebugStream.h>
+#include <TimingsManager.h>
+#include <StackTimer.h>
+
+#include <Utility.h>
+#include <DebugStream.h>
+
+#include <limits>
+#include <algorithm>
+#include <stack>
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor constructor
+//
+//  Arguments:
+//      w       The width.
+//      h       The height.
+//      d       The depth.
+//
+//  Programmer: Hank Childs
+//  Creation:   December 5, 2000
+//     
+//  Modifications:
+//
+//    Hank Childs, Thu Nov 15 15:39:48 PST 2001
+//    Moved construction of cell list to Execute to account new limitations of
+//    sample points involving multiple variables.
+//
+//    Hank Childs, Tue Jan  1 10:01:20 PST 2002
+//    Initialized sendCells.
+//
+//    Hank Childs, Sun Dec 14 11:07:56 PST 2003
+//    Initialized massVoxelExtractor.
+//
+//    Hank Childs, Fri Nov 19 13:57:02 PST 2004
+//    Initialized rectilinearGridsAreInWorldSpace.
+//
+//    Hank Childs, Fri Dec 10 09:59:57 PST 2004
+//    Initialized shouldDoTiling.
+//
+//    Hank Childs, Wed Feb  2 08:56:00 PST 2005
+//    Initialize modeIs3D.
+//
+//    Hank Childs, Sun Dec  4 19:12:42 PST 2005
+//    Initialize kernelBasedSampling.
+//
+//    Hank Childs, Tue Jan 24 16:42:40 PST 2006
+//    Added point extractor.
+//
+//    Timo Bremer, Thu Sep 13 14:02:40 PDT 2007
+//    Added hex20 extractor.
+//
+//    Hank Childs, Tue Jan 15 14:26:06 PST 2008
+//    Initialize members for sample point arbitration.
+//
+//    Hank Childs, Fri Jan  9 14:10:25 PST 2009
+//    Initialize jitter.
+//
+//    Mark C. Miller, Thu Oct  2 09:41:37 PDT 2014
+//    Initialize lightDirection.
+// ****************************************************************************
+
+avtOSPRaySamplePointExtractor::avtOSPRaySamplePointExtractor(int w,
+							     int h,
+                                                             int d)
+    : avtSamplePointExtractorBase(w, h, d)
+{
+    ospray_core = NULL;
+    osprayVoxelExtractor = NULL;
+    modelViewProj = vtkMatrix4x4::New();
+    patchCount = 0;
+    imageMetaPatchVector.clear();
+    imgDataHashMap.clear();
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor destructor
+//
+//  Programmer: Hank Childs
+//  Creation:   December 8, 2000
+//      
+//  Modifications:
+//
+//    Hank Childs, Sun Dec 14 11:07:56 PST 2003
+//    Deleted massVoxelExtractor.
+//
+//    Hank Childs, Tue Jan 24 16:42:40 PST 2006
+//    Deleted pointExtractor.
+//
+//    Timo Bremer, Thu Sep 13 14:02:40 PDT 2007
+//    Deleted hex20Extractor.
+//
+//    Hank Childs, Tue Jan 15 21:25:01 PST 2008
+//    Delete arbitrator.
+//
+// ****************************************************************************
+
+avtOSPRaySamplePointExtractor::~avtOSPRaySamplePointExtractor()
+{
+    if (osprayVoxelExtractor != NULL)
+    {
+        delete osprayVoxelExtractor;
+        osprayVoxelExtractor = NULL;
+    }
+
+    DelImgPatches();
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::SetUpExtractors
+//
+//  Purpose:
+//      Sets up the extractors and tell them which volume to extract into.
+//
+//  Programmer: Hank Childs
+//  Creation:   November 15, 2001
+//
+//  Modifications:
+//
+//    Hank Childs, Tue Jan  1 10:01:20 PST 2002
+//    Tell the extractors whether they should extract from large cells.
+//
+//    Hank Childs, Sun Dec 14 11:07:56 PST 2003
+//    Set up massVoxelExtractor.
+//
+//    Hank Childs, Fri Dec 10 09:59:57 PST 2004
+//    Do the sampling in tiles if necessary.
+//
+//    Hank Childs, Sun Dec  4 19:12:42 PST 2005
+//    Add support for kernel based sampling.
+//
+//    Timo Bremer, Thu Sep 13 14:02:40 PDT 2007
+//    Added hex20 extractor.
+//
+//    Hank Childs, Fri Jan  9 14:11:24 PST 2009
+//    Tell extractors whether or not to jitter.  Also remove call to 
+//    massVoxelExtractor regarding "sendCellsMode", as it does not participate
+//    in that mode ... so the call was worthless.
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::SetUpExtractors(void)
+{
+    StackTimer t0("avtOSPRaySamplePointExtractor::SetUpExtractors");
+    avtSamplePoints_p output = GetTypedOutput();
+
+    //
+    // This will always be NULL the first time through.  For subsequent tiles
+    // (provided we are doing tiling) will not have this issue.
+    //
+    if (output->GetVolume() == NULL)
+        output->SetVolume(width, height, depth);
+    else
+        output->GetVolume()->ResetSamples();
+    output->ResetCellList();
+    avtVolume *volume = output->GetVolume();
+    if (shouldDoTiling)
+        volume->Restrict(width_min, width_max-1, height_min, height_max-1);
+
+    //
+    // Set up the extractors and tell them which cell list to use.
+    //
+    avtCellList *cl = output->GetCellList();
+
+    if (osprayVoxelExtractor != NULL)
+    {
+        delete osprayVoxelExtractor;
+    }
+    osprayVoxelExtractor = new avtOSPRayVoxelExtractor(width, height, depth,
+                                                       volume, cl);
+    // osprayVoxelExtractor->SetJittering(jitter);
+    if (shouldDoTiling)
+    {
+        osprayVoxelExtractor->Restrict(width_min, width_max-1,
+                                      height_min, height_max-1);
+    }
+}
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::InitSampling
+//
+//  Purpose:
+//      Initialize sampling, called by base class ExecuteTree method before.
+//      the actual iteration starts. This function might be useful for
+//      children classes
+//
+//  Arguments:
+//      dt      The dataset tree that should be processed.
+//
+//  Programmer: Qi WU 
+//  Creation:   June 18, 2018
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::InitSampling(avtDataTree_p dt)
+{
+    ospray::Context* ospray = (ospray::Context*)ospray_core;	
+    for (int i = 0; i < dt->GetNChildren(); ++i)
+    { ospray->InitPatch(i); }    
+    patchCount = 0;
+    imageMetaPatchVector.clear();
+    imgDataHashMap.clear();
+}
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::DoSampling
+//
+//  Purpose:
+//      Performs sampling, called by base class ExecuteTree method.
+//
+//  Arguments:
+//      ds      The data set that should be processed.
+//      idx     The index of the dataset.
+//
+//  Programmer: Kathleen Biagas 
+//  Creation:   April 18, 2018
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::DoSampling(vtkDataSet *ds, int idx)
+{
+    // initialize ospray
+    StackTimer t0("avtOSPRaySamplePointExtractor::DoSampling "
+                  "OSPVisItContext::InitPatch");    
+    // volume scalar range
+    double scalarRange[2]; 
+    {
+        StackTimer t1("avtOSPRaySamplePointExtractor::DoSampling "
+                      "Retrieve Volume Scalar Range");
+        ds->GetScalarRange(scalarRange);
+    }
+
+    // transfer function visible range
+    double tfnVisibleRange[2];
+    {
+        StackTimer t2("avtOSPRaySamplePointExtractor::DoSampling "
+                      "Retrieve TFN Visible Range");
+        tfnVisibleRange[0] = transferFn1D->GetMinVisibleScalar();
+        tfnVisibleRange[1] = transferFn1D->GetMaxVisibleScalar();
+    }
+
+    osprayVoxelExtractor->SetScalarRange(scalarRange);
+    osprayVoxelExtractor->SetTFVisibleRange(tfnVisibleRange);
+    RasterBasedSample(ds, idx);
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::RasterBasedSample
+//
+//  Purpose:
+//      Does raster based sampling.
+//
+//  Programmer: Hank Childs
+//  Creation:   January 1, 2006
+//
+//  Modifications:
+//    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
+//    Added support for rectilinear grids with an inherent transform.
+//
+//    Hank Childs, Fri Jun  1 12:50:45 PDT 2007
+//    Added support for non-scalars.
+//
+//    Timo Bremer, Thu Sep 13 14:02:40 PDT 2007
+//    Added support for hex-20s.
+//
+//    Hank Childs, Mon Oct 29 20:29:55 PST 2007
+//    Ignore surface primitives in 3D.
+//
+//    Kevin Griffin, Fri Apr 22 16:31:57 PDT 2016
+//    Added support for polygons.
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
+{
+    StackTimer t0("avtOSPRaySamplePointExtractor::RasterBasedSample");
+
+    if (ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
+    {
+        avtDataAttributes &atts = GetInput()->GetInfo().GetAttributes();
+        const double *xform = NULL;
+        if (atts.GetRectilinearGridHasTransform())
+            xform = atts.GetRectilinearGridTransform();
+        avtSamplePoints_p samples = GetTypedOutput();
+        int numVars = samples->GetNumberOfRealVariables();
+        std::vector<std::string> varnames;
+        std::vector<int>         varsizes;
+        for (int i = 0 ; i < numVars ; i++)
+        {
+            varnames.push_back(samples->GetVariableName(i));
+            varsizes.push_back(samples->GetVariableSize(i));
+        }
+
+        //-----------------------------
+        // Extractor Setup
+        //-----------------------------	
+        osprayVoxelExtractor->SetProcIdPatchID(PAR_Rank(), num);
+        osprayVoxelExtractor->SetOSPRay(ospray_core);
+	osprayVoxelExtractor->SetViewInfo(viewInfo);
+        osprayVoxelExtractor->SetSamplingRate(samplingRate);       
+        osprayVoxelExtractor->SetRenderingExtents(renderingExtents);	
+        osprayVoxelExtractor->SetMVPMatrix(modelViewProj);
+
+	// Note (Qi): probably not necessary
+        osprayVoxelExtractor->SetGridsAreInWorldSpace
+            (rectilinearGridsAreInWorldSpace, view, aspect, xform);
+	
+        //-----------------------------
+        // Extract
+        //-----------------------------
+        osprayVoxelExtractor->Extract((vtkRectilinearGrid *) ds, varnames,
+                                      varsizes);
+
+        //-----------------------------
+        // Get rendering results
+        // put them into a proper vector, sort them based on z value
+        //-----------------------------
+        ospray::ImgMetaData tmpImageMetaPatch;
+        tmpImageMetaPatch = InitMetaPatch(patchCount);
+
+        osprayVoxelExtractor->GetImageDimensions
+            (tmpImageMetaPatch.inUse,     tmpImageMetaPatch.dims, 
+             tmpImageMetaPatch.screen_ll, tmpImageMetaPatch.screen_ur, 
+             tmpImageMetaPatch.eye_z,     tmpImageMetaPatch.clip_z);
+        if (tmpImageMetaPatch.inUse == 1)
+        {
+            tmpImageMetaPatch.avg_z = tmpImageMetaPatch.eye_z;
+            tmpImageMetaPatch.destProcId = tmpImageMetaPatch.procId;
+            imageMetaPatchVector.push_back(tmpImageMetaPatch);
+
+            ospray::ImgData tmpImageDataHash;
+            tmpImageDataHash.procId = tmpImageMetaPatch.procId;
+            tmpImageDataHash.patchNumber = tmpImageMetaPatch.patchNumber;
+            tmpImageDataHash.imagePatch = 
+                new float[tmpImageMetaPatch.dims[0] * 
+                          tmpImageMetaPatch.dims[1] * 4];
+
+            osprayVoxelExtractor->GetComputedImage
+                                                (tmpImageDataHash.imagePatch);
+            imgDataHashMap.insert
+                (std::pair<int, ospray::ImgData> (tmpImageDataHash.patchNumber,
+                                                  tmpImageDataHash));
+
+            patchCount++;
+        }
+    } else {
+        //---------------------------------------------------------
+        // Other Grid
+        //---------------------------------------------------------
+	if (num == 0) {
+	    const std::string msg = 
+		"Dataset type " + std::to_string((int)(ds->GetDataObjectType())) + " "
+		"is not a VTK_RECTILINEAR_GRID. "
+		"Currently the RayCasting:OSPRay renderer "
+		"only supports rectilinear grid, " 
+		"thus the volume cannot be rendered\n";
+	    //ospray::Warning(msg);
+	    ospray::Exception(msg);
+	}
+    }
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::SendJittering
+//
+//  Purpose:
+//      Tell the individual cell extractors whether or not to jitter.
+//
+//  Arguments:
+//      j     true if the cell extractors should jitter
+//
+//  Programmer: Hank Childs
+//  Creation:   January 9, 2009
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::SendJittering()
+{
+    if (osprayVoxelExtractor != NULL)
+    {
+        osprayVoxelExtractor->SetJittering(jitter);
+    }
+}
+
+
+// ****************************************************************************
+//  Method:  avtOSPRaySamplePointExtractor::FilterUnderstandsTransformedRectMesh
+//
+//  Purpose:
+//    If this filter returns true, this means that it correctly deals
+//    with rectilinear grids having an implied transform set in the
+//    data attributes.  It can do this conditionally if desired.
+//
+//  Arguments:
+//    none
+//
+//  Programmer:  Jeremy Meredith
+//  Creation:    February 15, 2007
+//
+// ****************************************************************************
+
+bool
+avtOSPRaySamplePointExtractor::FilterUnderstandsTransformedRectMesh()
+{
+    return true;
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::DelImgPatches
+//
+//  Purpose:
+//      allocates space to the pointer address and copy the image generated
+//      to it
+//
+//  Programmer: TODO
+//  Creation:   
+//
+//  Modifications:
+//
+//      Qi WU: TODO
+//      Rename based on VisIt naming convension
+//
+// ****************************************************************************
+void
+avtOSPRaySamplePointExtractor::DelImgPatches() {
+    imageMetaPatchVector.clear();
+    for (iter_t it=imgDataHashMap.begin(); it!=imgDataHashMap.end(); it++)
+    {
+        if ((*it).second.imagePatch != NULL) { 
+	    delete [](*it).second.imagePatch;
+	}
+        (*it).second.imagePatch = NULL;
+    }
+    imgDataHashMap.clear();
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::GetImgData
+//
+//  Purpose:
+//      Copies a patchover
+//
+//  Programmer: TODO
+//  Creation:   
+//
+//  Modifications:
+//
+//      Qi WU: TODO
+//      Rename based on VisIt naming convension
+//      Does shallow copy instead deep copy for efficiency
+//
+// ****************************************************************************
+void 
+avtOSPRaySamplePointExtractor::GetAndDelImgData(int patchId, 
+                                          ospray::ImgData &tempImgData) 
+{
+    size_t imagePatchSize = 
+	imageMetaPatchVector[patchId].dims[0] * 
+	imageMetaPatchVector[patchId].dims[1] * sizeof(float) * 4;
+    iter_t it = imgDataHashMap.find(patchId);
+    tempImgData.procId = it->second.procId;
+    tempImgData.patchNumber = it->second.patchNumber;
+    // do shallow copy instead of deep copy
+    tempImgData.imagePatch = it->second.imagePatch;
+    // memcpy(tempImgData.imagePatch,
+    // 	      it->second.imagePatch,
+    //        imagePatchSize);
+    // delete [](*it).second.imagePatch;
+    it->second.imagePatch = NULL;
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::InitMetaPatch
+//
+//  Purpose:
+//
+//  Programmer: 
+//  Creation:   
+//
+//  Modifications:
+//
+// ****************************************************************************
+ospray::ImgMetaData
+avtOSPRaySamplePointExtractor::InitMetaPatch(int id)
+{
+    ospray::ImgMetaData temp;
+    temp.inUse = 0;
+    temp.procId = PAR_Rank();
+    temp.destProcId = PAR_Rank();
+    temp.patchNumber = id;
+    temp.dims[0] = temp.dims[1] = -1;
+    temp.screen_ll[0] = temp.screen_ll[1] = -1;
+    temp.screen_ur[0] = temp.screen_ur[1] = -1;
+    temp.avg_z = -1.0;
+    temp.eye_z = -1.0;
+    temp.clip_z = -1.0;
+    return temp;
+}
diff --git a/avt/Filters/avtOSPRaySamplePointExtractor.h b/avt/Filters/avtOSPRaySamplePointExtractor.h
new file mode 100644
index 000000000..7fd90b7fb
--- /dev/null
+++ b/avt/Filters/avtOSPRaySamplePointExtractor.h
@@ -0,0 +1,180 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                      avtOSPRaySamplePointExtractor.h                      //
+// ************************************************************************* //
+
+#ifndef AVT_OSPRAY_SAMPLE_POINT_EXTRACTOR_H
+#define AVT_OSPRAY_SAMPLE_POINT_EXTRACTOR_H
+
+#include <filters_exports.h>
+
+#include <avtSamplePointExtractorBase.h>
+#include <avtOSPRayCommon.h> // this ensures VISIT_OSPRAY is defined
+
+class     avtOSPRayVoxelExtractor;
+
+#include <vtkMatrix4x4.h>
+
+#include <vector>
+#include <map>
+
+// ****************************************************************************
+//  Class: avtOSPRaySamplePointExtractor
+//
+//  Purpose:
+//      This is a component that will take an avtDataset as an input and find
+//      all of the sample points from that dataset.
+//
+//  Programmer: Hank Childs
+//  Creation:   December 5, 2000
+//
+//  Modifications:
+//
+//    Hank Childs, Sat Jan 27 15:09:34 PST 2001
+//    Added support for sending cells when doing parallel volume rendering.
+//
+//    Kathleen Bonnell, Sat Apr 21, 13:09:27 PDT 2001 
+//    Added recursive Execute method to walk down input data tree. 
+//
+//    Hank Childs, Tue Nov 13 15:51:15 PST 2001
+//    Remove boolean argument to Extract<Cell> calls since it is no longer
+//    necessary when all of the variables are being extracted.
+//
+//    Hank Childs, Sun Dec 14 11:07:56 PST 2003
+//    Added mass voxel extractor.
+//
+//    Hank Childs, Fri Nov 19 13:41:56 PST 2004
+//    Added view conversion option.
+//
+//    Hank Childs, Sat Jan 29 13:32:54 PST 2005
+//    Added 2D extractors.
+//
+//    Hank Childs, Sun Dec  4 19:12:42 PST 2005
+//    Added support for kernel-based sampling.
+//
+//    Hank Childs, Sun Jan  1 10:56:19 PST 2006
+//    Added RasterBasedSample and KernelBasedSample.
+//
+//    Hank Childs, Tue Feb 28 08:25:33 PST 2006
+//    Added PreExecute.
+//
+//    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
+//    Added support for rectilinear grids with an inherent transform.
+//
+//    Hank Childs, Fri Jun  1 11:47:56 PDT 2007
+//    Add method GetLoadingInfoForArrays.
+//
+//    Hank Childs, Thu Sep 13 14:02:40 PDT 2007
+//    Added support for hex-20s.
+//
+//    Hank Childs, Tue Jan 15 14:17:15 PST 2008
+//    Have this class set up custom sample point arbitrators, since it has
+//    the most knowledge.
+//
+//    Hank Childs, Fri Jan  9 14:09:57 PST 2009
+//    Add support for jittering.
+//
+//    Kevin Griffin, Fri Apr 22 16:31:57 PDT 2016
+//    Added support for polygons.
+//
+//    Qi Wu, Sun Jul 1 2018
+//    Added support for ospray volume rendering.
+//
+// ****************************************************************************
+
+class AVTFILTERS_API avtOSPRaySamplePointExtractor 
+    : public avtSamplePointExtractorBase
+{
+  public:
+                          avtOSPRaySamplePointExtractor(int, int, int);
+    virtual              ~avtOSPRaySamplePointExtractor();
+
+    virtual const char   *GetType(void)
+                                   { return "avtOSPRaySamplePointExtractor"; };
+    virtual const char   *GetDescription(void)
+                                         { return "Extracting sample points";};
+
+    void                  SetOSPRay(OSPVisItContext* o)   { ospray_core = o; };
+    void                  SetViewInfo(const avtViewInfo & v) { viewInfo = v; };
+    void                  SetSamplingRate(double r)      { samplingRate = r; };
+    void                  SetRenderingExtents(int extents[4]) 
+    {
+        renderingExtents[0] = extents[0];
+        renderingExtents[1] = extents[1];
+        renderingExtents[2] = extents[2];
+        renderingExtents[3] = extents[3];
+    }
+    void                  SetMVPMatrix(vtkMatrix4x4 *mvp)
+    {
+	modelViewProj->DeepCopy(mvp);
+    };
+
+    int                   GetImgPatchSize() { return patchCount; };
+    void                  GetAndDelImgData(int patchId,
+					   ospray::ImgData &tempImgData);
+    ospray::ImgMetaData   GetImgMetaPatch(int patchId)
+                                  { return imageMetaPatchVector.at(patchId); };
+    void                  DelImgPatches();
+    
+    std::vector<ospray::ImgMetaData>    imageMetaPatchVector;
+    std::multimap<int, ospray::ImgData> imgDataHashMap;
+    typedef std::multimap<int, ospray::ImgData>::iterator iter_t;
+
+  protected:
+    
+    virtual void              InitSampling(avtDataTree_p dt);
+    virtual void              DoSampling(vtkDataSet *, int);
+    virtual void              SetUpExtractors(void);
+    virtual void              SendJittering(void);
+    virtual bool              FilterUnderstandsTransformedRectMesh(void);
+    void                      RasterBasedSample(vtkDataSet *, int num = 0);
+    ospray::ImgMetaData       InitMetaPatch(int id);
+
+    OSPVisItContext          *ospray_core;
+    avtOSPRayVoxelExtractor  *osprayVoxelExtractor;
+    avtViewInfo               viewInfo;
+    vtkMatrix4x4             *modelViewProj;
+    double                    samplingRate;
+    int                       renderingExtents[4];
+    int                       patchCount;
+};
+
+
+#endif
diff --git a/avt/Filters/avtOSPRayVoxelExtractor.C b/avt/Filters/avtOSPRayVoxelExtractor.C
new file mode 100644
index 000000000..98ec65558
--- /dev/null
+++ b/avt/Filters/avtOSPRayVoxelExtractor.C
@@ -0,0 +1,639 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                            avtOSPRayVoxelExtractor.C                      //
+// ************************************************************************* //
+
+#include <avtOSPRayVoxelExtractor.h>
+
+#include <float.h>
+
+#include <avtAccessor.h>
+#include <avtCellList.h>
+#include <avtVolume.h>
+
+#include <vtkDataArray.h>
+#include <vtkCamera.h>
+#include <vtkCellData.h>
+#include <vtkMatrix4x4.h>
+#include <vtkPointData.h>
+#include <vtkRectilinearGrid.h>
+#include <vtkTemplateAliasMacro.h>
+#include <vtkUnsignedCharArray.h>
+
+#include <DebugStream.h>
+#include <StackTimer.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+
+#include <iostream>
+#include <fstream>
+#include <string>
+#include <sstream>
+#include <algorithm>
+#include <limits>
+#include <math.h>
+
+#if defined (_MSC_VER) && (_MSC_VER < 1800) && !defined(round)
+inline double round(double x) {return (x-floor(x)) > 0.5 ? ceil(x) : floor(x);}
+#endif
+
+// ****************************************************************************
+//  Method: avtOSPRayVoxelExtractor constructor
+//
+//  Arguments:
+//     w     The number of sample points in the x direction (width).
+//     h     The number of sample points in the y direction (height).
+//     d     The number of sample points in the z direction (depth).
+//     vol   The volume to put samples into.
+//     cl    The cell list to put cells whose sampling was deferred.
+//
+//  Programmer: Hank Childs
+//  Creation:   December 14, 2003
+//
+//  Modifications:
+//
+//    Hank Childs, Fri Nov 19 14:50:58 PST 2004
+//    Initialize gridsAreInWorldSpace.
+//
+//    Jeremy Meredith, Thu Feb 15 13:11:34 EST 2007
+//    Added an ability to extract voxels using the world-space version
+//    even when they're really in image space.
+//
+//    Hank Childs, Wed Aug 27 11:11:28 PDT 2008
+//    Initialize spatial coordinates array.
+//
+//    Hank Childs, Wed Dec 24 11:22:43 PST 2008
+//    Remove reference to ProportionSpaceToZBufferSpace data member.
+//
+//    Kathleen Biagas, Fri Jul 13 09:23:55 PDT 2012
+//    Use double instead of float.
+//
+// ****************************************************************************
+
+avtOSPRayVoxelExtractor::avtOSPRayVoxelExtractor(int w, int h, int d,
+                                             avtVolume *vol, avtCellList *cl)
+    : avtVoxelExtractor(w, h, d, vol, cl)
+{
+    ospray_core = NULL;
+    model_to_screen_transform = vtkMatrix4x4::New();
+    screen_to_model_transform = vtkMatrix4x4::New();
+
+    proc  = 0;
+    patch = 0;
+    drawn = 0;
+    imgDims[0] = imgDims[1] = 0;             // size of the patch
+    imgLowerLeft[0] = imgLowerLeft[1] = 0;   // coordinates in the whole image
+    imgUpperRight[0] = imgUpperRight[1] = 0; // coordinates in the whole image
+    eyeSpaceDepth  = -1;
+    clipSpaceDepth = -1;
+
+    finalImage = NULL;                         // the image data
+
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRayVoxelExtractor destructor
+//
+//  Purpose:
+//      Defines the destructor.  Note: this should not be inlined in the header
+//      because it causes problems for certain compilers.
+//
+//  Programmer: Hank Childs
+//  Creation:   February 5, 2004
+//
+//  Modifications:
+//
+//    Hank Childs, Sun Nov 21 10:35:40 PST 2004
+//    Delete the view to world transform.
+//
+//    Hank Childs, Wed Aug 27 11:10:51 PDT 2008
+//    Delete the spatial coordinate arrays.
+//
+//    Hank Childs, Wed Dec 24 11:22:43 PST 2008
+//    Remove reference to ProportionSpaceToZBufferSpace data member.
+//
+// ****************************************************************************
+
+avtOSPRayVoxelExtractor::~avtOSPRayVoxelExtractor()
+{
+    model_to_screen_transform->Delete();
+    screen_to_model_transform->Delete();
+
+    if (finalImage != NULL)
+        delete []finalImage;
+
+    finalImage = NULL;
+}
+
+// ****************************************************************************
+//  Method: avtOSPRayVoxelExtractor::Extract
+//
+//  Purpose:
+//      Extracts the grid into the sample points.
+//
+//  Programmer: Hank Childs
+//  Creation:   November 19, 2004
+//
+//  Modifications:
+//    Jeremy Meredith, Thu Feb 15 13:11:34 EST 2007
+//    Added an ability to extract voxels using the world-space version
+//    even when they're really in image space.
+//
+//    Hank Childs, Fri Jun  1 16:40:10 PDT 2007
+//    Added support for non-scalars.
+//
+// ****************************************************************************
+
+void
+avtOSPRayVoxelExtractor::Extract(vtkRectilinearGrid *rgrid,
+                std::vector<std::string> &varnames, std::vector<int> &varsizes)
+{
+    if (gridsAreInWorldSpace || pretendGridsAreInWorldSpace)
+        ExtractWorldSpaceGridOSPRay(rgrid, varnames, varsizes);
+    else {
+	ospray::Exception("Attempt to extract an image space grid,"
+			  "however, RayCasting OSPRay supports only"
+			  "world space grid extraction");
+        //ExtractImageSpaceGrid(rgrid, varnames, varsizes);
+    }
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay
+//
+//  Purpose:
+//      Compute region that patch covers
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 14, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay(vtkRectilinearGrid *rgrid,
+                 std::vector<std::string> &varnames, std::vector<int> &varsize)
+{
+    StackTimer t0("Calling avtOSPRayVoxelExtractor::"
+                  "ExtractWorldSpaceGridOSPRay");
+    //=======================================================================//
+    // Initialization
+    //=======================================================================//
+    // Flag to indicate if the patch is drawn
+    ospray::Context* ospray = (ospray::Context*)ospray_core;
+    drawn = 0;
+    
+    //=======================================================================//
+    // Register data and early skipping
+    //=======================================================================//
+    int w_min;
+    int w_max;
+    int h_min;
+    int h_max;
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Register Data (VisIt preparation)");
+        // Some of our sampling routines need a chance to pre-process the data.
+        // Register the grid here so we can do that.
+        // Stores the values in a structure so that it can be used
+        RegisterGrid(rgrid, varnames, varsize);
+        // Determine what range we are dealing with on this iteration.
+        w_min = restrictedMinWidth;
+        w_max = restrictedMaxWidth + 1;
+        h_min = restrictedMinHeight;
+        h_max = restrictedMaxHeight + 1;
+        imgWidth = imgHeight = 0;
+        /*
+        // Let's find out if this range can even intersect the dataset.
+        // If not, just skip it.
+        if (!FrustumIntersectsGrid(w_min, w_max, h_min, h_max)) { return; }
+        */
+    }
+    
+    //=======================================================================//
+    // obtain data pointers & ghost region information
+    //=======================================================================//
+    void* volumePointer = NULL;
+    int   volumeDataType;
+    int nX = 0, nY = 0, nZ = 0;
+    bool ghost_bound[6] = {false};
+    double volumeCube[6];
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Compute metadata & ghost boundary "
+                      "(Pre-OSPRay preparation)");
+        // Calculate patch dimensions for point array and cell array
+        //   This is to check if the patch is a cell data or a point data
+        //   I have to assume cell dataset has a higher priority
+        if (ncell_arrays > 0) {
+
+            ospout << "[avtOSPRayVoxelExtractor] Cell Dataset "
+                   << std::endl << std::endl;
+            if (DebugStream::Level5() || ospray::visit::CheckVerbose())
+                for (int i = 0; i < ncell_arrays; ++i)
+                    ospout << "  variable_name: "
+                           << rgrid->GetCellData()->GetArray(i)->GetName()
+                           << std::endl
+                           << "  idx_cell_arrays: " << i << std::endl
+                           << "  cell_index["    << i << "] "
+                           << cell_index[i]      << std::endl
+                           << "  cell_size["     << i << "] "
+                           << cell_size[i]       << std::endl
+                           << "  cell_vartypes[" << i << "] "
+                           << cell_vartypes[i]   << std::endl << std::endl;
+            if (rgrid->GetCellData()->GetArray(ncell_arrays-1)->GetName() !=
+                ospray->GetVariableName())
+            {
+                ospray::Exception("Error: primary variable " +
+                                  ospray->GetVariableName() +
+                                  " not found.");		
+            }
+            if (cell_size[ncell_arrays-1] != 1)
+            {
+                ospray::Exception("Error: non-scalar variable " +
+                                  ospray->GetVariableName() +
+                                  " of length " +
+                                  std::to_string(cell_size[ncell_arrays-1]) +
+                                  " found.");
+            }
+            nX = dims[0] - 1;
+            nY = dims[1] - 1;
+            nZ = dims[2] - 1;
+            volumePointer = cell_arrays[ncell_arrays-1];
+            volumeDataType = cell_vartypes[ncell_arrays-1];
+        }
+        else if (npt_arrays > 0) {
+            ospout << "[avtOSPRayVoxelExtractor] Point Dataset "
+                   << std::endl << std::endl;
+            if (DebugStream::Level5() || ospray::visit::CheckVerbose())
+                for (int i = 0; i < npt_arrays; ++i)
+                    ospout << "  variable_name: "
+                           << rgrid->GetPointData()->GetArray(i)->GetName()
+                           << std::endl
+                           << "  idx_pt_arrays: " << i << std::endl
+                           << "  pt_index["    << i << "] "
+                           << pt_index[i]      << std::endl
+                           << "  pt_size["     << i << "] "
+                           << pt_size[i]       << std::endl
+                           << "  pt_vartypes[" << i << "] "
+                           << pt_vartypes[i]   << std::endl << std::endl;
+            if (rgrid->GetPointData()->GetArray(npt_arrays-1)->GetName() !=
+                ospray->GetVariableName())
+            {
+                ospray::Exception("Error: primary variable " +
+                                  ospray->GetVariableName() +
+                                  " not found.");		
+            }
+            if (pt_size[npt_arrays-1] != 1)
+            {
+                ospray::Exception("Error: non-scalar variable " +
+                                  ospray->GetVariableName() +
+                                  " of length " +
+                                  std::to_string(pt_size[npt_arrays-1]) +
+                                  " found.");
+            }
+            nX = dims[0];
+            nY = dims[1];
+            nZ = dims[2];
+            volumePointer = pt_arrays[npt_arrays-1];
+            volumeDataType = pt_vartypes[npt_arrays-1];
+        } else {
+	    ospray::Exception("dataset found is neither nodal nor zonal. "
+			      "OSPRay does not know how to handle it.");
+        }
+        ospout << "[avtOSPRayVoxelExtractor] patch dimension "
+               << nX << " " << nY << " " << nZ << std::endl;
+        // Calculate ghost region boundaries
+        //   ghost_boundaries is an array to indicate if the patch contains
+        //   any ghost regions in six different directions
+        // Here I assume the patch is larger than 3-cube
+        // If not then you might want to dig into this code and see if
+        // there will be any special boundary cases
+        //
+        // debug5 << "VAR: ghost value " << (int)ghosts[0] << std::endl;
+        //
+        if (ghosts != NULL) {
+            int gnX = 0, gnY = 0, gnZ = 0;
+            gnX = dims[0] - 1;
+            gnY = dims[1] - 1;
+            gnZ = dims[2] - 1;	
+            for (int y = 1; y < (gnY-1); ++y) {
+                for (int z = 1; z < (gnZ-1); ++z) {
+                    if (!ghost_bound[0]) {
+                        if (ghosts[z*gnY*gnX+y*gnX        ] != 0)
+                            { ghost_bound[0] = true; }
+                    }
+                    if (!ghost_bound[3]) {
+                        if (ghosts[z*gnY*gnX+y*gnX+(gnX-1)] != 0)
+                            { ghost_bound[3] = true; }
+                    }
+                    if (ghost_bound[0] && ghost_bound[3]) { break; }
+                }
+            }
+            for (int x = 1; x < (gnX-1); ++x) {
+                for (int z = 1; z < (gnZ-1); ++z) {
+                    if (!ghost_bound[1]) {
+                        if (ghosts[z*gnY*gnX            +x] != 0)
+                            { ghost_bound[1] = true; }
+                    }
+                    if (!ghost_bound[4]) {
+                        if (ghosts[z*gnY*gnX+(gnY-1)*gnX+x] != 0)
+                            { ghost_bound[4] = true; }
+                    }
+                    if (ghost_bound[1] && ghost_bound[4]) { break; }
+                }
+            }
+            for (int x = 1; x < (gnX-1); ++x) {
+                for (int y = 1; y < (gnY-1); ++y) {
+                    if (!ghost_bound[2]) {
+                        if (ghosts[                y*gnX+x] != 0) 
+                            { ghost_bound[2] = true; }
+                    }
+                    if (!ghost_bound[5]) {
+                        if (ghosts[(gnZ-1)*gnY*gnX+y*gnX+x] != 0)
+                            { ghost_bound[5] = true; }
+                    }
+                    if (ghost_bound[2] && ghost_bound[5]) { break; }
+                }
+            }
+        }
+        // Data bounding box
+        volumeCube[0] = X[0];
+        volumeCube[2] = Y[0];
+        volumeCube[4] = Z[0];
+        if (ncell_arrays > 0) { 
+          volumeCube[1] = X[nX];
+          volumeCube[3] = Y[nY];
+          volumeCube[5] = Z[nZ];
+        } else {
+          volumeCube[1] = X[nX-1];
+          volumeCube[3] = Y[nY-1];
+          volumeCube[5] = Z[nZ-1];
+        }
+    }
+
+    //=======================================================================//
+    // Determine the screen size of the patch being processed
+    //=======================================================================//
+    int patchScreenExtents[4];
+    double patch_center[3];
+    double patch_depth;
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Get screen size of the patch (Pre-OSPRay preparation)");
+	double renderingDepthsExtents[2];
+        ospray::ProjectWorldToScreenCube(volumeCube, w_max, h_max, 
+					 viewInfo.imagePan, viewInfo.imageZoom,
+                                         model_to_screen_transform, 
+                                         patchScreenExtents, 
+                                         renderingDepthsExtents);
+        xMin = patchScreenExtents[0];
+        xMax = patchScreenExtents[1];
+        yMin = patchScreenExtents[2];
+        yMax = patchScreenExtents[3];
+        ospout << "[avtOSPRayVoxelExtractor] patch ghost bounds:"
+               << "   " << ghost_bound[0] << " " << ghost_bound[3] 
+               << " | " << ghost_bound[1] << " " << ghost_bound[4] 
+               << " | " << ghost_bound[2] << " " << ghost_bound[5]
+               << std::endl;   
+        patch_center[0] = (volumeCube[0] + volumeCube[1])/2.0;
+        patch_center[1] = (volumeCube[2] + volumeCube[3])/2.0;
+        patch_center[2] = (volumeCube[4] + volumeCube[5])/2.0;        
+        patch_depth = // use the norm of patch center as patch depth
+            std::sqrt((patch_center[0]-viewInfo.camera[0])*
+                      (patch_center[0]-viewInfo.camera[0])+
+                      (patch_center[1]-viewInfo.camera[1])*
+                      (patch_center[1]-viewInfo.camera[1])+
+                      (patch_center[2]-viewInfo.camera[2])*
+                      (patch_center[2]-viewInfo.camera[2]));
+        eyeSpaceDepth = patch_depth;
+        clipSpaceDepth = renderingDepthsExtents[0];
+    }
+
+    //=======================================================================//
+    // create framebuffer
+    //=======================================================================//
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Create ImgArray (Pre-OSPRay preparation)");
+        ospout << "[avtOSPRayVoxelExtractor] patch extents " 
+               << xMin << " " << xMax << " "
+               << yMin << " " << yMax << std::endl;
+        if (xMin < renderingExtents[0]) { xMin = renderingExtents[0]; }
+        if (yMin < renderingExtents[2]) { yMin = renderingExtents[2]; }    
+        if (xMax > renderingExtents[1]) { xMax = renderingExtents[1]; }
+        if (yMax > renderingExtents[3]) { yMax = renderingExtents[3]; }
+        imgWidth  = xMax-xMin;
+        imgHeight = yMax-yMin;
+        finalImage = new float[((imgWidth)*4) * imgHeight];
+    }
+
+    //=======================================================================//
+    // Render using OSPRay
+    //=======================================================================//
+    double volumePBox[6];
+    double volumeBBox[6];
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Using OSPRay");
+        {
+            StackTimer t2("avtOSPRayVoxelExtractor::"
+                          "ExtractWorldSpaceGridOSPRay "
+                          "OSPRay bbox and clip (OSPRay preparation)");
+            // shift grid and make it cel centered for cell data
+            // for cell centered data, we put the voxel on its left boundary
+            volumePBox[0] = X[0];
+            volumePBox[1] = Y[0];
+            volumePBox[2] = Z[0];
+            if (ncell_arrays > 0) { 
+              /* zonal data need to occupy a whole cell */
+              volumePBox[3] = X[nX];
+              volumePBox[4] = Y[nY];
+              volumePBox[5] = Z[nZ];
+            } else {
+              volumePBox[3] = X[nX-1];
+              volumePBox[4] = Y[nY-1];
+              volumePBox[5] = Z[nZ-1];
+            }
+            // compute boundingbox and clipping plane for ospray
+            if (ncell_arrays > 0) {
+                volumeBBox[0] = ghost_bound[0]?(X[0]+X[1])/2.:volumePBox[0];
+                volumeBBox[1] = ghost_bound[1]?(Y[0]+Y[1])/2.:volumePBox[1];
+                volumeBBox[2] = ghost_bound[2]?(Z[0]+Z[1])/2.:volumePBox[2];
+                volumeBBox[3] = 
+                    ghost_bound[3] ? (X[nX]+X[nX-1])/2. : volumePBox[3];
+                volumeBBox[4] = 
+                    ghost_bound[4] ? (Y[nY]+Y[nY-1])/2. : volumePBox[4];
+                volumeBBox[5] = 
+                    ghost_bound[5] ? (Z[nZ]+Z[nZ-1])/2. : volumePBox[5];
+            }
+            else {
+                volumeBBox[0] = ghost_bound[0] ? X[1] : volumePBox[0];
+                volumeBBox[1] = ghost_bound[1] ? Y[1] : volumePBox[1];
+                volumeBBox[2] = ghost_bound[2] ? Z[1] : volumePBox[2];
+                volumeBBox[3] = ghost_bound[3] ? X[nX-2] : volumePBox[3];
+                volumeBBox[4] = ghost_bound[4] ? Y[nY-2] : volumePBox[4];
+                volumeBBox[5] = ghost_bound[5] ? Z[nZ-2] : volumePBox[5];
+            }
+            ospout << "[avtOSPRayVoxelExtractor] patch data position:" 
+                   << " " << volumePBox[0]
+                   << " " << volumePBox[1]
+                   << " " << volumePBox[2]
+                   << " |"
+                   << " " << volumePBox[3]
+                   << " " << volumePBox[4]
+                   << " " << volumePBox[5]
+                   << std::endl;  
+            ospout << "[avtOSPRayVoxelExtractor] patch data bbox:" 
+                   << " " << volumeBBox[0]
+                   << " " << volumeBBox[1]
+                   << " " << volumeBBox[2]
+                   << " |"
+                   << " " << volumeBBox[3]
+                   << " " << volumeBBox[4]
+                   << " " << volumeBBox[5]
+                   << std::endl; 
+        }
+        // Create volume and model
+        {
+            StackTimer t2("avtOSPRayVoxelExtractor::"
+                          "ExtractWorldSpaceGridOSPRay "
+                          "OSPRay Create Volume");
+            ospray->SetupPatch(patch, volumeDataType,
+			       (size_t)nX * (size_t)nY * (size_t)nZ,
+			       volumePointer, X, Y, Z, nX, nY, nZ,
+			       volumePBox, volumeBBox);
+        }
+        // Render Volume
+        {
+            StackTimer t2("avtOSPRayVoxelExtractor::"
+                          "ExtractWorldSpaceGridOSPRay "
+                          "OSPRay Render Volume");
+            if ((scalarRange[1] >= tFVisibleRange[0]) &&
+                (scalarRange[0] <= tFVisibleRange[1])) {
+                ospray->RenderPatch(patch, xMin, xMax, yMin, yMax,
+				    imgWidth, imgHeight, finalImage);
+                drawn = 1;
+                
+            }
+        }
+    }
+
+    //=======================================================================//
+    // Send rays
+    //=======================================================================//
+    imgDims[0] = imgWidth;
+    imgDims[1] = imgHeight;
+    imgLowerLeft[0] = xMin;
+    imgLowerLeft[1] = yMin;
+    imgUpperRight[0] = xMax; 
+    imgUpperRight[1] = yMax;
+
+    //=======================================================================//
+    // Deallocate memory if not used
+    //=======================================================================//
+    if (drawn == 0)
+    { 
+        if (finalImage != NULL) 
+        { 
+            delete []finalImage; finalImage = NULL; 
+        } 
+    }
+}
+
+
+// ****************************************************************************
+//  Method: avtSLIVRVoxelExtractor::getImageDimensions
+//
+//  Purpose:
+//      Transfers the metadata of the patch
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 14, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRayVoxelExtractor::GetImageDimensions(int &inUse, int dims[2],
+                                            int screen_ll[2],
+                                            int screen_ur[2],
+                                            float &eyeDepth,
+                                            float &clipDepth)
+{
+    inUse = drawn;
+    dims[0] = imgDims[0];
+    dims[1] = imgDims[1];
+    screen_ll[0] = imgLowerLeft[0];
+    screen_ll[1] = imgLowerLeft[1];
+    screen_ur[0] = imgUpperRight[0];
+    screen_ur[1] = imgUpperRight[1];
+    eyeDepth  = eyeSpaceDepth;
+    clipDepth = clipSpaceDepth;
+}
+
+// ****************************************************************************
+//  Method: avtSLIVRVoxelExtractor::getComputedImage
+//
+//  Purpose:
+//      Allocates space to the pointer address and copy the image generated
+//      to it
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 14, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRayVoxelExtractor::GetComputedImage(float *image)
+{
+    memcpy(image, finalImage, imgDims[0]*4*imgDims[1]*sizeof(float));
+    if (finalImage != NULL)
+        delete []finalImage;
+    finalImage = NULL;
+}
diff --git a/avt/Filters/avtOSPRayVoxelExtractor.h b/avt/Filters/avtOSPRayVoxelExtractor.h
new file mode 100644
index 000000000..2533d4a3e
--- /dev/null
+++ b/avt/Filters/avtOSPRayVoxelExtractor.h
@@ -0,0 +1,184 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                            avtOSPRayVoxelExtractor.h                      //
+// ************************************************************************* //
+
+#ifndef AVT_OSPRAY_VOXEL_EXTRACTOR_H
+#define AVT_OSPRAY_VOXEL_EXTRACTOR_H
+
+#include <filters_exports.h>
+
+#include <avtVoxelExtractor.h>
+#include <avtOSPRayCommon.h>
+#include <avtOpacityMap.h>
+
+#include <DebugStream.h>
+
+#include <vtkMatrix3x3.h>
+#include <vtkMatrix4x4.h>
+#include <vtkCamera.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <algorithm>
+
+class     vtkRectilinearGrid;
+class     vtkMatrix4x4;
+
+// ****************************************************************************
+//  Class: avtOSPRayVoxelExtractor
+//
+//  Purpose:
+//      Extracts sample points from a collection of voxels.  It assumes that 
+//      the voxels it has been given are in camera space and does not try to
+//      populate points that are not in the cube [-1, 1], [-1, 1], [-1, 1].
+//
+//  Programmer: Hank Childs
+//  Creation:   December 14, 2003
+//
+//  Modifications:
+//
+//    Hank Childs, Thu Feb  5 17:11:06 PST 2004
+//    Moved inlined constructor and destructor definitions to .C files
+//    because certain compilers have problems with them.
+//
+//    Hank Childs, Fri Nov 19 14:50:58 PST 2004
+//    Added support for accepting grids that need to do a world space to
+//    image space conversion as well.  Also changed API to AVTFILTERS_API.
+//
+//    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
+//    Added support for rectilinear grids with an inherent transform.
+//
+//    Hank Childs, Fri Jun  1 15:28:14 PDT 2007
+//    Added support for non-scalars.
+//
+//    Hank Childs, Wed Aug 27 11:24:53 PDT 2008
+//    Add support for non-floats.
+//
+//    Hank Childs, Wed Dec 24 11:24:47 PST 2008
+//    Remove data member ProportionSpaceToZBufferSpace, as we now do our
+//    sampling in even intervals (wbuffer).
+//
+//    Kathleen Biagas, Fri Jul 13 09:44:45 PDT 2012
+//    Use double internally instead of float.
+//
+//    Qi Wu, Sun Jul 1 2018
+//    Added support for ospray volume rendering.
+//
+// ****************************************************************************
+using namespace ospray;
+class AVTFILTERS_API avtOSPRayVoxelExtractor : public avtVoxelExtractor
+{
+  public:
+                     avtOSPRayVoxelExtractor(int, int, int, avtVolume *,
+                                            avtCellList *);
+    virtual         ~avtOSPRayVoxelExtractor();
+
+    void             Extract(vtkRectilinearGrid *,
+                             std::vector<std::string> &varnames,
+                             std::vector<int> &varsize);
+
+    // void             SetVariableInformation(std::vector<std::string> &names,
+    //                                         std::vector<int> varsize);
+
+    void             SetProcIdPatchID(int c, int p)   { proc = c; patch = p; };
+    void             SetOSPRay(OSPVisItContext* o)        { ospray_core = o; };
+    void             SetViewInfo(const avtViewInfo & v)      { viewInfo = v; };
+    void             SetSamplingRate(double r)           { samplingRate = r; };
+    void             SetRenderingExtents(int extents[4]) 
+    {
+	renderingExtents[0] = extents[0];
+	renderingExtents[1] = extents[1];
+	renderingExtents[2] = extents[2];	
+	renderingExtents[3] = extents[3];
+    };
+    void             SetMVPMatrix(vtkMatrix4x4 *mvp)
+    {
+	model_to_screen_transform->DeepCopy(mvp); 
+	vtkMatrix4x4::Invert(model_to_screen_transform, 
+			     screen_to_model_transform); 
+    };
+    void             SetScalarRange(double r[2])
+    {
+	scalarRange[0] = r[0];
+	scalarRange[1] = r[1];
+    };
+    void             SetTFVisibleRange(double r[2])
+    {
+	tFVisibleRange[0] = r[0];
+	tFVisibleRange[1] = r[1];
+    };
+    void             GetImageDimensions(int&,int dims[2],int screen_ll[2],
+					int screen_ur[2],float &, float &);
+    void             GetComputedImage(float *image);
+
+  protected:
+    // the output image
+    float           *finalImage;
+    // some meta information
+    bool             drawn;  // whether the patch is drawn or not
+    int              patch;  // id of the patch
+    int              proc;   // id of the processor
+    // fields
+    avtViewInfo      viewInfo;
+    OSPVisItContext *ospray_core;    
+    double           samplingRate;    
+    int              renderingExtents[4];
+    // matrix
+    vtkMatrix4x4    *model_to_screen_transform;
+    vtkMatrix4x4    *screen_to_model_transform;
+    // others
+    double           scalarRange[2];
+    double           tFVisibleRange[2];
+    int              imgWidth;
+    int              imgHeight;
+    int              imgDims[2];       // size of the patch
+    int              imgLowerLeft[2];  // coordinates in the whole image
+    int              imgUpperRight[2]; // coordinates in the whole image
+    float            eyeSpaceDepth;    // for blending patches
+    float            clipSpaceDepth;   // clip space depth for blending with bg
+    int              xMin, xMax, yMin, yMax;
+
+    void             ExtractWorldSpaceGridOSPRay(vtkRectilinearGrid *,  
+                                   std::vector<std::string> &varnames,
+                                           std::vector<int> &varsize);
+};
+
+#endif
diff --git a/avt/Filters/avtSLIVRCommon.C b/avt/Filters/avtSLIVRCommon.C
new file mode 100644
index 000000000..fba43591d
--- /dev/null
+++ b/avt/Filters/avtSLIVRCommon.C
@@ -0,0 +1,38 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+#include <avtSLIVRCommon.h>
diff --git a/avt/Filters/avtSLIVRCommon.h b/avt/Filters/avtSLIVRCommon.h
new file mode 100644
index 000000000..641ae817c
--- /dev/null
+++ b/avt/Filters/avtSLIVRCommon.h
@@ -0,0 +1,138 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+#ifndef AVT_SLIVR_COMMON_H
+#define AVT_SLIVR_COMMON_H
+#include <stdio.h>
+#include <string>
+#include <iostream>
+
+// ****************************************************************************
+//  Struct:  imgMetaData
+//
+//  Purpose:
+//    Holds information about patches but not the image 
+//
+//  Programmer:  
+//  Creation:   
+//
+// ****************************************************************************
+struct imgMetaData
+{
+    int procId;       // processor that produced the patch
+    int patchNumber;  // id of the patch on that processor - with procId, acts as a key
+
+    int destProcId;   // destination proc where this patch gets composited
+
+    int inUse;   // whether the patch is composed locally or not
+    int dims[2];      // height, width
+    int screen_ll[2]; // position in the final image
+    int screen_ur[2];
+
+    float avg_z;        // camera space z = depth of the patch - used for compositing
+    float eye_z;        // camera space z
+    float clip_z;       // clip space z
+};
+
+
+// ****************************************************************************
+//  Struct:  imgData
+//
+//  Purpose:
+//    Holds the image data generated
+//
+//  Programmer:  
+//  Creation:    
+//
+// ****************************************************************************
+struct imgData
+{
+    int procId;         // processor that produced the patch
+    int patchNumber;    // id of the patch on that processor  - with procId, acts as a key
+
+    float *imagePatch;  // the image data - RGBA
+
+    bool operator==(const imgData &a){
+        return (patchNumber == a.patchNumber);
+    }
+};
+
+
+// ****************************************************************************
+//  Struct:  convexHull
+//
+//  Purpose:
+//    Holds the image data generated
+//
+//  Programmer:  
+//  Creation:    
+//
+// ****************************************************************************
+struct convexHull
+{
+    int numPatches;
+    int arrangement[3];     // [0] rows along x axis, [1] rows along y axis, [2] rows along z axis
+
+    float extents[6];       // minX, maxX   minY, maxY   minZ, maxZ
+    float cellDims[3];      // x, y, z
+    float tolerance;        // amount of overlap that is considered ok - typically 2 cells for cell centered data
+
+
+    // 0: no overlap    1: overlpa in Z    2: overlap in Y    3: overlap in Z
+    int overlap(convexHull _hull)
+    {
+
+        if ( (_hull.extents[1] < extents[0]) || (_hull.extents[0] > extents[1]) )   // No overlap in X
+        {
+            if ( (_hull.extents[3] < extents[2]) || (_hull.extents[2] > extents[3]) )   // No overlap in Y
+            {
+                if ( (_hull.extents[5] < extents[4]) || (_hull.extents[4] > extents[5]) )   // No overlap in Z
+                {
+                    return 0;
+                }
+                else
+                    return 3;
+            }
+            else
+                return 2;
+        }
+        else
+            return 1;
+    }
+};
+
+#endif
diff --git a/avt/Filters/avtSLIVRImageCompositor.C b/avt/Filters/avtSLIVRImageCompositor.C
new file mode 100644
index 000000000..fc7cfd12a
--- /dev/null
+++ b/avt/Filters/avtSLIVRImageCompositor.C
@@ -0,0 +1,1651 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                         avtSLIVRImageCompositor.C                         //
+// ************************************************************************* //
+
+#include <avtParallel.h>
+#include <avtSLIVRImageCompositor.h>
+#include <ImproperUseException.h>
+#include <DebugStream.h>
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>     /* srand, rand */
+#include <time.h>       /* time */
+
+#include <algorithm>
+#include <cmath>
+#include <fstream>
+#include <limits>
+#include <set>
+
+#if defined (_MSC_VER) && (_MSC_VER < 1800) && !defined(round)
+inline double round(double x) {return (x-floor(x)) > 0.5 ? ceil(x) : floor(x);}
+#endif
+
+enum blendDirection {FRONT_TO_BACK = 0, BACK_TO_FRONT = 1};
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::avtSLIVRImageCompositor
+//
+//  Purpose: Constructor
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+avtSLIVRImageCompositor::avtSLIVRImageCompositor()
+{
+  #ifdef PARALLEL
+    MPI_Comm_size(VISIT_MPI_COMM, &num_procs);
+    MPI_Comm_rank(VISIT_MPI_COMM, &my_id);
+
+  #else
+    num_procs = 1;
+    my_id = 0;
+  #endif
+
+    totalPatches = 0;
+
+    intermediateImage = NULL;
+    imgBuffer = NULL;
+
+    for (int i=0; i<4; i++)
+    {
+        intermediateImageExtents[i] = 0;
+        intermediateImageBB[i] = 0;
+    }
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::~avtSLIVRImageCompositor
+//
+//  Purpose:
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+avtSLIVRImageCompositor::~avtSLIVRImageCompositor()
+{
+    if (my_id == 0)
+    {
+        if (imgBuffer != NULL)
+            delete []imgBuffer;
+    }
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//    Barrier, useful for debugging
+//
+//  Programmer: Pascal Grosset
+//  Creation: July 2013
+//
+//  Modifications:
+//
+// ****************************************************************************
+void avtSLIVRImageCompositor::barrier(){
+  #ifdef PARALLEL
+    MPI_Barrier( MPI_COMM_WORLD );
+  #endif
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::getcompositedImage
+//
+//  Purpose:
+//      Returns the whole image if needed
+//
+//  Programmer: Pascal Grosset
+//  Creation: July 2013
+//
+//  Modifications:
+//
+// ****************************************************************************
+void avtSLIVRImageCompositor::getcompositedImage(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage)
+{
+    for (int i=0; i< imgBufferHeight; i++)
+        for (int j=0; j<imgBufferWidth; j++){
+            int bufferIndex = (imgBufferWidth*4*i) + (j*4);
+            int wholeImgIndex = (imgBufferWidth*3*i) + (j*3);
+
+            wholeImage[wholeImgIndex+0] = (imgBuffer[bufferIndex+0] ) * 255;
+            wholeImage[wholeImgIndex+1] = (imgBuffer[bufferIndex+1] ) * 255;
+            wholeImage[wholeImgIndex+2] = (imgBuffer[bufferIndex+2] ) * 255;
+        }
+
+    if (imgBuffer != NULL)
+        delete []imgBuffer;
+    imgBuffer = NULL;
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//       Fills an image with a specific color
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+void
+avtSLIVRImageCompositor::colorImage(float *& srcImage, int widthSrc, int heightSrc, float _color[4])
+{
+    for (int _y=0; _y<heightSrc; _y++)
+        for (int _x=0; _x<widthSrc; _x++)
+        {
+            int srcIndex = widthSrc*_y*4 + _x*4;
+
+            srcImage[srcIndex+0] = _color[0];
+            srcImage[srcIndex+1] = _color[1];
+            srcImage[srcIndex+2] = _color[2];
+            srcImage[srcIndex+3] = _color[3];
+        }
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::placeInImage
+//
+//  Purpose:
+//      Puts srcImage into dstImage
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+void
+avtSLIVRImageCompositor::placeInImage(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
+{
+    int widthSrc, heightSrc, widthDst;
+    widthSrc  = srcExtents[1] - srcExtents[0];
+    heightSrc = srcExtents[3] - srcExtents[2];
+
+    widthDst  = dstExtents[1] - dstExtents[0];
+
+    for (int _y=0; _y<heightSrc; _y++)
+        for (int _x=0; _x<widthSrc; _x++)
+        {
+            int startingX = srcExtents[0];
+            int startingY = srcExtents[2];
+
+            int srcIndex = widthSrc*_y*4 + _x*4;                                                                  // index in the subimage
+            int dstIndex = ( (startingY+_y - dstExtents[2])*widthDst*4  + (startingX+_x - dstExtents[0])*4 );     // index in the big buffer
+
+            dstImage[dstIndex+0] = srcImage[srcIndex+0];
+            dstImage[dstIndex+1] = srcImage[srcIndex+1];
+            dstImage[dstIndex+2] = srcImage[srcIndex+2];
+            dstImage[dstIndex+3] = srcImage[srcIndex+3];
+        }
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::blendWithBackground
+//
+//  Purpose:
+//      Blends _image with the backgroundColor
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::blendWithBackground(float *_image, int extents[4], float backgroundColor[4])
+{
+    int numPixels = (extents[3]-extents[2]) * (extents[1]-extents[0]);
+
+    for (int index=0; index<numPixels; index++)      // estimated potential speedup: 2.240
+    {
+        int indexSrc = index*4;
+        float alpha = (1.0 - _image[indexSrc+3]);
+
+        _image[indexSrc+0] = backgroundColor[0] * alpha +  _image[indexSrc+0];
+        _image[indexSrc+1] = backgroundColor[1] * alpha +  _image[indexSrc+1];
+        _image[indexSrc+2] = backgroundColor[2] * alpha +  _image[indexSrc+2];
+        _image[indexSrc+3] = backgroundColor[3] * alpha +  _image[indexSrc+3];
+    }
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//      Blends tow patches in a front to back manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::blendFrontToBack(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4])
+{
+    int widthSrc, heightSrc, widthDst;
+    widthSrc  = srcExtents[1] - srcExtents[0];
+    heightSrc = srcExtents[3] - srcExtents[2];
+
+    widthDst  = dstExtents[1] - dstExtents[0];
+
+    #if defined(VISIT_THREADS)
+    #endif
+
+    for (int _y=blendExtents[2]; _y<blendExtents[3]; _y++)
+        for (int _x=blendExtents[0]; _x<blendExtents[1]; _x++)
+        {
+
+            int srcIndex = (_y-srcExtents[2]) * widthSrc * 4 + (_x-srcExtents[0]) * 4;
+            int dstIndex = (_y-dstExtents[2]) * widthDst * 4 + (_x-dstExtents[0]) * 4;
+
+            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
+            float alpha = 1.0 - dstImage[dstIndex+3];
+            dstImage[dstIndex+0] = clamp( (srcImage[srcIndex+0] * alpha) + dstImage[dstIndex+0] );
+            dstImage[dstIndex+1] = clamp( (srcImage[srcIndex+1] * alpha) + dstImage[dstIndex+1] );
+            dstImage[dstIndex+2] = clamp( (srcImage[srcIndex+2] * alpha) + dstImage[dstIndex+2] );
+            dstImage[dstIndex+3] = clamp( (srcImage[srcIndex+3] * alpha) + dstImage[dstIndex+3] );
+        }
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//      Blends tow patches in a back to front manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::blendBackToFront(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4])
+{
+    int widthSrc, heightSrc, widthDst;
+    widthSrc  = srcExtents[1] - srcExtents[0];
+    heightSrc = srcExtents[3] - srcExtents[2];
+
+    widthDst  = dstExtents[1] - dstExtents[0];
+
+    for (int _y=blendExtents[2]; _y<blendExtents[3]; _y++)
+        for (int _x=blendExtents[0]; _x<blendExtents[1]; _x++)
+        {
+
+            int srcIndex = (_y-srcExtents[2]) * widthSrc * 4 + (_x-srcExtents[0]) * 4;
+            int dstIndex = (_y-dstExtents[2]) * widthDst * 4 + (_x-dstExtents[0]) * 4;
+
+            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
+            float alpha = 1.0 - srcImage[srcIndex+3];
+            dstImage[dstIndex+0] = clamp( (dstImage[dstIndex+0] * alpha) + srcImage[srcIndex+0] );
+            dstImage[dstIndex+1] = clamp( (dstImage[dstIndex+1] * alpha) + srcImage[srcIndex+1] );
+            dstImage[dstIndex+2] = clamp( (dstImage[dstIndex+2] * alpha) + srcImage[srcIndex+2] );
+            dstImage[dstIndex+3] = clamp( (dstImage[dstIndex+3] * alpha) + srcImage[srcIndex+3] );
+        }
+}
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//      Blends tow patches in a front to back manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::blendFrontToBack(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
+{
+    int widthSrc, heightSrc, widthDst;
+    widthSrc  = srcExtents[1] - srcExtents[0];
+    heightSrc = srcExtents[3] - srcExtents[2];
+
+    widthDst  = dstExtents[1] - dstExtents[0];
+
+    for (int _y=0; _y<heightSrc; _y++)
+        for (int _x=0; _x<widthSrc; _x++)
+        {
+            int startingX = srcExtents[0];
+            int startingY = srcExtents[2];
+
+            if ((startingX + _x) > dstExtents[1])
+                continue;
+
+            if ((startingY + _y) > dstExtents[3])
+                continue;
+
+            int srcIndex = widthSrc*_y*4 + _x*4;                                                                  // index in the subimage
+            int dstIndex = ( (startingY+_y - dstExtents[2])*widthDst*4  + (startingX+_x - dstExtents[0])*4 );     // index in the big buffer
+
+            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
+            float alpha = 1.0 - dstImage[dstIndex+3];
+            dstImage[dstIndex+0] = clamp( (srcImage[srcIndex+0] * alpha) + dstImage[dstIndex+0] );
+            dstImage[dstIndex+1] = clamp( (srcImage[srcIndex+1] * alpha) + dstImage[dstIndex+1] );
+            dstImage[dstIndex+2] = clamp( (srcImage[srcIndex+2] * alpha) + dstImage[dstIndex+2] );
+            dstImage[dstIndex+3] = clamp( (srcImage[srcIndex+3] * alpha) + dstImage[dstIndex+3] );
+        }
+}
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//      Blends tow patches in a back to front manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::blendBackToFront(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
+{
+    int widthSrc, heightSrc, widthDst;
+    widthSrc  = srcExtents[1] - srcExtents[0];
+    heightSrc = srcExtents[3] - srcExtents[2];
+
+    widthDst  = dstExtents[1] - dstExtents[0];
+
+    for (int _y=0; _y<heightSrc; _y++)
+        for (int _x=0; _x<widthSrc; _x++)
+        {
+            int startingX = srcExtents[0];
+            int startingY = srcExtents[2];
+
+            if ((startingX + _x) > dstExtents[1])
+                continue;
+
+            if ((startingY + _y) > dstExtents[3])
+                continue;
+
+            int srcIndex = widthSrc*_y*4 + _x*4;                                                                  // index in the subimage
+            int dstIndex = ( (startingY+_y - dstExtents[2])*widthDst*4  + (startingX+_x - dstExtents[0])*4 );     // index in the big buffer
+
+            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
+            float alpha = 1.0 - srcImage[srcIndex+3];
+            dstImage[dstIndex+0] = clamp( (dstImage[dstIndex+0] * alpha) + srcImage[srcIndex+0] );
+            dstImage[dstIndex+1] = clamp( (dstImage[dstIndex+1] * alpha) + srcImage[srcIndex+1] );
+            dstImage[dstIndex+2] = clamp( (dstImage[dstIndex+2] * alpha) + srcImage[srcIndex+2] );
+            dstImage[dstIndex+3] = clamp( (dstImage[dstIndex+3] * alpha) + srcImage[srcIndex+3] );
+        }
+}
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::regionAllocation
+//
+//  Purpose:
+//      Arbitrarily allocates regions to MPI ranks
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+void
+avtSLIVRImageCompositor::regionAllocation(int numMPIRanks, int *& regions)
+{
+    regions = new int[numMPIRanks];
+
+    // Initial allocation: partition for section rank
+    for (int i=0; i<numMPIRanks; i++)
+        regions[i] = i;
+}
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::updateBoundingBox(int currentBoundingBox[4], int imageExtents[4])
+{
+    if ( (currentBoundingBox[0] == 0 && currentBoundingBox[1] == 0) && (currentBoundingBox[2] == 0 && currentBoundingBox[3] == 0))
+    {
+        currentBoundingBox[0]=imageExtents[0];
+        currentBoundingBox[1]=imageExtents[1];
+        currentBoundingBox[2]=imageExtents[2];
+        currentBoundingBox[3]=imageExtents[3];
+
+        return;
+    }
+
+    if (imageExtents[0] < currentBoundingBox[0])
+        currentBoundingBox[0] = imageExtents[0];
+
+    if (imageExtents[2] < currentBoundingBox[2])
+        currentBoundingBox[2] = imageExtents[2];
+
+    if (imageExtents[1] > currentBoundingBox[1])
+        currentBoundingBox[1] = imageExtents[1];
+
+    if (imageExtents[3] > currentBoundingBox[3])
+        currentBoundingBox[3] = imageExtents[3];
+}
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::gatherDepthAtRoot
+//
+//  Purpose:
+//      Used by Serial Direct Send
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::gatherDepthAtRoot(int numlocalPatches, float *localPatchesDepth, int &totalPatches, int *& patchCountPerRank, float *& allPatchesDepth)
+{
+  #ifdef PARALLEL
+    //
+    // Get how many patches are coming from each MPI rank
+    totalPatches = 0;
+    int *patchesOffset = NULL;
+
+
+    if (my_id == 0) // root!
+        patchCountPerRank = new int[num_procs]();
+
+    MPI_Gather(&numlocalPatches, 1, MPI_INT,   patchCountPerRank, 1, MPI_INT,    0, MPI_COMM_WORLD);
+
+
+    //
+    // Gather number of patch group
+    if (my_id == 0)
+    {
+        patchesOffset = new int[num_procs]();
+        patchesOffset[0] = 0;
+
+        for (int i=0; i<num_procs; i++)
+        {
+            totalPatches += patchCountPerRank[i];
+
+            if (i == 0)
+                patchesOffset[i] = 0;
+            else
+                patchesOffset[i] = patchesOffset[i-1] + patchCountPerRank[i-1];
+        }
+
+        allPatchesDepth = new float[totalPatches];
+    }
+
+    MPI_Gatherv(localPatchesDepth, numlocalPatches, MPI_FLOAT,   allPatchesDepth, patchCountPerRank, patchesOffset,    MPI_FLOAT, 0, MPI_COMM_WORLD);
+
+    //
+    // Cleanup
+    if (my_id == 0)
+        if (patchesOffset != NULL)
+            delete []patchesOffset;
+
+    patchesOffset = NULL;
+  #endif
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::serialDirectSend
+//
+//  Purpose:
+//      A very simple compositing that we can fall back to if Parallel direct send is buggy.
+//      Works with convex patches though
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::serialDirectSend(int numPatches, float *localPatchesDepth, int *extents, float *imgData, float backgroundColor[4], int width, int height)
+{
+  #ifdef PARALLEL
+    //debug5 << "serialDirectSend" << std::endl;
+
+    float *recvImage = NULL;
+
+    int tags[2] = {5781, 5782};
+
+    int totalPatches;
+    int *patchCountPerRank = NULL;
+    float *patchesDepth = NULL;
+    gatherDepthAtRoot(numPatches, localPatchesDepth, totalPatches, patchCountPerRank, patchesDepth);
+
+    if (my_id == 0)
+    {
+        //
+        // Root
+        int srcSize[2], srcPos[2], dstSize[2], dstPos[2];
+        srcSize[0] = width;  srcSize[1] = height;
+        srcPos[0] = 0;       srcPos[1] = 0;
+
+        //
+        // Sort patches we will receive
+        std::multimap<float,int> depthRankPatches;
+
+        int index = 0;
+        for (int i=0; i<num_procs; i++)
+            for (int j=0; j<patchCountPerRank[i]; j++)
+            {
+                depthRankPatches.insert( std::pair<float,int>(patchesDepth[index],i) );
+                index++;
+            }
+
+
+        //
+        // Create space for buffers
+        int recvParams[4];                          // minX, maxX, minY, maxY
+        int imgExtents[4];
+        imgExtents[0] = 0;  imgExtents[1] = width;
+        imgExtents[2] = 0;  imgExtents[3] = height;
+
+        recvImage = new float[width*height*4]();
+        imgBuffer = new float[width*height*4]();
+
+        int localIndex = 0;
+
+        //
+        // Compositing
+        for (std::multimap<float,int>::iterator it=depthRankPatches.begin(); it!=depthRankPatches.end(); ++it)
+        {
+            int rank = (*it).second;
+
+            //debug5 << "\nRecv and blend from " << rank << " depth: " << (*it).first << std::endl;
+
+            if (rank != my_id)
+            {
+                MPI_Recv(recvParams,             4, MPI_INT,   rank, tags[0],  MPI_COMM_WORLD, MPI_STATUS_IGNORE);  // recv image info
+                MPI_Recv(recvImage, width*height*4, MPI_FLOAT, rank, tags[1],  MPI_COMM_WORLD, MPI_STATUS_IGNORE);  // recv image
+
+                dstPos[0]  = dstPos[0];                      dstPos[1]  = dstPos[1];
+                dstSize[0] = recvParams[2]-recvParams[0];    dstSize[1] = recvParams[3]-recvParams[1];
+            }
+            else
+            {
+                // It's local
+                recvParams[0] = extents[ localIndex*4 + 0];
+                recvParams[1] = extents[ localIndex*4 + 1];
+                recvParams[2] = extents[ localIndex*4 + 2];
+                recvParams[3] = extents[ localIndex*4 + 3];
+
+                recvImage = &imgData[ localIndex*(width*height*4) ];
+                localIndex++;
+            }
+
+            blendFrontToBack(recvImage, recvParams, imgBuffer, imgExtents);
+        }
+        blendWithBackground(imgBuffer, imgExtents, backgroundColor);
+
+        //writeArrayToPPM("/home/pascal/Desktop/debugImages/full_with back_" + toStr(__index), imgBuffer, imgExtents[1]-imgExtents[0], imgExtents[3]-imgExtents[2]);
+    }
+    else
+    {
+        //
+        // Sender
+        for (int i=0; i<numPatches; i++)
+        {
+            int imgSize = (extents[i*4 + 1] - extents[i*4 + 0]) * (extents[i*4 + 3] - extents[i*4 + 2]) * 4;
+
+            if (imgSize > 0)
+            {
+                //debug5 << "Sending: Extents " <<  extents[i*4 + 0] << ", " << extents[i*4 + 1] << ", " << extents[i*4 + 2] << ", " << extents[i*4 + 3] << std::endl;
+                //writeArrayToPPM("/home/pascal/Desktop/debugImages/sending_to_root_from_" + toStr(my_id), &imgData[i*(width*height*4)], (extents[i*4 + 1] - extents[i*4 + 0]), (extents[i*4 + 3] - extents[i*4 + 2]) );
+
+                MPI_Send( &extents[i*4],                       4, MPI_INT,   0, tags[0], MPI_COMM_WORLD);
+                MPI_Send( &imgData[i*(width*height*4)],  imgSize, MPI_FLOAT, 0, tags[1], MPI_COMM_WORLD);
+            }
+        }
+    }
+
+    //debug5 << "Free memory" << std::endl;
+
+    //
+    // Cleanup
+    if (patchesDepth != NULL)
+      delete []patchesDepth;
+
+    if (patchCountPerRank != NULL)
+        delete []patchCountPerRank;
+
+    if (recvImage != NULL)
+        delete []recvImage;
+
+    recvImage = NULL;
+    patchCountPerRank = NULL;
+    patchesDepth = NULL;
+
+  #endif
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::parallelDirectSend
+//
+//  Purpose:
+//      Parallel Direct Send rendering that can blend convex patches from each MPI rank.
+//      However, since we are not guaranteed to have convex patches. It's not used.
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::parallelDirectSend(float *imgData, int imgExtents[4], int region[], int numRegions, int tags[2], int fullImageExtents[4])
+{
+  #ifdef PARALLEL
+    //
+    // Determine position in region (myPositionInRegion)
+    int width =  fullImageExtents[1]-fullImageExtents[0];
+    int height = fullImageExtents[3]-fullImageExtents[2];
+
+    //debug5 << "fullImageExtents: " << fullImageExtents[0] << ", " << fullImageExtents[1] << "   " << fullImageExtents[2] << ", " << fullImageExtents[3] << endl;
+
+    compositingDone = false;
+    int myPositionInRegion = -1;
+    bool inRegion = true;
+    std::vector<int> regionVector(region, region+numRegions);
+    std::vector<int>::iterator it = std::find(regionVector.begin(), regionVector.end(), my_id);
+
+    if (it == regionVector.end())
+    {
+        inRegion = false;
+        //debug5 << my_id << " ~ SHOULD NOT HAPPEN: Not found " << my_id <<  " !!!" << std::endl;
+    }
+    else
+        myPositionInRegion = it - regionVector.begin();
+
+    //
+    // Region boundaries
+    int regionHeight = height/numRegions;
+    int lastRegionHeight = height - regionHeight*(numRegions-1);
+
+    // Extents of my region
+    int myStartingHeight = fullImageExtents[2] + myPositionInRegion * regionHeight;
+    int myEndingHeight = myStartingHeight + regionHeight;
+    if (myPositionInRegion == numRegions-1)
+        myEndingHeight = fullImageExtents[3];
+
+    int myRegionHeight = myEndingHeight-myStartingHeight;
+
+    // Size of one buffer
+    int sizeOneBuffer = std::max(regionHeight,lastRegionHeight) * width * 4;
+
+    //debug5 << "myPositionInRegion: " << myPositionInRegion << std::endl;
+    //debug5 << "My extents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
+    //debug5 << "myRegionHeight: " << myRegionHeight << "  lastRegionHeight: " << lastRegionHeight << " regionHeight: " << regionHeight << "  myStartingHeight: " << myStartingHeight << "  myEndingHeight: " << myEndingHeight << std::endl;
+
+
+    //
+    // MPI Async
+
+    // Recv
+    MPI_Request *recvMetaRq = new MPI_Request[ numRegions-1 ];
+    MPI_Request *recvImageRq = new MPI_Request[ numRegions-1 ];
+
+    MPI_Status *recvMetaSt = new MPI_Status[ numRegions-1 ];
+    MPI_Status *recvImageSt = new MPI_Status[ numRegions-1 ];
+
+    // Send
+    MPI_Request *sendMetaRq = new MPI_Request[ numRegions-1 ];
+    MPI_Request *sendImageRq = new MPI_Request[ numRegions-1 ];
+
+    MPI_Status *sendMetaSt = new MPI_Status[ numRegions-1 ];
+    MPI_Status *sendImageSt = new MPI_Status[ numRegions-1 ];
+
+
+    //
+    // Create Buffers
+
+    // Create buffer for receiving images
+    float *recvDataBuffer;
+    recvDataBuffer = new float[ sizeOneBuffer * numRegions];
+
+    // Create buffer for receiving messages
+    std::vector<int> msgBuffer;
+    msgBuffer.clear();
+    msgBuffer.resize(5 * numRegions);
+
+    // Create buffer for sending messages
+    int *sendExtents = new int[numRegions*5];
+
+    //
+    // Async Recv
+    if (inRegion)
+    {
+        int recvCount=0;
+        for (int i=0; i<numRegions; i++)
+        {
+            if ( regionVector[i] == my_id )
+                continue;
+
+            int src = regionVector[i];
+            MPI_Irecv(&msgBuffer[i*5],                              5, MPI_INT,   src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvCount] );
+            MPI_Irecv(&recvDataBuffer[i*sizeOneBuffer], sizeOneBuffer, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+            recvCount++;
+        }
+    }
+
+    //debug5 << "Async Recv setup done " << std::endl;
+
+    //
+    // Async Send
+    int sendCount = 0;
+    int sendingOffset;
+    for (int i=0; i<numRegions; i++)
+    {
+        int regionStart, regionEnd, imgSize, dest;
+        dest = regionVector[i];
+
+        if ( dest == my_id )
+            continue;
+
+        regionStart = i*regionHeight;
+        regionEnd = regionStart + regionHeight;
+        if (i == numRegions-1) // the last one in region
+            regionEnd = height;
+
+        int startingYExtents = fullImageExtents[2] + regionStart;
+        int endingYExtents = fullImageExtents[2] + regionEnd;
+
+        //debug5 << "startingYExtents: " << startingYExtents <<"   endingYExtents: " << endingYExtents <<  std::endl;
+
+        if (startingYExtents < imgExtents[2])
+            startingYExtents = imgExtents[2];
+
+        if (endingYExtents > imgExtents[3])
+            endingYExtents = imgExtents[3];
+
+        bool hasData = true;
+        if (endingYExtents - startingYExtents <= 0 || imgExtents[1]-imgExtents[0] <= 0)
+        {
+            hasData = false;
+
+            sendingOffset = 0;
+            imgSize = sendExtents[i*5 + 0] = sendExtents[i*5 + 1] = sendExtents[i*5 + 2] = sendExtents[i*5 + 3] =  sendExtents[i*5 + 4] = 0;
+        }
+        else
+        {
+            imgSize = (endingYExtents-startingYExtents) * (imgExtents[1]-imgExtents[0]) * 4;
+            sendingOffset = (startingYExtents-imgExtents[2]) * (imgExtents[1]-imgExtents[0]) * 4;
+
+            sendExtents[i*5 + 0] = imgExtents[0];
+            sendExtents[i*5 + 1] = imgExtents[1];
+            sendExtents[i*5 + 2] = startingYExtents;
+            sendExtents[i*5 + 3] = endingYExtents;
+            sendExtents[i*5 + 4] = 0;
+        }
+
+        //std::cout << my_id << " ~ i: " << i << "   regionVector[index]: " << regionVector[index] << "  extents: " <<  sendExtents[index*5 + 0] << ", " << sendExtents[index*5 + 1]  << ", " << sendExtents[index*5 + 2] << ", " << sendExtents[index*5 + 3] << "  sending ... " << std::endl;
+        MPI_Isend(&sendExtents[i*5],             5,   MPI_INT, dest, tags[0], MPI_COMM_WORLD, &sendMetaRq[sendCount]);
+        MPI_Isend(&imgData[sendingOffset], imgSize, MPI_FLOAT, dest, tags[1], MPI_COMM_WORLD, &sendImageRq[sendCount]);
+
+        //debug5 << "dest: " << dest <<"   sendExtents: " << sendExtents[i*5 +0] << ", " << sendExtents[i*5 +1] << "    " << sendExtents[i*5 +2] << ", " << sendExtents[i*5 +3] << std::endl << std::endl;
+
+        sendCount++;
+    }
+
+    //debug5 << "Async Recv" << std::endl;
+
+    //
+    // Create buffer for region
+    intermediateImageExtents[0] = fullImageExtents[0];  intermediateImageExtents[1] = fullImageExtents[1];
+    intermediateImageExtents[2] = myStartingHeight;     intermediateImageExtents[3] = myEndingHeight;
+
+    intermediateImage = new float[width * (myEndingHeight-myStartingHeight) * 4]();
+
+    int recvImageExtents[4];
+    float *recvImageData;
+
+    //
+    // Blend
+    int numBlends = 0;
+    int countBlend = 0;
+
+    intermediateImageBB[0] = intermediateImageBB[2] = 0;
+    intermediateImageBB[1] = intermediateImageBB[3] = 0;
+
+    if (inRegion)
+    {
+        for (int i=0; i<numRegions; i++)
+        {
+            int index = i;
+
+            //debug5 << "regionVector[" << i << "] " << regionVector[index] << std::endl;
+
+            if (regionVector[index] == my_id)
+            {
+                int startingYExtents = myStartingHeight;
+                int endingYExtents = myEndingHeight;
+
+                if (startingYExtents < imgExtents[2])
+                    startingYExtents = imgExtents[2];
+
+                if (endingYExtents > imgExtents[3])
+                    endingYExtents = imgExtents[3];
+
+
+                bool hasData = true;
+                if (endingYExtents - startingYExtents <= 0)
+                {
+                    hasData = false;
+                    endingYExtents = startingYExtents = 0;
+                }
+
+                if (hasData == true)
+                {
+                    int extentsSectionRecv[4];
+                    extentsSectionRecv[0] = imgExtents[0];
+                    extentsSectionRecv[1] = imgExtents[1];
+                    extentsSectionRecv[2] = startingYExtents;
+                    extentsSectionRecv[3] = endingYExtents;
+
+                    blendFrontToBack(imgData, imgExtents, extentsSectionRecv, intermediateImage, intermediateImageExtents);
+                    //debug5 << "Blend with: " << regionVector[index]  << "  extentsSectionRecv: " << extentsSectionRecv[0] << ", " << extentsSectionRecv[1] << "    " << extentsSectionRecv[2] << ", " << extentsSectionRecv[3] << ", "  << std::endl;
+                    //writeArrayToPPM("/home/pascal/Desktop/debugImages/composited_AFTER_recv_from_" + toStr(regionVector[index]) + "_at_" + toStr(my_id), intermediateImage, intermediateImageExtents[1]-intermediateImageExtents[0], intermediateImageExtents[3]-intermediateImageExtents[2]);
+
+
+                    updateBoundingBox(intermediateImageBB, extentsSectionRecv);
+                    numBlends++;
+                }
+            }
+            else
+            {
+                MPI_Wait(&recvMetaRq[countBlend], &recvMetaSt[countBlend]);
+
+                for (int j=0; j<4; j++)
+                    recvImageExtents[j] = msgBuffer[index*5 + j];
+
+                bool hasData =  false;
+                if (recvImageExtents[1]-recvImageExtents[0] > 0 && recvImageExtents[3]-recvImageExtents[2] > 0)
+                {
+                    hasData = true;
+                    MPI_Wait(&recvImageRq[countBlend], &recvImageSt[countBlend]);
+                    recvImageData = &recvDataBuffer[index*sizeOneBuffer];
+                }
+
+                if (hasData)
+                {
+
+                    blendFrontToBack(recvImageData, recvImageExtents, intermediateImage, intermediateImageExtents);
+
+                    updateBoundingBox(intermediateImageBB, recvImageExtents);
+                    numBlends++;
+                }
+
+                countBlend++;
+            }
+        }
+    }
+    else
+        compositingDone = true;
+
+    //debug5 << "PDS blending done" << std::endl;
+
+    msgBuffer.clear();
+
+
+    if (recvDataBuffer != NULL)
+        delete []recvDataBuffer;
+    recvDataBuffer = NULL;
+
+
+    if (numBlends == 0)
+        intermediateImageBB[0]=intermediateImageBB[1]=intermediateImageBB[2]=intermediateImageBB[3] = 0;
+
+    delete []recvMetaRq;
+    delete []recvImageRq;
+    delete []recvMetaSt;
+    delete []recvImageSt;
+
+    delete []sendMetaRq;
+    delete []sendImageRq;
+    delete []sendMetaSt;
+    delete []sendImageSt;
+
+    recvMetaRq = NULL;
+    recvImageRq = NULL;
+    recvMetaSt = NULL;
+    recvImageSt = NULL;
+
+    sendMetaRq = NULL;
+    sendImageRq = NULL;
+    sendMetaSt = NULL;
+    sendImageSt = NULL;
+  #endif
+}
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::findRegionsForPatch
+//
+//  Purpose:
+//      Needed by Parallel Direct Send to determine the regions a patch will overlap
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+int
+avtSLIVRImageCompositor::findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to)
+{
+    from = to = 0;
+    if (patchExtents[1]-patchExtents[0] <=0 || patchExtents[3]-patchExtents[2] <=0)
+        return 0;
+
+    if ( patchExtents[0] > screenProjectedExtents[1])
+        return 0;
+
+    if ( patchExtents[1] < screenProjectedExtents[0])
+        return 0;
+
+    if ( patchExtents[2] > screenProjectedExtents[3])
+        return 0;
+
+    if ( patchExtents[3] < screenProjectedExtents[2])
+        return 0;
+
+
+    // find from
+    for (int i=numRegions-1; i>=0; i--)
+        if ( patchExtents[2] >= getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
+        {
+            from = i;
+            break;
+        }
+    
+
+    // find to
+    for (int i=numRegions-1; i>=0; i--)
+        if ( patchExtents[3] > getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
+        {
+            to = i;
+            break;
+        }
+
+    return ( std::max( (to - from) + 1, 0) );
+}
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::computeRegionExtents
+//
+//  Purpose:
+//      Compute extents for each region
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::computeRegionExtents(int numRanks, int height)
+{
+    int regionHeight = round((float)height/numRanks);
+    regularRegionSize = regionHeight;
+    maxRegionHeight = 0;
+    regionRankExtents.resize(numRanks*3);
+    for (int i=0; i<numRanks; i++)
+    {
+        int startRegionExtents, endRegionExtents, _currentRegionHeight;
+
+        startRegionExtents = clamp(regionHeight * i, 0, height);
+        endRegionExtents = clamp(regionHeight * i + regionHeight, 0, height);
+
+        if ( i == numRanks -1 )
+            if ( endRegionExtents < height )
+                endRegionExtents = height;
+
+        _currentRegionHeight = clamp(endRegionExtents-startRegionExtents, 0, height);
+        maxRegionHeight = std::max(maxRegionHeight, _currentRegionHeight);
+
+        regionRankExtents[i*3+0] = startRegionExtents;
+        regionRankExtents[i*3+1] = endRegionExtents;
+        regionRankExtents[i*3+2] = _currentRegionHeight;
+
+        debug5 << i << " : (start, end, region): " << startRegionExtents << ", " << endRegionExtents << ", " << _currentRegionHeight << std::endl;
+    }
+}
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::parallelDirectSendManyPatches
+//
+//  Purpose:
+//      Parallel Direct Send rendering that can blend individual patches
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+int
+avtSLIVRImageCompositor::parallelDirectSendManyPatches(std::multimap<int, imgData> imgDataHashMap, std::vector<imgMetaData> imageMetaPatchVector, int numPatches, int region[], int numRegions, int tags[2], int fullImageExtents[4])
+{
+    int myRegionHeight = 0;
+  #ifdef PARALLEL
+    debug5 << "Parallel Direct Send" << endl;
+
+    //
+    // Some initializations
+    for (int i=0; i<4; i++)
+    {
+        intermediateImageExtents[i] = 0;
+        intermediateImageBB[i] = 0;
+    }
+
+    //
+    // Find my position in region
+    compositingDone = false;
+    int myPositionInRegion = -1;
+    bool inRegion = true;
+    std::vector<int> regionVector(region, region+numRegions);
+    std::vector<int>::iterator it = std::find(regionVector.begin(), regionVector.end(), my_id);
+
+    if (it == regionVector.end())
+    {
+        inRegion = false;
+        debug5 << my_id << " ~ SHOULD NOT HAPPEN!!!!: Not found " << my_id <<  " !!!" << std::endl;
+    }
+    else
+        myPositionInRegion = it - regionVector.begin();
+
+    int width =  fullImageExtents[1]-fullImageExtents[0];
+    int height = fullImageExtents[3]-fullImageExtents[2];
+
+    debug5 << my_id << " ~ myPositionInRegion: " << myPositionInRegion << ", num_procs: " << num_procs << std::endl;
+    debug5 << "width: " << width << ", height : " << height 
+           << " | fullImageExtents: " << fullImageExtents[0] << ", " << fullImageExtents[1] << ", " << fullImageExtents[2] << ", " << fullImageExtents[3] << std::endl;
+    
+    //
+    // Region boundaries
+    computeRegionExtents(num_procs,height);
+    int myStartingHeight = getScreenRegionStart(myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
+    int myEndingHeight   = getScreenRegionEnd(myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
+    myRegionHeight = clamp( (myEndingHeight-myStartingHeight), 0, height);
+
+    debug5 << "myStartingHeight: " << myStartingHeight << ", myEndingHeight: " << myEndingHeight << ", myRegionHeight: " << myRegionHeight << std::endl;
+
+
+    // Size of one buffer
+    int sizeOneBuffer = getMaxRegionHeight() * width * 4;
+
+
+    //
+    // Determine how many patches and pixel to send to each region
+    std::vector<int> numPatchesPerRegion;
+    std::vector<int> areaPerRegion;
+    std::set<int> numOfRegions;
+
+    numPatchesPerRegion.resize(numRegions);
+    areaPerRegion.resize(numRegions);
+
+
+    // 2D array: extents for each partition
+    std::vector < std::vector<float> > extentsPerPartiton;
+    for (int i=0; i<numRegions; i++)
+        extentsPerPartiton.push_back( std::vector<float>() );
+
+    debug5 << "Parallel Direct Send ~ numPatches " << numPatches << endl;
+
+    int totalSendBufferSize = 0;
+    for (int i=0; i<numPatches; i++)
+    {
+        int _patchExtents[4];
+        imgMetaData temp;
+        temp = imageMetaPatchVector.at(i);
+
+        _patchExtents[0]=temp.screen_ll[0];   // minX
+        _patchExtents[1]=temp.screen_ur[0];   // maxX
+        _patchExtents[2]=temp.screen_ll[1];   // minY
+        _patchExtents[3]=temp.screen_ur[1];   // maxY
+
+        std::multimap<int, imgData>::iterator it = imgDataHashMap.find( i );
+
+        int from, to;
+        int numRegionIntescection = findRegionsForPatch(_patchExtents, fullImageExtents, numRegions, from, to);
+        if (numRegionIntescection <= 0)
+            continue;
+
+        debug5 << "\nParallel Direct Send ~ patch " << i << "  from:" << from << "  to:" << to << "  numPatches: " << numPatches 
+        << "   _patchExtents: " << _patchExtents[0] << ", " << _patchExtents[1] << ", " << _patchExtents[2] << ", " << _patchExtents[3] 
+        << ", fullImageExtents[2]: " << fullImageExtents[2] << ", numRegions: " <<  numRegions << ", totalSendBufferSize: " << totalSendBufferSize << endl;
+
+        for (int j=from; j<=to; j++)
+            numPatchesPerRegion[j]++;
+
+        for (int partition=from; partition<=to; partition++)
+        {
+            int _extentsYStart = std::max( _patchExtents[2], getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) );
+            int _extentsYEnd   = std::min( _patchExtents[3], getScreenRegionEnd(  partition, fullImageExtents[2], fullImageExtents[3]) );
+
+            int _area = (_extentsYEnd-_extentsYStart)*(_patchExtents[1]-_patchExtents[0]);
+            areaPerRegion[partition] += _area;
+            totalSendBufferSize += _area;
+
+            debug5 << "_patchExtents[2]: " << _patchExtents[2] << ", region start: " << getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) <<  ", _extentsYStart: " << _extentsYStart<< endl;
+            debug5 << "_patchExtents[3]: " << _patchExtents[3] << ", region end: " << getScreenRegionEnd(partition, fullImageExtents[2], fullImageExtents[3]) << ", _extentsYEnd: " << _extentsYEnd << endl;
+            debug5 << "_area " << _area << endl;
+
+            extentsPerPartiton[partition].push_back(i);
+            extentsPerPartiton[partition].push_back(_patchExtents[0]);
+            extentsPerPartiton[partition].push_back(_patchExtents[1]);
+            extentsPerPartiton[partition].push_back(_extentsYStart);
+            extentsPerPartiton[partition].push_back(_extentsYEnd);
+            extentsPerPartiton[partition].push_back(temp.eye_z);
+
+            numOfRegions.insert(partition);
+        }
+    }
+    totalSendBufferSize *= 4;                           // to account for RGBA
+    int numRegionsWithData = numOfRegions.size();
+
+    debug5 << "\nParallel Direct Send ~ creating buffers" << endl;
+
+    //
+    // Copy the data for each region for each patch
+
+    // Create buffer
+    float *sendDataBuffer = new float[totalSendBufferSize];     // contains all the data arranged by region
+    int *sendDataBufferSize = new int[numRegionsWithData]();
+    int *sendDataBufferOffsets = new int[numRegionsWithData]();
+
+    int *sendBuffer = new int[numRegions*2]();
+    int regionWithDataCount = 0;
+    int numRegionsToSend = 0;
+
+    // Populate the buffer with data
+    int dataSendBufferOffset = 0;
+    for (int i=0; i<numRegions; i++)
+    {
+        int _dataSize = 0;
+        debug5 << "Region: " << i << "  size: " << extentsPerPartiton[i].size() << std::endl;
+        for (int j=0; j<extentsPerPartiton[i].size(); j+=6)
+        {
+            int _patchID = extentsPerPartiton[i][j + 0];
+            std::multimap<int, imgData>::iterator it = imgDataHashMap.find( _patchID );
+
+            int _width = (extentsPerPartiton[i][j+2] - extentsPerPartiton[i][j+1]);
+            int _bufferSize = _width * (extentsPerPartiton[i][j+4] - extentsPerPartiton[i][j+3]) * 4;
+            int _dataOffset = extentsPerPartiton[i][j+3] - imageMetaPatchVector[_patchID].screen_ll[1];
+
+            memcpy(&sendDataBuffer[dataSendBufferOffset], &(((*it).second).imagePatch[_width * _dataOffset * 4]), _bufferSize*sizeof(float) );
+
+            dataSendBufferOffset += _bufferSize;
+            _dataSize += _bufferSize;
+        }
+
+        if (_dataSize != 0){
+            sendDataBufferSize[regionWithDataCount] = _dataSize;
+
+            regionWithDataCount ++;
+            if (regionWithDataCount != numRegionsWithData)
+                sendDataBufferOffsets[regionWithDataCount] = sendDataBufferOffsets[regionWithDataCount-1] + sendDataBufferSize[regionWithDataCount-1];
+
+            if (regionVector[i] != my_id)
+                numRegionsToSend++;
+        }
+
+        sendBuffer[i*2+0] = numPatchesPerRegion[i];
+        sendBuffer[i*2+1] = areaPerRegion[i];
+
+        debug5 << "Region: " << i << "  numPatchesPerRegion: " << sendBuffer[i*2+0] << ", sendBuffer[i*2+1]: " << sendBuffer[i*2+1] << std::endl;
+    }
+
+    
+
+    //
+    // Exchange information about size to recv
+    int *recvInfoATABuffer = new int[numRegions*2]();
+    MPI_Alltoall(sendBuffer, 2, MPI_INT,  recvInfoATABuffer, 2, MPI_INT, MPI_COMM_WORLD);
+    delete []sendBuffer;
+    sendBuffer = NULL;
+
+    debug5 << "\nParallel Direct Send ~ Exchange information about size to recv" << endl;
+
+    //
+    // Calculate buffer size needed
+    int infoBufferSize = 0;
+    int dataBufferSize = 0;
+    int numRegionsToRecvFrom = 0;
+    for (int i=0; i<numRegions; i++)
+    {
+        infoBufferSize += recvInfoATABuffer[i*2 + 0];   // number of patches per region
+        dataBufferSize += recvInfoATABuffer[i*2 + 1];   // area per region
+
+        debug5 << "From: " << i << ", #patches: " << recvInfoATABuffer[i*2 + 0] << ", " << recvInfoATABuffer[i*2 + 1] << std::endl;
+
+        if (i == my_id)
+            continue;
+
+        if (recvInfoATABuffer[i*2 + 0] != 0)
+            numRegionsToRecvFrom++;
+    }
+
+
+    //
+    // Create structure for MPI Async send/recv
+
+    // Send
+    MPI_Request *sendMetaRq = new MPI_Request[ numRegionsToSend ];
+    MPI_Status *sendMetaSt = new MPI_Status[ numRegionsToSend ];
+
+    MPI_Request *sendImageRq = new MPI_Request[ numRegionsToSend  ];
+    MPI_Status *sendImageSt = new MPI_Status[ numRegionsToSend  ];
+
+    // Recv
+    MPI_Request *recvMetaRq = NULL;
+    MPI_Status *recvMetaSt = NULL;
+
+    MPI_Request *recvImageRq = NULL;
+    MPI_Status *recvImageSt = NULL;
+
+    int recvInfoCount = 0;
+    int offsetMeta = 0;
+    int offsetData = 0;
+    
+    //
+    // Create recv buffers
+    float *recvInfoBuffer = new float[infoBufferSize*6];  // 6 - passing 6 parameters for each patch
+    float *recvDataBuffer =  new float[dataBufferSize*4]; // 4 - to account for RGBA
+
+    debug5 << "infoBufferSize: " << infoBufferSize << ", dataBufferSize: " << dataBufferSize << std::endl;
+    if (myRegionHeight != 0)
+    {
+
+        // Recv
+        recvMetaRq = new MPI_Request[ numRegionsToRecvFrom ];
+        recvMetaSt = new MPI_Status[ numRegionsToRecvFrom ];
+
+        recvImageRq = new MPI_Request[ numRegionsToRecvFrom  ];
+        recvImageSt = new MPI_Status[ numRegionsToRecvFrom  ];
+
+
+        //
+        // Async Recv for info
+        for (int i=0; i<numRegions; i++)
+        {
+            if (recvInfoATABuffer[i*2 + 0] == 0)
+                continue;
+
+            if ( regionVector[i] == my_id )
+                continue;
+
+
+            int src = regionVector[i];
+            MPI_Irecv(&recvInfoBuffer[offsetMeta], recvInfoATABuffer[i*2 + 0]*6, MPI_FLOAT, src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvInfoCount] );
+            MPI_Irecv(&recvDataBuffer[offsetData], recvInfoATABuffer[i*2 + 1]*4, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvInfoCount] );
+
+            offsetMeta += recvInfoATABuffer[i*2 + 0]*6;
+            offsetData += recvInfoATABuffer[i*2 + 1]*4;
+            recvInfoCount++;
+        }
+
+        debug5 << "Async recv setup - numRegionsToRecvFrom: " << numRegionsToRecvFrom << "   recvInfoCount: " << recvInfoCount << endl;
+    }
+
+
+    //
+    // Async Send
+    int offset = 0;
+    int sendCount = 0;
+    int mpiSendCount = 0;
+
+    for (int i=0; i<numRegions; i++)
+    {
+        if ( extentsPerPartiton[i].size() != 0 ){
+            if ( regionVector[i] == my_id )
+            {
+                memcpy( &recvInfoBuffer[offsetMeta], &extentsPerPartiton[i][0], extentsPerPartiton[i].size()*sizeof(float) );
+                memcpy( &recvDataBuffer[offsetData], &sendDataBuffer[offset],   sendDataBufferSize[ sendCount ]*sizeof(float) );
+
+                offset += sendDataBufferSize[sendCount];
+                sendCount++;
+            }
+            else
+            {
+                MPI_Isend(&extentsPerPartiton[i][0],  extentsPerPartiton[i].size(),  MPI_FLOAT, region[i], tags[0], MPI_COMM_WORLD, &sendMetaRq[mpiSendCount]);
+                MPI_Isend(&sendDataBuffer[offset], sendDataBufferSize[ sendCount ], MPI_FLOAT, region[i], tags[1], MPI_COMM_WORLD, &sendImageRq[mpiSendCount]);
+
+                offset += sendDataBufferSize[sendCount];
+                sendCount++;
+                mpiSendCount++;
+            }
+        }
+    }
+
+    debug5 << "Asyn send setup done ~ numRegionsToSend: " << numRegionsToSend << "  mpiSendCount: " << mpiSendCount << endl;
+
+    if (myRegionHeight != 0)
+    {
+        debug5 << "MPI_Waitall ..." << std::endl;
+        MPI_Waitall(recvInfoCount, recvImageRq, recvImageSt);   // Means that we have reveived everything!
+
+        debug5 << "MAPI_WAITALL done!" << std::endl;
+
+        if (recvInfoATABuffer != NULL)
+            delete []recvInfoATABuffer;
+        recvInfoATABuffer = NULL;
+
+
+        debug5 << "Sorting..." << std::endl;
+
+        //
+        // Sort the data
+        std::multimap<float,int> patchData;
+        std::vector<int> patchOffset;
+        patchOffset.push_back(0);
+        for (int i=0; i<infoBufferSize; i++)
+        {
+            patchData.insert( std::pair<float,int> (recvInfoBuffer[i*6 + 5],i));
+            int _patchSize = (recvInfoBuffer[i*6 + 4]-recvInfoBuffer[i*6 + 3]) * (recvInfoBuffer[i*6 + 2]-recvInfoBuffer[i*6 + 1]) * 4;
+            int _offset = patchOffset[i] + _patchSize;
+
+            if (i != infoBufferSize-1)
+                patchOffset.push_back(_offset);
+        }
+
+
+        //
+        // Create buffer for current region
+        intermediateImageBB[0] = intermediateImageExtents[0] = fullImageExtents[0];
+        intermediateImageBB[1] = intermediateImageExtents[1] = fullImageExtents[1];
+        intermediateImageBB[2] = intermediateImageExtents[2] = myStartingHeight;
+        intermediateImageBB[3] = intermediateImageExtents[3] = myEndingHeight;
+
+        intermediateImage = new float[width * (myEndingHeight-myStartingHeight) * 4]();
+
+
+        //
+        // Blend
+        int numBlends = 0;
+        for (std::multimap<float,int>::iterator it=patchData.begin(); it!=patchData.end(); ++it)
+        {
+            int _id = (*it).second;
+            int _extents[4];
+            _extents[0] = recvInfoBuffer[_id*6 + 1];
+            _extents[1] = recvInfoBuffer[_id*6 + 2];
+            _extents[2] = recvInfoBuffer[_id*6 + 3];
+            _extents[3] = recvInfoBuffer[_id*6 + 4];
+
+            blendFrontToBack(&recvDataBuffer[ patchOffset[_id] ], _extents, _extents, intermediateImage, intermediateImageExtents);
+
+            //writeArrayToPPM("/home/pascal/Desktop/debugImages/blending_" + toStr(my_id) + "_"+ toStr(numBlends), intermediateImage, intermediateImageExtents[1]-intermediateImageExtents[0], intermediateImageExtents[3]-intermediateImageExtents[2]);
+            numBlends++;
+        }
+
+        if (numBlends == 0)
+            intermediateImageBB[0]=intermediateImageBB[1]=intermediateImageBB[2]=intermediateImageBB[3] = 0;
+    }
+
+
+    MPI_Waitall(numRegionsToSend, sendImageRq, sendImageSt);   // Means that we have sent everything!
+
+
+    if (myRegionHeight == 0)
+        compositingDone = true;
+
+    //
+    // Cleanup
+    if (sendDataBuffer != NULL)
+        delete []sendDataBuffer;
+    sendDataBuffer = NULL;
+
+    if (sendDataBufferSize != NULL)
+        delete []sendDataBufferSize;
+    sendDataBufferSize = NULL;
+
+    if (sendDataBufferOffsets != NULL)
+        delete []sendDataBufferOffsets;
+    sendDataBufferOffsets = NULL;
+
+
+    if (sendMetaRq != NULL)
+        delete []sendMetaRq;
+
+    if (sendImageRq != NULL)
+        delete []sendImageRq;
+
+    if (sendMetaSt != NULL)
+        delete []sendMetaSt;
+
+    if (sendImageSt != NULL)
+        delete []sendImageSt;
+
+    sendMetaRq = NULL;
+    sendImageRq = NULL;
+    sendMetaSt = NULL;
+    sendImageSt = NULL;
+
+    if (myRegionHeight != 0)
+    {
+        if (recvInfoBuffer != NULL)
+            delete []recvInfoBuffer;
+        recvInfoBuffer = NULL;
+
+        if (recvDataBuffer != NULL)
+            delete []recvDataBuffer;
+        recvDataBuffer = NULL;
+
+        if (recvMetaRq != NULL)
+            delete []recvMetaRq;
+
+        if (recvMetaSt != NULL)
+            delete []recvMetaSt;
+
+        if (recvImageRq != NULL)
+            delete []recvImageRq;
+
+        if (recvImageSt != NULL)
+            delete []recvImageSt;
+
+        recvMetaRq = NULL;
+        recvImageRq = NULL;
+        recvMetaSt = NULL;
+        recvImageSt = NULL;
+    }
+
+    debug5 << "All PDS done" << std::endl;
+  #endif
+    return myRegionHeight;
+}
+
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::gatherImages
+//
+//  Purpose:
+//      Gather images from Parallel Direct Send
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::gatherImages(int regionGather[], int totalNumRanks, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight)
+{
+  #ifdef PARALLEL
+    debug5 << "gatherImages starting... totalNumRanks: " << totalNumRanks << ", compositingDone: " << compositingDone
+           << ", imgExtents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
+
+    for (int i=0; i<4; i++)
+        finalImageExtents[i] = finalBB[i] = 0;
+
+    if (my_id == 0)
+    {
+        int width =  fullImageExtents[1]-fullImageExtents[0];
+        int height = fullImageExtents[3]-fullImageExtents[2];
+
+        debug5 << "Gather Images at 0, final size: " << fullImageExtents[1]-fullImageExtents[0] << " x " << fullImageExtents[3]-fullImageExtents[2] << std::endl;
+
+        //
+        // Receive at root/display node!
+        imgBuffer = new float[width*height*4];
+        finalImageExtents[0] = fullImageExtents[0];
+        finalImageExtents[1] = fullImageExtents[1];
+        finalImageExtents[2] = fullImageExtents[2];
+        finalImageExtents[3] = fullImageExtents[3];
+
+        int numRegionsWithData = 0;
+        int numToRecv = 0;
+        for (int i=0; i<totalNumRanks; i++)
+        {
+            if (getRegionSize(i) != 0)
+                numRegionsWithData++;
+        }
+        numToRecv = numRegionsWithData;
+
+        // remove itself from the recv
+        if (getRegionSize(my_id) != 0) 
+            numToRecv--;
+
+
+        //
+        // Create buffers for async reciving
+        MPI_Request *recvImageRq = new MPI_Request[ numToRecv ];
+        MPI_Status  *recvImageSt = new MPI_Status[ numToRecv ];
+
+        int lastBufferSize    = getRegionSize(totalNumRanks-1) * width * 4;
+        int regularBufferSize = regularRegionSize * width * 4;
+
+        debug5 << "numToRecv: " << numToRecv << ", numRegionsWithData: " << numRegionsWithData << std::endl;
+        debug5 << "regularBufferSize: " << regularBufferSize << ", lastBufferSize: " << lastBufferSize << std::endl;
+
+        // Async Recv
+        int recvCount=0;
+        for (int i=0; i<numRegionsWithData; i++)
+        {
+            int src = regionGather[i];
+
+            if (src == my_id)
+                continue;
+
+            if (i == totalNumRanks-1)
+            {
+                if (lastBufferSize != 0)
+                {
+                    MPI_Irecv(&imgBuffer[i*regularBufferSize], lastBufferSize,     MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+                }
+            }
+            else
+                MPI_Irecv(&imgBuffer[i*regularBufferSize], regularBufferSize,  MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+            
+
+            debug5 << i << " ~ recvCount: " << recvCount << std::endl;
+            recvCount++;
+        }
+
+        if (compositingDone == false)   // If root has data for the final image
+            placeInImage(inputImg, imgExtents, imgBuffer, finalImageExtents);
+
+        MPI_Waitall(numToRecv, recvImageRq, recvImageSt);
+        compositingDone = true;
+
+        delete []recvImageRq;
+        recvImageRq = NULL;
+        delete []recvImageSt;
+        recvImageSt = NULL;
+    }
+    else
+    {
+        if (compositingDone == false)   
+        {
+            int imgSize = (imgExtents[1]-imgExtents[0]) * (imgExtents[3]-imgExtents[2]) * 4;
+            debug5 << "imgSize: " << imgSize << std::endl;
+
+            MPI_Send(inputImg, imgSize, MPI_FLOAT, 0, tag, MPI_COMM_WORLD);
+            compositingDone = true;
+        }
+    }
+
+  #endif
+}
diff --git a/avt/Filters/avtSLIVRImageCompositor.h b/avt/Filters/avtSLIVRImageCompositor.h
new file mode 100644
index 000000000..b413d6ffa
--- /dev/null
+++ b/avt/Filters/avtSLIVRImageCompositor.h
@@ -0,0 +1,163 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                          avtSLIVRImageCompositor.h                        //
+// ************************************************************************* //
+
+#ifndef AVT_SLIVR_IMAGE_COMPOSITOR_H
+#define AVT_SLIVR_IMAGE_COMPOSITOR_H
+
+#include <filters_exports.h>
+#include <pipeline_exports.h>
+
+#include <avtSLIVRCommon.h>
+
+#include <algorithm>
+#include <string>
+#include <map>
+
+#ifdef PARALLEL
+#   include <mpi.h>
+#endif
+
+#define MSG_DATA 100
+#define MSG_RESULT 101
+
+const int SEND = 1;
+const int RECEIVE = 2;
+
+struct imageBuffer{
+    float *image;
+    float depth;
+};
+
+// ****************************************************************************
+//  Class: avtRayTracer
+//
+//  Purpose:
+//      Does the composition for Ray casting: SLIVR
+//
+//  Programmer: Pascal Grosset
+//  Creation:   Spetember 20, 2013
+//
+// ****************************************************************************
+
+class avtSLIVRImageCompositor
+{
+    int num_procs;
+    int my_id;
+    int totalPatches;
+    bool compositingDone;
+
+    // image sizing for compositing
+    int maxRegionHeight;
+    int regularRegionSize;
+    std::vector<int>regionRankExtents;
+
+    void placeInImage(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4]);
+    void colorImage(float *& srcImage, int widthSrc, int heightSrc, float _color[4]);
+    void updateBoundingBox(int currentBoundingBox[4], int imageExtents[4]);
+
+    void gatherDepthAtRoot(int numlocalPatches, float *localPatchesDepth, int &totalPatches, int *& patchCountPerRank, float *& allPatchesDepth);
+    void blendWithBackground(float *_image, int extents[4], float backgroundColor[4]);
+
+    void blendFrontToBack(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4]);
+    void blendBackToFront(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4]);
+
+    void blendFrontToBack(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4]);
+    void blendBackToFront(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4]);
+
+    
+
+    void computeRegionExtents(int numRanks, int height);
+    
+    int getRegularRegionSize(){ return regularRegionSize; } 
+    int getRegionStart(int region){ return regionRankExtents[region*3+0]; }
+    int getRegionEnd(int region){ return regionRankExtents[region*3+1]; }
+    int getRegionSize(int region){ return regionRankExtents[region*3+2]; }
+    int getMaxRegionHeight(){ return maxRegionHeight; }
+    
+    int getScreenRegionStart(int region, int screenImgMinY, int screenImgMaxY){
+        return clamp( getRegionStart(region)+screenImgMinY, screenImgMinY, screenImgMaxY); 
+    }
+    int getScreenRegionEnd(int region, int screenImgMinY, int screenImgMaxY){
+        return clamp( getRegionEnd(region)+screenImgMinY, screenImgMinY, screenImgMaxY); 
+    }
+
+    
+
+public:
+    float *imgBuffer;                   // Final image is here
+    int finalImageExtents[4];
+    int finalBB[4];
+
+    float *intermediateImage;           // Intermediate image, e.g. in parallel direct send
+    int intermediateImageExtents[4];
+    int intermediateImageBB[4];
+
+
+    avtSLIVRImageCompositor();
+    ~avtSLIVRImageCompositor();
+
+    virtual const char *GetType(void) { return "avtSLIVRImageCompositor"; };
+    virtual const char *GetDescription(void) { return "Doing compositing for ray casting SLIVR";};
+
+    int clamp(int value, int _min, int _max){ return std::max( std::min(value,_max), _min); }
+    float clamp(float x){ return std::min( std::max(x, 0.0f), 1.0f); }
+    
+    void barrier();
+
+    int GetNumProcs(){ return num_procs;};
+    int GetMyId(){ return my_id;};
+
+    void getcompositedImage(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage);  // get the final composited image
+    void regionAllocation(int numMPIRanks, int *& regions);
+
+    int findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to);
+
+    // Both currently unused but good for simple testing
+    void serialDirectSend(int numPatches, float *localPatchesDepth, int *extents, float *imgData, float backgroundColor[4], int width, int height);
+    void parallelDirectSend(float *imgData, int imgExtents[4], int region[], int numRegions, int tags[2], int fullImageExtents[4]);
+    
+    int parallelDirectSendManyPatches(std::multimap<int, imgData> imgDataHashMap, std::vector<imgMetaData> imageMetaPatchVector, int numPatches, int region[], int numRegions, int tags[2], int fullImageExtents[4]);
+    void gatherImages(int regionGather[], int numToRecv, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight);
+};
+
+
+#endif
diff --git a/avt/Filters/avtSLIVRRayTracer.C b/avt/Filters/avtSLIVRRayTracer.C
index d4eef7ac1..68b393ec9 100644
--- a/avt/Filters/avtSLIVRRayTracer.C
+++ b/avt/Filters/avtSLIVRRayTracer.C
@@ -85,7 +85,6 @@ bool SLIVRsortImgMetaDataByEyeSpaceDepth(imgMetaData const& before, imgMetaData
 
 avtSLIVRRayTracer::avtSLIVRRayTracer() : avtRayTracerBase()
 {
-
     panPercentage[0] = 0;
     panPercentage[1] = 0;
     lighting = false;
@@ -250,7 +249,6 @@ avtSLIVRRayTracer::Execute()
     extractor.SetTransferFn(transferFn1D);
     extractor.SetInput(trans.GetOutput());
 
-
     //
     // Ray casting: SLIVR ~ Before Rendering
     //
@@ -271,6 +269,7 @@ avtSLIVRRayTracer::Execute()
 
     //
     // Camera Settings
+    //
     vtkCamera *sceneCam = vtkCamera::New();
     sceneCam->SetPosition(view.camera[0],view.camera[1],view.camera[2]);
     sceneCam->SetFocalPoint(view.focus[0],view.focus[1],view.focus[2]);
diff --git a/avt/Filters/avtSLIVRRayTracer.h b/avt/Filters/avtSLIVRRayTracer.h
index cd1b4abfc..7082831d3 100644
--- a/avt/Filters/avtSLIVRRayTracer.h
+++ b/avt/Filters/avtSLIVRRayTracer.h
@@ -46,7 +46,7 @@
 #include <filters_exports.h>
 
 #include <avtRayTracerBase.h>
-#include <avtImgCommunicator.h>
+#include <avtSLIVRImageCompositor.h>
 
 class   vtkMatrix4x4;
 
@@ -116,7 +116,7 @@ class AVTFILTERS_API avtSLIVRRayTracer : public avtRayTracerBase
 
     virtual void          Execute(void);
 
-    avtImgCommunicator    imgComm;
+    avtSLIVRImageCompositor    imgComm;
     bool                  lighting;
     double                lightPosition[4];
     double                lightDirection[3];
diff --git a/avt/Filters/avtSLIVRSamplePointExtractor.C b/avt/Filters/avtSLIVRSamplePointExtractor.C
index 6c15476ff..157986191 100644
--- a/avt/Filters/avtSLIVRSamplePointExtractor.C
+++ b/avt/Filters/avtSLIVRSamplePointExtractor.C
@@ -124,7 +124,10 @@ avtSLIVRSamplePointExtractor::avtSLIVRSamplePointExtractor(int w, int h, int d)
     : avtSamplePointExtractorBase(w, h, d)
 {
     slivrVoxelExtractor = NULL;
+
     patchCount = 0;
+    imageMetaPatchVector.clear();
+    imgDataHashMap.clear();
 
     modelViewProj = vtkMatrix4x4::New();
 
@@ -177,7 +180,6 @@ avtSLIVRSamplePointExtractor::~avtSLIVRSamplePointExtractor()
     delImgPatches();
 }
 
-
 // ****************************************************************************
 //  Method: avtSLIVRSamplePointExtractor::SetUpExtractors
 //
@@ -239,8 +241,9 @@ avtSLIVRSamplePointExtractor::SetUpExtractors(void)
     {
         delete slivrVoxelExtractor;
     }
-    slivrVoxelExtractor = new avtSLIVRVoxelExtractor(width, height, depth, volume,cl);
-//    slivrVoxelExtractor->SetJittering(jitter);
+    slivrVoxelExtractor = new avtSLIVRVoxelExtractor(width, height, depth,
+													 volume,cl);
+    //slivrVoxelExtractor->SetJittering(jitter);
     if (shouldDoTiling)
     {
         slivrVoxelExtractor->Restrict(width_min, width_max-1,
@@ -248,6 +251,32 @@ avtSLIVRSamplePointExtractor::SetUpExtractors(void)
     }
 }
 
+// ****************************************************************************
+//  Method: avtSLIVRSamplePointExtractor::InitSampling
+//
+//  Purpose:
+//      Initialize sampling, called by base class ExecuteTree method before.
+//      the actual iteration starts. This function might be useful for
+//      children classes
+//
+//  Arguments:
+//      dt      The dataset tree that should be processed.
+//
+//  Programmer: Qi WU 
+//  Creation:   April 18, 2018
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtSLIVRSamplePointExtractor::InitSampling(avtDataTree_p dt)
+{
+    patchCount = 0;
+    imageMetaPatchVector.clear();
+    imgDataHashMap.clear();
+}
+
 // ****************************************************************************
 //  Method: avtSLIVRSamplePointExtractor::DoSampling
 //
@@ -268,18 +297,9 @@ avtSLIVRSamplePointExtractor::SetUpExtractors(void)
 void
 avtSLIVRSamplePointExtractor::DoSampling(vtkDataSet *ds, int idx)
 {
-    //initialize sampling state
-    patchCount = 0;
-    imageMetaPatchVector.clear();
-    imgDataHashMap.clear();
-
     double _scalarRange[2];
     ds->GetScalarRange(_scalarRange);
 
-    double _tfRange[2];
-    _tfRange[0] = transferFn1D->GetMin();
-    _tfRange[1] = transferFn1D->GetMax();
-
     double _tfVisibleRange[2];
     _tfVisibleRange[0] = transferFn1D->GetMinVisibleScalar();
     _tfVisibleRange[1] = transferFn1D->GetMaxVisibleScalar();
@@ -322,7 +342,7 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
 {
     StackTimer t0("avtSLIVRSamplePointExtractor::RasterBasedSample");
 
-    //debug5 << PAR_Rank() << " avtSLIVRSamplePointExtractor::RasterBasedSample  " << num << std::endl;
+    
     if (ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
     {
         avtDataAttributes &atts = GetInput()->GetInfo().GetAttributes();
@@ -339,15 +359,16 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
             varsizes.push_back(samples->GetVariableSize(i));
         }
 
-        // Use SLIVR mass voxel extractor.
-
         //
         // Compositing Setup
+	//
         slivrVoxelExtractor->SetGridsAreInWorldSpace(
-            rectilinearGridsAreInWorldSpace, viewInfo, aspect, xform);
+            rectilinearGridsAreInWorldSpace, view, aspect, xform);
 
-        slivrVoxelExtractor->setDepthBuffer(depthBuffer, bufferExtents[1]*bufferExtents[3]);
-        slivrVoxelExtractor->setRGBBuffer(rgbColorBuffer, bufferExtents[1],bufferExtents[3]);
+        slivrVoxelExtractor->setDepthBuffer(depthBuffer,
+					    bufferExtents[1]*bufferExtents[3]);
+        slivrVoxelExtractor->setRGBBuffer(rgbColorBuffer,
+					  bufferExtents[1],bufferExtents[3]);
         slivrVoxelExtractor->setBufferExtents(bufferExtents);
 
         slivrVoxelExtractor->SetViewDirection(view_direction);
@@ -363,11 +384,9 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
         slivrVoxelExtractor->SetMatProperties(materialProperties);
         slivrVoxelExtractor->SetTransferFn(transferFn1D);
 
-        //debug5 << PAR_Rank() << " avtSLIVRSamplePointExtractor::RasterBasedSample extract ...  " << num << std::endl;
-
-        slivrVoxelExtractor->Extract((vtkRectilinearGrid *) ds, varnames, varsizes);
 
-        //debug5 << PAR_Rank() << " avtSLIVRSamplePointExtractor::RasterBasedSample extract done!" << num << std::endl;
+        slivrVoxelExtractor->Extract((vtkRectilinearGrid *) ds,
+									 varnames, varsizes);
 
         //
         // Get rendering results
@@ -375,7 +394,12 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
         imgMetaData      tmpImageMetaPatch;
         tmpImageMetaPatch = initMetaPatch(patchCount);
 
-        slivrVoxelExtractor->getImageDimensions(tmpImageMetaPatch.inUse, tmpImageMetaPatch.dims, tmpImageMetaPatch.screen_ll, tmpImageMetaPatch.screen_ur, tmpImageMetaPatch.eye_z, tmpImageMetaPatch.clip_z);
+        slivrVoxelExtractor->getImageDimensions(tmpImageMetaPatch.inUse,
+												tmpImageMetaPatch.dims,
+												tmpImageMetaPatch.screen_ll,
+												tmpImageMetaPatch.screen_ur,
+												tmpImageMetaPatch.eye_z,
+												tmpImageMetaPatch.clip_z);
         if (tmpImageMetaPatch.inUse == 1)
         {
             tmpImageMetaPatch.avg_z = tmpImageMetaPatch.eye_z;
@@ -385,11 +409,14 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
             imgData tmpImageDataHash;
             tmpImageDataHash.procId = tmpImageMetaPatch.procId;
             tmpImageDataHash.patchNumber = tmpImageMetaPatch.patchNumber;
-            tmpImageDataHash.imagePatch = new float[ tmpImageMetaPatch.dims[0]*tmpImageMetaPatch.dims[1] * 4 ];
+            tmpImageDataHash.imagePatch =
+				new float[tmpImageMetaPatch.dims[0] *
+						  tmpImageMetaPatch.dims[1] * 4];
 
             slivrVoxelExtractor->getComputedImage(tmpImageDataHash.imagePatch);
-            imgDataHashMap.insert( std::pair<int, imgData> (tmpImageDataHash.patchNumber , tmpImageDataHash) );
-            //writeArrayToPPM("/home/pascal/Desktop/debugImages/local_" + toStr(tmpImageMetaPatch.procId) + "_"+ toStr(tmpImageMetaPatch.patchNumber), tmpImageDataHash.imagePatch, tmpImageMetaPatch.dims[0], tmpImageMetaPatch.dims[1]);
+            imgDataHashMap.insert
+				(std::pair<int, imgData>(tmpImageDataHash.patchNumber,
+										 tmpImageDataHash));
 
             patchCount++;
         }
diff --git a/avt/Filters/avtSLIVRSamplePointExtractor.h b/avt/Filters/avtSLIVRSamplePointExtractor.h
index 371d23115..e4e13d920 100644
--- a/avt/Filters/avtSLIVRSamplePointExtractor.h
+++ b/avt/Filters/avtSLIVRSamplePointExtractor.h
@@ -52,7 +52,7 @@
 
 #include <vtkMatrix4x4.h>
 
-#include <imgMetaData.h>
+#include <avtSLIVRCommon.h>
 
 class  avtSLIVRVoxelExtractor;
 
@@ -163,10 +163,13 @@ class AVTFILTERS_API avtSLIVRSamplePointExtractor
     typedef std::multimap<int, imgData>::iterator iter_t;
 
   protected:
+    virtual void              InitSampling(avtDataTree_p dt);
     virtual void              DoSampling(vtkDataSet *, int);
     virtual void              SetUpExtractors(void);
     virtual void              SendJittering(void);
-    virtual bool              FilterUnderstandsTransformedRectMesh(void);
+    virtual bool              FilterUnderstandsTransformedRectMesh(void);   
+    void                      RasterBasedSample(vtkDataSet *, int num=0);
+    imgMetaData               initMetaPatch(int id);    // initialize a patch
 
     double                    minMaxSpatialBounds[6];
     double                    avgPatchExtents[3];
@@ -192,9 +195,6 @@ class AVTFILTERS_API avtSLIVRSamplePointExtractor
     double                    lightDirection[3];
     double                    materialProperties[4];
 
-    imgMetaData               initMetaPatch(int id);    // initialize a patch
-
-    void                      RasterBasedSample(vtkDataSet *, int num=0);
 };
 
 
diff --git a/avt/Filters/avtSLIVRVoxelExtractor.C b/avt/Filters/avtSLIVRVoxelExtractor.C
index a35f629c9..31d376a0a 100644
--- a/avt/Filters/avtSLIVRVoxelExtractor.C
+++ b/avt/Filters/avtSLIVRVoxelExtractor.C
@@ -37,7 +37,7 @@
 *****************************************************************************/
 
 // ************************************************************************* //
-//                            avtSLIVRVoxelExtractor.C                        //
+//                            avtSLIVRVoxelExtractor.C                       //
 // ************************************************************************* //
 
 #include <avtSLIVRVoxelExtractor.h>
diff --git a/avt/Filters/avtSLIVRVoxelExtractor.h b/avt/Filters/avtSLIVRVoxelExtractor.h
index 3e17c52e5..3fd3dd313 100644
--- a/avt/Filters/avtSLIVRVoxelExtractor.h
+++ b/avt/Filters/avtSLIVRVoxelExtractor.h
@@ -46,7 +46,7 @@
 #include <filters_exports.h>
 
 #include <avtVoxelExtractor.h>
-
+#include <avtSLIVRCommon.h>
 #include <avtOpacityMap.h>
 
 #include <DebugStream.h>
@@ -59,7 +59,7 @@ class     vtkMatrix4x4;
 #include <stdlib.h>
 #include <stdio.h>
 #include <algorithm>
-#include "imgMetaData.h"
+
 
 // ****************************************************************************
 //  Class: avtSLIVRVoxelExtractor
diff --git a/avt/Filters/avtSamplePointExtractor.C b/avt/Filters/avtSamplePointExtractor.C
index a599aaac7..52a67bff5 100644
--- a/avt/Filters/avtSamplePointExtractor.C
+++ b/avt/Filters/avtSamplePointExtractor.C
@@ -628,7 +628,7 @@ avtSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
         }
 
         massVoxelExtractor->SetGridsAreInWorldSpace(
-            rectilinearGridsAreInWorldSpace, viewInfo, aspect, xform);
+            rectilinearGridsAreInWorldSpace, view, aspect, xform);
         massVoxelExtractor->SetTransferFn(transferFn1D);
         massVoxelExtractor->Extract((vtkRectilinearGrid *) ds, varnames, varsizes);
         return;
diff --git a/avt/Filters/avtSamplePointExtractorBase.C b/avt/Filters/avtSamplePointExtractorBase.C
index 15a70c134..0c165895b 100644
--- a/avt/Filters/avtSamplePointExtractorBase.C
+++ b/avt/Filters/avtSamplePointExtractorBase.C
@@ -190,7 +190,7 @@ avtSamplePointExtractorBase::SetRectilinearGridsAreInWorldSpace(bool val,
                  const avtViewInfo &v, double a)
 {
     rectilinearGridsAreInWorldSpace = val;
-    viewInfo = v;
+    view = v;
     aspect = a;
 }
 
@@ -207,7 +207,8 @@ avtSamplePointExtractorBase::SetRectilinearGridsAreInWorldSpace(bool val,
 // ****************************************************************************
 
 void
-avtSamplePointExtractorBase::RestrictToTile(int wmin, int wmax, int hmin, int hmax)
+avtSamplePointExtractorBase::RestrictToTile(int wmin, int wmax,
+											int hmin, int hmax)
 {
     shouldDoTiling = true;
     width_min  = wmin;
@@ -338,28 +339,38 @@ struct datatree_childindex
 void
 avtSamplePointExtractorBase::ExecuteTree(avtDataTree_p dt)
 {
-    StackTimer t0(std::string(GetType()) + std::string("::ExecuteTree"));
+    /////////////////////////
+    // Check memory before //
+    /////////////////////////
+    if (DebugStream::Level5())
+    { 
+	unsigned long m_size, m_rss;
+	avtMemory::GetMemorySize(m_size, m_rss);
+	debug5 << "RAR_Rank: " << PAR_Rank() << " "
+	       << GetType() << "::ExecuteTree " 
+	       << " Initial Memory Usage: "
+	       << m_size << " rss (MB): "
+	       << m_rss/(1024*1024) << endl;
+    }
 
-    //check memory
-    unsigned long m_size, m_rss;
-    avtMemory::GetMemorySize(m_size, m_rss);
-    debug5 << PAR_Rank() << " ~ " << GetType() << "::ExecuteTree  .. .  " 
-           << "    Memory use before: " << m_size << "  rss (MB): "
-           << m_rss/(1024*1024) << endl;
+    //
+    // Start timing
+    //
+    StackTimer t0(std::string(GetType()) + std::string("::ExecuteTree"));
 
+    //
+    // Call this function for initialization if necessary by children classes
+    //
+    InitSampling(dt);	
 
     if (*dt == NULL || (dt->GetNChildren() <= 0 && (!(dt->HasData()))))
         return;
 
-    debug5 << " ~ " << GetType() << "::dt->GetNChildren()  "
-           << dt->GetNChildren() << endl;
-
     //
     // Process tree
-    std::stack<datatree_childindex*> nodes;
-
-    //iterative depth-first sampling
-    nodes.push(new datatree_childindex(dt,0));
+    //
+    std::stack<datatree_childindex*> nodes;    
+    nodes.push(new datatree_childindex(dt,0)); //iterative depth-first sampling
     while (!nodes.empty())
     {
         datatree_childindex *ci=nodes.top();
@@ -372,7 +383,8 @@ avtSamplePointExtractorBase::ExecuteTree(avtDataTree_p dt)
             {
                 if (ch->ChildIsPresent(i))
                 {
-                    if (*ch == NULL || (ch->GetNChildren() <= 0 && (!(ch->HasData()))))
+                    if (*ch == NULL || (ch->GetNChildren() <= 0 &&
+					(!(ch->HasData()))))
                         continue;
                     nodes.push(new datatree_childindex(ch->GetChild(i),i));
                 }
@@ -381,15 +393,12 @@ avtSamplePointExtractorBase::ExecuteTree(avtDataTree_p dt)
             continue;
         }
 
-        //do the work
         nodes.pop();
 
         if (*ch == NULL || (ch->GetNChildren() <= 0 && (!(ch->HasData()))))
             continue;
 
-        //
         // Get the dataset for this leaf in the tree.
-        //
         vtkDataSet *ds = ch->GetDataRepresentation().GetDataVTK();
 
         // Performed by derived classes
@@ -399,12 +408,19 @@ avtSamplePointExtractorBase::ExecuteTree(avtDataTree_p dt)
         currentNode++;
     }
 
-
-    //check memory after
-    avtMemory::GetMemorySize(m_size, m_rss);
-    debug5 << PAR_Rank() << " ~ Memory use after: " << m_size
-           << "  rss (MB): " << m_rss/(1024*1024)
-           <<  "   ... " << GetType() << "::ExecuteTree done@!!!" << endl;
+    /////////////////////////
+    // Check memory before //
+    /////////////////////////
+    if (DebugStream::Level5())
+    { 
+	unsigned long m_size, m_rss;
+	avtMemory::GetMemorySize(m_size, m_rss);
+	debug5 << "RAR_Rank: " << PAR_Rank() << " "
+	       << GetType() << "::ExecuteTree " 
+	       << " Final Memory Usage: "
+	       << m_size << " rss (MB): "
+	       << m_rss/(1024*1024) << endl;
+    }
 }
 
 
diff --git a/avt/Filters/avtSamplePointExtractorBase.h b/avt/Filters/avtSamplePointExtractorBase.h
index ce7fc8b00..de65466e1 100644
--- a/avt/Filters/avtSamplePointExtractorBase.h
+++ b/avt/Filters/avtSamplePointExtractorBase.h
@@ -166,7 +166,7 @@ class AVTFILTERS_API avtSamplePointExtractorBase
     bool                      jitter;
 
     bool                      rectilinearGridsAreInWorldSpace;
-    avtViewInfo               viewInfo;
+    avtViewInfo               view; // controlled by SetRectilinearGridsAreInWorldSpace
     double                    aspect;
 
     avtOpacityMap             *transferFn1D;
@@ -186,12 +186,14 @@ class AVTFILTERS_API avtSamplePointExtractorBase
       int                               nVars;
     } LoadingInfo;
 
-    void                      GetLoadingInfoForArrays(vtkDataSet *, LoadingInfo &);
+    void                      GetLoadingInfoForArrays(vtkDataSet *,
+						      LoadingInfo &);
 
     virtual bool              FilterUnderstandsTransformedRectMesh() = 0;
     virtual void              SetUpExtractors(void) = 0;
     virtual void              SendJittering(void) = 0;
     virtual void              DoSampling(vtkDataSet *ds, int idx) = 0;
+    virtual void              InitSampling(avtDataTree_p dt) {};
 
 };
 
diff --git a/avt/Pipeline/Data/avtOpacityMap.C b/avt/Pipeline/Data/avtOpacityMap.C
index a35f50db8..1bf94c14b 100644
--- a/avt/Pipeline/Data/avtOpacityMap.C
+++ b/avt/Pipeline/Data/avtOpacityMap.C
@@ -78,7 +78,7 @@ avtOpacityMap::avtOpacityMap(int te)
     tableEntries = te;
     table = new RGBA[tableEntries];
   
-    transferFn1D = new _RGBA[tableEntries]();
+    transferFn1D = new RGBAF[tableEntries]();
     // RGBA contains a padded byte after the B and before the A.  Use a memset
     // to make sure this inaccessible byte is initialized.  This will allow
     // us to avoid purify issues.
@@ -104,8 +104,8 @@ avtOpacityMap::avtOpacityMap(const avtOpacityMap &obj)
     tableEntries = obj.tableEntries;
     table = new RGBA[tableEntries];
     memcpy(table, obj.table, tableEntries * sizeof(RGBA));
-    transferFn1D = new _RGBA[tableEntries];
-    memcpy(transferFn1D, obj.transferFn1D, tableEntries * sizeof(_RGBA));
+    transferFn1D = new RGBAF[tableEntries];
+    memcpy(transferFn1D, obj.transferFn1D, tableEntries * sizeof(RGBAF));
     min = obj.min;
     max = obj.max;
     range = obj.range;
@@ -122,8 +122,8 @@ void avtOpacityMap::operator = (const avtOpacityMap &obj)
     tableEntries = obj.tableEntries;
     table = new RGBA[tableEntries];
     memcpy(table, obj.table, tableEntries * sizeof(RGBA));
-    transferFn1D = new _RGBA[tableEntries];
-    memcpy(transferFn1D, obj.transferFn1D, tableEntries * sizeof(_RGBA));
+    transferFn1D = new RGBAF[tableEntries];
+    memcpy(transferFn1D, obj.transferFn1D, tableEntries * sizeof(RGBAF));
     min = obj.min;
     max = obj.max;
     range = obj.range;
@@ -270,7 +270,7 @@ avtOpacityMap::SetTable(unsigned char *arr, int te, double attenuation)
 
     tableEntries = te;
     table = new RGBA[tableEntries];
-    transferFn1D = new _RGBA[tableEntries];
+    transferFn1D = new RGBAF[tableEntries];
     for (int i = 0 ; i < tableEntries ; i++)
     {
         table[i].R = arr[i*4];
@@ -378,7 +378,7 @@ avtOpacityMap::SetTableFloat(unsigned char *arr, int te, double attenuation, flo
     }
 
     tableEntries = te;
-    transferFn1D = new _RGBA[tableEntries]();
+    transferFn1D = new RGBAF[tableEntries]();
     minVisibleScalarIndex =  maxVisibleScalarIndex = -1;
     for (int i = 0 ; i < tableEntries ; i++)
     {
@@ -392,21 +392,76 @@ avtOpacityMap::SetTableFloat(unsigned char *arr, int te, double attenuation, flo
         transferFn1D[i].A = alpha;
         if (alpha != 0 && minVisibleScalarIndex == -1){
             minVisibleScalarIndex = i;
-            //debug5 << "starting alpha = 0 at i= " << i << std::endl;
         }
 
-        //debug5 << i << " : " << transferFn1D[i].R << ", " << transferFn1D[i].G << ", " << transferFn1D[i].B <<  ", " << transferFn1D[i].A << std::endl;
     }
     for (int i=tableEntries-1; i>=0; i--)
     {
         if (transferFn1D[i].A != 0 && maxVisibleScalarIndex == -1){
             maxVisibleScalarIndex = i;
-            //debug5 << "ending alpha = 0 at i= " << i << std::endl;
         }
     }
 
+    //
+    // We need to set the intermediate vars again since the table size has
+    // potentially changed.
+    //
+    SetIntermediateVars();
+}
+
+
+// ****************************************************************************
+//  Method: avtOpacityMap::SetTableFloatNOC
+//
+//  Purpose:
+//      A version of function SetTableFloat that does not apply the opacity
+//      correction term to it
+//
+//  Arguments:
+//      arr             The new table in RGBA format.
+//      te              The number of entries in arr.
+//      attenuation     The attenuation parameter specified
+//      over            Reducing based on the number of slices
+//
+//  Programmer: Qi WU
+//  Creation:   Sat Jun 10 22:21:27 MST 2018
+//
+// ****************************************************************************
+void
+avtOpacityMap::SetTableFloatNOC(unsigned char *arr, int te, double attenuation)
+{
+    if (attenuation < -1. || attenuation > 1.)
+    {
+        debug1 << "Bad attenuation value " << attenuation << std::endl;
+        EXCEPTION0(ImproperUseException);
+    }
+
+    if (transferFn1D != NULL) { delete [] transferFn1D; }
 
-    //debug5 << "minVisibleScalarIndex: " << minVisibleScalarIndex << "   maxVisibleScalarIndex: " << maxVisibleScalarIndex << std::endl;
+    tableEntries = te;
+    transferFn1D = new RGBAF[tableEntries]();
+    minVisibleScalarIndex = maxVisibleScalarIndex = -1;
+
+    for (int i = 0 ; i < tableEntries ; i++)
+    {
+	double bp = tan(1.570796327 * (0.5 - attenuation*0.49999));
+	double alpha = pow((float) arr[i*4+3]/255.0f, (float)bp);
+        transferFn1D[i].R = (float)arr[i*4+0]/255.0f;
+        transferFn1D[i].G = (float)arr[i*4+1]/255.0f;
+        transferFn1D[i].B = (float)arr[i*4+2]/255.0f;
+        transferFn1D[i].A = alpha;
+        if (transferFn1D[i].A != 0 && minVisibleScalarIndex == -1) {
+            minVisibleScalarIndex = i;
+        }
+
+    }
+
+    for (int i=tableEntries-1; i>=0; i--)
+    {
+        if (transferFn1D[i].A != 0 && maxVisibleScalarIndex == -1){
+            maxVisibleScalarIndex = i;
+        }
+    }
 
     //
     // We need to set the intermediate vars again since the table size has
@@ -414,6 +469,8 @@ avtOpacityMap::SetTableFloat(unsigned char *arr, int te, double attenuation, flo
     //
     SetIntermediateVars();
 }
+
+
 // ****************************************************************************
 //  Method: avtOpacityMap::GetMinVisibleScalar
 //
@@ -455,26 +512,35 @@ double avtOpacityMap::GetMaxVisibleScalar()
 //  Programmer: Pascal Grosset
 //  Creation:   July 14, 2016
 //
+//  Modifications:
+//
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Code formatting
+//
 // ****************************************************************************
-void avtOpacityMap::computeVisibleRange()
+void avtOpacityMap::ComputeVisibleRange()
 {
     double scalarRange = max - min;
     if (minVisibleScalarIndex == 0)
         minVisibleScalar =  min;
     else
-        minVisibleScalar = ( ((float)minVisibleScalarIndex/(tableEntries-1)) * scalarRange) + min;
+        minVisibleScalar = (((float)minVisibleScalarIndex/(tableEntries-1)) *
+                            scalarRange) + min;
     
-
-
     if (maxVisibleScalarIndex == tableEntries-1)
         maxVisibleScalar =  max;
     else
-        maxVisibleScalar = ( ((float)maxVisibleScalarIndex/(tableEntries-1)) * scalarRange) + min;
-
-
-     debug5 << "max: " << max << "  min: " << min << "  scalarRange: " << scalarRange << "  minVisibleScalarIndex: " << minVisibleScalarIndex <<
-             "  maxVisibleScalarIndex: " << maxVisibleScalarIndex << "   tableEntries: " << tableEntries << 
-             "  maxVisibleScalar: " << maxVisibleScalar << "   minVisibleScalar: " << minVisibleScalar << std::endl;
+        maxVisibleScalar = (((float)maxVisibleScalarIndex/(tableEntries-1)) * 
+                            scalarRange) + min;
+
+     debug5 << " max: " << max << " min: " << min 
+	    << " scalarRange: " << scalarRange 
+            << " minVisibleScalarIndex: " << minVisibleScalarIndex 
+	    << " maxVisibleScalarIndex: " << maxVisibleScalarIndex 
+            << " tableEntries: " << tableEntries
+	    << " maxVisibleScalar: " << maxVisibleScalar 
+            << " minVisibleScalar: " << minVisibleScalar 
+	    << std::endl;
 }
 
 // ****************************************************************************
@@ -535,9 +601,6 @@ avtOpacityMap::SetTable(RGBA *arr, int te, double attenuation)
 }
 
 
-
-
-
 // ****************************************************************************
 //  Method: avtOpacityMap::GetOpacity
 //
diff --git a/avt/Pipeline/Data/avtOpacityMap.h b/avt/Pipeline/Data/avtOpacityMap.h
index 3a430c180..ccd31c74b 100644
--- a/avt/Pipeline/Data/avtOpacityMap.h
+++ b/avt/Pipeline/Data/avtOpacityMap.h
@@ -54,7 +54,7 @@ struct RGBA
     float         A;
 };
 
-struct _RGBA
+struct RGBAF
 {
     float R;
     float G;
@@ -62,6 +62,8 @@ struct _RGBA
     float A;
 };
 
+// added by Qi, for using RGBAF nicely outside the function
+
 // ****************************************************************************
 //  Class: avtOpacityMap
 //
@@ -87,6 +89,11 @@ struct _RGBA
 //    Define private copy constructor and assignment operator to prevent
 //    accidental use of default, bitwise copy implementations.
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Add function 'SetTableFloatNOC' to generate a transfer function without
+//    the opacity correction term. This function will be used for OSPRay 
+//    volume rendering
+//
 // ****************************************************************************
 
 class PIPELINE_API avtOpacityMap
@@ -99,9 +106,14 @@ class PIPELINE_API avtOpacityMap
     void operator = (const avtOpacityMap &obj);
 
     const RGBA                  *GetTable(void) { return table; };
+    const RGBAF                 *GetTableFloat(void) { return transferFn1D; };
     void                         SetTable(unsigned char *, int, double = 1.);
-    void                         SetTable(unsigned char *arr, int te, double attenuation, float over);
-    void                         SetTableFloat(unsigned char *arr, int te, double attenuation, float over);
+    void                         SetTable(unsigned char *arr, int te, 
+                                               double attenuation, float over);
+    void                         SetTableFloat(unsigned char *arr, int te,
+                                               double attenuation, float over);
+    void                         SetTableFloatNOC(unsigned char *arr, int te,
+                                                           double attenuation);
     void                         SetTable(RGBA *, int, double = 1.);
     const RGBA                  &GetOpacity(double);
 
@@ -114,20 +126,21 @@ class PIPELINE_API avtOpacityMap
     double                       GetMinVisibleScalar();
     double                       GetMaxVisibleScalar();
     
-    void                         computeVisibleRange();
+    void                         ComputeVisibleRange();
 
     inline int                   Quantize(const double &);
     int                          GetNumberOfTableEntries(void)
                                                       { return tableEntries; };
 
     float                        QuantizeValF(const double &val);
-    int                          QueryTF(double scalarValue, double color[4]) const;
+    int                          QueryTF(double scalarValue, 
+                                         double color[4]) const;
     float                        QueryAlpha(double scalarValue) const;
 
-    friend PIPELINE_API ostream &operator << (ostream &, const avtOpacityMap &);
+    friend PIPELINE_API ostream &operator <<(ostream &, const avtOpacityMap &);
   protected:
     RGBA                        *table;
-    _RGBA                       *transferFn1D;
+    RGBAF                       *transferFn1D;
     int                          tableEntries;
 
     double                       max, min;
@@ -214,11 +227,13 @@ avtOpacityMap::QuantizeValF(const double &val){
 //  Method: avtOpacityMap::QueryTF
 //
 //  Purpose:
-//      Queries a Transfer function for the color based on the scalr value passed in 
+//      Queries a Transfer function for the color based on the scalr value
+//      passed in 
 //
 //  Arguments:
 //      scalarValue     scalar value
-//      color           the color queried from the transfer function based on the scalar value
+//      color           the color queried from the transfer function based on
+//                      the scalar value
 //
 //  Returns: 
 //
@@ -230,6 +245,9 @@ avtOpacityMap::QuantizeValF(const double &val){
 //    Qi Wu, Tue Aug 8 12:47:52 MT 2017
 //    Fixed index overflow problem when the scalar value reaches its maximum
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Fix bad coding formats
+//
 // ****************************************************************************
 inline int
 avtOpacityMap::QueryTF(double scalarValue, double color[4]) const
@@ -237,7 +255,7 @@ avtOpacityMap::QueryTF(double scalarValue, double color[4]) const
     if (scalarValue <= min){
         int index = 0;
 
-        _RGBA colorRGBA = transferFn1D[index];
+        RGBAF colorRGBA = transferFn1D[index];
         color[0] = colorRGBA.R;
         color[1] = colorRGBA.G;
         color[2] = colorRGBA.B;
@@ -248,7 +266,7 @@ avtOpacityMap::QueryTF(double scalarValue, double color[4]) const
 
     if (scalarValue >= max){
         int index = tableEntries-1;
-        _RGBA colorRGBA = transferFn1D[index];
+        RGBAF colorRGBA = transferFn1D[index];
         color[0] = colorRGBA.R;
         color[1] = colorRGBA.G;
         color[2] = colorRGBA.B;
@@ -258,11 +276,12 @@ avtOpacityMap::QueryTF(double scalarValue, double color[4]) const
     }
 
     int indexLow, indexHigh;
-    _RGBA colorRGBALow, colorRGBAHigh;
+    RGBAF colorRGBALow, colorRGBAHigh;
     double colorLow[4], colorHigh[4];
     float indexPos, indexDiff;
 
-    indexPos  = (scalarValue-min)/(max-min) * (tableEntries-1);    // multiplier = 1.0/(max-min) * tableEntries
+    indexPos  = (scalarValue-min)/(max-min) * (tableEntries-1); 
+    // ^^^^ multiplier = 1.0/(max-min) * tableEntries
     indexLow  = (int)indexPos;
     indexHigh = (int)(indexPos+1.0);
 
diff --git a/avt/Plotter/CMakeLists.txt b/avt/Plotter/CMakeLists.txt
index 4ca2625d9..79a18e9f0 100644
--- a/avt/Plotter/CMakeLists.txt
+++ b/avt/Plotter/CMakeLists.txt
@@ -77,6 +77,12 @@
 #   Remove vtkRenderingVolumeOpenGL2 from link line. Moved module init back
 #   into volume plot.
 #
+#   Qi WU, Sat Jun 10 22:21:27 MST 2018
+#   Remove the old VISIT_OSPRAY configurations because they are too old. 
+#   Additional Note: The FindOSPRay.cmake file is broken for a recent version
+#                    of OSPRay. We should use the built-inosprayConfig.cmake
+#                    file to find OSPRay instead.
+#
 #****************************************************************************/
 
 #if(VISIT_OSPRAY)
@@ -217,14 +223,9 @@ TARGET_LINK_LIBRARIES(avtplotter_ser
     visitcommon avtmath avtview avtfilters_ser avtpipeline_ser visit_vtk 
     lightweight_visit_vtk vtkFiltersHybrid vtkRenderingOpenGL2 
     vtkRenderingFreeType ${OPENGL_LIBRARIES})
-
 IF(VISIT_OSPRAY)
-    MESSAGE(STATUS "OSPRAY_TARGET_LINK_LIBRARIES: " ${OSPRAY_TARGET_LINK_LIBRARIES})
-    MESSAGE(STATUS "OSPRAY_LIBRARIES: " ${OSPRAY_LIBRARIES})
-    MESSAGE(STATUS "OSPRAY_INCLUDE_DIRS: " ${OSPRAY_INCLUDE_DIRS})
-    TARGET_LINK_LIBRARIES(avtplotter_ser ${OSPRAY_TARGET_LINK_LIBRARIES}
-        ${OSPRAY_LIBRARIES} ${VTK_LIBRARIES})
-    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS} ${VISIT_SOURCE_DIR}/../../VTK-6.1.0/Parallel/Core)
+    TARGET_LINK_LIBRARIES(avtplotter_ser ${OSPRAY_LIBRARIES} ${VTK_LIBRARIES})
+    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS})
 ENDIF(VISIT_OSPRAY)
 VISIT_INSTALL_TARGETS(avtplotter_ser)
 
@@ -233,12 +234,9 @@ IF(VISIT_PARALLEL)
     ADD_PARALLEL_LIBRARY(avtplotter_par ${AVTPLOTTER_SOURCES})
     TARGET_LINK_LIBRARIES(avtplotter_par visitcommon avtmath avtview avtfilters_par avtpipeline_par visit_vtk lightweight_visit_vtk vtkFiltersHybrid vtkRenderingOpenGL2 vtkRenderingFreeType ${OPENGL_LIBRARIES})
     IF(VISIT_OSPRAY)
-        TARGET_LINK_LIBRARIES(avtplotter_par ${OSPRAY_TARGET_LINK_LIBRARIES}
-            ${OSPRAY_LIBRARIES} ${VTK_LIBRARIES})
-        INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS})
+      TARGET_LINK_LIBRARIES(avtplotter_par ${OSPRAY_LIBRARIES})
+      INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS})
     ENDIF(VISIT_OSPRAY)
-
     VISIT_INSTALL_TARGETS(avtplotter_par)
 ENDIF(VISIT_PARALLEL)
 
-
diff --git a/avt/Plotter/vtk/InitVTKRendering.C b/avt/Plotter/vtk/InitVTKRendering.C
index f99371412..2d3927c95 100644
--- a/avt/Plotter/vtk/InitVTKRendering.C
+++ b/avt/Plotter/vtk/InitVTKRendering.C
@@ -188,6 +188,9 @@ vtkVisItGraphicsFactory::vtkVisItGraphicsFactory()
 //    Carson Brownlee, Sun May  6 16:25:28 PDT 2012
 //    Add support for Manta.
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Remove the old VISIT_OSPRAY configurations because they are too old. 
+//
 // ****************************************************************************
 
 void
diff --git a/config-site/.DS_Store b/config-site/.DS_Store
new file mode 100644
index 000000000..5008ddfcf
Binary files /dev/null and b/config-site/.DS_Store differ
diff --git a/plots/Volume/CMakeLists.txt b/plots/Volume/CMakeLists.txt
index 725a48f70..f4e7e2244 100644
--- a/plots/Volume/CMakeLists.txt
+++ b/plots/Volume/CMakeLists.txt
@@ -97,6 +97,11 @@ IF(VISIT_SLIVR)
     ADD_DEFINITIONS(-DVISIT_SLIVR)
 ENDIF(VISIT_SLIVR)
 
+IF(VISIT_OSPRAY)
+    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIR})
+    ADD_DEFINITIONS(-DVISIT_OSPRAY)
+ENDIF ()
+
 LINK_DIRECTORIES(${VISIT_LIBRARY_DIR} ${EAVL_LIBRARY_DIR} ${VTKM_LIBRARY_DIR} )
 
 ADD_LIBRARY(IVolumePlot ${LIBI_SOURCES})
@@ -111,6 +116,10 @@ IF(NOT VISIT_SERVER_COMPONENTS_ONLY AND NOT VISIT_ENGINE_ONLY AND NOT VISIT_DBIO
     ADD_LIBRARY(VVolumePlot ${LIBV_SOURCES})
     TARGET_LINK_LIBRARIES(VVolumePlot visitcommon viewer vtkRenderingVolumeOpenGL2 )
 
+    IF(VISIT_OSPRAY)
+      TARGET_LINK_LIBRARIES(VVolumePlot ${OSPRAY_LIBRARIES})
+    ENDIF()
+
     SET(INSTALLTARGETS ${INSTALLTARGETS} GVolumePlot VVolumePlot)
 
     IF(VISIT_PYTHON_SCRIPTING)
@@ -134,12 +143,18 @@ ENDIF(NOT VISIT_SERVER_COMPONENTS_ONLY AND NOT VISIT_ENGINE_ONLY AND NOT VISIT_D
 
 ADD_LIBRARY(EVolumePlot_ser ${LIBE_SOURCES})
 TARGET_LINK_LIBRARIES(EVolumePlot_ser visitcommon avtplotter_ser avtpipeline_ser avtexpressions_ser vtkRenderingVolumeOpenGL2 )
+IF(VISIT_OSPRAY)
+    TARGET_LINK_LIBRARIES(EVolumePlot_ser ${OSPRAY_LIBRARIES})
+ENDIF()
 SET(INSTALLTARGETS ${INSTALLTARGETS} EVolumePlot_ser)
 ADD_TARGET_DEFINITIONS(EVolumePlot_ser ENGINE)
 
 IF(VISIT_PARALLEL)
     ADD_PARALLEL_LIBRARY(EVolumePlot_par ${LIBE_SOURCES})
     TARGET_LINK_LIBRARIES(EVolumePlot_par visitcommon avtplotter_par avtpipeline_par avtexpressions_par vtkRenderingVolumeOpenGL2 )
+    IF(VISIT_OSPRAY)
+        TARGET_LINK_LIBRARIES(EVolumePlot_par ${OSPRAY_LIBRARIES})
+    ENDIF()
     SET(INSTALLTARGETS ${INSTALLTARGETS} EVolumePlot_par)
     ADD_TARGET_DEFINITIONS(EVolumePlot_par ENGINE)
 ENDIF(VISIT_PARALLEL)
diff --git a/plots/Volume/PyVolumeAttributes.C b/plots/Volume/PyVolumeAttributes.C
index 4880d99ad..3c8a0d74a 100644
--- a/plots/Volume/PyVolumeAttributes.C
+++ b/plots/Volume/PyVolumeAttributes.C
@@ -78,6 +78,44 @@ PyVolumeAttributes_ToString(const VolumeAttributes *atts, const char *prefix)
     std::string str;
     char tmpStr[1000];
 
+    if(atts->GetOsprayShadowsEnabledFlag())
+        SNPRINTF(tmpStr, 1000, "%sosprayShadowsEnabledFlag = 1\n", prefix);
+    else
+        SNPRINTF(tmpStr, 1000, "%sosprayShadowsEnabledFlag = 0\n", prefix);
+    str += tmpStr;
+    if(atts->GetOsprayUseGridAcceleratorFlag())
+        SNPRINTF(tmpStr, 1000, "%sosprayUseGridAcceleratorFlag = 1\n", prefix);
+    else
+        SNPRINTF(tmpStr, 1000, "%sosprayUseGridAcceleratorFlag = 0\n", prefix);
+    str += tmpStr;
+    if(atts->GetOsprayPreIntegrationFlag())
+        SNPRINTF(tmpStr, 1000, "%sosprayPreIntegrationFlag = 1\n", prefix);
+    else
+        SNPRINTF(tmpStr, 1000, "%sosprayPreIntegrationFlag = 0\n", prefix);
+    str += tmpStr;
+    if(atts->GetOspraySingleShadeFlag())
+        SNPRINTF(tmpStr, 1000, "%sospraySingleShadeFlag = 1\n", prefix);
+    else
+        SNPRINTF(tmpStr, 1000, "%sospraySingleShadeFlag = 0\n", prefix);
+    str += tmpStr;
+    if(atts->GetOsprayOneSidedLightingFlag())
+        SNPRINTF(tmpStr, 1000, "%sosprayOneSidedLightingFlag = 1\n", prefix);
+    else
+        SNPRINTF(tmpStr, 1000, "%sosprayOneSidedLightingFlag = 0\n", prefix);
+    str += tmpStr;
+    if(atts->GetOsprayAoTransparencyEnabledFlag())
+        SNPRINTF(tmpStr, 1000, "%sosprayAoTransparencyEnabledFlag = 1\n", prefix);
+    else
+        SNPRINTF(tmpStr, 1000, "%sosprayAoTransparencyEnabledFlag = 0\n", prefix);
+    str += tmpStr;
+    SNPRINTF(tmpStr, 1000, "%sospraySpp = %d\n", prefix, atts->GetOspraySpp());
+    str += tmpStr;
+    SNPRINTF(tmpStr, 1000, "%sosprayAoSamples = %d\n", prefix, atts->GetOsprayAoSamples());
+    str += tmpStr;
+    SNPRINTF(tmpStr, 1000, "%sosprayAoDistance = %g\n", prefix, atts->GetOsprayAoDistance());
+    str += tmpStr;
+    SNPRINTF(tmpStr, 1000, "%sosprayMinContribution = %g\n", prefix, atts->GetOsprayMinContribution());
+    str += tmpStr;
     if(atts->GetLegendFlag())
         SNPRINTF(tmpStr, 1000, "%slegendFlag = 1\n", prefix);
     else
@@ -181,7 +219,7 @@ PyVolumeAttributes_ToString(const VolumeAttributes *atts, const char *prefix)
     str += tmpStr;
     SNPRINTF(tmpStr, 1000, "%ssamplesPerRay = %d\n", prefix, atts->GetSamplesPerRay());
     str += tmpStr;
-    const char *rendererType_names = "Default, RayCasting, RayCastingIntegration, RayCastingSLIVR";
+    const char *rendererType_names = "Default, RayCasting, RayCastingIntegration, RayCastingSLIVR, RayCastingOSPRay";
     switch (atts->GetRendererType())
     {
       case VolumeAttributes::Default:
@@ -200,6 +238,10 @@ PyVolumeAttributes_ToString(const VolumeAttributes *atts, const char *prefix)
           SNPRINTF(tmpStr, 1000, "%srendererType = %sRayCastingSLIVR  # %s\n", prefix, prefix, rendererType_names);
           str += tmpStr;
           break;
+      case VolumeAttributes::RayCastingOSPRay:
+          SNPRINTF(tmpStr, 1000, "%srendererType = %sRayCastingOSPRay  # %s\n", prefix, prefix, rendererType_names);
+          str += tmpStr;
+          break;
       default:
           break;
     }
@@ -351,6 +393,246 @@ VolumeAttributes_Notify(PyObject *self, PyObject *args)
     return Py_None;
 }
 
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayShadowsEnabledFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the osprayShadowsEnabledFlag in the object.
+    obj->data->SetOsprayShadowsEnabledFlag(ival != 0);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayShadowsEnabledFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(obj->data->GetOsprayShadowsEnabledFlag()?1L:0L);
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayUseGridAcceleratorFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the osprayUseGridAcceleratorFlag in the object.
+    obj->data->SetOsprayUseGridAcceleratorFlag(ival != 0);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayUseGridAcceleratorFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(obj->data->GetOsprayUseGridAcceleratorFlag()?1L:0L);
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayPreIntegrationFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the osprayPreIntegrationFlag in the object.
+    obj->data->SetOsprayPreIntegrationFlag(ival != 0);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayPreIntegrationFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(obj->data->GetOsprayPreIntegrationFlag()?1L:0L);
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOspraySingleShadeFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the ospraySingleShadeFlag in the object.
+    obj->data->SetOspraySingleShadeFlag(ival != 0);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOspraySingleShadeFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(obj->data->GetOspraySingleShadeFlag()?1L:0L);
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayOneSidedLightingFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the osprayOneSidedLightingFlag in the object.
+    obj->data->SetOsprayOneSidedLightingFlag(ival != 0);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayOneSidedLightingFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(obj->data->GetOsprayOneSidedLightingFlag()?1L:0L);
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayAoTransparencyEnabledFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the osprayAoTransparencyEnabledFlag in the object.
+    obj->data->SetOsprayAoTransparencyEnabledFlag(ival != 0);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayAoTransparencyEnabledFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(obj->data->GetOsprayAoTransparencyEnabledFlag()?1L:0L);
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOspraySpp(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the ospraySpp in the object.
+    obj->data->SetOspraySpp((int)ival);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOspraySpp(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(long(obj->data->GetOspraySpp()));
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayAoSamples(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the osprayAoSamples in the object.
+    obj->data->SetOsprayAoSamples((int)ival);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayAoSamples(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(long(obj->data->GetOsprayAoSamples()));
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayAoDistance(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    double dval;
+    if(!PyArg_ParseTuple(args, "d", &dval))
+        return NULL;
+
+    // Set the osprayAoDistance in the object.
+    obj->data->SetOsprayAoDistance(dval);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayAoDistance(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyFloat_FromDouble(obj->data->GetOsprayAoDistance());
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayMinContribution(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    double dval;
+    if(!PyArg_ParseTuple(args, "d", &dval))
+        return NULL;
+
+    // Set the osprayMinContribution in the object.
+    obj->data->SetOsprayMinContribution(dval);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayMinContribution(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyFloat_FromDouble(obj->data->GetOsprayMinContribution());
+    return retval;
+}
+
 /*static*/ PyObject *
 VolumeAttributes_SetLegendFlag(PyObject *self, PyObject *args)
 {
@@ -957,14 +1239,15 @@ VolumeAttributes_SetRendererType(PyObject *self, PyObject *args)
         return NULL;
 
     // Set the rendererType in the object.
-    if(ival >= 0 && ival < 4)
+    if(ival >= 0 && ival < 5)
         obj->data->SetRendererType(VolumeAttributes::Renderer(ival));
     else
     {
         fprintf(stderr, "An invalid rendererType value was given. "
-                        "Valid values are in the range of [0,3]. "
+                        "Valid values are in the range of [0,4]. "
                         "You can also use the following names: "
-                        "Default, RayCasting, RayCastingIntegration, RayCastingSLIVR.");
+                        "Default, RayCasting, RayCastingIntegration, RayCastingSLIVR, RayCastingOSPRay"
+                        ".");
         return NULL;
     }
 
@@ -1301,6 +1584,26 @@ VolumeAttributes_GetMaterialProperties(PyObject *self, PyObject *args)
 
 PyMethodDef PyVolumeAttributes_methods[VOLUMEATTRIBUTES_NMETH] = {
     {"Notify", VolumeAttributes_Notify, METH_VARARGS},
+    {"SetOsprayShadowsEnabledFlag", VolumeAttributes_SetOsprayShadowsEnabledFlag, METH_VARARGS},
+    {"GetOsprayShadowsEnabledFlag", VolumeAttributes_GetOsprayShadowsEnabledFlag, METH_VARARGS},
+    {"SetOsprayUseGridAcceleratorFlag", VolumeAttributes_SetOsprayUseGridAcceleratorFlag, METH_VARARGS},
+    {"GetOsprayUseGridAcceleratorFlag", VolumeAttributes_GetOsprayUseGridAcceleratorFlag, METH_VARARGS},
+    {"SetOsprayPreIntegrationFlag", VolumeAttributes_SetOsprayPreIntegrationFlag, METH_VARARGS},
+    {"GetOsprayPreIntegrationFlag", VolumeAttributes_GetOsprayPreIntegrationFlag, METH_VARARGS},
+    {"SetOspraySingleShadeFlag", VolumeAttributes_SetOspraySingleShadeFlag, METH_VARARGS},
+    {"GetOspraySingleShadeFlag", VolumeAttributes_GetOspraySingleShadeFlag, METH_VARARGS},
+    {"SetOsprayOneSidedLightingFlag", VolumeAttributes_SetOsprayOneSidedLightingFlag, METH_VARARGS},
+    {"GetOsprayOneSidedLightingFlag", VolumeAttributes_GetOsprayOneSidedLightingFlag, METH_VARARGS},
+    {"SetOsprayAoTransparencyEnabledFlag", VolumeAttributes_SetOsprayAoTransparencyEnabledFlag, METH_VARARGS},
+    {"GetOsprayAoTransparencyEnabledFlag", VolumeAttributes_GetOsprayAoTransparencyEnabledFlag, METH_VARARGS},
+    {"SetOspraySpp", VolumeAttributes_SetOspraySpp, METH_VARARGS},
+    {"GetOspraySpp", VolumeAttributes_GetOspraySpp, METH_VARARGS},
+    {"SetOsprayAoSamples", VolumeAttributes_SetOsprayAoSamples, METH_VARARGS},
+    {"GetOsprayAoSamples", VolumeAttributes_GetOsprayAoSamples, METH_VARARGS},
+    {"SetOsprayAoDistance", VolumeAttributes_SetOsprayAoDistance, METH_VARARGS},
+    {"GetOsprayAoDistance", VolumeAttributes_GetOsprayAoDistance, METH_VARARGS},
+    {"SetOsprayMinContribution", VolumeAttributes_SetOsprayMinContribution, METH_VARARGS},
+    {"GetOsprayMinContribution", VolumeAttributes_GetOsprayMinContribution, METH_VARARGS},
     {"SetLegendFlag", VolumeAttributes_SetLegendFlag, METH_VARARGS},
     {"GetLegendFlag", VolumeAttributes_GetLegendFlag, METH_VARARGS},
     {"SetLightingFlag", VolumeAttributes_SetLightingFlag, METH_VARARGS},
@@ -1393,6 +1696,26 @@ VolumeAttributes_compare(PyObject *v, PyObject *w)
 PyObject *
 PyVolumeAttributes_getattr(PyObject *self, char *name)
 {
+    if(strcmp(name, "osprayShadowsEnabledFlag") == 0)
+        return VolumeAttributes_GetOsprayShadowsEnabledFlag(self, NULL);
+    if(strcmp(name, "osprayUseGridAcceleratorFlag") == 0)
+        return VolumeAttributes_GetOsprayUseGridAcceleratorFlag(self, NULL);
+    if(strcmp(name, "osprayPreIntegrationFlag") == 0)
+        return VolumeAttributes_GetOsprayPreIntegrationFlag(self, NULL);
+    if(strcmp(name, "ospraySingleShadeFlag") == 0)
+        return VolumeAttributes_GetOspraySingleShadeFlag(self, NULL);
+    if(strcmp(name, "osprayOneSidedLightingFlag") == 0)
+        return VolumeAttributes_GetOsprayOneSidedLightingFlag(self, NULL);
+    if(strcmp(name, "osprayAoTransparencyEnabledFlag") == 0)
+        return VolumeAttributes_GetOsprayAoTransparencyEnabledFlag(self, NULL);
+    if(strcmp(name, "ospraySpp") == 0)
+        return VolumeAttributes_GetOspraySpp(self, NULL);
+    if(strcmp(name, "osprayAoSamples") == 0)
+        return VolumeAttributes_GetOsprayAoSamples(self, NULL);
+    if(strcmp(name, "osprayAoDistance") == 0)
+        return VolumeAttributes_GetOsprayAoDistance(self, NULL);
+    if(strcmp(name, "osprayMinContribution") == 0)
+        return VolumeAttributes_GetOsprayMinContribution(self, NULL);
     if(strcmp(name, "legendFlag") == 0)
         return VolumeAttributes_GetLegendFlag(self, NULL);
     if(strcmp(name, "lightingFlag") == 0)
@@ -1452,6 +1775,8 @@ PyVolumeAttributes_getattr(PyObject *self, char *name)
         return PyInt_FromLong(long(VolumeAttributes::RayCastingIntegration));
     if(strcmp(name, "RayCastingSLIVR") == 0)
         return PyInt_FromLong(long(VolumeAttributes::RayCastingSLIVR));
+    if(strcmp(name, "RayCastingOSPRay") == 0)
+        return PyInt_FromLong(long(VolumeAttributes::RayCastingOSPRay));
 
     if(strcmp(name, "gradientType") == 0)
         return VolumeAttributes_GetGradientType(self, NULL);
@@ -1528,7 +1853,27 @@ PyVolumeAttributes_setattr(PyObject *self, char *name, PyObject *args)
     Py_INCREF(args);
     PyObject *obj = NULL;
 
-    if(strcmp(name, "legendFlag") == 0)
+    if(strcmp(name, "osprayShadowsEnabledFlag") == 0)
+        obj = VolumeAttributes_SetOsprayShadowsEnabledFlag(self, tuple);
+    else if(strcmp(name, "osprayUseGridAcceleratorFlag") == 0)
+        obj = VolumeAttributes_SetOsprayUseGridAcceleratorFlag(self, tuple);
+    else if(strcmp(name, "osprayPreIntegrationFlag") == 0)
+        obj = VolumeAttributes_SetOsprayPreIntegrationFlag(self, tuple);
+    else if(strcmp(name, "ospraySingleShadeFlag") == 0)
+        obj = VolumeAttributes_SetOspraySingleShadeFlag(self, tuple);
+    else if(strcmp(name, "osprayOneSidedLightingFlag") == 0)
+        obj = VolumeAttributes_SetOsprayOneSidedLightingFlag(self, tuple);
+    else if(strcmp(name, "osprayAoTransparencyEnabledFlag") == 0)
+        obj = VolumeAttributes_SetOsprayAoTransparencyEnabledFlag(self, tuple);
+    else if(strcmp(name, "ospraySpp") == 0)
+        obj = VolumeAttributes_SetOspraySpp(self, tuple);
+    else if(strcmp(name, "osprayAoSamples") == 0)
+        obj = VolumeAttributes_SetOsprayAoSamples(self, tuple);
+    else if(strcmp(name, "osprayAoDistance") == 0)
+        obj = VolumeAttributes_SetOsprayAoDistance(self, tuple);
+    else if(strcmp(name, "osprayMinContribution") == 0)
+        obj = VolumeAttributes_SetOsprayMinContribution(self, tuple);
+    else if(strcmp(name, "legendFlag") == 0)
         obj = VolumeAttributes_SetLegendFlag(self, tuple);
     else if(strcmp(name, "lightingFlag") == 0)
         obj = VolumeAttributes_SetLightingFlag(self, tuple);
diff --git a/plots/Volume/PyVolumeAttributes.h b/plots/Volume/PyVolumeAttributes.h
index a64c8d3a9..f7c940855 100644
--- a/plots/Volume/PyVolumeAttributes.h
+++ b/plots/Volume/PyVolumeAttributes.h
@@ -44,7 +44,7 @@
 //
 // Functions exposed to the VisIt module.
 //
-#define VOLUMEATTRIBUTES_NMETH 66
+#define VOLUMEATTRIBUTES_NMETH 86
 void           PyVolumeAttributes_StartUp(VolumeAttributes *subj, void *data);
 void           PyVolumeAttributes_CloseDown();
 PyMethodDef *  PyVolumeAttributes_GetMethodTable(int *nMethods);
diff --git a/plots/Volume/QvisVolumePlotWindow.C b/plots/Volume/QvisVolumePlotWindow.C
index 077c86d29..d4fe5a9f5 100644
--- a/plots/Volume/QvisVolumePlotWindow.C
+++ b/plots/Volume/QvisVolumePlotWindow.C
@@ -926,7 +926,6 @@ QvisVolumePlotWindow::CreateOpacityGroup(QWidget *parent, QVBoxLayout *pLayout,
 //   Removed tuvok.
 //
 // ****************************************************************************
-
 void QvisVolumePlotWindow::CreateSamplingGroups(QWidget *parent, QLayout *pLayout)
 {
     //resample group
@@ -968,6 +967,9 @@ void QvisVolumePlotWindow::CreateSamplingGroups(QWidget *parent, QLayout *pLayou
         pLayout->addWidget(defaultGroup);
     }
 
+    //ospray group
+    CreateOSPRayGroups(parent, pLayout);
+	
     //raycasting group
     {
         raycastingGroup = new QGroupBox(parent);
@@ -1057,17 +1059,19 @@ void QvisVolumePlotWindow::EnableDefaultGroup()
 void QvisVolumePlotWindow::UpdateSamplingGroup()
 {
     //hide all groups
+    osprayGroup->setVisible(false);
     resampleGroup->setVisible(false);
     defaultGroup->setVisible(false);
     raycastingGroup->setVisible(false);
-
+    methodsGroup->setVisible(true);
+	
     tfTabs->setTabEnabled(1, true);
 
     //lighting and material properties group, enabled for all but RayCastingIntegration
     lightMaterialPropGroup->setEnabled(true);
     lightingToggle->setEnabled(true);
 
-    //disable material properties (only enabled with lighting for SLIVR, RayCasting w/ Trilinear Sampling)
+    //disable material properties (only enabled with lighting for RayCasting w/ Trilinear Sampling)
     materialProperties->setEnabled(false);
 
     //enable/disable resampleTarget
@@ -1125,7 +1129,7 @@ void QvisVolumePlotWindow::UpdateSamplingGroup()
     case VolumeAttributes::RayCastingSLIVR:
         raycastingGroup->setVisible(true);
         UpdateLowGradientGroup(false);
-        materialProperties->setEnabled(volumeAtts->GetLightingFlag());
+        materialProperties->setEnabled(true);
         EnableSamplingMethods(false);
         samplesPerRayWidget->setEnabled(true);
         rendererSamplesWidget->setEnabled(true);
@@ -1137,6 +1141,28 @@ void QvisVolumePlotWindow::UpdateSamplingGroup()
         break;
 #endif
 
+#ifdef VISIT_OSPRAY
+    case VolumeAttributes::RayCastingOSPRay:
+	osprayGroup->setVisible(true);
+	osprayGroup->setEnabled(true);
+	raycastingGroup->setVisible(true);
+        EnableSamplingMethods(false);	
+        samplesPerRayWidget->setEnabled(true);
+	samplesPerRay->setEnabled(true);
+	samplesPerRayLabel->setEnabled(true);	
+        rendererSamplesWidget->setEnabled(true);
+        rendererSamples->setEnabled(true);
+        rendererSamplesLabel->setEnabled(true);
+	methodsGroup->setVisible(false);
+        centeredDiffButton->setEnabled(false);
+	sobelButton->setEnabled(false);
+	lightingToggle->setEnabled(true);
+	materialProperties->setEnabled(true);
+	lowGradientGroup->setVisible(false);
+        UpdateLowGradientGroup(false);
+        break;
+#endif
+
     default:
         EXCEPTION1(ImproperUseException, "No such renderer type.");
     }        
@@ -1175,6 +1201,9 @@ QvisVolumePlotWindow::CreateRendererOptionsGroup(int maxWidth)
     rendererTypesComboBox->addItem(tr("Ray casting: integration (grey scale)"));
 #ifdef VISIT_SLIVR
     rendererTypesComboBox->addItem(tr("Ray casting: SLIVR"));
+#endif
+#ifdef VISIT_OSPRAY
+    rendererTypesComboBox->addItem(tr("Ray casting: OSPRay"));
 #endif
     connect(rendererTypesComboBox, SIGNAL(activated(int)),
             this, SLOT(rendererTypeChanged(int)));
@@ -1190,7 +1219,7 @@ QvisVolumePlotWindow::CreateRendererOptionsGroup(int maxWidth)
     //
     // Create the methods stuff
     //
-    QGroupBox *methodsGroup = new QGroupBox(parent);
+    methodsGroup = new QGroupBox(parent);
     methodsGroup->setTitle(tr("Methods"));
     rendererOptionsLayout->addWidget(methodsGroup);
 
@@ -1279,6 +1308,174 @@ QvisVolumePlotWindow::CreateRendererOptionsGroup(int maxWidth)
     return parent;
 }
 
+void QvisVolumePlotWindow::CreateOSPRayGroups(QWidget *parent, QLayout *pLayout)
+{
+    osprayGroup = new QGroupBox(parent);
+    osprayGroup->setTitle(tr("OSPRay Options"));
+    osprayGroupLayout = new QGridLayout(osprayGroup);
+    pLayout->addWidget(osprayGroup);    
+    // flag: shadow enabled
+    osprayShadowToggle = new QCheckBox(tr("Shadow"), osprayGroup);
+    connect(osprayShadowToggle, SIGNAL(toggled(bool)),
+            this, SLOT(osprayShadowToggled(bool)));
+    // flag: use grid accelerator
+    osprayUseGridAcceleratorToggle = new QCheckBox(tr("Grid Accelerator"),
+    						   osprayGroup);
+    connect(osprayUseGridAcceleratorToggle, SIGNAL(toggled(bool)),
+            this, SLOT(osprayUseGridAcceleratorToggled(bool)));
+    // flag: enable pre integration
+    osprayPreIntegrationToggle =
+    	new QCheckBox(tr("Transfer Function Pre-Integration"),
+    		      osprayGroup);
+    connect(osprayPreIntegrationToggle, SIGNAL(toggled(bool)),
+            this, SLOT(osprayPreIntegrationToggled(bool)));
+    // flag: enable single shade
+    ospraySingleShadeToggle = new QCheckBox(tr("Single Shade"), osprayGroup);
+    connect(ospraySingleShadeToggle, SIGNAL(toggled(bool)),
+            this, SLOT(ospraySingleShadeToggled(bool)));
+    // flag: enable one sided shading
+    osprayOneSidedLightingToggle = new QCheckBox(tr("One-Sided Lighting"),
+    						 osprayGroup);
+    connect(osprayOneSidedLightingToggle, SIGNAL(toggled(bool)),
+            this, SLOT(osprayOneSidedLightingToggled(bool)));
+    // flag: enable ao transparency
+    osprayAoTransparencyToggle = new QCheckBox(tr("Ambient Occlusion (AO) Transparency"),
+    					       osprayGroup);
+    connect(osprayAoTransparencyToggle, SIGNAL(toggled(bool)),
+            this, SLOT(osprayAoTransparencyToggled(bool)));
+    // value: spp
+    ospraySppWidget         = new QWidget(osprayGroup);
+    QHBoxLayout *sppLayout  = new QHBoxLayout(ospraySppWidget);
+    ospraySppLabel          = new QLabel(tr("Samples Per Pixel"), ospraySppWidget);
+    ospraySpp               = new QSpinBox(ospraySppWidget);
+    ospraySpp->setKeyboardTracking(false);
+    ospraySpp->setMinimum(1);
+    ospraySpp->setMaximum(25000);
+    ospraySpp->setSingleStep(1);
+    ospraySpp->setValue(1);
+    ospraySppLabel->setBuddy(ospraySpp);
+    connect(ospraySpp, SIGNAL(valueChanged(int)),
+    	    this, SLOT(ospraySppChanged(int)));
+    sppLayout->addWidget(ospraySppLabel);
+    sppLayout->addWidget(ospraySpp, Qt::AlignLeft);
+    sppLayout->addStretch(QSizePolicy::Maximum);
+    // value: aoSamples
+    osprayAoSamplesWidget        = new QWidget(osprayGroup);
+    QHBoxLayout *aosamplesLayout = new QHBoxLayout(osprayAoSamplesWidget);
+    osprayAoSamplesLabel         = new QLabel(tr("AO Samples"),
+    					      osprayAoSamplesWidget);
+    osprayAoSamples              = new QSpinBox(osprayAoSamplesWidget);
+    osprayAoSamples->setKeyboardTracking(false);
+    osprayAoSamples->setMinimum(0);
+    osprayAoSamples->setMaximum(25000);
+    osprayAoSamples->setSingleStep(1);
+    osprayAoSamples->setValue(0);
+    osprayAoSamplesLabel->setBuddy(osprayAoSamples);
+    connect(osprayAoSamples, SIGNAL(valueChanged(int)),
+    	    this, SLOT(osprayAoSamplesChanged(int)));
+    aosamplesLayout->addWidget(osprayAoSamplesLabel);
+    aosamplesLayout->addWidget(osprayAoSamples, Qt::AlignLeft);
+    aosamplesLayout->addStretch(QSizePolicy::Maximum);
+    // value: aoDistance
+    osprayAoDistanceWidget        = new QWidget(osprayGroup);
+    QHBoxLayout *aodistanceLayout = new QHBoxLayout(osprayAoDistanceWidget);
+    osprayAoDistanceLabel         = new QLabel(tr("AO Distance"),
+    					      osprayAoDistanceWidget);
+    osprayAoDistance              = new QDoubleSpinBox(osprayAoDistanceWidget);
+    osprayAoDistance->setKeyboardTracking(false);
+    osprayAoDistance->setMinimum(100.0);
+    osprayAoDistance->setMaximum(1000000.0);
+    osprayAoDistance->setSingleStep(1.0);
+    osprayAoDistance->setValue(100000.0);
+    osprayAoDistance->setDecimals(1);
+    osprayAoDistanceLabel->setBuddy(osprayAoDistance);
+    connect(osprayAoDistance, SIGNAL(valueChanged(double)),
+    	    this, SLOT(osprayAoDistanceChanged(double)));
+    aodistanceLayout->addWidget(osprayAoDistanceLabel);
+    aodistanceLayout->addWidget(osprayAoDistance, Qt::AlignLeft);
+    aodistanceLayout->addStretch(QSizePolicy::Maximum);
+    // value: min contribution
+    osprayMinContributionWidget        = new QWidget(osprayGroup);
+    QHBoxLayout *mincontributionLayout = new QHBoxLayout(osprayMinContributionWidget);
+    osprayMinContributionLabel         = new QLabel(tr("Minimum Contrinution"),
+    						    osprayMinContributionWidget);
+    osprayMinContribution              = new QDoubleSpinBox(osprayMinContributionWidget);
+    osprayMinContribution->setKeyboardTracking(false);
+    osprayMinContribution->setMinimum(0.001);
+    osprayMinContribution->setMaximum(10000);
+    osprayMinContribution->setSingleStep(0.001);
+    osprayMinContribution->setValue(0.001);
+    osprayMinContribution->setDecimals(3);
+    osprayMinContributionLabel->setBuddy(osprayMinContribution);
+    connect(osprayMinContribution, SIGNAL(valueChanged(double)),
+    	    this, SLOT(osprayMinContributionChanged(double)));
+    mincontributionLayout->addWidget(osprayMinContributionLabel);
+    mincontributionLayout->addWidget(osprayMinContribution, Qt::AlignLeft);
+    mincontributionLayout->addStretch(QSizePolicy::Maximum);
+    // layout
+    osprayGroupLayout->addWidget(osprayShadowToggle,      0,0);
+    osprayGroupLayout->addWidget(ospraySingleShadeToggle, 1,0);
+    osprayGroupLayout->addWidget(osprayUseGridAcceleratorToggle, 0,2);
+    osprayGroupLayout->addWidget(osprayOneSidedLightingToggle,   1,2);
+    osprayGroupLayout->addWidget(osprayPreIntegrationToggle,     0,5,1,5);
+    osprayGroupLayout->addWidget(osprayAoTransparencyToggle,     1,5,1,5);
+    osprayGroupLayout->addWidget(ospraySppWidget,             2,1,1,2,Qt::AlignRight);
+    osprayGroupLayout->addWidget(osprayAoSamplesWidget,       3,1,1,2,Qt::AlignRight);
+    osprayGroupLayout->addWidget(osprayMinContributionWidget, 2,4,1,4,Qt::AlignRight);
+    osprayGroupLayout->addWidget(osprayAoDistanceWidget,      3,4,1,4,Qt::AlignRight);
+}
+
+void QvisVolumePlotWindow::osprayShadowToggled(bool val)
+{
+    volumeAtts->SetOsprayShadowsEnabledFlag(val);
+    Apply();
+}
+void QvisVolumePlotWindow::osprayUseGridAcceleratorToggled(bool val)
+{
+    volumeAtts->SetOsprayUseGridAcceleratorFlag(val);
+    Apply();
+}
+void QvisVolumePlotWindow::osprayPreIntegrationToggled(bool val)
+{
+    volumeAtts->SetOsprayPreIntegrationFlag(val);
+    Apply();
+}
+void QvisVolumePlotWindow::ospraySingleShadeToggled(bool val)
+{
+    volumeAtts->SetOspraySingleShadeFlag(val);
+    Apply();
+}
+void QvisVolumePlotWindow::osprayOneSidedLightingToggled(bool val)
+{
+    volumeAtts->SetOsprayOneSidedLightingFlag(val);
+    Apply();
+};
+void QvisVolumePlotWindow::osprayAoTransparencyToggled(bool val)
+{
+    volumeAtts->SetOsprayAoTransparencyEnabledFlag(val);
+    Apply();
+};
+void QvisVolumePlotWindow::ospraySppChanged(int val)
+{
+    volumeAtts->SetOspraySpp(val);
+    Apply();
+}
+void QvisVolumePlotWindow::osprayAoSamplesChanged(int val)
+{
+    volumeAtts->SetOsprayAoSamples(val);
+    Apply();
+}
+void QvisVolumePlotWindow::osprayAoDistanceChanged(double val)
+{
+    volumeAtts->SetOsprayAoDistance(val);
+    Apply();
+}
+void QvisVolumePlotWindow::osprayMinContributionChanged(double val)
+{
+    volumeAtts->SetOsprayMinContribution(val);
+    Apply();
+}
+
 // ****************************************************************************
 // Method: QvisVolumePlotWindow::UpdateHistogram
 //
@@ -1689,6 +1886,12 @@ QvisVolumePlotWindow::UpdateWindow(bool doAll)
                 rendererTypesComboBox->setCurrentIndex(3);
             }
 #endif
+#ifdef VISIT_OSPRAY
+            else if (volumeAtts->GetRendererType() == VolumeAttributes::RayCastingOSPRay)
+            {
+                rendererTypesComboBox->setCurrentIndex(4);
+            }
+#endif
 
             opacityVariable->setEnabled(true);
             rendererTypesComboBox->blockSignals(false);
@@ -3404,6 +3607,11 @@ QvisVolumePlotWindow::rendererTypeChanged(int val)
       case 3:
         volumeAtts->SetRendererType(VolumeAttributes::RayCastingSLIVR);
         break;
+#endif
+#ifdef VISIT_OSPRAY
+      case 4:
+        volumeAtts->SetRendererType(VolumeAttributes::RayCastingOSPRay);
+        break;
 #endif
       default:
         EXCEPTION1(ImproperUseException,
diff --git a/plots/Volume/QvisVolumePlotWindow.h b/plots/Volume/QvisVolumePlotWindow.h
index bf3919c0f..09fd95b91 100644
--- a/plots/Volume/QvisVolumePlotWindow.h
+++ b/plots/Volume/QvisVolumePlotWindow.h
@@ -54,6 +54,7 @@ class QRadioButton;
 class QSpinBox;
 class QDoubleSpinBox;
 class QVBoxLayout;
+class QGridLayout;
 class QvisColorTableButton;
 class QvisColorSelectionWidget;
 class QvisGaussianOpacityBar;
@@ -241,9 +242,17 @@ private slots:
     void clearAllGuassians();
     void setGuassians();
     void setManyGuassians();
-
-
-
+    // ospray options
+    void osprayShadowToggled(bool val);
+    void osprayUseGridAcceleratorToggled(bool val);
+    void osprayPreIntegrationToggled(bool val);
+    void ospraySingleShadeToggled(bool val);
+    void osprayOneSidedLightingToggled(bool val);
+    void osprayAoTransparencyToggled(bool val);
+    void ospraySppChanged(int val);
+    void osprayAoSamplesChanged(int val);
+    void osprayAoDistanceChanged(double val);
+    void osprayMinContributionChanged(double val);
 
 private:
     int                      plotType;
@@ -298,6 +307,7 @@ private:
     QCheckBox                *legendToggle;
     QCheckBox                *lightingToggle;
     QCheckBox                *resampleToggle;
+    QGroupBox                *methodsGroup;
     QGroupBox                *lowGradientGroup;
     QLabel                   *lowGradientLightingReductionLabel;
     QComboBox                *lowGradientLightingReductionCombo;
@@ -351,6 +361,28 @@ private:
     QPushButton              *setGaussButton;
     QPushButton              *setManyGaussButton;
 
+    //OSPRay group
+    QGroupBox               *osprayGroup;
+    QGridLayout             *osprayGroupLayout;
+    QCheckBox               *osprayShadowToggle;
+    QCheckBox               *osprayUseGridAcceleratorToggle;
+    QCheckBox               *osprayPreIntegrationToggle;
+    QCheckBox               *ospraySingleShadeToggle;
+    QCheckBox               *osprayOneSidedLightingToggle;
+    QCheckBox               *osprayAoTransparencyToggle;
+    QWidget                 *ospraySppWidget;
+    QLabel                  *ospraySppLabel;
+    QSpinBox                *ospraySpp;
+    QWidget                 *osprayAoSamplesWidget;
+    QLabel                  *osprayAoSamplesLabel;
+    QSpinBox                *osprayAoSamples;
+    QWidget                 *osprayAoDistanceWidget;
+    QLabel                  *osprayAoDistanceLabel;
+    QDoubleSpinBox          *osprayAoDistance;
+    QWidget                 *osprayMinContributionWidget;
+    QLabel                  *osprayMinContributionLabel;
+    QDoubleSpinBox          *osprayMinContribution;
+    
     //Sampling group
     QGroupBox               *resampleGroup;
     QWidget                 *defaultOptions;
@@ -358,6 +390,7 @@ private:
     QGroupBox               *defaultGroup;
     QGroupBox               *raycastingGroup;
     void                    CreateSamplingGroups(QWidget *parent, QLayout *pLayout);
+    void                    CreateOSPRayGroups(QWidget *parent, QLayout *pLayout);
     void                    UpdateSamplingGroup();
     void                    EnableSamplingMethods(bool enable);
     void                    EnableDefaultGroup();
diff --git a/plots/Volume/Volume.xml b/plots/Volume/Volume.xml
index e5d5b42d2..b157272c6 100644
--- a/plots/Volume/Volume.xml
+++ b/plots/Volume/Volume.xml
@@ -37,6 +37,7 @@
         RayCasting
         RayCastingIntegration
         RayCastingSLIVR
+        RayCastingOSPRay
       </Enum>
       <Enum name="GradientType">
         CenteredDifferences
@@ -71,6 +72,38 @@
         Higher
         Highest
       </Enum>
+      
+      <Field name="osprayShadowsEnabledFlag" label="osprayShadowsEnabledFlag" type="bool">
+        false
+      </Field>
+      <Field name="osprayUseGridAcceleratorFlag" label="osprayUseGridAcceleratorFlag" type="bool">
+        false
+      </Field>
+      <Field name="osprayPreIntegrationFlag" label="osprayPreIntegrationFlag" type="bool">
+        false
+      </Field>
+      <Field name="ospraySingleShadeFlag" label="ospraySingleShadeFlag" type="bool">
+        false
+      </Field>
+      <Field name="osprayOneSidedLightingFlag" label="osprayOneSidedLightingFlag" type="bool">
+        false
+      </Field>
+      <Field name="osprayAoTransparencyEnabledFlag" label="osprayAoTransparencyEnabledFlag" type="bool">
+        false
+      </Field>
+      <Field name="ospraySpp" label="ospraySpp" type="int">
+        1
+      </Field>
+      <Field name="osprayAoSamples" label="osprayAoSamples" type="int">
+        0
+      </Field>
+      <Field name="osprayAoDistance" label="osprayAoDistance" type="double">
+        100000.0
+      </Field>
+      <Field name="osprayMinContribution" label="osprayMinContribution" type="double">
+        0.001
+      </Field>
+      
       <Field name="legendFlag" label="legendFlag" type="bool">
         true
       </Field>
diff --git a/plots/Volume/VolumeAttributes.C b/plots/Volume/VolumeAttributes.C
index ba300dabe..019723c3d 100644
--- a/plots/Volume/VolumeAttributes.C
+++ b/plots/Volume/VolumeAttributes.C
@@ -47,20 +47,20 @@
 
 static const char *Renderer_strings[] = {
 "Default", "RayCasting", "RayCastingIntegration", 
-"RayCastingSLIVR"};
+"RayCastingSLIVR", "RayCastingOSPRay"};
 
 std::string
 VolumeAttributes::Renderer_ToString(VolumeAttributes::Renderer t)
 {
     int index = int(t);
-    if(index < 0 || index >= 4) index = 0;
+    if(index < 0 || index >= 5) index = 0;
     return Renderer_strings[index];
 }
 
 std::string
 VolumeAttributes::Renderer_ToString(int t)
 {
-    int index = (t < 0 || t >= 4) ? 0 : t;
+    int index = (t < 0 || t >= 5) ? 0 : t;
     return Renderer_strings[index];
 }
 
@@ -68,7 +68,7 @@ bool
 VolumeAttributes::Renderer_FromString(const std::string &s, VolumeAttributes::Renderer &val)
 {
     val = VolumeAttributes::Default;
-    for(int i = 0; i < 4; ++i)
+    for(int i = 0; i < 5; ++i)
     {
         if(s == Renderer_strings[i])
         {
@@ -323,6 +323,16 @@ VolumeAttributes::LowGradientLightingReduction_FromString(const std::string &s,
 
 void VolumeAttributes::Init()
 {
+    osprayShadowsEnabledFlag = false;
+    osprayUseGridAcceleratorFlag = false;
+    osprayPreIntegrationFlag = false;
+    ospraySingleShadeFlag = false;
+    osprayOneSidedLightingFlag = false;
+    osprayAoTransparencyEnabledFlag = false;
+    ospraySpp = 1;
+    osprayAoSamples = 0;
+    osprayAoDistance = 100000;
+    osprayMinContribution = 0.001;
     legendFlag = true;
     lightingFlag = true;
     SetDefaultColorControlPoints();
@@ -378,6 +388,16 @@ void VolumeAttributes::Init()
 void VolumeAttributes::Copy(const VolumeAttributes &obj)
 {
 
+    osprayShadowsEnabledFlag = obj.osprayShadowsEnabledFlag;
+    osprayUseGridAcceleratorFlag = obj.osprayUseGridAcceleratorFlag;
+    osprayPreIntegrationFlag = obj.osprayPreIntegrationFlag;
+    ospraySingleShadeFlag = obj.ospraySingleShadeFlag;
+    osprayOneSidedLightingFlag = obj.osprayOneSidedLightingFlag;
+    osprayAoTransparencyEnabledFlag = obj.osprayAoTransparencyEnabledFlag;
+    ospraySpp = obj.ospraySpp;
+    osprayAoSamples = obj.osprayAoSamples;
+    osprayAoDistance = obj.osprayAoDistance;
+    osprayMinContribution = obj.osprayMinContribution;
     legendFlag = obj.legendFlag;
     lightingFlag = obj.lightingFlag;
     colorControlPoints = obj.colorControlPoints;
@@ -583,7 +603,17 @@ VolumeAttributes::operator == (const VolumeAttributes &obj) const
         materialProperties_equal = (materialProperties[i] == obj.materialProperties[i]);
 
     // Create the return value
-    return ((legendFlag == obj.legendFlag) &&
+    return ((osprayShadowsEnabledFlag == obj.osprayShadowsEnabledFlag) &&
+            (osprayUseGridAcceleratorFlag == obj.osprayUseGridAcceleratorFlag) &&
+            (osprayPreIntegrationFlag == obj.osprayPreIntegrationFlag) &&
+            (ospraySingleShadeFlag == obj.ospraySingleShadeFlag) &&
+            (osprayOneSidedLightingFlag == obj.osprayOneSidedLightingFlag) &&
+            (osprayAoTransparencyEnabledFlag == obj.osprayAoTransparencyEnabledFlag) &&
+            (ospraySpp == obj.ospraySpp) &&
+            (osprayAoSamples == obj.osprayAoSamples) &&
+            (osprayAoDistance == obj.osprayAoDistance) &&
+            (osprayMinContribution == obj.osprayMinContribution) &&
+            (legendFlag == obj.legendFlag) &&
             (lightingFlag == obj.lightingFlag) &&
             (colorControlPoints == obj.colorControlPoints) &&
             (opacityAttenuation == obj.opacityAttenuation) &&
@@ -758,38 +788,48 @@ VolumeAttributes::NewInstance(bool copy) const
 void
 VolumeAttributes::SelectAll()
 {
-    Select(ID_legendFlag,                    (void *)&legendFlag);
-    Select(ID_lightingFlag,                  (void *)&lightingFlag);
-    Select(ID_colorControlPoints,            (void *)&colorControlPoints);
-    Select(ID_opacityAttenuation,            (void *)&opacityAttenuation);
-    Select(ID_opacityMode,                   (void *)&opacityMode);
-    Select(ID_opacityControlPoints,          (void *)&opacityControlPoints);
-    Select(ID_resampleFlag,                  (void *)&resampleFlag);
-    Select(ID_resampleTarget,                (void *)&resampleTarget);
-    Select(ID_opacityVariable,               (void *)&opacityVariable);
-    Select(ID_compactVariable,               (void *)&compactVariable);
-    Select(ID_freeformOpacity,               (void *)freeformOpacity, 256);
-    Select(ID_useColorVarMin,                (void *)&useColorVarMin);
-    Select(ID_colorVarMin,                   (void *)&colorVarMin);
-    Select(ID_useColorVarMax,                (void *)&useColorVarMax);
-    Select(ID_colorVarMax,                   (void *)&colorVarMax);
-    Select(ID_useOpacityVarMin,              (void *)&useOpacityVarMin);
-    Select(ID_opacityVarMin,                 (void *)&opacityVarMin);
-    Select(ID_useOpacityVarMax,              (void *)&useOpacityVarMax);
-    Select(ID_opacityVarMax,                 (void *)&opacityVarMax);
-    Select(ID_smoothData,                    (void *)&smoothData);
-    Select(ID_samplesPerRay,                 (void *)&samplesPerRay);
-    Select(ID_rendererType,                  (void *)&rendererType);
-    Select(ID_gradientType,                  (void *)&gradientType);
-    Select(ID_scaling,                       (void *)&scaling);
-    Select(ID_skewFactor,                    (void *)&skewFactor);
-    Select(ID_limitsMode,                    (void *)&limitsMode);
-    Select(ID_sampling,                      (void *)&sampling);
-    Select(ID_rendererSamples,               (void *)&rendererSamples);
-    Select(ID_lowGradientLightingReduction,  (void *)&lowGradientLightingReduction);
-    Select(ID_lowGradientLightingClampFlag,  (void *)&lowGradientLightingClampFlag);
-    Select(ID_lowGradientLightingClampValue, (void *)&lowGradientLightingClampValue);
-    Select(ID_materialProperties,            (void *)materialProperties, 4);
+    Select(ID_osprayShadowsEnabledFlag,        (void *)&osprayShadowsEnabledFlag);
+    Select(ID_osprayUseGridAcceleratorFlag,    (void *)&osprayUseGridAcceleratorFlag);
+    Select(ID_osprayPreIntegrationFlag,        (void *)&osprayPreIntegrationFlag);
+    Select(ID_ospraySingleShadeFlag,           (void *)&ospraySingleShadeFlag);
+    Select(ID_osprayOneSidedLightingFlag,      (void *)&osprayOneSidedLightingFlag);
+    Select(ID_osprayAoTransparencyEnabledFlag, (void *)&osprayAoTransparencyEnabledFlag);
+    Select(ID_ospraySpp,                       (void *)&ospraySpp);
+    Select(ID_osprayAoSamples,                 (void *)&osprayAoSamples);
+    Select(ID_osprayAoDistance,                (void *)&osprayAoDistance);
+    Select(ID_osprayMinContribution,           (void *)&osprayMinContribution);
+    Select(ID_legendFlag,                      (void *)&legendFlag);
+    Select(ID_lightingFlag,                    (void *)&lightingFlag);
+    Select(ID_colorControlPoints,              (void *)&colorControlPoints);
+    Select(ID_opacityAttenuation,              (void *)&opacityAttenuation);
+    Select(ID_opacityMode,                     (void *)&opacityMode);
+    Select(ID_opacityControlPoints,            (void *)&opacityControlPoints);
+    Select(ID_resampleFlag,                    (void *)&resampleFlag);
+    Select(ID_resampleTarget,                  (void *)&resampleTarget);
+    Select(ID_opacityVariable,                 (void *)&opacityVariable);
+    Select(ID_compactVariable,                 (void *)&compactVariable);
+    Select(ID_freeformOpacity,                 (void *)freeformOpacity, 256);
+    Select(ID_useColorVarMin,                  (void *)&useColorVarMin);
+    Select(ID_colorVarMin,                     (void *)&colorVarMin);
+    Select(ID_useColorVarMax,                  (void *)&useColorVarMax);
+    Select(ID_colorVarMax,                     (void *)&colorVarMax);
+    Select(ID_useOpacityVarMin,                (void *)&useOpacityVarMin);
+    Select(ID_opacityVarMin,                   (void *)&opacityVarMin);
+    Select(ID_useOpacityVarMax,                (void *)&useOpacityVarMax);
+    Select(ID_opacityVarMax,                   (void *)&opacityVarMax);
+    Select(ID_smoothData,                      (void *)&smoothData);
+    Select(ID_samplesPerRay,                   (void *)&samplesPerRay);
+    Select(ID_rendererType,                    (void *)&rendererType);
+    Select(ID_gradientType,                    (void *)&gradientType);
+    Select(ID_scaling,                         (void *)&scaling);
+    Select(ID_skewFactor,                      (void *)&skewFactor);
+    Select(ID_limitsMode,                      (void *)&limitsMode);
+    Select(ID_sampling,                        (void *)&sampling);
+    Select(ID_rendererSamples,                 (void *)&rendererSamples);
+    Select(ID_lowGradientLightingReduction,    (void *)&lowGradientLightingReduction);
+    Select(ID_lowGradientLightingClampFlag,    (void *)&lowGradientLightingClampFlag);
+    Select(ID_lowGradientLightingClampValue,   (void *)&lowGradientLightingClampValue);
+    Select(ID_materialProperties,              (void *)materialProperties, 4);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -822,6 +862,66 @@ VolumeAttributes::CreateNode(DataNode *parentNode, bool completeSave, bool force
     // Create a node for VolumeAttributes.
     DataNode *node = new DataNode("VolumeAttributes");
 
+    if(completeSave || !FieldsEqual(ID_osprayShadowsEnabledFlag, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayShadowsEnabledFlag", osprayShadowsEnabledFlag));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayUseGridAcceleratorFlag, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayUseGridAcceleratorFlag", osprayUseGridAcceleratorFlag));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayPreIntegrationFlag, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayPreIntegrationFlag", osprayPreIntegrationFlag));
+    }
+
+    if(completeSave || !FieldsEqual(ID_ospraySingleShadeFlag, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("ospraySingleShadeFlag", ospraySingleShadeFlag));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayOneSidedLightingFlag, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayOneSidedLightingFlag", osprayOneSidedLightingFlag));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayAoTransparencyEnabledFlag, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayAoTransparencyEnabledFlag", osprayAoTransparencyEnabledFlag));
+    }
+
+    if(completeSave || !FieldsEqual(ID_ospraySpp, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("ospraySpp", ospraySpp));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayAoSamples, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayAoSamples", osprayAoSamples));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayAoDistance, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayAoDistance", osprayAoDistance));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayMinContribution, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayMinContribution", osprayMinContribution));
+    }
+
     if(completeSave || !FieldsEqual(ID_legendFlag, &defaultObject))
     {
         addToParent = true;
@@ -1062,6 +1162,26 @@ VolumeAttributes::SetFromNode(DataNode *parentNode)
         return;
 
     DataNode *node;
+    if((node = searchNode->GetNode("osprayShadowsEnabledFlag")) != 0)
+        SetOsprayShadowsEnabledFlag(node->AsBool());
+    if((node = searchNode->GetNode("osprayUseGridAcceleratorFlag")) != 0)
+        SetOsprayUseGridAcceleratorFlag(node->AsBool());
+    if((node = searchNode->GetNode("osprayPreIntegrationFlag")) != 0)
+        SetOsprayPreIntegrationFlag(node->AsBool());
+    if((node = searchNode->GetNode("ospraySingleShadeFlag")) != 0)
+        SetOspraySingleShadeFlag(node->AsBool());
+    if((node = searchNode->GetNode("osprayOneSidedLightingFlag")) != 0)
+        SetOsprayOneSidedLightingFlag(node->AsBool());
+    if((node = searchNode->GetNode("osprayAoTransparencyEnabledFlag")) != 0)
+        SetOsprayAoTransparencyEnabledFlag(node->AsBool());
+    if((node = searchNode->GetNode("ospraySpp")) != 0)
+        SetOspraySpp(node->AsInt());
+    if((node = searchNode->GetNode("osprayAoSamples")) != 0)
+        SetOsprayAoSamples(node->AsInt());
+    if((node = searchNode->GetNode("osprayAoDistance")) != 0)
+        SetOsprayAoDistance(node->AsDouble());
+    if((node = searchNode->GetNode("osprayMinContribution")) != 0)
+        SetOsprayMinContribution(node->AsDouble());
     if((node = searchNode->GetNode("legendFlag")) != 0)
         SetLegendFlag(node->AsBool());
     if((node = searchNode->GetNode("lightingFlag")) != 0)
@@ -1124,7 +1244,7 @@ VolumeAttributes::SetFromNode(DataNode *parentNode)
         if(node->GetNodeType() == INT_NODE)
         {
             int ival = node->AsInt();
-            if(ival >= 0 && ival < 4)
+            if(ival >= 0 && ival < 5)
                 SetRendererType(Renderer(ival));
         }
         else if(node->GetNodeType() == STRING_NODE)
@@ -1233,6 +1353,76 @@ VolumeAttributes::SetFromNode(DataNode *parentNode)
 // Set property methods
 ///////////////////////////////////////////////////////////////////////////////
 
+void
+VolumeAttributes::SetOsprayShadowsEnabledFlag(bool osprayShadowsEnabledFlag_)
+{
+    osprayShadowsEnabledFlag = osprayShadowsEnabledFlag_;
+    Select(ID_osprayShadowsEnabledFlag, (void *)&osprayShadowsEnabledFlag);
+}
+
+void
+VolumeAttributes::SetOsprayUseGridAcceleratorFlag(bool osprayUseGridAcceleratorFlag_)
+{
+    osprayUseGridAcceleratorFlag = osprayUseGridAcceleratorFlag_;
+    Select(ID_osprayUseGridAcceleratorFlag, (void *)&osprayUseGridAcceleratorFlag);
+}
+
+void
+VolumeAttributes::SetOsprayPreIntegrationFlag(bool osprayPreIntegrationFlag_)
+{
+    osprayPreIntegrationFlag = osprayPreIntegrationFlag_;
+    Select(ID_osprayPreIntegrationFlag, (void *)&osprayPreIntegrationFlag);
+}
+
+void
+VolumeAttributes::SetOspraySingleShadeFlag(bool ospraySingleShadeFlag_)
+{
+    ospraySingleShadeFlag = ospraySingleShadeFlag_;
+    Select(ID_ospraySingleShadeFlag, (void *)&ospraySingleShadeFlag);
+}
+
+void
+VolumeAttributes::SetOsprayOneSidedLightingFlag(bool osprayOneSidedLightingFlag_)
+{
+    osprayOneSidedLightingFlag = osprayOneSidedLightingFlag_;
+    Select(ID_osprayOneSidedLightingFlag, (void *)&osprayOneSidedLightingFlag);
+}
+
+void
+VolumeAttributes::SetOsprayAoTransparencyEnabledFlag(bool osprayAoTransparencyEnabledFlag_)
+{
+    osprayAoTransparencyEnabledFlag = osprayAoTransparencyEnabledFlag_;
+    Select(ID_osprayAoTransparencyEnabledFlag, (void *)&osprayAoTransparencyEnabledFlag);
+}
+
+void
+VolumeAttributes::SetOspraySpp(int ospraySpp_)
+{
+    ospraySpp = ospraySpp_;
+    Select(ID_ospraySpp, (void *)&ospraySpp);
+}
+
+void
+VolumeAttributes::SetOsprayAoSamples(int osprayAoSamples_)
+{
+    osprayAoSamples = osprayAoSamples_;
+    Select(ID_osprayAoSamples, (void *)&osprayAoSamples);
+}
+
+void
+VolumeAttributes::SetOsprayAoDistance(double osprayAoDistance_)
+{
+    osprayAoDistance = osprayAoDistance_;
+    Select(ID_osprayAoDistance, (void *)&osprayAoDistance);
+}
+
+void
+VolumeAttributes::SetOsprayMinContribution(double osprayMinContribution_)
+{
+    osprayMinContribution = osprayMinContribution_;
+    Select(ID_osprayMinContribution, (void *)&osprayMinContribution);
+}
+
 void
 VolumeAttributes::SetLegendFlag(bool legendFlag_)
 {
@@ -1465,6 +1655,66 @@ VolumeAttributes::SetMaterialProperties(const double *materialProperties_)
 // Get property methods
 ///////////////////////////////////////////////////////////////////////////////
 
+bool
+VolumeAttributes::GetOsprayShadowsEnabledFlag() const
+{
+    return osprayShadowsEnabledFlag;
+}
+
+bool
+VolumeAttributes::GetOsprayUseGridAcceleratorFlag() const
+{
+    return osprayUseGridAcceleratorFlag;
+}
+
+bool
+VolumeAttributes::GetOsprayPreIntegrationFlag() const
+{
+    return osprayPreIntegrationFlag;
+}
+
+bool
+VolumeAttributes::GetOspraySingleShadeFlag() const
+{
+    return ospraySingleShadeFlag;
+}
+
+bool
+VolumeAttributes::GetOsprayOneSidedLightingFlag() const
+{
+    return osprayOneSidedLightingFlag;
+}
+
+bool
+VolumeAttributes::GetOsprayAoTransparencyEnabledFlag() const
+{
+    return osprayAoTransparencyEnabledFlag;
+}
+
+int
+VolumeAttributes::GetOspraySpp() const
+{
+    return ospraySpp;
+}
+
+int
+VolumeAttributes::GetOsprayAoSamples() const
+{
+    return osprayAoSamples;
+}
+
+double
+VolumeAttributes::GetOsprayAoDistance() const
+{
+    return osprayAoDistance;
+}
+
+double
+VolumeAttributes::GetOsprayMinContribution() const
+{
+    return osprayMinContribution;
+}
+
 bool
 VolumeAttributes::GetLegendFlag() const
 {
@@ -1757,38 +2007,48 @@ VolumeAttributes::GetFieldName(int index) const
 {
     switch (index)
     {
-    case ID_legendFlag:                    return "legendFlag";
-    case ID_lightingFlag:                  return "lightingFlag";
-    case ID_colorControlPoints:            return "colorControlPoints";
-    case ID_opacityAttenuation:            return "opacityAttenuation";
-    case ID_opacityMode:                   return "opacityMode";
-    case ID_opacityControlPoints:          return "opacityControlPoints";
-    case ID_resampleFlag:                  return "resampleFlag";
-    case ID_resampleTarget:                return "resampleTarget";
-    case ID_opacityVariable:               return "opacityVariable";
-    case ID_compactVariable:               return "compactVariable";
-    case ID_freeformOpacity:               return "freeformOpacity";
-    case ID_useColorVarMin:                return "useColorVarMin";
-    case ID_colorVarMin:                   return "colorVarMin";
-    case ID_useColorVarMax:                return "useColorVarMax";
-    case ID_colorVarMax:                   return "colorVarMax";
-    case ID_useOpacityVarMin:              return "useOpacityVarMin";
-    case ID_opacityVarMin:                 return "opacityVarMin";
-    case ID_useOpacityVarMax:              return "useOpacityVarMax";
-    case ID_opacityVarMax:                 return "opacityVarMax";
-    case ID_smoothData:                    return "smoothData";
-    case ID_samplesPerRay:                 return "samplesPerRay";
-    case ID_rendererType:                  return "rendererType";
-    case ID_gradientType:                  return "gradientType";
-    case ID_scaling:                       return "scaling";
-    case ID_skewFactor:                    return "skewFactor";
-    case ID_limitsMode:                    return "limitsMode";
-    case ID_sampling:                      return "sampling";
-    case ID_rendererSamples:               return "rendererSamples";
-    case ID_lowGradientLightingReduction:  return "lowGradientLightingReduction";
-    case ID_lowGradientLightingClampFlag:  return "lowGradientLightingClampFlag";
-    case ID_lowGradientLightingClampValue: return "lowGradientLightingClampValue";
-    case ID_materialProperties:            return "materialProperties";
+    case ID_osprayShadowsEnabledFlag:        return "osprayShadowsEnabledFlag";
+    case ID_osprayUseGridAcceleratorFlag:    return "osprayUseGridAcceleratorFlag";
+    case ID_osprayPreIntegrationFlag:        return "osprayPreIntegrationFlag";
+    case ID_ospraySingleShadeFlag:           return "ospraySingleShadeFlag";
+    case ID_osprayOneSidedLightingFlag:      return "osprayOneSidedLightingFlag";
+    case ID_osprayAoTransparencyEnabledFlag: return "osprayAoTransparencyEnabledFlag";
+    case ID_ospraySpp:                       return "ospraySpp";
+    case ID_osprayAoSamples:                 return "osprayAoSamples";
+    case ID_osprayAoDistance:                return "osprayAoDistance";
+    case ID_osprayMinContribution:           return "osprayMinContribution";
+    case ID_legendFlag:                      return "legendFlag";
+    case ID_lightingFlag:                    return "lightingFlag";
+    case ID_colorControlPoints:              return "colorControlPoints";
+    case ID_opacityAttenuation:              return "opacityAttenuation";
+    case ID_opacityMode:                     return "opacityMode";
+    case ID_opacityControlPoints:            return "opacityControlPoints";
+    case ID_resampleFlag:                    return "resampleFlag";
+    case ID_resampleTarget:                  return "resampleTarget";
+    case ID_opacityVariable:                 return "opacityVariable";
+    case ID_compactVariable:                 return "compactVariable";
+    case ID_freeformOpacity:                 return "freeformOpacity";
+    case ID_useColorVarMin:                  return "useColorVarMin";
+    case ID_colorVarMin:                     return "colorVarMin";
+    case ID_useColorVarMax:                  return "useColorVarMax";
+    case ID_colorVarMax:                     return "colorVarMax";
+    case ID_useOpacityVarMin:                return "useOpacityVarMin";
+    case ID_opacityVarMin:                   return "opacityVarMin";
+    case ID_useOpacityVarMax:                return "useOpacityVarMax";
+    case ID_opacityVarMax:                   return "opacityVarMax";
+    case ID_smoothData:                      return "smoothData";
+    case ID_samplesPerRay:                   return "samplesPerRay";
+    case ID_rendererType:                    return "rendererType";
+    case ID_gradientType:                    return "gradientType";
+    case ID_scaling:                         return "scaling";
+    case ID_skewFactor:                      return "skewFactor";
+    case ID_limitsMode:                      return "limitsMode";
+    case ID_sampling:                        return "sampling";
+    case ID_rendererSamples:                 return "rendererSamples";
+    case ID_lowGradientLightingReduction:    return "lowGradientLightingReduction";
+    case ID_lowGradientLightingClampFlag:    return "lowGradientLightingClampFlag";
+    case ID_lowGradientLightingClampValue:   return "lowGradientLightingClampValue";
+    case ID_materialProperties:              return "materialProperties";
     default:  return "invalid index";
     }
 }
@@ -1813,38 +2073,48 @@ VolumeAttributes::GetFieldType(int index) const
 {
     switch (index)
     {
-    case ID_legendFlag:                    return FieldType_bool;
-    case ID_lightingFlag:                  return FieldType_bool;
-    case ID_colorControlPoints:            return FieldType_att;
-    case ID_opacityAttenuation:            return FieldType_float;
-    case ID_opacityMode:                   return FieldType_enum;
-    case ID_opacityControlPoints:          return FieldType_att;
-    case ID_resampleFlag:                  return FieldType_bool;
-    case ID_resampleTarget:                return FieldType_int;
-    case ID_opacityVariable:               return FieldType_variablename;
-    case ID_compactVariable:               return FieldType_variablename;
-    case ID_freeformOpacity:               return FieldType_ucharArray;
-    case ID_useColorVarMin:                return FieldType_bool;
-    case ID_colorVarMin:                   return FieldType_float;
-    case ID_useColorVarMax:                return FieldType_bool;
-    case ID_colorVarMax:                   return FieldType_float;
-    case ID_useOpacityVarMin:              return FieldType_bool;
-    case ID_opacityVarMin:                 return FieldType_float;
-    case ID_useOpacityVarMax:              return FieldType_bool;
-    case ID_opacityVarMax:                 return FieldType_float;
-    case ID_smoothData:                    return FieldType_bool;
-    case ID_samplesPerRay:                 return FieldType_int;
-    case ID_rendererType:                  return FieldType_enum;
-    case ID_gradientType:                  return FieldType_enum;
-    case ID_scaling:                       return FieldType_enum;
-    case ID_skewFactor:                    return FieldType_double;
-    case ID_limitsMode:                    return FieldType_enum;
-    case ID_sampling:                      return FieldType_enum;
-    case ID_rendererSamples:               return FieldType_float;
-    case ID_lowGradientLightingReduction:  return FieldType_enum;
-    case ID_lowGradientLightingClampFlag:  return FieldType_bool;
-    case ID_lowGradientLightingClampValue: return FieldType_double;
-    case ID_materialProperties:            return FieldType_doubleArray;
+    case ID_osprayShadowsEnabledFlag:        return FieldType_bool;
+    case ID_osprayUseGridAcceleratorFlag:    return FieldType_bool;
+    case ID_osprayPreIntegrationFlag:        return FieldType_bool;
+    case ID_ospraySingleShadeFlag:           return FieldType_bool;
+    case ID_osprayOneSidedLightingFlag:      return FieldType_bool;
+    case ID_osprayAoTransparencyEnabledFlag: return FieldType_bool;
+    case ID_ospraySpp:                       return FieldType_int;
+    case ID_osprayAoSamples:                 return FieldType_int;
+    case ID_osprayAoDistance:                return FieldType_double;
+    case ID_osprayMinContribution:           return FieldType_double;
+    case ID_legendFlag:                      return FieldType_bool;
+    case ID_lightingFlag:                    return FieldType_bool;
+    case ID_colorControlPoints:              return FieldType_att;
+    case ID_opacityAttenuation:              return FieldType_float;
+    case ID_opacityMode:                     return FieldType_enum;
+    case ID_opacityControlPoints:            return FieldType_att;
+    case ID_resampleFlag:                    return FieldType_bool;
+    case ID_resampleTarget:                  return FieldType_int;
+    case ID_opacityVariable:                 return FieldType_variablename;
+    case ID_compactVariable:                 return FieldType_variablename;
+    case ID_freeformOpacity:                 return FieldType_ucharArray;
+    case ID_useColorVarMin:                  return FieldType_bool;
+    case ID_colorVarMin:                     return FieldType_float;
+    case ID_useColorVarMax:                  return FieldType_bool;
+    case ID_colorVarMax:                     return FieldType_float;
+    case ID_useOpacityVarMin:                return FieldType_bool;
+    case ID_opacityVarMin:                   return FieldType_float;
+    case ID_useOpacityVarMax:                return FieldType_bool;
+    case ID_opacityVarMax:                   return FieldType_float;
+    case ID_smoothData:                      return FieldType_bool;
+    case ID_samplesPerRay:                   return FieldType_int;
+    case ID_rendererType:                    return FieldType_enum;
+    case ID_gradientType:                    return FieldType_enum;
+    case ID_scaling:                         return FieldType_enum;
+    case ID_skewFactor:                      return FieldType_double;
+    case ID_limitsMode:                      return FieldType_enum;
+    case ID_sampling:                        return FieldType_enum;
+    case ID_rendererSamples:                 return FieldType_float;
+    case ID_lowGradientLightingReduction:    return FieldType_enum;
+    case ID_lowGradientLightingClampFlag:    return FieldType_bool;
+    case ID_lowGradientLightingClampValue:   return FieldType_double;
+    case ID_materialProperties:              return FieldType_doubleArray;
     default:  return FieldType_unknown;
     }
 }
@@ -1869,38 +2139,48 @@ VolumeAttributes::GetFieldTypeName(int index) const
 {
     switch (index)
     {
-    case ID_legendFlag:                    return "bool";
-    case ID_lightingFlag:                  return "bool";
-    case ID_colorControlPoints:            return "att";
-    case ID_opacityAttenuation:            return "float";
-    case ID_opacityMode:                   return "enum";
-    case ID_opacityControlPoints:          return "att";
-    case ID_resampleFlag:                  return "bool";
-    case ID_resampleTarget:                return "int";
-    case ID_opacityVariable:               return "variablename";
-    case ID_compactVariable:               return "variablename";
-    case ID_freeformOpacity:               return "ucharArray";
-    case ID_useColorVarMin:                return "bool";
-    case ID_colorVarMin:                   return "float";
-    case ID_useColorVarMax:                return "bool";
-    case ID_colorVarMax:                   return "float";
-    case ID_useOpacityVarMin:              return "bool";
-    case ID_opacityVarMin:                 return "float";
-    case ID_useOpacityVarMax:              return "bool";
-    case ID_opacityVarMax:                 return "float";
-    case ID_smoothData:                    return "bool";
-    case ID_samplesPerRay:                 return "int";
-    case ID_rendererType:                  return "enum";
-    case ID_gradientType:                  return "enum";
-    case ID_scaling:                       return "enum";
-    case ID_skewFactor:                    return "double";
-    case ID_limitsMode:                    return "enum";
-    case ID_sampling:                      return "enum";
-    case ID_rendererSamples:               return "float";
-    case ID_lowGradientLightingReduction:  return "enum";
-    case ID_lowGradientLightingClampFlag:  return "bool";
-    case ID_lowGradientLightingClampValue: return "double";
-    case ID_materialProperties:            return "doubleArray";
+    case ID_osprayShadowsEnabledFlag:        return "bool";
+    case ID_osprayUseGridAcceleratorFlag:    return "bool";
+    case ID_osprayPreIntegrationFlag:        return "bool";
+    case ID_ospraySingleShadeFlag:           return "bool";
+    case ID_osprayOneSidedLightingFlag:      return "bool";
+    case ID_osprayAoTransparencyEnabledFlag: return "bool";
+    case ID_ospraySpp:                       return "int";
+    case ID_osprayAoSamples:                 return "int";
+    case ID_osprayAoDistance:                return "double";
+    case ID_osprayMinContribution:           return "double";
+    case ID_legendFlag:                      return "bool";
+    case ID_lightingFlag:                    return "bool";
+    case ID_colorControlPoints:              return "att";
+    case ID_opacityAttenuation:              return "float";
+    case ID_opacityMode:                     return "enum";
+    case ID_opacityControlPoints:            return "att";
+    case ID_resampleFlag:                    return "bool";
+    case ID_resampleTarget:                  return "int";
+    case ID_opacityVariable:                 return "variablename";
+    case ID_compactVariable:                 return "variablename";
+    case ID_freeformOpacity:                 return "ucharArray";
+    case ID_useColorVarMin:                  return "bool";
+    case ID_colorVarMin:                     return "float";
+    case ID_useColorVarMax:                  return "bool";
+    case ID_colorVarMax:                     return "float";
+    case ID_useOpacityVarMin:                return "bool";
+    case ID_opacityVarMin:                   return "float";
+    case ID_useOpacityVarMax:                return "bool";
+    case ID_opacityVarMax:                   return "float";
+    case ID_smoothData:                      return "bool";
+    case ID_samplesPerRay:                   return "int";
+    case ID_rendererType:                    return "enum";
+    case ID_gradientType:                    return "enum";
+    case ID_scaling:                         return "enum";
+    case ID_skewFactor:                      return "double";
+    case ID_limitsMode:                      return "enum";
+    case ID_sampling:                        return "enum";
+    case ID_rendererSamples:                 return "float";
+    case ID_lowGradientLightingReduction:    return "enum";
+    case ID_lowGradientLightingClampFlag:    return "bool";
+    case ID_lowGradientLightingClampValue:   return "double";
+    case ID_materialProperties:              return "doubleArray";
     default:  return "invalid index";
     }
 }
@@ -1927,6 +2207,56 @@ VolumeAttributes::FieldsEqual(int index_, const AttributeGroup *rhs) const
     bool retval = false;
     switch (index_)
     {
+    case ID_osprayShadowsEnabledFlag:
+        {  // new scope
+        retval = (osprayShadowsEnabledFlag == obj.osprayShadowsEnabledFlag);
+        }
+        break;
+    case ID_osprayUseGridAcceleratorFlag:
+        {  // new scope
+        retval = (osprayUseGridAcceleratorFlag == obj.osprayUseGridAcceleratorFlag);
+        }
+        break;
+    case ID_osprayPreIntegrationFlag:
+        {  // new scope
+        retval = (osprayPreIntegrationFlag == obj.osprayPreIntegrationFlag);
+        }
+        break;
+    case ID_ospraySingleShadeFlag:
+        {  // new scope
+        retval = (ospraySingleShadeFlag == obj.ospraySingleShadeFlag);
+        }
+        break;
+    case ID_osprayOneSidedLightingFlag:
+        {  // new scope
+        retval = (osprayOneSidedLightingFlag == obj.osprayOneSidedLightingFlag);
+        }
+        break;
+    case ID_osprayAoTransparencyEnabledFlag:
+        {  // new scope
+        retval = (osprayAoTransparencyEnabledFlag == obj.osprayAoTransparencyEnabledFlag);
+        }
+        break;
+    case ID_ospraySpp:
+        {  // new scope
+        retval = (ospraySpp == obj.ospraySpp);
+        }
+        break;
+    case ID_osprayAoSamples:
+        {  // new scope
+        retval = (osprayAoSamples == obj.osprayAoSamples);
+        }
+        break;
+    case ID_osprayAoDistance:
+        {  // new scope
+        retval = (osprayAoDistance == obj.osprayAoDistance);
+        }
+        break;
+    case ID_osprayMinContribution:
+        {  // new scope
+        retval = (osprayMinContribution == obj.osprayMinContribution);
+        }
+        break;
     case ID_legendFlag:
         {  // new scope
         retval = (legendFlag == obj.legendFlag);
@@ -2138,6 +2468,9 @@ VolumeAttributes::FieldsEqual(int index_, const AttributeGroup *rhs) const
 //    Allen Harvey, Thurs Nov 3 7:21:13 EST 2011
 //    Added checks for not doing resampling
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Added RayCastingOSPRay option for volume rendering
+//
 // ****************************************************************************
 
 bool
@@ -2157,6 +2490,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
 
     if (rendererType == VolumeAttributes::RayCasting ||
         rendererType == VolumeAttributes::RayCastingSLIVR ||
+        rendererType == VolumeAttributes::RayCastingOSPRay ||
         rendererType == VolumeAttributes::RayCastingIntegration)
     {
         // Trilinear requires ghost zone while Rasterization and KernelBased do not
@@ -2185,6 +2519,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
         // modes does not require a reexecute.
         if(obj.rendererType == VolumeAttributes::RayCasting ||
            obj.rendererType == VolumeAttributes::RayCastingSLIVR ||
+           obj.rendererType == VolumeAttributes::RayCastingOSPRay ||
            obj.rendererType == VolumeAttributes::RayCastingIntegration)
         {
             return true;
diff --git a/plots/Volume/VolumeAttributes.code b/plots/Volume/VolumeAttributes.code
index 8873455ad..e8ecb65a5 100644
--- a/plots/Volume/VolumeAttributes.code
+++ b/plots/Volume/VolumeAttributes.code
@@ -52,6 +52,9 @@ Definition:
 //    Allen Harvey, Thurs Nov 3 7:21:13 EST 2011
 //    Added checks for not doing resampling
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Added RayCastingOSPRay option for volume rendering
+//
 // ****************************************************************************
 
 bool
@@ -71,6 +74,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
 
     if (rendererType == VolumeAttributes::RayCasting ||
         rendererType == VolumeAttributes::RayCastingSLIVR ||
+        rendererType == VolumeAttributes::RayCastingOSPRay ||
         rendererType == VolumeAttributes::RayCastingIntegration)
     {
         // Trilinear requires ghost zone while Rasterization and KernelBased do not
@@ -99,6 +103,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
         // modes does not require a reexecute.
         if(obj.rendererType == VolumeAttributes::RayCasting ||
            obj.rendererType == VolumeAttributes::RayCastingSLIVR ||
+           obj.rendererType == VolumeAttributes::RayCastingOSPRay ||
            obj.rendererType == VolumeAttributes::RayCastingIntegration)
         {
             return true;
@@ -664,3 +669,7 @@ Target: xml2cmake
 Condition: VISIT_SLIVR
 Definitions: -DVISIT_SLIVR
 
+Target: xml2cmake
+Condition: VISIT_OSPRAY
+Definitions: -DVISIT_OSPRAY
+
diff --git a/plots/Volume/VolumeAttributes.h b/plots/Volume/VolumeAttributes.h
index ac9aa8535..3567f4687 100644
--- a/plots/Volume/VolumeAttributes.h
+++ b/plots/Volume/VolumeAttributes.h
@@ -67,7 +67,8 @@ public:
         Default,
         RayCasting,
         RayCastingIntegration,
-        RayCastingSLIVR
+        RayCastingSLIVR,
+        RayCastingOSPRay
     };
     enum GradientType
     {
@@ -142,6 +143,16 @@ public:
     void SelectMaterialProperties();
 
     // Property setting methods
+    void SetOsprayShadowsEnabledFlag(bool osprayShadowsEnabledFlag_);
+    void SetOsprayUseGridAcceleratorFlag(bool osprayUseGridAcceleratorFlag_);
+    void SetOsprayPreIntegrationFlag(bool osprayPreIntegrationFlag_);
+    void SetOspraySingleShadeFlag(bool ospraySingleShadeFlag_);
+    void SetOsprayOneSidedLightingFlag(bool osprayOneSidedLightingFlag_);
+    void SetOsprayAoTransparencyEnabledFlag(bool osprayAoTransparencyEnabledFlag_);
+    void SetOspraySpp(int ospraySpp_);
+    void SetOsprayAoSamples(int osprayAoSamples_);
+    void SetOsprayAoDistance(double osprayAoDistance_);
+    void SetOsprayMinContribution(double osprayMinContribution_);
     void SetLegendFlag(bool legendFlag_);
     void SetLightingFlag(bool lightingFlag_);
     void SetColorControlPoints(const ColorControlPointList &colorControlPoints_);
@@ -176,6 +187,16 @@ public:
     void SetMaterialProperties(const double *materialProperties_);
 
     // Property getting methods
+    bool                           GetOsprayShadowsEnabledFlag() const;
+    bool                           GetOsprayUseGridAcceleratorFlag() const;
+    bool                           GetOsprayPreIntegrationFlag() const;
+    bool                           GetOspraySingleShadeFlag() const;
+    bool                           GetOsprayOneSidedLightingFlag() const;
+    bool                           GetOsprayAoTransparencyEnabledFlag() const;
+    int                            GetOspraySpp() const;
+    int                            GetOsprayAoSamples() const;
+    double                         GetOsprayAoDistance() const;
+    double                         GetOsprayMinContribution() const;
     bool                           GetLegendFlag() const;
     bool                           GetLightingFlag() const;
     const ColorControlPointList    &GetColorControlPoints() const;
@@ -276,7 +297,17 @@ public:
 
     // IDs that can be used to identify fields in case statements
     enum {
-        ID_legendFlag = 0,
+        ID_osprayShadowsEnabledFlag = 0,
+        ID_osprayUseGridAcceleratorFlag,
+        ID_osprayPreIntegrationFlag,
+        ID_ospraySingleShadeFlag,
+        ID_osprayOneSidedLightingFlag,
+        ID_osprayAoTransparencyEnabledFlag,
+        ID_ospraySpp,
+        ID_osprayAoSamples,
+        ID_osprayAoDistance,
+        ID_osprayMinContribution,
+        ID_legendFlag,
         ID_lightingFlag,
         ID_colorControlPoints,
         ID_opacityAttenuation,
@@ -312,6 +343,16 @@ public:
     };
 
 private:
+    bool                     osprayShadowsEnabledFlag;
+    bool                     osprayUseGridAcceleratorFlag;
+    bool                     osprayPreIntegrationFlag;
+    bool                     ospraySingleShadeFlag;
+    bool                     osprayOneSidedLightingFlag;
+    bool                     osprayAoTransparencyEnabledFlag;
+    int                      ospraySpp;
+    int                      osprayAoSamples;
+    double                   osprayAoDistance;
+    double                   osprayMinContribution;
     bool                     legendFlag;
     bool                     lightingFlag;
     ColorControlPointList    colorControlPoints;
@@ -349,6 +390,6 @@ private:
     static const char *TypeMapFormatString;
     static const private_tmfs_t TmfsStruct;
 };
-#define VOLUMEATTRIBUTES_TMFS "bbafiabissUbfbfbfbfbiiiidiifibdD"
+#define VOLUMEATTRIBUTES_TMFS "bbbbbbiiddbbafiabissUbfbfbfbfbiiiidiifibdD"
 
 #endif
diff --git a/plots/Volume/VolumeAttributes.java b/plots/Volume/VolumeAttributes.java
index 129f5a16d..310f19b10 100644
--- a/plots/Volume/VolumeAttributes.java
+++ b/plots/Volume/VolumeAttributes.java
@@ -61,13 +61,14 @@ import llnl.visit.GaussianControlPointList;
 
 public class VolumeAttributes extends AttributeSubject implements Plugin
 {
-    private static int VolumeAttributes_numAdditionalAtts = 32;
+    private static int VolumeAttributes_numAdditionalAtts = 42;
 
     // Enum values
     public final static int RENDERER_DEFAULT = 0;
     public final static int RENDERER_RAYCASTING = 1;
     public final static int RENDERER_RAYCASTINGINTEGRATION = 2;
     public final static int RENDERER_RAYCASTINGSLIVR = 3;
+    public final static int RENDERER_RAYCASTINGOSPRAY = 4;
 
     public final static int GRADIENTTYPE_CENTEREDDIFFERENCES = 0;
     public final static int GRADIENTTYPE_SOBELOPERATOR = 1;
@@ -101,6 +102,16 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
     {
         super(VolumeAttributes_numAdditionalAtts);
 
+        osprayShadowsEnabledFlag = false;
+        osprayUseGridAcceleratorFlag = false;
+        osprayPreIntegrationFlag = false;
+        ospraySingleShadeFlag = false;
+        osprayOneSidedLightingFlag = false;
+        osprayAoTransparencyEnabledFlag = false;
+        ospraySpp = 1;
+        osprayAoSamples = 0;
+        osprayAoDistance = 100000;
+        osprayMinContribution = 0.001;
         legendFlag = true;
         lightingFlag = true;
         colorControlPoints = new ColorControlPointList();
@@ -145,6 +156,16 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
     {
         super(VolumeAttributes_numAdditionalAtts + nMoreFields);
 
+        osprayShadowsEnabledFlag = false;
+        osprayUseGridAcceleratorFlag = false;
+        osprayPreIntegrationFlag = false;
+        ospraySingleShadeFlag = false;
+        osprayOneSidedLightingFlag = false;
+        osprayAoTransparencyEnabledFlag = false;
+        ospraySpp = 1;
+        osprayAoSamples = 0;
+        osprayAoDistance = 100000;
+        osprayMinContribution = 0.001;
         legendFlag = true;
         lightingFlag = true;
         colorControlPoints = new ColorControlPointList();
@@ -191,6 +212,16 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
 
         int i;
 
+        osprayShadowsEnabledFlag = obj.osprayShadowsEnabledFlag;
+        osprayUseGridAcceleratorFlag = obj.osprayUseGridAcceleratorFlag;
+        osprayPreIntegrationFlag = obj.osprayPreIntegrationFlag;
+        ospraySingleShadeFlag = obj.ospraySingleShadeFlag;
+        osprayOneSidedLightingFlag = obj.osprayOneSidedLightingFlag;
+        osprayAoTransparencyEnabledFlag = obj.osprayAoTransparencyEnabledFlag;
+        ospraySpp = obj.ospraySpp;
+        osprayAoSamples = obj.osprayAoSamples;
+        osprayAoDistance = obj.osprayAoDistance;
+        osprayMinContribution = obj.osprayMinContribution;
         legendFlag = obj.legendFlag;
         lightingFlag = obj.lightingFlag;
         colorControlPoints = new ColorControlPointList(obj.colorControlPoints);
@@ -258,7 +289,17 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
             materialProperties_equal = (materialProperties[i] == obj.materialProperties[i]);
 
         // Create the return value
-        return ((legendFlag == obj.legendFlag) &&
+        return ((osprayShadowsEnabledFlag == obj.osprayShadowsEnabledFlag) &&
+                (osprayUseGridAcceleratorFlag == obj.osprayUseGridAcceleratorFlag) &&
+                (osprayPreIntegrationFlag == obj.osprayPreIntegrationFlag) &&
+                (ospraySingleShadeFlag == obj.ospraySingleShadeFlag) &&
+                (osprayOneSidedLightingFlag == obj.osprayOneSidedLightingFlag) &&
+                (osprayAoTransparencyEnabledFlag == obj.osprayAoTransparencyEnabledFlag) &&
+                (ospraySpp == obj.ospraySpp) &&
+                (osprayAoSamples == obj.osprayAoSamples) &&
+                (osprayAoDistance == obj.osprayAoDistance) &&
+                (osprayMinContribution == obj.osprayMinContribution) &&
+                (legendFlag == obj.legendFlag) &&
                 (lightingFlag == obj.lightingFlag) &&
                 (colorControlPoints.equals(obj.colorControlPoints)) &&
                 (opacityAttenuation == obj.opacityAttenuation) &&
@@ -296,191 +337,251 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
     public String GetVersion() { return "1.1"; }
 
     // Property setting methods
+    public void SetOsprayShadowsEnabledFlag(boolean osprayShadowsEnabledFlag_)
+    {
+        osprayShadowsEnabledFlag = osprayShadowsEnabledFlag_;
+        Select(0);
+    }
+
+    public void SetOsprayUseGridAcceleratorFlag(boolean osprayUseGridAcceleratorFlag_)
+    {
+        osprayUseGridAcceleratorFlag = osprayUseGridAcceleratorFlag_;
+        Select(1);
+    }
+
+    public void SetOsprayPreIntegrationFlag(boolean osprayPreIntegrationFlag_)
+    {
+        osprayPreIntegrationFlag = osprayPreIntegrationFlag_;
+        Select(2);
+    }
+
+    public void SetOspraySingleShadeFlag(boolean ospraySingleShadeFlag_)
+    {
+        ospraySingleShadeFlag = ospraySingleShadeFlag_;
+        Select(3);
+    }
+
+    public void SetOsprayOneSidedLightingFlag(boolean osprayOneSidedLightingFlag_)
+    {
+        osprayOneSidedLightingFlag = osprayOneSidedLightingFlag_;
+        Select(4);
+    }
+
+    public void SetOsprayAoTransparencyEnabledFlag(boolean osprayAoTransparencyEnabledFlag_)
+    {
+        osprayAoTransparencyEnabledFlag = osprayAoTransparencyEnabledFlag_;
+        Select(5);
+    }
+
+    public void SetOspraySpp(int ospraySpp_)
+    {
+        ospraySpp = ospraySpp_;
+        Select(6);
+    }
+
+    public void SetOsprayAoSamples(int osprayAoSamples_)
+    {
+        osprayAoSamples = osprayAoSamples_;
+        Select(7);
+    }
+
+    public void SetOsprayAoDistance(double osprayAoDistance_)
+    {
+        osprayAoDistance = osprayAoDistance_;
+        Select(8);
+    }
+
+    public void SetOsprayMinContribution(double osprayMinContribution_)
+    {
+        osprayMinContribution = osprayMinContribution_;
+        Select(9);
+    }
+
     public void SetLegendFlag(boolean legendFlag_)
     {
         legendFlag = legendFlag_;
-        Select(0);
+        Select(10);
     }
 
     public void SetLightingFlag(boolean lightingFlag_)
     {
         lightingFlag = lightingFlag_;
-        Select(1);
+        Select(11);
     }
 
     public void SetColorControlPoints(ColorControlPointList colorControlPoints_)
     {
         colorControlPoints = colorControlPoints_;
-        Select(2);
+        Select(12);
     }
 
     public void SetOpacityAttenuation(float opacityAttenuation_)
     {
         opacityAttenuation = opacityAttenuation_;
-        Select(3);
+        Select(13);
     }
 
     public void SetOpacityMode(int opacityMode_)
     {
         opacityMode = opacityMode_;
-        Select(4);
+        Select(14);
     }
 
     public void SetOpacityControlPoints(GaussianControlPointList opacityControlPoints_)
     {
         opacityControlPoints = opacityControlPoints_;
-        Select(5);
+        Select(15);
     }
 
     public void SetResampleFlag(boolean resampleFlag_)
     {
         resampleFlag = resampleFlag_;
-        Select(6);
+        Select(16);
     }
 
     public void SetResampleTarget(int resampleTarget_)
     {
         resampleTarget = resampleTarget_;
-        Select(7);
+        Select(17);
     }
 
     public void SetOpacityVariable(String opacityVariable_)
     {
         opacityVariable = opacityVariable_;
-        Select(8);
+        Select(18);
     }
 
     public void SetCompactVariable(String compactVariable_)
     {
         compactVariable = compactVariable_;
-        Select(9);
+        Select(19);
     }
 
     public void SetFreeformOpacity(byte[] freeformOpacity_)
     {
         for(int i = 0; i < 256; ++i)
              freeformOpacity[i] = freeformOpacity_[i];
-        Select(10);
+        Select(20);
     }
 
     public void SetUseColorVarMin(boolean useColorVarMin_)
     {
         useColorVarMin = useColorVarMin_;
-        Select(11);
+        Select(21);
     }
 
     public void SetColorVarMin(float colorVarMin_)
     {
         colorVarMin = colorVarMin_;
-        Select(12);
+        Select(22);
     }
 
     public void SetUseColorVarMax(boolean useColorVarMax_)
     {
         useColorVarMax = useColorVarMax_;
-        Select(13);
+        Select(23);
     }
 
     public void SetColorVarMax(float colorVarMax_)
     {
         colorVarMax = colorVarMax_;
-        Select(14);
+        Select(24);
     }
 
     public void SetUseOpacityVarMin(boolean useOpacityVarMin_)
     {
         useOpacityVarMin = useOpacityVarMin_;
-        Select(15);
+        Select(25);
     }
 
     public void SetOpacityVarMin(float opacityVarMin_)
     {
         opacityVarMin = opacityVarMin_;
-        Select(16);
+        Select(26);
     }
 
     public void SetUseOpacityVarMax(boolean useOpacityVarMax_)
     {
         useOpacityVarMax = useOpacityVarMax_;
-        Select(17);
+        Select(27);
     }
 
     public void SetOpacityVarMax(float opacityVarMax_)
     {
         opacityVarMax = opacityVarMax_;
-        Select(18);
+        Select(28);
     }
 
     public void SetSmoothData(boolean smoothData_)
     {
         smoothData = smoothData_;
-        Select(19);
+        Select(29);
     }
 
     public void SetSamplesPerRay(int samplesPerRay_)
     {
         samplesPerRay = samplesPerRay_;
-        Select(20);
+        Select(30);
     }
 
     public void SetRendererType(int rendererType_)
     {
         rendererType = rendererType_;
-        Select(21);
+        Select(31);
     }
 
     public void SetGradientType(int gradientType_)
     {
         gradientType = gradientType_;
-        Select(22);
+        Select(32);
     }
 
     public void SetScaling(int scaling_)
     {
         scaling = scaling_;
-        Select(23);
+        Select(33);
     }
 
     public void SetSkewFactor(double skewFactor_)
     {
         skewFactor = skewFactor_;
-        Select(24);
+        Select(34);
     }
 
     public void SetLimitsMode(int limitsMode_)
     {
         limitsMode = limitsMode_;
-        Select(25);
+        Select(35);
     }
 
     public void SetSampling(int sampling_)
     {
         sampling = sampling_;
-        Select(26);
+        Select(36);
     }
 
     public void SetRendererSamples(float rendererSamples_)
     {
         rendererSamples = rendererSamples_;
-        Select(27);
+        Select(37);
     }
 
     public void SetLowGradientLightingReduction(int lowGradientLightingReduction_)
     {
         lowGradientLightingReduction = lowGradientLightingReduction_;
-        Select(28);
+        Select(38);
     }
 
     public void SetLowGradientLightingClampFlag(boolean lowGradientLightingClampFlag_)
     {
         lowGradientLightingClampFlag = lowGradientLightingClampFlag_;
-        Select(29);
+        Select(39);
     }
 
     public void SetLowGradientLightingClampValue(double lowGradientLightingClampValue_)
     {
         lowGradientLightingClampValue = lowGradientLightingClampValue_;
-        Select(30);
+        Select(40);
     }
 
     public void SetMaterialProperties(double[] materialProperties_)
@@ -489,7 +590,7 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
         materialProperties[1] = materialProperties_[1];
         materialProperties[2] = materialProperties_[2];
         materialProperties[3] = materialProperties_[3];
-        Select(31);
+        Select(41);
     }
 
     public void SetMaterialProperties(double e0, double e1, double e2, double e3)
@@ -498,10 +599,20 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
         materialProperties[1] = e1;
         materialProperties[2] = e2;
         materialProperties[3] = e3;
-        Select(31);
+        Select(41);
     }
 
     // Property getting methods
+    public boolean                  GetOsprayShadowsEnabledFlag() { return osprayShadowsEnabledFlag; }
+    public boolean                  GetOsprayUseGridAcceleratorFlag() { return osprayUseGridAcceleratorFlag; }
+    public boolean                  GetOsprayPreIntegrationFlag() { return osprayPreIntegrationFlag; }
+    public boolean                  GetOspraySingleShadeFlag() { return ospraySingleShadeFlag; }
+    public boolean                  GetOsprayOneSidedLightingFlag() { return osprayOneSidedLightingFlag; }
+    public boolean                  GetOsprayAoTransparencyEnabledFlag() { return osprayAoTransparencyEnabledFlag; }
+    public int                      GetOspraySpp() { return ospraySpp; }
+    public int                      GetOsprayAoSamples() { return osprayAoSamples; }
+    public double                   GetOsprayAoDistance() { return osprayAoDistance; }
+    public double                   GetOsprayMinContribution() { return osprayMinContribution; }
     public boolean                  GetLegendFlag() { return legendFlag; }
     public boolean                  GetLightingFlag() { return lightingFlag; }
     public ColorControlPointList    GetColorControlPoints() { return colorControlPoints; }
@@ -539,68 +650,88 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
     public void WriteAtts(CommunicationBuffer buf)
     {
         if(WriteSelect(0, buf))
-            buf.WriteBool(legendFlag);
+            buf.WriteBool(osprayShadowsEnabledFlag);
         if(WriteSelect(1, buf))
-            buf.WriteBool(lightingFlag);
+            buf.WriteBool(osprayUseGridAcceleratorFlag);
         if(WriteSelect(2, buf))
-            colorControlPoints.Write(buf);
+            buf.WriteBool(osprayPreIntegrationFlag);
         if(WriteSelect(3, buf))
-            buf.WriteFloat(opacityAttenuation);
+            buf.WriteBool(ospraySingleShadeFlag);
         if(WriteSelect(4, buf))
-            buf.WriteInt(opacityMode);
+            buf.WriteBool(osprayOneSidedLightingFlag);
         if(WriteSelect(5, buf))
-            opacityControlPoints.Write(buf);
+            buf.WriteBool(osprayAoTransparencyEnabledFlag);
         if(WriteSelect(6, buf))
-            buf.WriteBool(resampleFlag);
+            buf.WriteInt(ospraySpp);
         if(WriteSelect(7, buf))
-            buf.WriteInt(resampleTarget);
+            buf.WriteInt(osprayAoSamples);
         if(WriteSelect(8, buf))
-            buf.WriteString(opacityVariable);
+            buf.WriteDouble(osprayAoDistance);
         if(WriteSelect(9, buf))
-            buf.WriteString(compactVariable);
+            buf.WriteDouble(osprayMinContribution);
         if(WriteSelect(10, buf))
-            buf.WriteByteArray(freeformOpacity, true);
+            buf.WriteBool(legendFlag);
         if(WriteSelect(11, buf))
-            buf.WriteBool(useColorVarMin);
+            buf.WriteBool(lightingFlag);
         if(WriteSelect(12, buf))
-            buf.WriteFloat(colorVarMin);
+            colorControlPoints.Write(buf);
         if(WriteSelect(13, buf))
-            buf.WriteBool(useColorVarMax);
+            buf.WriteFloat(opacityAttenuation);
         if(WriteSelect(14, buf))
-            buf.WriteFloat(colorVarMax);
+            buf.WriteInt(opacityMode);
         if(WriteSelect(15, buf))
-            buf.WriteBool(useOpacityVarMin);
+            opacityControlPoints.Write(buf);
         if(WriteSelect(16, buf))
-            buf.WriteFloat(opacityVarMin);
+            buf.WriteBool(resampleFlag);
         if(WriteSelect(17, buf))
-            buf.WriteBool(useOpacityVarMax);
+            buf.WriteInt(resampleTarget);
         if(WriteSelect(18, buf))
-            buf.WriteFloat(opacityVarMax);
+            buf.WriteString(opacityVariable);
         if(WriteSelect(19, buf))
-            buf.WriteBool(smoothData);
+            buf.WriteString(compactVariable);
         if(WriteSelect(20, buf))
-            buf.WriteInt(samplesPerRay);
+            buf.WriteByteArray(freeformOpacity, true);
         if(WriteSelect(21, buf))
-            buf.WriteInt(rendererType);
+            buf.WriteBool(useColorVarMin);
         if(WriteSelect(22, buf))
-            buf.WriteInt(gradientType);
+            buf.WriteFloat(colorVarMin);
         if(WriteSelect(23, buf))
-            buf.WriteInt(scaling);
+            buf.WriteBool(useColorVarMax);
         if(WriteSelect(24, buf))
-            buf.WriteDouble(skewFactor);
+            buf.WriteFloat(colorVarMax);
         if(WriteSelect(25, buf))
-            buf.WriteInt(limitsMode);
+            buf.WriteBool(useOpacityVarMin);
         if(WriteSelect(26, buf))
-            buf.WriteInt(sampling);
+            buf.WriteFloat(opacityVarMin);
         if(WriteSelect(27, buf))
-            buf.WriteFloat(rendererSamples);
+            buf.WriteBool(useOpacityVarMax);
         if(WriteSelect(28, buf))
-            buf.WriteInt(lowGradientLightingReduction);
+            buf.WriteFloat(opacityVarMax);
         if(WriteSelect(29, buf))
-            buf.WriteBool(lowGradientLightingClampFlag);
+            buf.WriteBool(smoothData);
         if(WriteSelect(30, buf))
-            buf.WriteDouble(lowGradientLightingClampValue);
+            buf.WriteInt(samplesPerRay);
         if(WriteSelect(31, buf))
+            buf.WriteInt(rendererType);
+        if(WriteSelect(32, buf))
+            buf.WriteInt(gradientType);
+        if(WriteSelect(33, buf))
+            buf.WriteInt(scaling);
+        if(WriteSelect(34, buf))
+            buf.WriteDouble(skewFactor);
+        if(WriteSelect(35, buf))
+            buf.WriteInt(limitsMode);
+        if(WriteSelect(36, buf))
+            buf.WriteInt(sampling);
+        if(WriteSelect(37, buf))
+            buf.WriteFloat(rendererSamples);
+        if(WriteSelect(38, buf))
+            buf.WriteInt(lowGradientLightingReduction);
+        if(WriteSelect(39, buf))
+            buf.WriteBool(lowGradientLightingClampFlag);
+        if(WriteSelect(40, buf))
+            buf.WriteDouble(lowGradientLightingClampValue);
+        if(WriteSelect(41, buf))
             buf.WriteDoubleArray(materialProperties);
     }
 
@@ -609,101 +740,131 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
         switch(index)
         {
         case 0:
-            SetLegendFlag(buf.ReadBool());
+            SetOsprayShadowsEnabledFlag(buf.ReadBool());
             break;
         case 1:
-            SetLightingFlag(buf.ReadBool());
+            SetOsprayUseGridAcceleratorFlag(buf.ReadBool());
             break;
         case 2:
-            colorControlPoints.Read(buf);
-            Select(2);
+            SetOsprayPreIntegrationFlag(buf.ReadBool());
             break;
         case 3:
-            SetOpacityAttenuation(buf.ReadFloat());
+            SetOspraySingleShadeFlag(buf.ReadBool());
             break;
         case 4:
-            SetOpacityMode(buf.ReadInt());
+            SetOsprayOneSidedLightingFlag(buf.ReadBool());
             break;
         case 5:
-            opacityControlPoints.Read(buf);
-            Select(5);
+            SetOsprayAoTransparencyEnabledFlag(buf.ReadBool());
             break;
         case 6:
-            SetResampleFlag(buf.ReadBool());
+            SetOspraySpp(buf.ReadInt());
             break;
         case 7:
-            SetResampleTarget(buf.ReadInt());
+            SetOsprayAoSamples(buf.ReadInt());
             break;
         case 8:
-            SetOpacityVariable(buf.ReadString());
+            SetOsprayAoDistance(buf.ReadDouble());
             break;
         case 9:
-            SetCompactVariable(buf.ReadString());
+            SetOsprayMinContribution(buf.ReadDouble());
             break;
         case 10:
-            SetFreeformOpacity(buf.ReadByteArray());
+            SetLegendFlag(buf.ReadBool());
             break;
         case 11:
-            SetUseColorVarMin(buf.ReadBool());
+            SetLightingFlag(buf.ReadBool());
             break;
         case 12:
-            SetColorVarMin(buf.ReadFloat());
+            colorControlPoints.Read(buf);
+            Select(12);
             break;
         case 13:
-            SetUseColorVarMax(buf.ReadBool());
+            SetOpacityAttenuation(buf.ReadFloat());
             break;
         case 14:
-            SetColorVarMax(buf.ReadFloat());
+            SetOpacityMode(buf.ReadInt());
             break;
         case 15:
-            SetUseOpacityVarMin(buf.ReadBool());
+            opacityControlPoints.Read(buf);
+            Select(15);
             break;
         case 16:
-            SetOpacityVarMin(buf.ReadFloat());
+            SetResampleFlag(buf.ReadBool());
             break;
         case 17:
-            SetUseOpacityVarMax(buf.ReadBool());
+            SetResampleTarget(buf.ReadInt());
             break;
         case 18:
-            SetOpacityVarMax(buf.ReadFloat());
+            SetOpacityVariable(buf.ReadString());
             break;
         case 19:
-            SetSmoothData(buf.ReadBool());
+            SetCompactVariable(buf.ReadString());
             break;
         case 20:
-            SetSamplesPerRay(buf.ReadInt());
+            SetFreeformOpacity(buf.ReadByteArray());
             break;
         case 21:
-            SetRendererType(buf.ReadInt());
+            SetUseColorVarMin(buf.ReadBool());
             break;
         case 22:
-            SetGradientType(buf.ReadInt());
+            SetColorVarMin(buf.ReadFloat());
             break;
         case 23:
-            SetScaling(buf.ReadInt());
+            SetUseColorVarMax(buf.ReadBool());
             break;
         case 24:
-            SetSkewFactor(buf.ReadDouble());
+            SetColorVarMax(buf.ReadFloat());
             break;
         case 25:
-            SetLimitsMode(buf.ReadInt());
+            SetUseOpacityVarMin(buf.ReadBool());
             break;
         case 26:
-            SetSampling(buf.ReadInt());
+            SetOpacityVarMin(buf.ReadFloat());
             break;
         case 27:
-            SetRendererSamples(buf.ReadFloat());
+            SetUseOpacityVarMax(buf.ReadBool());
             break;
         case 28:
-            SetLowGradientLightingReduction(buf.ReadInt());
+            SetOpacityVarMax(buf.ReadFloat());
             break;
         case 29:
-            SetLowGradientLightingClampFlag(buf.ReadBool());
+            SetSmoothData(buf.ReadBool());
             break;
         case 30:
-            SetLowGradientLightingClampValue(buf.ReadDouble());
+            SetSamplesPerRay(buf.ReadInt());
             break;
         case 31:
+            SetRendererType(buf.ReadInt());
+            break;
+        case 32:
+            SetGradientType(buf.ReadInt());
+            break;
+        case 33:
+            SetScaling(buf.ReadInt());
+            break;
+        case 34:
+            SetSkewFactor(buf.ReadDouble());
+            break;
+        case 35:
+            SetLimitsMode(buf.ReadInt());
+            break;
+        case 36:
+            SetSampling(buf.ReadInt());
+            break;
+        case 37:
+            SetRendererSamples(buf.ReadFloat());
+            break;
+        case 38:
+            SetLowGradientLightingReduction(buf.ReadInt());
+            break;
+        case 39:
+            SetLowGradientLightingClampFlag(buf.ReadBool());
+            break;
+        case 40:
+            SetLowGradientLightingClampValue(buf.ReadDouble());
+            break;
+        case 41:
             SetMaterialProperties(buf.ReadDoubleArray());
             break;
         }
@@ -712,6 +873,16 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
     public String toString(String indent)
     {
         String str = new String();
+        str = str + boolToString("osprayShadowsEnabledFlag", osprayShadowsEnabledFlag, indent) + "\n";
+        str = str + boolToString("osprayUseGridAcceleratorFlag", osprayUseGridAcceleratorFlag, indent) + "\n";
+        str = str + boolToString("osprayPreIntegrationFlag", osprayPreIntegrationFlag, indent) + "\n";
+        str = str + boolToString("ospraySingleShadeFlag", ospraySingleShadeFlag, indent) + "\n";
+        str = str + boolToString("osprayOneSidedLightingFlag", osprayOneSidedLightingFlag, indent) + "\n";
+        str = str + boolToString("osprayAoTransparencyEnabledFlag", osprayAoTransparencyEnabledFlag, indent) + "\n";
+        str = str + intToString("ospraySpp", ospraySpp, indent) + "\n";
+        str = str + intToString("osprayAoSamples", osprayAoSamples, indent) + "\n";
+        str = str + doubleToString("osprayAoDistance", osprayAoDistance, indent) + "\n";
+        str = str + doubleToString("osprayMinContribution", osprayMinContribution, indent) + "\n";
         str = str + boolToString("legendFlag", legendFlag, indent) + "\n";
         str = str + boolToString("lightingFlag", lightingFlag, indent) + "\n";
         str = str + indent + "colorControlPoints = {\n" + colorControlPoints.toString(indent + "    ") + indent + "}\n";
@@ -749,6 +920,8 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
             str = str + "RENDERER_RAYCASTINGINTEGRATION";
         if(rendererType == RENDERER_RAYCASTINGSLIVR)
             str = str + "RENDERER_RAYCASTINGSLIVR";
+        if(rendererType == RENDERER_RAYCASTINGOSPRAY)
+            str = str + "RENDERER_RAYCASTINGOSPRAY";
         str = str + "\n";
         str = str + indent + "gradientType = ";
         if(gradientType == GRADIENTTYPE_CENTEREDDIFFERENCES)
@@ -806,6 +979,16 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
 
 
     // Attributes
+    private boolean                  osprayShadowsEnabledFlag;
+    private boolean                  osprayUseGridAcceleratorFlag;
+    private boolean                  osprayPreIntegrationFlag;
+    private boolean                  ospraySingleShadeFlag;
+    private boolean                  osprayOneSidedLightingFlag;
+    private boolean                  osprayAoTransparencyEnabledFlag;
+    private int                      ospraySpp;
+    private int                      osprayAoSamples;
+    private double                   osprayAoDistance;
+    private double                   osprayMinContribution;
     private boolean                  legendFlag;
     private boolean                  lightingFlag;
     private ColorControlPointList    colorControlPoints;
diff --git a/plots/Volume/avtVolumeFilter.C b/plots/Volume/avtVolumeFilter.C
index 23a1e585d..752176b8d 100644
--- a/plots/Volume/avtVolumeFilter.C
+++ b/plots/Volume/avtVolumeFilter.C
@@ -79,6 +79,13 @@
 #include <avtSLIVRRayTracer.h>
 #endif
 
+#ifdef VISIT_OSPRAY
+# define VISIT_OSPRAY_CONTEXT_ONLY /*dont have to include helper funcitons*/
+# include <avtOSPRayCommon.h>
+# undef VISIT_OSPRAY_CONTEXT_ONLY
+# include <avtOSPRayRayTracer.h>
+#endif
+
 //
 // Function Prototypes
 //
@@ -103,6 +110,9 @@ static void CreateViewInfoFromViewAttributes(avtViewInfo &,
 avtVolumeFilter::avtVolumeFilter()
 {
     primaryVariable = NULL;
+#ifdef VISIT_OSPRAY
+    ospray = NULL;
+#endif
 }
 
 
@@ -126,6 +136,11 @@ avtVolumeFilter::~avtVolumeFilter()
         delete [] primaryVariable;
         primaryVariable = NULL;
     }
+#ifdef VISIT_OSPRAY
+    if (ospray != NULL) {
+      delete (OSPVisItContext*)ospray;
+    }
+#endif
 }
 
 
@@ -225,10 +240,14 @@ avtVolumeFilter::Execute(void)
     int t1 = visitTimer->StartTimer();
 
     // Get the local histogram for this rank.
+    // const std::string variableName_ =
+    // 	(atts.GetScaling() == VolumeAttributes::Linear) ?
+    // 	primaryVariable : "_expr_" + std::string(primaryVariable);
+    // std::cout << "primaryVariable = " << primaryVariable << std::endl;
     std::vector<VISIT_LONG_LONG> numvals_in(numValsInHist, 0);
-    if( avtDatasetExaminer::CalculateHistogram(ds, primaryVariable,
-                                               minmax[0], minmax[1],
-                                               numvals_in) )
+    if(avtDatasetExaminer::CalculateHistogram(ds, primaryVariable,
+					      minmax[0], minmax[1],
+					      numvals_in))
         
     {
       debug1 << "CalculateHistogram failed for "
@@ -237,8 +256,8 @@ avtVolumeFilter::Execute(void)
 
     // Get the global histograms acrosss all ranks.
     std::vector<VISIT_LONG_LONG> numvals_out(numValsInHist, 0);
-    SumLongLongArrayAcrossAllProcessors( &(numvals_in[0]),
-                                         &(numvals_out[0]), numValsInHist);
+    SumLongLongArrayAcrossAllProcessors(&(numvals_in[0]),
+					&(numvals_out[0]), numValsInHist);
     
     VISIT_LONG_LONG maxVal = 0;
     for (i = 0 ; i < numValsInHist ; i++)
@@ -292,20 +311,36 @@ avtVolumeFilter::CreateOpacityMap(double range[2])
     if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR)
     {
         // Set the opacity map. This modifies the opacities though.
-        om.SetTable(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0, atts.GetRendererSamples());
-        om.SetTableFloat(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0, atts.GetRendererSamples());
+        om.SetTable(vtf, 256, atts.GetOpacityAttenuation() * 2.0 - 1.0,
+                    atts.GetRendererSamples());
+        om.SetTableFloat(vtf, 256, atts.GetOpacityAttenuation() * 2.0 - 1.0,
+                         atts.GetRendererSamples());
     }
     else
 #endif
     {
-        if ((atts.GetRendererType() == VolumeAttributes::RayCasting) && (atts.GetSampling() == VolumeAttributes::Trilinear))
-            om.SetTable(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0, atts.GetRendererSamples());
+#ifdef VISIT_OSPRAY
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay)
+    {
+        om.SetTable(vtf, 256, atts.GetOpacityAttenuation() * 2.0 - 1.0, 
+                    atts.GetRendererSamples());
+	om.SetTableFloatNOC(vtf, 256,
+			    atts.GetOpacityAttenuation() * 2.0 - 1.0); 
+    }
+    else
+#endif
+    {
+        if ((atts.GetRendererType() == VolumeAttributes::RayCasting) && 
+            (atts.GetSampling() == VolumeAttributes::Trilinear))
+            om.SetTable(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0,
+			atts.GetRendererSamples());
         else
         {
             // Set the opacity map just using the transfer function.
             om.SetTable(vtf, 256, atts.GetOpacityAttenuation());
         }
     }
+    }
 
     double actualRange[2];
     bool artificialMin = atts.GetUseColorVarMin();
@@ -345,7 +380,7 @@ avtVolumeFilter::CreateOpacityMap(double range[2])
     }
     om.SetMin(range[0]);
     om.SetMax(range[1]);
-    om.computeVisibleRange();
+    om.ComputeVisibleRange();
 
     if (atts.GetRendererType() == VolumeAttributes::RayCastingIntegration)
     {
@@ -370,11 +405,13 @@ avtVolumeFilter::CreateOpacityMap(double range[2])
     return om;
 }
 
-extern bool GetLogicalBounds(avtDataObject_p input,int &width,int &height, int &depth);
+extern bool GetLogicalBounds(avtDataObject_p input,
+			     int &width,int &height, int &depth);
+
+#if defined(VISIT_SLIVR) || defined(VISIT_OSPRAY)
 
-#ifdef VISIT_SLIVR
 // ****************************************************************************
-//  Method: avtVolumeFilter::RenderImageRaycastingSLIVR
+//  Method: avtVolumeFilter::RenderImageRayCasting
 //
 //  Purpose:
 //      Do SW rendering with SLIVR.
@@ -389,8 +426,8 @@ extern bool GetLogicalBounds(avtDataObject_p input,int &width,int &height, int &
 // ****************************************************************************
 
 avtImage_p
-avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
-                             const WindowAttributes &window)
+avtVolumeFilter::RenderImageRayCasting(avtImage_p opaque_image,
+                                 const WindowAttributes &window)
 {
     //
     // We need to create a dummy pipeline with the volume renderer that we
@@ -401,7 +438,23 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     //
     // Set up the volume renderer.
     //
-    avtSLIVRRayTracer *software = new avtSLIVRRayTracer;
+    avtRayTracerBase *software = nullptr;
+#ifdef VISIT_SLIVR
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) {        
+        software = new avtSLIVRRayTracer;
+    }
+    else
+#endif
+    {
+#ifdef VISIT_OSPRAY
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay) {
+        software = new avtOSPRayRayTracer;
+        if (ospray == NULL) { ospray = new OSPVisItContext; }
+        ((avtOSPRayRayTracer*)software)->SetOSPRay
+                                           ((OSPVisItContext*)ospray);
+    }
+#endif
+    }
     software->SetInput(termsrc.GetOutput());
     software->InsertOpaqueImage(opaque_image);
 
@@ -410,7 +463,7 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     //
     double range[2] = {0., 0.};
     avtOpacityMap om(CreateOpacityMap(range));
-    om.computeVisibleRange();
+    om.ComputeVisibleRange();
 
     avtFlatLighting fl;
     avtLightingModel *lm = &fl;
@@ -418,9 +471,9 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     avtCompositeRF *compositeRF = new avtCompositeRF(lm, &om, &om);
     software->SetTransferFn(&om);
 
-    debug5 << "Min visible scalar range:" << om.GetMinVisibleScalar() << "  Max visible scalar range: "  <<  om.GetMaxVisibleScalar() << std::endl;
-
-
+    debug5 << "Min visible scalar range: " << om.GetMinVisibleScalar() << " "
+           << "Max visible scalar range: " << om.GetMaxVisibleScalar()
+           << std::endl;
 
     //
     // Determine which variables to use and tell the ray function.
@@ -437,7 +490,8 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     const char *gradvar = atts.GetOpacityVariable().c_str();
     if (strcmp(gradvar, "default") == 0)
         gradvar = primaryVariable;
-    // This name is explicitly sent to the avtGradientExpression in avtVolumePlot.
+    // This name is explicitly sent to the avtGradientExpression in
+    // avtVolumePlot.
     SNPRINTF(gradName, 128, "_%s_gradient", gradvar);
 
     for (int i = 0 ; i < vl.nvars ; i++)
@@ -454,10 +508,10 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
         {
             opacIndex = count;
         }
-       // if (vl.varnames[i] == gradName)
-       // {
-       //     gradIndex = count;
-       // }
+	// if (vl.varnames[i] == gradName)
+	// {
+	//     gradIndex = count;
+	// }
         count += vl.varsizes[i];
     }
 
@@ -494,16 +548,12 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
         }
     }
 
-
     //
     // Unsure about this one??? RayFunction seems important
     //
     software->SetRayFunction(compositeRF);
     software->SetSamplesPerRay(atts.GetSamplesPerRay());
-
-    debug5 << "Sampling rate: "  << atts.GetRendererSamples() << std::endl;
-
-
+    debug5 << "Sampling rate: " << atts.GetRendererSamples() << std::endl;
 
     //
     // Set camera parameters
@@ -521,66 +571,90 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     {
         double viewDirection[3];
         int numSlices;
-
-        viewDirection[0] = (view.GetViewNormal()[0] > 0)? view.GetViewNormal()[0]: -view.GetViewNormal()[0];
-        viewDirection[1] = (view.GetViewNormal()[1] > 0)? view.GetViewNormal()[1]: -view.GetViewNormal()[1];
-        viewDirection[2] = (view.GetViewNormal()[2] > 0)? view.GetViewNormal()[2]: -view.GetViewNormal()[2];
-
-        numSlices = (width_*viewDirection[0] + height_*viewDirection[1] + depth_*viewDirection[2]) * atts.GetRendererSamples();
-
+        viewDirection[0] = (view.GetViewNormal()[0] > 0)?
+	    view.GetViewNormal()[0]:
+            -view.GetViewNormal()[0];
+        viewDirection[1] = (view.GetViewNormal()[1] > 0)?
+	    view.GetViewNormal()[1]:
+            -view.GetViewNormal()[1];
+        viewDirection[2] = (view.GetViewNormal()[2] > 0)?
+	    view.GetViewNormal()[2]: 
+            -view.GetViewNormal()[2];
+        numSlices = (width_ * viewDirection[0] +
+                     height_* viewDirection[1] + 
+                     depth_ * viewDirection[2]) * atts.GetRendererSamples();
         software->SetSamplesPerRay(numSlices);
-        debug5 << "RayCastingSLIVR - slices: "<< numSlices << " : " << width_ << " ,  " << height_  << " , " << depth_ << endl;
     }
-
     software->SetView(vi);
 
-    double view_dir[3];
-    view_dir[0] = vi.focus[0] - vi.camera[0];
-    view_dir[1] = vi.focus[1] - vi.camera[1];
-    view_dir[2] = vi.focus[2] - vi.camera[2];
-    double mag = sqrt(view_dir[0]*view_dir[0] + view_dir[1]*view_dir[1]
-                      + view_dir[2]*view_dir[2]);
+    double viewDirection[3];
+    viewDirection[0] = vi.focus[0] - vi.camera[0];
+    viewDirection[1] = vi.focus[1] - vi.camera[1];
+    viewDirection[2] = vi.focus[2] - vi.camera[2];
+    double mag = sqrt(viewDirection[0]*viewDirection[0] + viewDirection[1]*viewDirection[1]
+                      + viewDirection[2]*viewDirection[2]);
     if (mag != 0.) // only 0 if focus and camera are the same
     {
-        view_dir[0] /= mag;
-        view_dir[1] /= mag;
-        view_dir[2] /= mag;
+        viewDirection[0] /= mag;
+        viewDirection[1] /= mag;
+        viewDirection[2] /= mag;
     }
-    software->SetViewDirection(view_dir);
 
     //
     // Set up lighting and material properties
     //
-    if (atts.GetLightingFlag())
-        software->SetLighting(true);
-    else
-        software->SetLighting(false);
-
-    double tempLightDir[3];
-    tempLightDir[0] = ((window.GetLights()).GetLight(0)).GetDirection()[0];
-    tempLightDir[1] = ((window.GetLights()).GetLight(0)).GetDirection()[1];
-    tempLightDir[2] = ((window.GetLights()).GetLight(0)).GetDirection()[2];
-    software->SetLightDirection(tempLightDir);
-
     double *matProp = atts.GetMaterialProperties();
     double materialPropArray[4];
     materialPropArray[0] = matProp[0];
     materialPropArray[1] = matProp[1];
     materialPropArray[2] = matProp[2];
     materialPropArray[3] = matProp[3];
-    software->SetMatProperties(materialPropArray);
-
-
+    
+#ifdef VISIT_SLIVR
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) {
+      double tempLightDir[3];
+      tempLightDir[0] = ((window.GetLights()).GetLight(0)).GetDirection()[0];
+      tempLightDir[1] = ((window.GetLights()).GetLight(0)).GetDirection()[1];
+      tempLightDir[2] = ((window.GetLights()).GetLight(0)).GetDirection()[2];      
+      avtSLIVRRayTracer* s = (avtSLIVRRayTracer*)software;
+      s->SetViewDirection(viewDirection);
+      s->SetLighting(atts.GetLightingFlag());
+      s->SetLightDirection(tempLightDir);
+      s->SetMatProperties(materialPropArray);
+    } else
+#endif
+    {
+#ifdef VISIT_OSPRAY
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay) {
+      avtOSPRayRayTracer* s = (avtOSPRayRayTracer*)software;
+      s->SetActiveVariable(primaryVariable);
+      s->SetLightInfo(window.GetLights());
+      s->SetMatProperties(materialPropArray);
+      s->SetViewDirection(viewDirection);
+      s->SetLighting(atts.GetLightingFlag());
+      s->SetSamplingRate(atts.GetRendererSamples());
+      s->SetShadowsEnabled(atts.GetOsprayShadowsEnabledFlag());
+      s->SetUseGridAccelerator(atts.GetOsprayUseGridAcceleratorFlag());
+      s->SetPreIntegration(atts.GetOsprayPreIntegrationFlag());
+      s->SetSingleShade(atts.GetOspraySingleShadeFlag());
+      s->SetOneSidedLighting(atts.GetOsprayOneSidedLightingFlag());
+      s->SetAoTransparencyEnabled(atts.GetOsprayAoTransparencyEnabledFlag());
+      s->SetSpp(atts.GetOspraySpp());
+      s->SetAoSamples(atts.GetOsprayAoSamples());
+      s->SetAoDistance(atts.GetOsprayAoDistance());
+      s->SetMinContribution(atts.GetOsprayMinContribution());
+    }
+#endif
+    }
 
     //
     // Set the volume renderer's background color and mode from the
     // window attributes.
     //
-    //software->SetBackgroundMode(window.GetBackgroundMode());
     software->SetBackgroundColor(window.GetBackground());
+    //software->SetBackgroundMode(window.GetBackgroundMode());
     //software->SetGradientBackgroundColors(window.GetGradBG1(), window.GetGradBG2());
 
-
     //
     // Do the funny business to force an update. ... and called avtDataObject
     //
@@ -592,7 +666,6 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     //
     delete software;
     avtRay::SetArbitrator(NULL);
-
     delete compositeRF;
 
     //
@@ -715,9 +788,10 @@ avtImage_p
 avtVolumeFilter::RenderImage(avtImage_p opaque_image,
                              const WindowAttributes &window)
 {
-#ifdef VISIT_SLIVR
-    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR){
-        return RenderImageRaycastingSLIVR(opaque_image,window);
+#if defined(VISIT_SLIVR) || defined(VISIT_SLIVR)
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+        atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay){
+        return RenderImageRayCasting(opaque_image,window);
     }
 #endif
 
@@ -1247,7 +1321,8 @@ avtVolumeFilter::ModifyContract(avtContract_p contract)
     {
         if (((atts.GetRendererType() == VolumeAttributes::RayCasting) &&
             (atts.GetSampling() == VolumeAttributes::Trilinear)) ||
-            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR))
+            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) ||
+            (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay))
             ds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
         newcontract = new avtContract(contract, ds);
         primaryVariable = new char[strlen(var)+1];
@@ -1272,7 +1347,8 @@ avtVolumeFilter::ModifyContract(avtContract_p contract)
 
         if (((atts.GetRendererType() == VolumeAttributes::RayCasting) &&
             (atts.GetSampling() == VolumeAttributes::Trilinear)) ||
-            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR))
+            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) ||
+            (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay))
             nds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
         newcontract = new avtContract(contract, nds);
         primaryVariable = new char[exprName.size()+1];
@@ -1289,7 +1365,8 @@ avtVolumeFilter::ModifyContract(avtContract_p contract)
         nds->AddSecondaryVariable(var);
         if (((atts.GetRendererType() == VolumeAttributes::RayCasting) &&
             (atts.GetSampling() == VolumeAttributes::Trilinear)) ||
-            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR))
+            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) ||
+            (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay))
             nds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
         newcontract = new avtContract(contract, nds);
         primaryVariable = new char[strlen(exprName.c_str())+1];
diff --git a/plots/Volume/avtVolumeFilter.h b/plots/Volume/avtVolumeFilter.h
index d60df439e..675a8121b 100644
--- a/plots/Volume/avtVolumeFilter.h
+++ b/plots/Volume/avtVolumeFilter.h
@@ -44,11 +44,11 @@
 #define AVT_VOLUME_FILTER_H
 
 #include <avtDatasetToDatasetFilter.h>
-#include <avtOpacityMap.h>
 
 #include <VolumeAttributes.h>
 
 #include <avtImage.h>
+#include <avtOpacityMap.h>
 
 class     WindowAttributes;
 
@@ -75,6 +75,9 @@ class     WindowAttributes;
 //    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
 //    Added support for rectilinear grids with an inherent transform.
 //
+//    Qi WU, Wed Jun 20 2018
+//    Added support for ospray volume rendering filter
+//
 // ****************************************************************************
 
 class avtVolumeFilter : public avtDatasetToDatasetFilter
@@ -89,15 +92,22 @@ class avtVolumeFilter : public avtDatasetToDatasetFilter
                                   { return "Volume rendering"; };
 
     avtImage_p               RenderImage(avtImage_p, const WindowAttributes &);
-#ifdef VISIT_SLIVR
-    avtImage_p               RenderImageRaycastingSLIVR(avtImage_p opaque_image, const WindowAttributes &);
+    
+#if defined(VISIT_SLIVR) || defined(VISIT_OSPRAY)
+    avtImage_p               RenderImageRayCasting(avtImage_p,
+                                                   const WindowAttributes &);
 #endif
+
     int                      GetNumberOfStages(const WindowAttributes &);
 
   protected:
     VolumeAttributes         atts;
     char                    *primaryVariable;
 
+#ifdef VISIT_OSPRAY /* handler for ospray volume rendering filter*/
+    void                    *ospray;
+#endif
+
     avtOpacityMap            CreateOpacityMap(double range[2]);
 
     virtual void             Execute(void);
diff --git a/plots/Volume/avtVolumePlot.C b/plots/Volume/avtVolumePlot.C
index ecdf4b192..6ef3990c6 100644
--- a/plots/Volume/avtVolumePlot.C
+++ b/plots/Volume/avtVolumePlot.C
@@ -233,7 +233,8 @@ avtVolumePlot::PlotIsImageBased(void)
 {
     return (atts.GetRendererType() == VolumeAttributes::RayCasting ||
             atts.GetRendererType() == VolumeAttributes::RayCastingIntegration ||
-            atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR);
+            atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+            atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay);
 }
 
 
@@ -689,7 +690,8 @@ avtVolumePlot::ApplyRenderingTransformation(avtDataObject_p input)
 
     if (atts.GetRendererType() == VolumeAttributes::RayCasting ||
         atts.GetRendererType() == VolumeAttributes::RayCastingIntegration ||
-        atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR)
+        atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+        atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay)
     {
 #ifdef ENGINE
         // gradient calc for raycasting integration not needed, but
diff --git a/svn_bin/bv_support/bv_embree.sh b/svn_bin/bv_support/bv_embree.sh
new file mode 100644
index 000000000..999e14880
--- /dev/null
+++ b/svn_bin/bv_support/bv_embree.sh
@@ -0,0 +1,171 @@
+function bv_embree_initialize
+{
+    export DO_EMBREE="no"
+    export USE_SYSTEM_EMBREE="no"
+    add_extra_commandline_args "embree" "alt-embree-dir" 1 "Use alternative directory for embree"
+}
+
+function bv_embree_enable
+{
+    DO_EMBREE="yes"
+}
+
+function bv_embree_disable
+{
+    DO_EMBREE="no"
+}
+
+function bv_embree_alt_embree_dir
+{
+    echo "Using alternate embree directory"
+    bv_embree_enable
+    USE_SYSTEM_EMBREE="yes"
+    EMBREE_INSTALL_DIR="$1"
+}
+
+function bv_embree_depends_on
+{
+    echo ""
+}
+
+function bv_embree_initialize_vars
+{
+    info "initializing embree vars"
+    if [[ "$DO_EMBREE" == "yes" ]] ; then
+        if [[ "$USE_SYSTEM_EMBREE" == "no" ]]; then
+            EMBREE_INSTALL_DIR=$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH
+        fi
+    fi
+}
+
+function bv_embree_info
+{
+    export EMBREE_VERSION=${EMBREE_VERSION:-"3.2.0"}
+    if [[ "$OPSYS" == "Darwin" ]] ; then
+        export EMBREE_FILE=${EMBREE_FILE:-"embree-${EMBREE_VERSION}.x86_64.macosx.tar.gz"}
+    else
+        export EMBREE_FILE=${EMBREE_FILE:-"embree-${EMBREE_VERSION}.x86_64.linux.tar.gz"}
+    fi
+    export EMBREE_COMPATIBILITY_VERSION=${EMBREE_COMPATIBILITY_VERSION:-"${EMBREE_VERSION}"}
+    export EMBREE_BUILD_DIR=${EMBREE_BUILD_DIR:-"${EMBREE_VERSION}"}
+    export EMBREE_URL=${EMBREE_URL:-"https://github.com/embree/embree/releases/download/v${EMBREE_VERSION}/"}
+    export EMBREE_INSTALL_DIR_NAME=embree-$EMBREE_VERSION.x86_64.linux
+    export EMBREE_MD5_CHECKSUM=""
+    export EMBREE_SHA256_CHECKSUM=""
+}
+
+function bv_embree_print
+{
+    printf "%s%s\n" "EMBREE_FILE=" "${EMBREE_FILE}"
+    printf "%s%s\n" "EMBREE_VERSION=" "${EMBREE_VERSION}"
+    printf "%s%s\n" "EMBREE_COMPATIBILITY_VERSION=" "${EMBREE_COMPATIBILITY_VERSION}"
+    printf "%s%s\n" "EMBREE_BUILD_DIR=" "${EMBREE_BUILD_DIR}"
+}
+
+function bv_embree_host_profile
+{
+    if [[ "$DO_EMBREE" == "yes" ]] ; then
+        echo >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        echo "## EMBREE" >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        if [[ "$USE_SYSTEM_EMBREE" == "no" ]]; then
+            echo "VISIT_OPTION_DEFAULT(VISIT_EMBREE_ROOT \${VISITHOME}/embree/$EMBREE_VERSION/\${VISITARCH})" >> $HOSTCONF
+        else
+            echo "VISIT_OPTION_DEFAULT(VISIT_EMBREE_ROOT ${EMBREE_INSTALL_DIR})" >> $HOSTCONF
+        fi
+    fi
+}
+
+function bv_embree_print_usage
+{
+    #embree does not have an option, it is only dependent on embree.
+    printf "%-15s %s [%s]\n" "--embree" "Build embree" "$DO_EMBREE"
+}
+
+function bv_embree_ensure
+{
+    if [[ "$DO_EMBREE" == "yes" && "$USE_SYSTEM_EMBREE" == "no" ]] ; then
+        ensure_built_or_ready "embree" $EMBREE_VERSION $EMBREE_BUILD_DIR $EMBREE_FILE $EMBREE_URL
+        if [[ $? != 0 ]] ; then
+            ANY_ERRORS="yes"
+            DO_EMBREE="no"
+            error "Unable to build embree.  ${EMBREE_FILE} not found."
+        fi
+    elif [[ "$USE_SYSTEM_EMBREE" == "yes" ]] ; then
+        if [[ ! -d $EMBREE_INSTALL_DIR/include/embree3 ]]; then
+            error "Unable to find embree v3.+ in the alternative path, perhaps a wrong embree version is provided."
+        fi
+    fi
+}
+
+function bv_embree_dry_run
+{
+    if [[ "$DO_EMBREE" == "yes" ]] ; then
+        echo "Dry run option not set for embree."
+    fi
+}
+
+# ***************************************************************************
+# build_embree
+#
+# Modifications:
+#
+# ***************************************************************************
+
+function build_embree
+{
+    # Unzip the EMBREE tarball and copy it to the VisIt installation.
+    info "Installing prebuilt embree"    
+    tar zxvf $EMBREE_FILE
+    rm $EMBREE_INSTALL_DIR_NAME/lib/libtbbmalloc.so.2
+    rm $EMBREE_INSTALL_DIR_NAME/lib/libtbb.so.2
+    mkdir -p $VISITDIR/embree/$EMBREE_VERSION/$VISITARCH
+    cp -R $EMBREE_INSTALL_DIR_NAME/* "$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH"
+    rm -rf $EMBREE_INSTALL_DIR_NAME
+    if [[ "$DO_GROUP" == "yes" ]] ; then
+        chmod -R ug+w,a+rX "$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH"
+        chgrp -R ${GROUP} "$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH"
+    fi
+    cd "$START_DIR"
+    info "Done with embree"
+    return 0
+}
+
+function bv_embree_is_enabled
+{
+    if [[ $DO_EMBREE == "yes" ]]; then
+        return 1    
+    fi
+    return 0
+}
+
+function bv_embree_is_installed
+{
+    if [[ "$USE_SYSTEM_EMBREE" == "yes" ]]; then   
+        return 1
+    fi
+
+    check_if_installed "embree" $EMBREE_VERSION
+    if [[ $? == 0 ]] ; then
+        return 1
+    fi
+    return 0
+}
+
+function bv_embree_build
+{
+    if [[ "$DO_EMBREE" == "yes" && "$USE_SYSTEM_EMBREE" == "no" ]] ; then
+        check_if_installed "embree" $EMBREE_VERSION
+        if [[ $? == 0 ]] ; then
+            info "Skipping build of embree"
+        else
+            build_embree
+            if [[ $? != 0 ]] ; then
+                error "Unable to build or install embree.  Bailing out."
+            fi
+            info "Done building embree"
+        fi
+    fi
+}
+
diff --git a/svn_bin/bv_support/bv_ispc.sh b/svn_bin/bv_support/bv_ispc.sh
new file mode 100644
index 000000000..1327b5eff
--- /dev/null
+++ b/svn_bin/bv_support/bv_ispc.sh
@@ -0,0 +1,166 @@
+function bv_ispc_initialize
+{
+    export DO_ISPC="no"
+    export USE_SYSTEM_ISPC="no"
+    add_extra_commandline_args "ispc" "alt-ispc-dir" 1 "Use alternative directory for ispc"
+}
+
+function bv_ispc_enable
+{
+    DO_ISPC="yes"
+}
+
+function bv_ispc_disable
+{
+    DO_ISPC="no"
+}
+
+function bv_ispc_alt_ispc_dir
+{
+    echo "Using alternate ispc directory"
+    bv_ispc_enable
+    USE_SYSTEM_ISPC="yes"
+    ISPC_INSTALL_DIR="$1"
+}
+
+function bv_ispc_depends_on
+{
+    echo ""
+}
+
+function bv_ispc_initialize_vars
+{
+    info "initializing ispc vars"
+    if [[ "$DO_ISPC" == "yes" ]] ; then
+        if [[ "$USE_SYSTEM_ISPC" == "no" ]]; then
+            ISPC_INSTALL_DIR=$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH
+        fi
+    fi
+}
+
+function bv_ispc_info
+{
+    export ISPC_VERSION=${ISPC_VERSION:-"1.9.2"}
+    if [[ "$OPSYS" == "Darwin" ]] ; then
+        export ISPC_FILE=${ISPC_FILE:-"ispc-v${ISPC_VERSION}-osx.tar.gz"}
+        export ISPC_URL=${ISPC_URL:-"http://sdvis.org/ospray/download/dependencies/osx/"}
+    else
+        export ISPC_FILE=${ISPC_FILE:-"ispc-v${ISPC_VERSION}-linux.tar.gz"}
+        export ISPC_URL=${ISPC_URL:-"http://sdvis.org/ospray/download/dependencies/linux/"}
+    fi
+    export ISPC_COMPATIBILITY_VERSION=${ISPC_COMPATIBILITY_VERSION:-"${ISPC_VERSION}"}
+    export ISPC_BUILD_DIR=${ISPC_BUILD_DIR:-"${ISPC_VERSION}"}
+    export ISPC_INSTALL_DIR_NAME=ispc-v$ISPC_VERSION-linux
+    export ISPC_MD5_CHECKSUM=""
+    export ISPC_SHA256_CHECKSUM=""
+}
+
+function bv_ispc_print
+{
+    printf "%s%s\n" "ISPC_FILE=" "${ISPC_FILE}"
+    printf "%s%s\n" "ISPC_VERSION=" "${ISPC_VERSION}"
+    printf "%s%s\n" "ISPC_COMPATIBILITY_VERSION=" "${ISPC_COMPATIBILITY_VERSION}"
+    printf "%s%s\n" "ISPC_BUILD_DIR=" "${ISPC_BUILD_DIR}"
+}
+
+function bv_ispc_host_profile
+{
+    if [[ "$DO_ISPC" == "yes" ]]; then
+        echo >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        echo "## ISPC" >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        if [[ "$USE_SYSTEM_ISPC" == "no" ]]; then
+            echo "VISIT_OPTION_DEFAULT(VISIT_ISPC_ROOT \${VISITHOME}/ispc/$ISPC_VERSION/\${VISITARCH})" >> $HOSTCONF
+        else
+            echo "VISIT_OPTION_DEFAULT(VISIT_ISPC_ROOT ${ISPC_INSTALL_DIR})" >> $HOSTCONF
+        fi
+    fi
+}
+
+function bv_ispc_print_usage
+{
+    #ispc does not have an option, it is only dependent on ispc.
+    printf "%-15s %s [%s]\n" "--ispc" "Build ISPC" "$DO_ISPC"
+}
+
+function bv_ispc_ensure
+{
+    if [[ "$DO_ISPC" == "yes" && "$USE_SYSTEM_ISPC" == "no" ]] ; then
+        ensure_built_or_ready "ispc" $ISPC_VERSION $ISPC_BUILD_DIR $ISPC_FILE $ISPC_URL
+        if [[ $? != 0 ]] ; then
+            ANY_ERRORS="yes"
+            DO_ISPC="no"
+            error "Unable to build ISPC.  ${ISPC_FILE} not found."
+        fi
+    fi
+}
+
+function bv_ispc_dry_run
+{
+    if [[ "$DO_ISPC" == "yes" ]] ; then
+        echo "Dry run option not set for ISPC."
+    fi
+}
+
+# ***************************************************************************
+# build_ispc
+#
+# Modifications:
+#
+# ***************************************************************************
+
+function build_ispc
+{
+    # Unzip the ISPC tarball and copy it to the VisIt installation.
+    info "Installing prebuilt ISPC"    
+    tar zxvf $ISPC_FILE
+    mkdir -p $VISITDIR/ispc/$ISPC_VERSION/$VISITARCH
+    cp -R $ISPC_INSTALL_DIR_NAME/* "$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH"
+    rm -rf $ISPC_INSTALL_DIR_NAME
+    if [[ "$DO_GROUP" == "yes" ]] ; then
+        chmod -R ug+w,a+rX "$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH"
+        chgrp -R ${GROUP} "$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH"
+    fi
+    cd "$START_DIR"
+    info "Done with ISPC"
+    return 0
+}
+
+function bv_ispc_is_enabled
+{
+    if [[ $DO_ISPC == "yes" ]]; then
+        return 1    
+    fi
+    return 0
+}
+
+function bv_ispc_is_installed
+{
+    if [[ "$USE_SYSTEM_ISPC" == "yes" ]]; then   
+        return 1
+    fi
+
+    check_if_installed "ispc" $ISPC_VERSION
+    if [[ $? == 0 ]] ; then
+        return 1
+    fi
+    return 0
+}
+
+function bv_ispc_build
+{
+    if [[ "$DO_ISPC" == "yes" && "$USE_SYSTEM_ISPC" == "no" ]] ; then
+        check_if_installed "ispc" $ISPC_VERSION
+        if [[ $? == 0 ]] ; then
+            info "Skipping build of ISPC"
+        else
+            build_ispc
+            if [[ $? != 0 ]] ; then
+                error "Unable to build or install ISPC.  Bailing out."
+            fi
+            info "Done building ISPC"
+        fi
+    fi
+}
+
diff --git a/svn_bin/bv_support/bv_ospray.sh b/svn_bin/bv_support/bv_ospray.sh
index 0db31d351..de5dbf93b 100644
--- a/svn_bin/bv_support/bv_ospray.sh
+++ b/svn_bin/bv_support/bv_ospray.sh
@@ -1,6 +1,11 @@
+# Module automatically read in from construct_build_visit
+# Insert header and comments
 function bv_ospray_initialize
 {
     export DO_OSPRAY="no"
+    export USE_SYSTEM_OSPRAY="no"
+    export OSPRAY_CONFIG_DIR=""
+    add_extra_commandline_args "ospray" "alt-ospray-dir" 1 "Use alternative directory for ospray"
 }
 
 function bv_ospray_enable
@@ -13,26 +18,64 @@ function bv_ospray_disable
     DO_OSPRAY="no"
 }
 
+function bv_ospray_alt_ospray_dir
+{
+    echo "Using alternate ospray directory"
+    bv_ospray_enable
+    USE_SYSTEM_OSPRAY="ospray"
+    OSPRAY_CONFIG_DIR="$1"
+}
+
+function bv_ospray_check_openmp
+{
+    _OPENMP=$(echo | cpp -fopenmp -dM | grep -i open)
+    if [[ "$_OPENMP" == "#define _OPENMP"* ]]; then
+        return 0
+    fi
+    return -1
+}
+
 function bv_ospray_depends_on
 {
-    depends_on=""
+    depends_on="cmake ispc embree"
+
+    if [[ "$DO_TBB" == "yes" ]]; then
+        depends_on="${depends_on} tbb"
+    else
+        bv_ospray_check_openmp
+        if [[ $? == -1 ]]; then
+            depends_on="${depends_on} tbb"
+        fi
+    fi
 
     echo ${depends_on}
 }
 
 function bv_ospray_info
 {
+    # versions
     export OSPRAY_VERSION=${OSPRAY_VERSION:-"1.6.1"}
-    export OSPRAY_FILE=${OSPRAY_FILE:-"ospray-${OSPRAY_VERSION}.x86_64.linux.tar.gz"}
-    export OSPRAY_BUILD_DIR=${OSPRAY_BUILD_DIR:-"ospray-${OSPRAY_VERSION}.x86_64.linux"}
-    export OSPRAY_URL=${OSPRAY_URL:-"https://github.com/ospray/ospray/releases/download/v${OSPRAY_VERSION}/"}
+    export OSPRAY_VISIT_MODULE_VERSION=${OSPRAY_VISIT_MODULE_VERSION:-"1.6.x"}
+    
+    # ospray source
+    export OSPRAY_TARBALL=${OSPRAY_TARBALL:-"ospray-${OSPRAY_VERSION}.tar.gz"}
+    export OSPRAY_BUILD_DIR=${OSPRAY_BUILD_DIR:-"ospray-${OSPRAY_VERSION}"}
+    export OSPRAY_DOWNLOAD_URL=${OSPRAY_DOWNLOAD_URL:-"https://github.com/wilsonCernWq/module_visit/releases/download/v1.6.x"}
+
+    # ospray module
+    export OSPRAY_VISIT_MODULE_TARBALL=${OSPRAY_VISIT_MODULE_TARBALL:-"module_visit-${OSPRAY_VISIT_MODULE_VERSION}.zip"}
+    export OSPRAY_VISIT_MODULE_UNTAR_DIR=${OSPRAY_VISIT_MODULE_UNTAR_DIR:-"module_visit-${OSPRAY_VISIT_MODULE_VERSION}"}
+    export OSPRAY_VISIT_MODULE_BUILD_DIR=${OSPRAY_VISIT_MODULE_BUILD_DIR:-"${OSPRAY_BUILD_DIR}/modules/module_visit"}
+    export OSPRAY_VISIT_MODULE_DOWNLOAD_URL=${OSPRAY_VISIT_MODULE_DOWNLOAD_URL:-"https://github.com/wilsonCernWq/module_visit/releases/download/v1.6.x"}
+    
+    # checksum
     export OSPRAY_MD5_CHECKSUM=""
     export OSPRAY_SHA256_CHECKSUM=""
 }
 
 function bv_ospray_print
 {
-    print "%s%s\n" "OSPRAY_FILE=" "${OSPRAY_FILE}"
+    print "%s%s\n" "OSPRAY_TARBALL=" "${OSPRAY_TARBALL}"
     print "%s%s\n" "OSPRAY_VERSION=" "${OSPRAY_VERSION}"
     print "%s%s\n" "OSPRAY_TARGET=" "${OSPRAY_TARGET}"
     print "%s%s\n" "OSPRAY_BUILD_DIR=" "${OSPRAY_BUILD_DIR}"
@@ -45,13 +88,23 @@ function bv_ospray_print_usage
 
 function bv_ospray_host_profile
 {
-    if [[ "$DO_OSPRAY" == "yes" ]] ; then
+    if [[ "$DO_OSPRAY" == "yes" ]]; then
         echo >> $HOSTCONF
         echo "##" >> $HOSTCONF
         echo "## OSPRay" >> $HOSTCONF
         echo "##" >> $HOSTCONF
         echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY ON TYPE BOOL)" >> $HOSTCONF
-        echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY_DIR \${VISITHOME}/ospray/$OSPRAY_VERSION/\${VISITARCH})" >> $HOSTCONF
+        if [[ "$USE_SYSTEM_OSPRAY" == "no" ]]; then
+            if [[ -d $OSPRAY_INSTALL_DIR/lib ]]; then
+                echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY_DIR \${VISITHOME}/ospray/$OSPRAY_VERSION/\${VISITARCH}/lib/cmake/ospray-${OSPRAY_VERSION})" >> $HOSTCONF
+            elif [[ -d $OSPRAY_INSTALL_DIR/lib64 ]]; then
+                echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY_DIR \${VISITHOME}/ospray/$OSPRAY_VERSION/\${VISITARCH}/lib64/cmake/ospray-${OSPRAY_VERSION})" >> $HOSTCONF
+            else
+                error "No library path for OSPRay has been found."
+            fi
+        else
+            echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY_DIR ${OSPRAY_CONFIG_DIR})" >> $HOSTCONF
+        fi
     fi
 }
 
@@ -65,26 +118,44 @@ function bv_ospray_is_enabled
 
 function bv_ospray_ensure
 {
-    if [[ "$DO_OSPRAY" == "yes" ]]; then
+    if [[ "$DO_OSPRAY" == "yes" && "$USE_SYSTEM_OSPRAY" == "no" ]]; then
         ensure_built_or_ready "ospray" \
             $OSPRAY_VERSION \
             $OSPRAY_BUILD_DIR \
-            $OSPRAY_FILE \
-            $OSPRAY_URL
+            $OSPRAY_TARBALL \
+            $OSPRAY_DOWNLOAD_URL 
         if [[ $? != 0 ]] ; then
             return 1
         fi
+        ensure_built_or_ready "ospray-visit-module" \
+            $OSPRAY_VISIT_MODULE_VERSION \
+            $OSPRAY_VISIT_MODULE_BUILD_DIR \
+            $OSPRAY_VISIT_MODULE_TARBALL \
+            $OSPRAY_VISIT_MODULE_DOWNLOAD_URL
+        if [[ $? != 0 ]] ; then
+            return 1
+        fi       
     fi
 }
 
 function bv_ospray_initialize_vars
 {
     info "initializing ospray vars"
-    if [[ "$DO_OSPRAY" == "yes" ]] ; then
-        OSPRAY_INSTALL_DIR="${VISITDIR}/ospray/${OSPRAY_VERSION}/${VISITARCH}"
+    if [[ "$DO_OSPRAY" == "yes" ]]; then
+        if [[ "$USE_SYSTEM_OSPRAY" == "no" ]]; then
+            OSPRAY_INSTALL_DIR="${VISITDIR}/ospray/${OSPRAY_VERSION}/${VISITARCH}"
+        else
+            OSPRAY_INSTALL_DIR="${OSPRAY_CONFIG_DIR}/../../../"
+        fi
+
+        # Qi's Note: Are those variables necessary ?
         OSPRAY_INCLUDE_DIR="${OSPRAY_INSTALL_DIR}/include"
-        OSPRAY_LIB_DIR="${OSPRAY_INSTALL_DIR}/lib"
-        OSPRAY_LIB="${OSPRAY_LIB_DIR}/libospray.so"
+        if [[ -d $OSPRAY_INSTALL_DIR/lib64 ]]; then
+            OSPRAY_LIB_DIR="${OSPRAY_INSTALL_DIR}/lib64"
+        else
+            OSPRAY_LIB_DIR="${OSPRAY_INSTALL_DIR}/lib"
+        fi        
+        OSPRAY_LIB="${OSPRAY_LIB_DIR}/libospray.so"            
 
         VTK_USE_OSPRAY="yes"
     fi
@@ -99,6 +170,10 @@ function bv_ospray_dry_run
 
 function bv_ospray_is_installed
 {
+    if [[ "$USE_SYSTEM_OSPRAY" == "yes" ]]; then   
+        return 1
+    fi
+
     check_if_installed "ospray" $OSPRAY_VERSION
     if [[ $? == 0 ]] ; then
         return 1
@@ -106,28 +181,90 @@ function bv_ospray_is_installed
     return 0
 }
 
+function build_ospray_in_source
+{
+    # set compiler if the user hasn't explicitly set CC and CXX
+    if [ -z $CC ]; then
+        echo "***NOTE: using compiler $C_COMPILER/$CXX_COMPILER!"
+        export CC=$C_COMPILER
+        export CXX=$CXX_COMPILER
+    fi
+
+    #### Build OSPRay ####
+    mkdir -p build
+    cd build
+
+    # Clean out build directory to be sure we are doing a fresh build
+    rm -rf *
+
+    # set release and RPM settings
+    info "Configure OSPRay . . . "
+    CMAKE_INSTALL=${CMAKE_INSTALL:-"$VISITDIR/cmake/${CMAKE_VERSION}/$VISITARCH/bin"}
+
+    CMAKE_VARS=""
+    CMAKE_VARS=${CMAKE_VARS}" -D CMAKE_INSTALL_PREFIX=${OSPRAY_INSTALL_DIR} "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_BUILD_ISA=ALL "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_MODULE_VISIT=ON "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_MODULE_MPI=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_MODULE_MPI_APPS=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_APPS_EXAMPLEVIEWER=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_APPS_BENCHMARK=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_SG_CHOMBO=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_SG_OPENIMAGEIO=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_SG_VTK=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_ZIP_MODE=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D embree_DIR=${EMBREE_INSTALL_DIR} "
+    CMAKE_VARS=${CMAKE_VARS}" -D ISPC_EXECUTABLE=${ISPC_INSTALL_DIR}/ispc "
+    if [[ "${TBB_INSTALL_DIR}" == "" ]]; then
+        bv_ospray_check_openmp
+        if [[ $? == 0 ]]; then
+            CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_TASKING_SYSTEM=OpenMP "
+        else
+            error "OSPRay cannot find neither TBB nor OpenMP."
+        fi
+    else
+        CMAKE_VARS=${CMAKE_VARS}" -D TBB_ROOT=${TBB_INSTALL_DIR} "
+    fi
+    ${CMAKE_INSTALL}/cmake ${CMAKE_VARS} \
+        .. || error "OSPRay did not configure correctly.  Giving up."
+
+    #
+    # Now build OSPRay
+    #
+    info "Building OSPRay (~10 minute)"
+    env DYLD_LIBRARY_PATH=`pwd`/bin $MAKE $MAKE_OPT_FLAGS || \
+        error "OSPRay did not build correctly.  Giving up."
+
+    info "Installing OSPRay . . . "
+    $MAKE install || error "OSPRay did not install correctly."
+}
+
 function build_ospray
 {
-    prepare_build_dir $OSPRAY_BUILD_DIR $OSPRAY_FILE
+    # prepare directories
+    prepare_build_dir $OSPRAY_BUILD_DIR $OSPRAY_TARBALL
     untarred_ospray=$?
-    if [[ $untarred_ospray == -1 ]] ; then
+    if [[ $untarred_ospray == -1 ]]; then
         warn "Unable to prepare OSPRay build directory. Giving up!"
         return 1
     fi
-
-    cd $OSPRAY_BUILD_DIR || error "Couldn't cd to OSPRay build dir."
-    info "Installing OSPRay . . ."
-    echo mkdir -p ${OSPRAY_INSTALL_DIR}
-    mkdir -p ${OSPRAY_INSTALL_DIR}
-    echo cp -a include lib ${OSPRAY_INSTALL_DIR}
-    cp -a include lib ${OSPRAY_INSTALL_DIR}
-
-    if [[  $? != 0 ]] ; then
-        warn "OSPRay install failed. Giving up"
+    prepare_build_dir $OSPRAY_VISIT_MODULE_BUILD_DIR $OSPRAY_VISIT_MODULE_TARBALL
+    untarred_ospray_visit_module=$?
+    if [[ $untarred_ospray_visit_module == -1 ]]; then
+        warn "Unable to prepare OSPRay build directory. Giving up!"
         return 1
+    elif [[ $untarred_ospray_visit_module == 1 ]]; then
+        rm -fr $OSPRAY_VISIT_MODULE_BUILD_DIR
+        mv $OSPRAY_VISIT_MODULE_UNTAR_DIR $OSPRAY_VISIT_MODULE_BUILD_DIR \
+            || error "Couldn't find module_visit for OSPRay"
     fi
-    
-    if [[ "$DO_GROUP" == "yes" ]] ; then
+
+    # build and install
+    cd $OSPRAY_BUILD_DIR || error "Couldn't cd to OSPRay build dir."
+    build_ospray_in_source
+
+    # others
+    if [[ "$DO_GROUP" == "yes" ]]; then
         chmod -R ug+w,a+rX "$VISITDIR/ospray"
         chgrp -R ${GROUP} "$VISITDIR/ospray"
     fi
@@ -139,17 +276,16 @@ function build_ospray
 function bv_ospray_build
 {
     cd "$START_DIR"
-    if [[ "$DO_OSPRAY" == "yes" ]]; then
+    if [[ "$DO_OSPRAY" == "yes" && "$USE_SYSTEM_OSPRAY" == "no" ]]; then
         check_if_installed "ospray" $OSPRAY_VERSION
         if [[ $? == 0 ]] ; then
             info "Skipping OSPRay build. OSPRay is already installed."
         else
-            info "Building OSPRay (~1 minute)"
             build_ospray
-            if [[ $? != 0 ]] ; then
+            if [[ $? != 0 ]]; then
                 error "Unable to build or install OSPRay. Bailing out."
             fi
-            info "Done building OSPRay"
         fi
     fi
 }
+
diff --git a/svn_bin/bv_support/bv_tbb.sh b/svn_bin/bv_support/bv_tbb.sh
index e35301881..a60f9ba29 100644
--- a/svn_bin/bv_support/bv_tbb.sh
+++ b/svn_bin/bv_support/bv_tbb.sh
@@ -1,6 +1,8 @@
 function bv_tbb_initialize
 {
     export DO_TBB="no"
+    export USE_SYSTEM_TBB="no"
+    add_extra_commandline_args "tbb" "alt-tbb-dir" 1 "Use alternative directory for tbb"
 }
 
 function bv_tbb_enable
@@ -13,9 +15,32 @@ function bv_tbb_disable
     DO_TBB="no"
 }
 
+function bv_tbb_alt_tbb_dir
+{
+    echo "Using alternate TBB directory"
+    bv_tbb_enable
+    USE_SYSTEM_TBB="yes"
+    TBB_INSTALL_DIR="$1"
+}
+
 function bv_tbb_depends_on
 {
-    echo ""
+    if [[ "$USE_SYSTEM_TBB" == "yes" ]] ; then
+        echo ""
+    else
+        echo ""
+    fi
+}
+
+function bv_tbb_initialize_vars
+{
+    info "initializing TBB vars"
+    if [[ "$DO_TBB" == "yes" ]] ; then
+        if [[ "$USE_SYSTEM_TBB" == "no" ]]; then
+            TBB_INSTALL_DIR=$VISITDIR/tbb/$TBB_VERSION/$VISITARCH
+        fi
+    fi
+    export TBB_ROOT="${TBB_INSTALL_DIR}"
 }
 
 function bv_tbb_info
@@ -47,8 +72,11 @@ function bv_tbb_host_profile
         echo "##" >> $HOSTCONF
         echo "## TBB" >> $HOSTCONF
         echo "##" >> $HOSTCONF
-        echo "VISIT_OPTION_DEFAULT(TBB_ROOT \${VISITHOME}/tbb/\${VISITARCH}/$TBB_VERSION)" \
-            >> $HOSTCONF
+        if [[ "$USE_SYSTEM_TBB" == "no" ]]; then
+            echo "VISIT_OPTION_DEFAULT(TBB_ROOT \${VISITHOME}/tbb/$TBB_VERSION/\${VISITARCH})" >> $HOSTCONF
+        else
+            echo "VISIT_OPTION_DEFAULT(TBB_ROOT ${TBB_INSTALL_DIR})" >> $HOSTCONF
+        fi
     fi
 }
 
@@ -60,7 +88,7 @@ function bv_tbb_print_usage
 
 function bv_tbb_ensure
 {
-    if [[ "$DO_TBB" == "yes" ]] ; then
+    if [[ "$DO_TBB" == "yes" && "$USE_SYSTEM_TBB" == "no" ]] ; then
         ensure_built_or_ready "tbb" $TBB_VERSION $TBB_BUILD_DIR $TBB_FILE
         if [[ $? != 0 ]] ; then
             ANY_ERRORS="yes"
@@ -89,14 +117,14 @@ function build_tbb
     # Unzip the TBB tarball and copy it to the VisIt installation.
     info "Installing prebuilt TBB"
     tar zxvf $TBB_FILE
-    mkdir $VISITDIR/tbb
-    mkdir $VISITDIR/tbb/$VISITARCH
-    cp -R $TBB_VERSION "$VISITDIR/tbb/$VISITARCH"
+    mkdir -p $VISITDIR/tbb/$TBB_VERSION/$VISITARCH
+    cp -R $TBB_VERSION/* "$VISITDIR/tbb/$TBB_VERSION/$VISITARCH"
     rm -rf $TBB_VERSION
 
+    # others
     if [[ "$DO_GROUP" == "yes" ]] ; then
-        chmod -R ug+w,a+rX "$VISITDIR/tbb/$VISITARCH"
-        chgrp -R ${GROUP} "$VISITDIR/tbb/$VISITARCH"
+        chmod -R ug+w,a+rX "$VISITDIR/tbb/$TBB_VERSION/$VISITARCH"
+        chgrp -R ${GROUP} "$VISITDIR/tbb/$TBB_VERSION/$VISITARCH"
     fi
     cd "$START_DIR"
     info "Done with TBB"
@@ -113,7 +141,11 @@ function bv_tbb_is_enabled
 
 function bv_tbb_is_installed
 {
-    check_if_installed "tbb"
+    if [[ "$USE_SYSTEM_TBB" == "yes" ]]; then   
+        return 1
+    fi
+
+    check_if_installed "tbb" $TBB_VERSION
     if [[ $? == 0 ]] ; then
         return 1
     fi
@@ -122,8 +154,8 @@ function bv_tbb_is_installed
 
 function bv_tbb_build
 {
-    if [[ "$DO_TBB" == "yes" ]] ; then
-        check_if_installed "tbb"
+    if [[ "$DO_TBB" == "yes" && "$USE_SYSTEM_TBB" == "no" ]] ; then
+        check_if_installed "tbb" $TBB_VERSION
         if [[ $? == 0 ]] ; then
             info "Skipping build of TBB"
         else
diff --git a/svn_bin/bv_support/bv_vtk.sh b/svn_bin/bv_support/bv_vtk.sh
index 0516822c9..4160290ce 100644
--- a/svn_bin/bv_support/bv_vtk.sh
+++ b/svn_bin/bv_support/bv_vtk.sh
@@ -51,7 +51,7 @@ function bv_vtk_depends_on
     fi
 
     if [[ "$DO_OSPRAY" == "yes" ]]; then
-        depends_on="${depends_on} ospray"
+        depends_on="${depends_on} embree ospray"
     fi
 
     # Only depend on Qt if we're not doing server-only builds.
@@ -803,6 +803,7 @@ function build_vtk
     if [[ "$DO_OSPRAY" == "yes" ]] ; then
         vopts="${vopts} -DModule_vtkRenderingOSPRay:BOOL=ON"
         vopts="${vopts} -DOSPRAY_INSTALL_DIR=${OSPRAY_INSTALL_DIR}"
+        vopts="${vopts} -Dembree_DIR=${EMBREE_INSTALL_DIR}"
     fi
 
     CMAKE_BIN="${CMAKE_INSTALL}/cmake"
diff --git a/svn_bin/bv_support/modules.xml b/svn_bin/bv_support/modules.xml
index f66242099..8af931c19 100644
--- a/svn_bin/bv_support/modules.xml
+++ b/svn_bin/bv_support/modules.xml
@@ -20,6 +20,7 @@
             <lib name="conduit"/>
             <lib name="cgns"/>
             <lib name="eavl"/>
+            <lib name="embree"/>
             <lib name="fastbit"/>
             <lib name="fastquery"/>
             <lib name="gdal"/>
@@ -28,6 +29,7 @@
             <lib name="hdf4"/>
             <lib name="hdf5"/>
             <lib name="icet"/>
+            <lib name="ispc"/>
             <lib name="llvm"/>
 <!--        <lib name="mdsplus"/>    Removed for now by Allen Sanderson-->
             <lib name="mesagl"/>
@@ -39,10 +41,10 @@
             <lib name="nektarpp"/>
             <lib name="netcdf"/>
             <lib name="openexr"/>
-            <lib name="pidx"/>
             <lib name="openssl"/>
             <lib name="osmesa"/>
             <lib name="ospray"/>
+            <lib name="pidx"/>
             <lib name="pyside"/>
             <lib name="silo"/>
             <lib name="szip"/>
@@ -73,11 +75,13 @@
             <lib name="cfitsio"/>
             <lib name="conduit"/>
             <lib name="cgns"/>
+            <lib name="embree"/>
             <lib name="gdal"/>
             <lib name="fastbit"/>
             <lib name="fastquery"/>
             <lib name="hdf5"/>
             <lib name="h5part"/>
+            <lib name="ispc"/>
             <lib name="mpich"/>
             <lib name="mxml"/>
             <lib name="netcdf"/>
@@ -89,6 +93,7 @@
             <lib name="pyside"/>
             <lib name="silo"/>
             <lib name="szip"/>
+            <lib name="tbb"/>
             <lib name="uintah"/>
             <lib name="visus"/>
             <lib name="xdmf"/>
@@ -169,6 +174,9 @@
         -->
         <group name="nonio" comment="Build non I/O libraries" enabled="no">
             <lib name="icet"/>
+            <lib name="embree"/>
+            <lib name="ispc"/>
+            <lib name="tbb"/>
             <lib name="ospray"/>
         </group>
 
