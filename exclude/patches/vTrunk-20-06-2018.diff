diff --git a/CMakeLists.txt b/CMakeLists.txt
index a2b91e962e..073ebbb928 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -426,6 +426,9 @@
 #    icons. Previously, this resulted in a couple of invalid symbolic links
 #    ending up in the distribution file.
 #
+#    Qi WU, Sat Jun 10 22:21:27 MST 2018
+#    I added support to find OSPRay
+#
 #****************************************************************************/
 
 CMAKE_MINIMUM_REQUIRED(VERSION 3.8 FATAL_ERROR)
@@ -694,8 +697,8 @@ SET(CXX_TEST_PATH ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
 # configure options
 #-----------------------------------------------------------------------------
 OPTION(VISIT_PARALLEL "Build VisIt's parallel compute engine." OFF)
-
 OPTION(VISIT_SLIVR    "Build VisIt with support for the SLIVR volume rendering library." ON)
+OPTION(VISIT_OSPRAY   "Build VisIt with support for the OSPRay volume rendering library." OFF)
 OPTION(VISIT_STATIC   "Build VisIt statically." OFF)
 IF(VISIT_STATIC)
     ADD_DEFINITIONS(-DVISIT_STATIC)
@@ -871,6 +874,11 @@ VISIT_3RDPARTY_VAR(ZLIB_DIR      "Path containing the zlib library's include and
 VISIT_3RDPARTY_VAR(MOAB_DIR      "Path containing the MOAB library's include and lib")
 VISIT_3RDPARTY_VAR(MOAB_MPI_DIR  "Path containing the parallel MOAB library's include and lib")
 
+VISIT_3RDPARTY_VAR(OSPRAY_DIR    "Path containing the OSPRay library's include and lib")
+VISIT_3RDPARTY_VAR(EMBREE_ROOT   "Path containing the embree library's include and lib")
+VISIT_3RDPARTY_VAR(ISPC_ROOT     "Path containing the ISPC library's include and lib")
+VISIT_3RDPARTY_VAR(TBB_ROOT      "Path containing the TBB library's include and lib")
+
 #-----------------------------------------------------------------------------
 # Read the version
 #-----------------------------------------------------------------------------
@@ -1154,11 +1162,33 @@ ELSE(VISIT_THREAD)
     MESSAGE(STATUS "Threading for VisIt: OFF")
 ENDIF(VISIT_THREAD)
 
+# Enable OSPRay for VisIt
 IF(VISIT_OSPRAY)
+    # setup variables 
+    SET(OSPRAY_USE_EXTERNAL_EMBREE ON)
+    SET(ospray_DIR ${OSPRAY_DIR})
+    SET(embree_DIR ${EMBREE_ROOT})
+    SET(ISPC_EXECUTABLE ${ISPC_ROOT})
+    IF(NOT DEFINED TBB_ROOT)
+      SET(TBB_ROOT ${VISIT_TBB_ROOT})
+    ENDIF(NOT DEFINED TBB_ROOT)     
+    FIND_PACKAGE(ospray REQUIRED)
+    # setup ospray
     ADD_DEFINITIONS(-DVISIT_OSPRAY)
-    MESSAGE(STATUS "OSPRAY for VisIt: ON")
+    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIR})
+    LINK_DIRECTORIES(${VISIT_OSPRAY_DIR}/../..)
+    # additional module library
+    SET(OSPRAY_LIBRARIES
+      ${OSPRAY_LIBRARIES}
+      ${LIBRARY_PATH_PREFIX}ospray_module_ispc${LIBRARY_SUFFIX}
+      ${LIBRARY_PATH_PREFIX}ospray_module_visit${LIBRARY_SUFFIX}
+      ${LIBRARY_PATH_PREFIX}visit_image_composite${LIBRARY_SUFFIX})
+    # debug
+    MESSAGE(STATUS "OSPRAY_INCLUDE_DIR: " ${OSPRAY_INCLUDE_DIR})
+    MESSAGE(STATUS "OSPRAY_LIBRARIES: " ${OSPRAY_LIBRARIES})
+    MESSAGE(STATUS "OSPRay for VisIt: ON")
 ELSE(VISIT_OSPRAY)
-    MESSAGE(STATUS "OSPRAY for VisIt: OFF")
+    MESSAGE(STATUS "OSPRay for VisIt: OFF")
 ENDIF(VISIT_OSPRAY)
 
 #-----------------------------------------------------------------------------
diff --git a/avt/Filters/CMakeLists.txt b/avt/Filters/CMakeLists.txt
index e0f4d336e3..e01be9754d 100644
--- a/avt/Filters/CMakeLists.txt
+++ b/avt/Filters/CMakeLists.txt
@@ -131,14 +131,42 @@ avtWorldSpaceToImageSpaceTransform.C
 avtXRayFilter.C
 )
 
-if (VISIT_SLIVR)
-    list(APPEND AVTFILTERS_SOURCES
-         avtImgCommunicator.C
+IF(VISIT_SLIVR)
+    LIST(APPEND AVTFILTERS_SOURCES
+         avtSLIVRCommon.C
+         avtSLIVRImageCompositor.C
          avtSLIVRRayTracer.C
          avtSLIVRSamplePointExtractor.C
          avtSLIVRVoxelExtractor.C)
-    add_definitions(-DVISIT_SLIVR)
-endif()
+    ADD_DEFINITIONS(-DVISIT_SLIVR)
+ENDIF()
+
+IF(VISIT_OSPRAY)
+    LIST(APPEND AVTFILTERS_SOURCES
+         avtOSPRayCommon.C
+         avtOSPRayImageCompositor.C
+         avtOSPRayRayTracer.C
+         avtOSPRaySamplePointExtractor.C
+         avtOSPRayVoxelExtractor.C
+	 )
+    ADD_DEFINITIONS(-DVISIT_OSPRAY)
+    IF(ICET_FOUND)
+        # If we have Ice-T then add -DHAVE_ICET to the compilation flags.
+        # We need to link with OpenGL on Mac when we have IceT.
+        IF(APPLE)
+            SET(ICET_OPENGL ${OPENGL_gl_LIBRARY})
+        ENDIF(APPLE)
+        # Link icet libraries using absolute pathes
+	SET(ICET_FULLPATH_LIB ${ICET_OPENGL})
+	FOREACH(X ${ICET_LIB})
+	    LIST(APPEND ICET_FULLPATH_LIB "${ICET_LIBRARY_DIR}/${X}")
+	ENDFOREACH()
+        # Other setups
+        INCLUDE_DIRECTORIES(${ICET_INCLUDE_DIR})
+        LINK_DIRECTORIES(${ICET_LIBRARY_DIR})
+        ADD_DEFINITIONS(-DVISIT_OSPRAY_ICET)
+    ENDIF()
+ENDIF()
 
 INCLUDE_DIRECTORIES(
 ${CMAKE_CURRENT_SOURCE_DIR}
@@ -178,11 +206,23 @@ ENDIF()
 #********************************* SERIAL ************************************
 ADD_LIBRARY(avtfilters_ser ${AVTFILTERS_SOURCES})
 TARGET_LINK_LIBRARIES(avtfilters_ser visitcommon lightweight_visit_vtk visit_vtk avtmath avtview avtpipeline_ser avtdatabase_ser avtdbatts ${EAVL_LIB} ${VISIT_VTKM_LIB} vtkFiltersModeling)
+IF(VISIT_OSPRAY) 
+    TARGET_LINK_LIBRARIES(avtfilters_ser ${OSPRAY_LIBRARIES})
+    IF(ICET_FOUND)
+        TARGET_LINK_LIBRARIES(avtfilters_ser ${ICET_FULLPATH_LIB})
+    ENDIF()
+ENDIF() 
 VISIT_INSTALL_TARGETS(avtfilters_ser)
 
 #********************************* PARALLEL **********************************
 IF(VISIT_PARALLEL)
     ADD_PARALLEL_LIBRARY(avtfilters_par ${AVTFILTERS_SOURCES})
     TARGET_LINK_LIBRARIES(avtfilters_par visitcommon lightweight_visit_vtk visit_vtk avtmath avtview avtpipeline_par avtdatabase_par avtdbatts ${EAVL_LIB} ${VISIT_VTKM_LIB} vtkFiltersModeling)
+    IF(VISIT_OSPRAY) 
+        TARGET_LINK_LIBRARIES(avtfilters_par ${OSPRAY_LIBRARIES})
+        IF(ICET_FOUND)
+            TARGET_LINK_LIBRARIES(avtfilters_par ${ICET_FULLPATH_LIB})
+        ENDIF()
+    ENDIF()
     VISIT_INSTALL_TARGETS(avtfilters_par)
 ENDIF(VISIT_PARALLEL)
diff --git a/avt/Filters/avtOSPRayCommon.C b/avt/Filters/avtOSPRayCommon.C
new file mode 100644
index 0000000000..5bc07fcd43
--- /dev/null
+++ b/avt/Filters/avtOSPRayCommon.C
@@ -0,0 +1,1047 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2017, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+#include <avtOSPRayCommon.h>
+
+#include <avtParallel.h>
+#include <avtMemory.h>
+
+#include <DebugStream.h>
+#include <StackTimer.h>
+#include <TimingsManager.h>
+#include <ImproperUseException.h>
+
+#include <ospray/ospray.h>
+#include <ospray/visit/VisItImageComposite.h>
+
+#ifdef __unix__
+# include <unistd.h>
+#endif
+
+inline bool CheckThreadedBlend_MetaData() {
+    bool use = true;
+    const char* env_use = std::getenv("OSPRAY_SERIAL_BLEND");
+    if (env_use) { use = atoi(env_use) <= 0; }
+    return use;
+}
+static bool UseThreadedBlend_MetaData = CheckThreadedBlend_MetaData();
+
+std::ostream *ospray::osp_out = &DebugStream::Stream5();
+std::ostream *ospray::osp_err = &DebugStream::Stream1();
+
+
+// ****************************************************************************
+//
+// OSPContext
+//
+// ****************************************************************************
+
+void OSPContext_ErrorFunc(OSPError, const char* msg) { 
+    osperr << "#osp: (rank " << PAR_Rank() << ")" 
+           << msg; 
+}
+void OSPContext_StatusFunc(const char* msg) { 
+    osperr << "#osp: (rank " << PAR_Rank() << ")" 
+           << msg; 
+}
+bool OSPVisItContext::initialized = false;
+void OSPVisItContext::Finalize() {}
+void OSPVisItContext::InitOSP(int numThreads) 
+{     
+    if (!OSPVisItContext::initialized) 
+    {
+	// check hostname
+#ifdef __unix__
+	char hname[200];
+	gethostname(hname, 200);
+	ospout << "[ospray] on host >> " << hname << "<<" << std::endl;;
+#endif
+	// load ospray device
+	ospout << "[ospray] Initialize OSPRay" << std::endl;	
+	OSPDevice device = ospGetCurrentDevice();
+	if (!device) {
+		ospout << "[ospray] device not found, creating one" << std::endl;
+	    device = ospNewDevice("default"); 
+	    if (DebugStream::Level5()) { 
+		ospout << "[ospray] --> debug mode" << std::endl;
+		ospDeviceSet1i(device, "debug", 0);
+	    }	
+	    if (numThreads > 0) {
+		ospout << "[ospray] --> numThreads: " << numThreads << std::endl;
+		ospDeviceSet1i(device, "numThreads", numThreads);
+	    }
+	    ospDeviceSetErrorFunc(device, OSPContext_ErrorFunc);
+	    ospDeviceSetStatusFunc(device, OSPContext_StatusFunc);
+	    ospDeviceCommit(device);
+	    ospSetCurrentDevice(device);
+	}
+	// load ospray module
+	OSPError err = ospLoadModule("visit");
+	if (err != OSP_NO_ERROR) {
+	    osperr << "[Error] can't load visit module" << std::endl;
+	}
+	OSPVisItContext::initialized = true;
+    }
+}
+
+// We use this function to minimize interface
+void OSPVisItContext::Render(float xMin, float xMax, float yMin, float yMax,
+			     int imgWidth, int imgHeight,
+			     float*& dest, OSPVisItVolume* volume) 
+{
+    int timing_SetSubCamera = visitTimer->StartTimer();
+    camera.SetScreen(xMin, xMax, yMin, yMax);
+    visitTimer->StopTimer(timing_SetSubCamera,
+			  "[OSPRay] Calling OSPContext::SetSubCamera");
+
+    int timing_SetModel = visitTimer->StartTimer();
+    renderer.SetModel(volume->GetWorld());
+    renderer.SetCamera(camera.camera);
+    visitTimer->StopTimer(timing_SetModel,
+			  "[OSPRay] Calling OSPContext::SetModel");
+
+    int timing_InitFB = visitTimer->StartTimer();
+    volume->InitFB(imgWidth, imgHeight);
+    visitTimer->StopTimer(timing_InitFB,
+			  "[OSPRay] Calling OSPContext::InitFB");
+
+    int timing_RenderFB = visitTimer->StartTimer();
+    volume->RenderFB();
+    visitTimer->StopTimer(timing_RenderFB,
+			  "[OSPRay] Calling OSPContext::RenderFB");
+
+    int timing_stdcopy = visitTimer->StartTimer();
+    std::copy(volume->GetFBData(), 
+	      volume->GetFBData() + (imgWidth * imgHeight) * 4, dest);
+    visitTimer->StopTimer(timing_stdcopy, 
+			  "[OSPRay] Calling OSPContext::std::copy");
+}
+
+void OSPVisItContext::InitPatch(int id) 
+{
+    if (volumes.find(id) == volumes.end()) {
+	OSPVisItVolume v;
+	v.patchId = id;
+	v.parent = this;
+	volumes[id] = v;
+    }
+}
+
+// ****************************************************************************
+//
+// OSPVolume
+//
+// ****************************************************************************
+
+void OSPVisItVolume::Set(int type, void *ptr, double *X, double *Y, double *Z, 
+			 int nX, int nY, int nZ,
+			 double volumePBox[6], 
+			 double volumeBBox[6], 
+			 double mtl[4], float sr,
+			 bool shading)
+{
+    /* OSPRay Volume */
+    specularKs    = (float)mtl[2];
+    specularNs    = (float)mtl[3];
+    enableShading = shading;
+    samplingRate  = sr;
+    // TODO: It seems if a volume is recovered from a session
+    // ospray will crash during zooming ...
+    // So we refresh volume everytime to fix the bug
+    // which means we need to disable grid accelerator
+    // to speed things up. Until I found the reason of crashing
+    if (ptr != dataPtr) {
+        ospout << "[ospray] update data" << std::endl;
+    };
+    if (true/*!finished*/) {
+	// Because we initialized the volume each frame
+	// we need to removed the old volume from model first
+	volumeType = OSP_INVALID;
+	InitVolume();
+	SetVolume(type, ptr, X, Y, Z, nX, nY, nZ,
+		  volumePBox, volumeBBox);
+    }
+    /* OSPRay Model */
+    if (true/*!finished*/) {
+	worldType = OSP_INVALID; 
+	InitWorld();
+	SetWorld();
+    }
+    /* update volume */
+    finished = true;
+}
+
+// ospModel component
+void OSPVisItVolume::InitWorld() {
+    if (worldType == OSP_INVALID) {
+	CleanWorld();
+	worldType = OSP_VALID;
+	world = ospNewModel();
+    }
+}
+void OSPVisItVolume::SetWorld() {
+    if (world != NULL) { 
+	ospAddVolume(world, volume);
+	ospCommit(world);
+    }
+}
+
+// ospVolume component
+void OSPVisItVolume::InitVolume(unsigned char type) {
+    if (volumeType != type) { // only initialize once
+	CleanVolume();
+	volumeType = type;
+	switch (type) {
+	case (OSP_BLOCK_BRICKED_VOLUME):
+	    volume = ospNewVolume("block_bricked_volume"); 
+	    break;
+	case (OSP_SHARED_STRUCTURED_VOLUME):
+	    volume = ospNewVolume("visit_shared_structured_volume"); 
+	    break;
+	default:
+	    debug1 << "ERROR: ospray volume not initialized"
+		   << std::endl;
+	    volumeType = OSP_INVALID;
+	    EXCEPTION1(VisItException, 
+		       "ERROR: ospray volume not initialized");
+	}
+    }
+}
+
+void 
+OSPVisItVolume::SetVolume(int type, void *ptr, 
+			  double *X, double *Y, double *Z, 
+			  int nX, int nY, int nZ,
+			  double volumePBox[6], double volumeBBox[6]) 
+{
+    // calculate volume data type
+    if (type == VTK_UNSIGNED_CHAR) {
+	dataType = "uchar";
+	voxelDataType = OSP_UCHAR;
+    } else if (type == VTK_SHORT) {
+	dataType = "short";
+	voxelDataType = OSP_SHORT;
+    } else if (type == VTK_UNSIGNED_SHORT) {
+	dataType = "ushort";
+	voxelDataType = OSP_USHORT;
+    } else if (type == VTK_FLOAT) {
+	dataType = "float";
+	voxelDataType = OSP_FLOAT;
+    } else if (type == VTK_DOUBLE) {
+	dataType = "double";
+	voxelDataType = OSP_DOUBLE;
+    } else {
+	debug1 << "ERROR: Unsupported ospray volume type" << std::endl;
+	EXCEPTION1(VisItException, "ERROR: Unsupported ospray volume type");
+    }
+    ospout << "[ospray] data type " << dataType << std::endl;
+    // assign data pointer
+    dataPtr = ptr;
+    // assign structure
+    regionStart.x   = volumePBox[0];
+    regionStart.y   = volumePBox[1];
+    regionStart.z   = volumePBox[2];
+    regionStop.x    = volumePBox[3];
+    regionStop.y    = volumePBox[4];
+    regionStop.z    = volumePBox[5];
+    regionSize.x    = nX;
+    regionSize.y    = nY;
+    regionSize.z    = nZ;
+    regionSpacing.x = (regionStop.x-regionStart.x)/((float)regionSize.x-1.0f);
+    regionSpacing.y = (regionStop.y-regionStart.y)/((float)regionSize.y-1.0f);
+    regionSpacing.z = (regionStop.z-regionStart.z)/((float)regionSize.z-1.0f);
+    regionLowerClip.x = volumeBBox[0];
+    regionLowerClip.y = volumeBBox[1];
+    regionLowerClip.z = volumeBBox[2];
+    regionUpperClip.x = volumeBBox[3];
+    regionUpperClip.y = volumeBBox[4];
+    regionUpperClip.z = volumeBBox[5];
+
+    // other objects
+    ospSetString(volume, "voxelType", dataType.c_str());
+    ospSetObject(volume, "transferFunction", parent->transferfcn.transferfcn);
+
+    // commit voxel data
+    if (voxelData != NULL) { 
+	debug1 << "ERROR: Found VoxelData to be non-empty "
+	       << "while creating new volume" << std::endl;
+	EXCEPTION1(VisItException, 
+		   "ERROR: Found VoxelData to be non-empty "
+		   "while creating new volume");
+    }
+    voxelSize = nX * nY * nZ;
+    voxelData = ospNewData(voxelSize, voxelDataType,
+			   dataPtr, OSP_DATA_SHARED_BUFFER);
+    ospSetData(volume, "voxelData", voxelData);
+
+    // commit volume
+    // -- no lighting by default
+    ospout << "[ospray] setting specular value to " << specularKs << std::endl;
+    osp::vec3f Ks; Ks.x = Ks.y = Ks.z = specularKs;
+    ospSetVec3f(volume, "specular", Ks);
+    ospSet1f(volume, "Ns", specularNs);
+    ospSet1i(volume, "gradientShadingEnabled", (int)enableShading);
+    // -- other properties
+    osp::vec3f scaledBBoxLower;
+    osp::vec3f scaledBBoxUpper;
+    osp::vec3f scaledSpacing;
+    osp::vec3f scaledOrigin;
+    osp::vec3f scaledGlobalBBoxLower;
+    osp::vec3f scaledGlobalBBoxUpper;
+    scaledGlobalBBoxLower.x = parent->bounds[0] * regionScaling.x;
+    scaledGlobalBBoxUpper.x = parent->bounds[1] * regionScaling.x;
+    scaledGlobalBBoxLower.y = parent->bounds[2] * regionScaling.y;
+    scaledGlobalBBoxUpper.y = parent->bounds[3] * regionScaling.y;
+    scaledGlobalBBoxLower.z = parent->bounds[4] * regionScaling.z;
+    scaledGlobalBBoxUpper.z = parent->bounds[5] * regionScaling.z;
+    // -- x
+    scaledBBoxLower.x = regionLowerClip.x * parent->regionScaling.x;
+    scaledBBoxUpper.x = regionUpperClip.x * parent->regionScaling.x;
+    scaledSpacing.x   = regionSpacing.x   * parent->regionScaling.x;
+    scaledOrigin.x    = regionStart.x     * parent->regionScaling.x;
+    // -- y
+    scaledBBoxLower.y = regionLowerClip.y * parent->regionScaling.y;
+    scaledBBoxUpper.y = regionUpperClip.y * parent->regionScaling.y;
+    scaledSpacing.y   = regionSpacing.y   * parent->regionScaling.y;
+    scaledOrigin.y    = regionStart.y     * parent->regionScaling.y;
+    // -- z
+    scaledBBoxLower.z = regionLowerClip.z * parent->regionScaling.z;
+    scaledBBoxUpper.z = regionUpperClip.z * parent->regionScaling.z;
+    scaledSpacing.z   = regionSpacing.z   * parent->regionScaling.z;
+    scaledOrigin.z    = regionStart.z     * parent->regionScaling.z;
+    // -- commit ospray
+    ospSet1i(volume, "useGridAccelerator", 0);
+    ospSetVec3f(volume, "volumeClippingBoxLower", scaledBBoxLower);
+    ospSetVec3f(volume, "volumeClippingBoxUpper", scaledBBoxUpper);
+    ospSetVec3f(volume, "gridSpacing", scaledSpacing);
+    ospSetVec3f(volume, "gridOrigin",  scaledOrigin);
+    ospSetVec3i(volume, "dimensions",  regionSize);
+    ospSet1f(volume, "samplingRate", samplingRate); 
+    ospSet1i(volume, "adaptiveSampling", 0);
+    ospSet1i(volume, "preIntegration", 0);
+    ospSet1i(volume, "singleShade", 0);
+    ospSetVec3f(volume, "volumeGlobalBoundingBoxLower", scaledGlobalBBoxLower);
+    ospSetVec3f(volume, "volumeGlobalBoundingBoxUpper", scaledGlobalBBoxUpper);
+    ospCommit(volume);
+}
+
+// ospFrameBuffer component     
+void OSPVisItVolume::InitFB(unsigned int width, unsigned int height)
+{
+    // preparation
+    imageSize.x = width;
+    imageSize.y = height;
+    // create max depth texture
+    std::vector<float> maxDepth(width * height);
+    //
+    // The reason I use round(r * (N-1)) instead of floor(r * N) is that 
+    // during the composition phase, there will be a wired offset between
+    // rendered image and the background, which is about one pixel in size.
+    // Using round(r * (N - 1)) can remove the problem
+    //
+    // const int Xs = 
+    // 	floor(parent->camera.imgS.x * parent->camera.size[0]);
+    // const int Ys = 
+    // 	floor(parent->camera.imgS.y * parent->camera.size[1]);
+    // const int Xs = 
+    // 	round(parent->camera.imgS.x * (parent->camera.size[0]-1));
+    // const int Ys = 
+    // 	round(parent->camera.imgS.y * (parent->camera.size[1]-1));
+    //
+    // It seems this is the correct way of doing it
+    //
+    // It seems we need to also fix pan and zoom also
+    //
+    const int Xs = 
+    	std::min((int)round((parent->camera.r_xl + parent->camera.panx) * 
+			    parent->camera.size[0]),
+		 parent->camera.size[0]-1);
+    const int Ys =
+	std::min((int)round((parent->camera.r_yl + parent->camera.pany) * 
+			    parent->camera.size[1]),
+		 parent->camera.size[1]-1);
+    for (int i = 0; i < width; ++i) {
+    	for (int j = 0; j < height; ++j) {
+    	    maxDepth[i + j * width] = 
+    		parent->renderer.maxDepthBuffer
+		[Xs + i + (Ys + j) * parent->renderer.maxDepthSize.x];
+    	}
+    }
+    framebufferBg = ospNewTexture2D(imageSize, OSP_TEXTURE_R32F, 
+				    maxDepth.data(),
+				    OSP_TEXTURE_FILTER_NEAREST);
+    ospCommit(framebufferBg);
+    ospSetObject(parent->renderer.renderer, "maxDepthTexture", framebufferBg);
+    ospCommit(parent->renderer.renderer);
+    ospRelease(framebufferBg);
+    framebufferBg = NULL;
+    // create framebuffer
+    CleanFB();
+    framebuffer = ospNewFrameBuffer(imageSize, 
+				    OSP_FB_RGBA32F,
+				    OSP_FB_COLOR);
+}
+void OSPVisItVolume::RenderFB() {
+    static int i = 0;
+    ospRenderFrame(framebuffer, parent->renderer.renderer, OSP_FB_COLOR);
+    framebufferData = (float*) ospMapFrameBuffer(framebuffer, OSP_FB_COLOR);
+}
+float* OSPVisItVolume::GetFBData() {
+    return framebufferData;
+}
+
+// ****************************************************************************
+//
+// OSPLight
+//
+// ****************************************************************************
+void OSPVisItLight::Init(const OSPRenderer& renderer)
+{
+    /* TODO check repeated initialization ? */
+    Clean();
+    aLight = ospNewLight(renderer, "ambient");
+    dLight = ospNewLight(renderer, "distant");
+    sLight = ospNewLight(renderer, "distant");
+    ospCommit(aLight);
+    ospCommit(dLight);
+    ospCommit(sLight);
+    OSPLight lights[3] = { aLight, dLight, sLight };
+    lightdata = ospNewData(3, OSP_OBJECT, lights);
+    ospCommit(lightdata);
+}
+void OSPVisItLight::Set(double materialProperties[4], double viewDirection[3])
+{
+    // light direction
+    osp::vec3f lightDir;
+    lightDir.x = (float)viewDirection[0];
+    lightDir.y = (float)viewDirection[1];
+    lightDir.z = (float)viewDirection[2];
+    // ambient light
+    ospSet1f(aLight, "intensity", (float)materialProperties[0]);
+    ospSet1i(aLight, "isVisible", 0);
+    ospCommit(aLight);
+    // directional light
+    ospSet1f(dLight, "intensity", (float)materialProperties[1]);
+    ospSet1f(dLight, "angularDiameter", 0.53f);
+    ospSet1i(dLight, "isVisible", 0);
+    ospSetVec3f(dLight, "direction", lightDir);
+    ospCommit(dLight);
+    // sun light
+    ospSet1f(sLight, "intensity", 1.5f /*TODO hard code it for now*/);
+    ospSet1f(sLight, "angularDiameter", 0.53f);
+    ospSet1i(sLight, "isVisible", 0);
+    ospSetVec3f(sLight, "direction", lightDir);
+    ospCommit(sLight);
+}
+
+// ****************************************************************************
+//
+// OSPRenderer
+//
+// ****************************************************************************
+
+void OSPVisItRenderer::Init() 
+{
+    if (rendererType == INVALID) {
+	Clean();
+	rendererType = SCIVIS;
+	renderer = ospNewRenderer("scivis");
+	lights.Init(renderer);
+    }
+}
+void OSPVisItRenderer::Set(double materialProperties[4],
+			   double viewDirection[3],
+			   bool flagUseShading) 
+{    
+    ospSet1f(renderer, "bgColor",   0.f);
+    ospSet1i(renderer, "aoSamples", aoSamples);
+    ospSet1i(renderer, "spp",       spp);
+    ospSet1i(renderer, "oneSidedLighting",      flagOneSidedLighting);
+    ospSet1i(renderer, "shadowsEnabled",        flagShadowsEnabled);
+    ospSet1i(renderer, "aoTransparencyEnabled", flagAoTransparencyEnabled);
+    if (flagUseShading)
+    {
+	ospout << "[ospray] use lighting w/ material " 
+	    << "ambient "    << materialProperties[0] << " "
+	    << "diffuse "    << materialProperties[1] << " "
+	    << "specular "   << materialProperties[2] << " "
+	    << "glossiness " << materialProperties[3] << std::endl;
+	lights.Set(materialProperties, viewDirection);
+	ospSetData(renderer, "lights", lights.lightdata);
+	ospCommit(renderer);	
+    }
+    ospCommit(renderer);
+}
+void OSPVisItRenderer::SetCamera(const OSPCamera& camera)
+{
+    ospSetObject(renderer, "camera", camera);
+    ospCommit(renderer);
+}
+void OSPVisItRenderer::SetModel(const OSPModel& world)
+{
+    ospSetObject(renderer, "model",  world);
+    ospCommit(renderer);
+}
+
+// ****************************************************************************
+//
+// OSPCamera
+//
+// ****************************************************************************
+
+void OSPVisItCamera::Init(State type) 
+{
+    if (cameraType != type) {
+	Clean();
+	cameraType = type;
+	switch (cameraType) {
+	case (PERSPECTIVE):
+	    camera = ospNewCamera("perspective");
+	    break;
+	case (ORTHOGRAPHIC):
+	    camera = ospNewCamera("orthographic");
+	    break;
+	default:
+	    cameraType = INVALID;
+	    EXCEPTION1(VisItException, "ERROR: wrong ospray camera type"); 
+	}
+    }
+}
+void OSPVisItCamera::Set(const double camp[3], 
+			 const double camf[3], 
+			 const double camu[3], 
+			 const double camd[3],
+			 const double sceneSize[2],
+			 const double aspect, 
+			 const double fovy, 
+			 const double zoom_ratio, 
+			 const double pan_ratio[2],
+			 const int bufferExtents[4],
+			 const int screenExtents[2]) 
+{
+    osp::vec3f camP, camD, camU;
+    camP.x = camp[0]; camP.y = camp[1]; camP.z = camp[2];    
+    camD.x = camd[0]; camD.y = camd[1]; camD.z = camd[2];
+    camU.x = camu[0]; camU.y = camu[1]; camU.z = camu[2];
+    panx = pan_ratio[0] * zoom_ratio;
+    pany = pan_ratio[1] * zoom_ratio;
+    size[0] = screenExtents[0];
+    size[1] = screenExtents[1];
+    zoom = zoom_ratio;
+    ospSetVec3f(camera, "pos", camP);
+    ospSetVec3f(camera, "dir", camD);
+    ospSetVec3f(camera, "up",  camU);
+    ospSet1f(camera, "aspect", aspect);
+    if      (cameraType == PERSPECTIVE)  { ospSet1f(camera, "fovy", fovy); }
+    else if (cameraType == ORTHOGRAPHIC) { 
+	ospSet1f(camera, "height", sceneSize[1]); 
+    }
+    ospCommit(camera);
+    this->SetScreen(bufferExtents[0], bufferExtents[1],
+		    bufferExtents[2], bufferExtents[3]);
+}
+void OSPVisItCamera::SetScreen(float xMin, float xMax, float yMin, float yMax) 
+{
+    r_xl = xMin/size[0] - panx; 
+    r_yl = yMin/size[1] - pany; 
+    r_xu = xMax/size[0] - panx;
+    r_yu = yMax/size[1] - pany;	
+    imgS.x = (r_xl - 0.5f) / zoom + 0.5f;
+    imgS.y = (r_yl - 0.5f) / zoom + 0.5f;
+    imgE.x = (r_xu - 0.5f) / zoom + 0.5f;
+    imgE.y = (r_yu - 0.5f) / zoom + 0.5f;
+    ospSetVec2f(camera, "imageStart", imgS);
+    ospSetVec2f(camera, "imageEnd",   imgE);
+    ospCommit(camera);
+}
+
+// ****************************************************************************
+//
+// OSPTransferFunction
+//
+// ****************************************************************************
+
+void OSPVisItTransferFunction::Init() 
+{
+    if (transferfcnType == INVALID) {
+	Clean();
+	transferfcnType = PIECEWISE_LINEAR;
+	transferfcn = ospNewTransferFunction("piecewise_linear");
+    }
+}
+void OSPVisItTransferFunction::Set(const OSPVisItColor *table,
+				   const unsigned int size, 
+				   const float datamin, 
+				   const float datamax) 
+{
+    std::vector<osp::vec3f> colors;
+    std::vector<float>      opacities;
+    for (int i = 0; i < size; ++i) {
+	osp::vec3f color;
+	color.x = table[i].R;
+	color.y = table[i].G;
+	color.z = table[i].B;
+	colors.push_back(color);
+	opacities.push_back(table[i].A);
+    }
+    OSPData colorData   = 
+	ospNewData(colors.size(), OSP_FLOAT3, colors.data());
+    OSPData opacityData = 
+	ospNewData(opacities.size(), OSP_FLOAT, opacities.data());
+    osp::vec2f range;
+    range.x = datamin;
+    range.y = datamax;
+    ospSetData(transferfcn, "colors",      colorData);
+    ospSetData(transferfcn, "opacities",   opacityData);
+    ospSetVec2f(transferfcn, "valueRange", range);
+    ospCommit(transferfcn);
+    ospRelease(colorData);
+    ospRelease(opacityData);
+}
+
+// ****************************************************************************
+//
+//
+//
+//  Extra Functions Defined here
+//
+//
+//
+// ****************************************************************************
+
+void ospray::CheckMemoryHere(const std::string& message, std::string debugN)
+{
+    if (debugN.compare("ospout") == 0) {	
+	ospray::CheckMemoryHere(message, *osp_out);
+    }
+    else if (debugN.compare("debug5") == 0) {
+	if (DebugStream::Level5()) {
+	    ospray::CheckMemoryHere(message, DebugStream::Stream5());
+	}       
+    }
+    else if (debugN.compare("debug4") == 0) {
+	if (DebugStream::Level4()) {
+	    ospray::CheckMemoryHere(message, DebugStream::Stream4());
+	}       
+    }
+    else if (debugN.compare("debug3") == 0) {
+	if (DebugStream::Level3()) {
+	    ospray::CheckMemoryHere(message, DebugStream::Stream3());
+	}       
+    }
+    else if (debugN.compare("debug2") == 0) {
+	if (DebugStream::Level2()) {
+	    ospray::CheckMemoryHere(message, DebugStream::Stream2());
+	}       
+    }
+    else if (debugN.compare("debug1") == 0) {
+	if (DebugStream::Level1()) {
+	    ospray::CheckMemoryHere(message, DebugStream::Stream1());
+	}       
+    }
+}
+
+void ospray::CheckMemoryHere(const std::string& message, std::ostream& out)
+{
+    unsigned long m_size, m_rss;
+    avtMemory::GetMemorySize(m_size, m_rss);
+    out << message << std::endl << "\t"
+	<< " Rank " << PAR_Rank()
+	<< " Memory use begin " << m_size 
+	<< " rss " << m_rss/(1024*1024) << " (MB)"
+	<< std::endl;
+}
+
+double ospray::ProjectWorldToScreen(const double worldCoord[3], 
+                                    const int screenWidth, 
+                                    const int screenHeight,
+                                    const double panPercentage[2], 
+                                    const double imageZoom,
+                                    vtkMatrix4x4 *mvp, int screenCoord[2])
+{
+    // world space coordinate in homogeneous coordinate
+    double worldHCoord[4] = {
+	worldCoord[0],
+	worldCoord[1],
+	worldCoord[2],
+	1.0
+    };
+
+    // world to clip space (-1 ~ 1)
+    double clipHCoord[4];
+    mvp->MultiplyPoint(worldHCoord, clipHCoord);
+    if (clipHCoord[3] == 0.0)
+    {
+	std::cerr << "ProjectWorldToScreen "
+		  << "Zero Division During Projection" 
+		  << std::endl;
+	std::cerr << "world coordinates: (" 
+		  << worldHCoord[0] << ", " 
+		  << worldHCoord[1] << ", " 
+		  << worldHCoord[2] << ", " 
+		  << worldHCoord[3] << ")" << std::endl
+		  << "clip space coordinate: ("
+		  << clipHCoord[0] << ", " 
+		  << clipHCoord[1] << ", " 
+		  << clipHCoord[2] << ", "
+		  << clipHCoord[3] << std::endl;
+	std::cerr << "Matrix: " << *mvp << std::endl;
+	EXCEPTION1(VisItException, "Zero Division During Projection");
+    }
+
+    // normalize clip space coordinate
+    double clipCoord[3] = {
+	clipHCoord[0]/clipHCoord[3],
+	clipHCoord[1]/clipHCoord[3],
+	clipHCoord[2]/clipHCoord[3]
+    };
+
+    // screen coordinates (int integer)
+    screenCoord[0] = round(clipCoord[0]*(screenWidth /2.0)+(screenWidth /2.0));
+    screenCoord[1] = round(clipCoord[1]*(screenHeight/2.0)+(screenHeight/2.0));
+
+    // add panning
+    screenCoord[0] += round(screenWidth  * panPercentage[0] * imageZoom);
+    screenCoord[1] += round(screenHeight * panPercentage[1] * imageZoom); 
+
+    // return point depth
+    return clipCoord[2];
+}
+
+void
+ospray::ProjectScreenToWorld(const int screenCoord[2], const double z,
+                            const int screenWidth, const int screenHeight, 
+                            const double panPercentage[2], 
+                            const double imageZoom,
+                            vtkMatrix4x4 *imvp, double worldCoord[3])
+{
+    // remove panning
+    const int x = 
+	screenCoord[0] - round(screenWidth*panPercentage[0]*imageZoom);
+    const int y = 
+	screenCoord[1] - round(screenHeight*panPercentage[1]*imageZoom);
+    
+    // do projection
+    double worldHCoord[4] = {0,0,0,1};
+    double clipHCoord[4] = {
+	(x - screenWidth/2.0) /(screenWidth/2.0),
+	(y - screenHeight/2.0)/(screenHeight/2.0),
+	z, 1.0};
+    imvp->MultiplyPoint(clipHCoord, worldHCoord);
+    if (worldHCoord[3] == 0) {
+	debug5 << "ProjectScreenToWorld "
+	       << "Zero Division During Projection" 
+	       << std::endl;
+	std::cerr << "world coordinates: (" 
+		  << worldHCoord[0] << ", " 
+		  << worldHCoord[1] << ", " 
+		  << worldHCoord[2] << ", " 
+		  << worldHCoord[3] << ")" << std::endl
+		  << "clip space coordinate: ("
+		  << clipHCoord[0] << ", " 
+		  << clipHCoord[1] << ", " 
+		  << clipHCoord[2] << ", "
+		  << clipHCoord[3] << std::endl;
+	std::cerr << "Matrix: " << *imvp << std::endl;
+	EXCEPTION1(VisItException, "Zero Division During Projection");
+    }
+    
+    // normalize world space coordinate	
+    worldCoord[0] = worldHCoord[0]/worldHCoord[3];
+    worldCoord[1] = worldHCoord[1]/worldHCoord[3];
+    worldCoord[2] = worldHCoord[2]/worldHCoord[3];
+}
+
+void
+ospray::ProjectScreenToCamera(const int screenCoord[2], const double z,
+                             const int screenWidth, const int screenHeight, 
+                             vtkMatrix4x4 *imvp, double cameraCoord[3])
+{
+    // remove panning
+    const int x = screenCoord[0];
+    const int y = screenCoord[1];
+    
+    // do projection
+    double cameraHCoord[4] = {0,0,0,1};
+    double clipHCoord[4] = {
+	(x - screenWidth /2.0)/(screenWidth /2.0),
+	(y - screenHeight/2.0)/(screenHeight/2.0),
+	z,
+	1.0};
+    imvp->MultiplyPoint(clipHCoord, cameraHCoord);
+    if (cameraHCoord[3] == 0) {
+	debug5 << "ProjectScreenToWorld "
+	       << "Zero Division During Projection" 
+	       << std::endl;
+	std::cerr << "world coordinates: (" 
+		  << cameraHCoord[0] << ", " 
+		  << cameraHCoord[1] << ", " 
+		  << cameraHCoord[2] << ", " 
+		  << cameraHCoord[3] << ")" << std::endl
+		  << "clip space coordinate: ("
+		  << clipHCoord[0] << ", " 
+		  << clipHCoord[1] << ", " 
+		  << clipHCoord[2] << ", "
+		  << clipHCoord[3] << std::endl;
+	std::cerr << "Matrix: " << *imvp << std::endl;
+	EXCEPTION1(VisItException, "Zero Division During Projection");
+    }
+    
+    // normalize world space coordinate	
+    cameraCoord[0] = cameraHCoord[0]/cameraHCoord[3];
+    cameraCoord[1] = cameraHCoord[1]/cameraHCoord[3];
+    cameraCoord[2] = cameraHCoord[2]/cameraHCoord[3];
+}
+
+void
+ospray::ProjectWorldToScreenCube(const double cube[6],
+                                 const int screenWidth, 
+                                 const int screenHeight, 
+                                 const double panPercentage[2], 
+                                 const double imageZoom,
+                                 vtkMatrix4x4 *mvp, 
+                                 int screenExtents[4], 
+                                 double depthExtents[2])
+{
+    int xMin = std::numeric_limits<int>::max();
+    int xMax = std::numeric_limits<int>::min();
+    int yMin = std::numeric_limits<int>::max();
+    int yMax = std::numeric_limits<int>::min();
+    double zMin = std::numeric_limits<double>::max();
+    double zMax = std::numeric_limits<double>::min();
+
+    float coordinates[8][3];
+    coordinates[0][0] = cube[0];   
+    coordinates[0][1] = cube[2];   
+    coordinates[0][2] = cube[4];	
+
+    coordinates[1][0] = cube[1];   
+    coordinates[1][1] = cube[2];   
+    coordinates[1][2] = cube[4];	
+
+    coordinates[2][0] = cube[1];  
+    coordinates[2][1] = cube[3];
+    coordinates[2][2] = cube[4];	
+
+    coordinates[3][0] = cube[0]; 
+    coordinates[3][1] = cube[3]; 
+    coordinates[3][2] = cube[4];
+
+    coordinates[4][0] = cube[0];
+    coordinates[4][1] = cube[2];
+    coordinates[4][2] = cube[5];
+
+    coordinates[5][0] = cube[1]; 
+    coordinates[5][1] = cube[2]; 
+    coordinates[5][2] = cube[5];	
+
+    coordinates[6][0] = cube[1]; 
+    coordinates[6][1] = cube[3];
+    coordinates[6][2] = cube[5];
+
+    coordinates[7][0] = cube[0]; 
+    coordinates[7][1] = cube[3]; 
+    coordinates[7][2] = cube[5];
+
+    double worldCoord[3];
+    int screenCoord[2]; double depth;
+    for (int i=0; i<8; i++)
+    {
+	worldCoord[0] = coordinates[i][0];
+	worldCoord[1] = coordinates[i][1];
+	worldCoord[2] = coordinates[i][2];
+	depth = ospray::ProjectWorldToScreen
+	    (worldCoord, screenWidth, screenHeight, 
+	     panPercentage, imageZoom, mvp, screenCoord);
+	// clamp values
+	screenCoord[0] = CLAMP(screenCoord[0], 0, screenWidth);
+	screenCoord[1] = CLAMP(screenCoord[1], 0, screenHeight);
+	screenExtents[0] = xMin = std::min(xMin, screenCoord[0]);
+	screenExtents[1] = xMax = std::max(xMax, screenCoord[0]);
+	screenExtents[2] = yMin = std::min(yMin, screenCoord[1]);
+	screenExtents[3] = yMax = std::max(yMax, screenCoord[1]);
+	depthExtents[0] = zMin = std::min(zMin, depth);
+	depthExtents[1] = zMax = std::max(zMax, depth);
+    }
+}
+
+void
+ospray::CompositeBackground(int screen[2],
+			 int compositedImageExtents[4],
+			 int compositedImageWidth,
+			 int compositedImageHeight,
+			 float *compositedImageBuffer,
+			 unsigned char *opaqueImageColor,
+			 float         *opaqueImageDepth,
+			 unsigned char *&imgFinal)
+{
+    if (UseThreadedBlend_MetaData) {
+    visit::CompositeBackground(screen,
+			       compositedImageExtents,
+			       compositedImageWidth,
+			       compositedImageHeight,
+			       compositedImageBuffer,
+			       opaqueImageColor,
+			       opaqueImageDepth,
+			       imgFinal);
+    } else {
+    for (int y = 0; y < screen[1]; y++)
+    {
+	for (int x = 0; x < screen[0]; x++)
+	{
+	    int indexScreen     = y * screen[0] + x;
+	    int indexComposited =
+		(y - compositedImageExtents[2]) * compositedImageWidth +
+		(x - compositedImageExtents[0]);
+
+	    bool insideComposited = 
+		((x >= compositedImageExtents[0] && 
+		  x < compositedImageExtents[1]) &&
+		 (y >= compositedImageExtents[2] && 
+		  y < compositedImageExtents[3]));
+
+	    if (insideComposited)
+	    {
+		if (compositedImageBuffer[indexComposited*4 + 3] == 0)
+		{
+		    // No data from rendering here! - Good
+		    imgFinal[indexScreen * 3 + 0] = 
+			opaqueImageColor[indexScreen * 3 + 0];
+		    imgFinal[indexScreen * 3 + 1] = 
+			opaqueImageColor[indexScreen * 3 + 1];
+		    imgFinal[indexScreen * 3 + 2] = 
+			opaqueImageColor[indexScreen * 3 + 2];
+		}
+		else
+		{
+		    // Volume in front
+		    float alpha = 
+			(1.0 - compositedImageBuffer[indexComposited * 4 + 3]);
+		    imgFinal[indexScreen * 3 + 0] = 
+			CLAMP(opaqueImageColor[indexScreen * 3 + 0] * alpha +
+			      compositedImageBuffer[indexComposited * 4 + 0] *
+			      255.f,
+			      0.f, 255.f);
+		    imgFinal[indexScreen * 3 + 1] = 
+			CLAMP(opaqueImageColor[indexScreen * 3 + 1] * alpha +
+			      compositedImageBuffer[indexComposited * 4 + 1] *
+			      255.f,
+			      0.f, 255.f);
+		    imgFinal[indexScreen * 3 + 2] =
+			CLAMP(opaqueImageColor[indexScreen * 3 + 2] * alpha +
+			      compositedImageBuffer[indexComposited * 4 + 2] *
+			      255.f,
+			      0.f, 255.f);
+		}
+	    }
+	    else
+	    {
+		// Outside bounding box: Use the background : Good
+		imgFinal[indexScreen * 3 + 0] = 
+		    opaqueImageColor[indexScreen * 3 + 0];
+		imgFinal[indexScreen * 3 + 1] =
+		    opaqueImageColor[indexScreen * 3 + 1];
+		imgFinal[indexScreen * 3 + 2] =
+		    opaqueImageColor[indexScreen * 3 + 2];
+	    }
+	}
+    }
+    }
+}
+
+
+void
+ospray::WriteArrayToPPM(std::string filename, const float * image,
+			int dimX, int dimY)
+{
+    std::ofstream outputFile((filename+ ".ppm").c_str(), 
+			     std::ios::out | std::ios::binary);
+    outputFile <<  "P6\n" << dimX << "\n" << dimY << "\n" << 255 << "\n"; 
+    for (int y=dimY-1; y>=0; --y)
+    {
+        for (int x=0; x<dimX; ++x)
+        {
+            int index = (y * dimX + x)*4;
+            char color[3];
+            float alpha = image[index + 3];
+            color[0] = CLAMP(image[index + 0]*alpha, 0.0f, 1.0f) * 255;
+            color[1] = CLAMP(image[index + 1]*alpha, 0.0f, 1.0f) * 255;
+            color[2] = CLAMP(image[index + 2]*alpha, 0.0f, 1.0f) * 255;
+            outputFile.write(color,3);
+        }
+    } 
+    outputFile.close();
+}
+
+void
+ospray::WriteArrayToPPM(std::string filename,  const unsigned char *image, 
+			int dimX, int dimY)
+{
+    std::ofstream outputFile((filename+ ".ppm").c_str(), 
+			     std::ios::out | std::ios::binary);
+    outputFile <<  "P6\n" << dimX << "\n" << dimY << "\n" << 255 << "\n"; 
+    for (int y=dimY-1; y>=0; --y)
+    {
+	outputFile.write(reinterpret_cast<const char*>(&image[y * dimX * 3]), 
+			 dimX * 3);
+    } 
+    outputFile.close();
+}
+
+void
+ospray::WriteArrayGrayToPPM(std::string filename, const float* image, 
+			    int dimX, int dimY)
+{
+    std::ofstream outputFile((filename+ ".ppm").c_str(), 
+			     std::ios::out | std::ios::binary);
+    outputFile <<  "P6\n" << dimX << "\n" << dimY << "\n" << 255 << "\n"; 
+    for (int y=dimY-1; y>=0; --y)
+    {
+        for (int x=0; x<dimX; ++x)
+        {
+            int index = (y * dimX + x);
+	    char var = CLAMP(image[index], 0.f, 1.f) * 255;
+            char color[3];
+            color[0] = var;
+            color[1] = var;
+            color[2] = var;
+            outputFile.write(color,3);
+        }
+    } 
+    outputFile.close();
+}
diff --git a/avt/Filters/avtOSPRayCommon.h b/avt/Filters/avtOSPRayCommon.h
new file mode 100644
index 0000000000..4198c82283
--- /dev/null
+++ b/avt/Filters/avtOSPRayCommon.h
@@ -0,0 +1,747 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2017, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef AVT_OSPRAY_COMMON_H
+#define AVT_OSPRAY_COMMON_H
+
+#ifndef VISIT_OSPRAY /* make sure VISIT_OSPRAY is defined */
+# error "VISIT_OSPRAY is not defined but ospray is used"
+#endif
+
+#include <avtParallel.h>
+
+#include <vtkType.h>
+#include <vtkMatrix4x4.h>
+
+#include <ospray/ospray.h>
+
+#include <cmath>
+#include <cstdlib>
+#include <iostream>
+#include <limits>
+#include <stdio.h>
+#include <string>
+#include <vector>
+#include <map>
+
+// some constants
+#define OSP_PERSPECTIVE              1
+#define OSP_ORTHOGRAPHIC             2
+#define OSP_BLOCK_BRICKED_VOLUME     3
+#define OSP_SHARED_STRUCTURED_VOLUME 4
+#define OSP_INVALID                  5
+#define OSP_VALID                    6
+
+// ostreams customized for ospray
+#ifdef ospout
+#undef ospout
+#endif
+#define ospout \
+    if (!ospray::CheckVerbose() && !DebugStream::Level5()) ; \
+    else (*ospray::osp_out)
+#ifdef osperr
+#undef osperr
+#endif
+#define osperr \
+    if (!ospray::CheckVerbose() && !DebugStream::Level1()) ; \
+    else (*ospray::osp_err)
+namespace ospray {
+    extern std::ostream *osp_out;
+    extern std::ostream *osp_err;
+    //////////////////////////////////////////////////////
+    //                                                  //
+    // Those function has to be inline, otherwise we    //
+    // need to link this library to other components    //
+    // manually                                         //
+    //                                                  //
+    //////////////////////////////////////////////////////
+    //                                                  //
+    // OSPRay defines following environmental variables //
+    //                                                  //
+    // OSPRAY_DEBUG                                     //
+    // OSPRAY_THREADS                                   //
+    // OSPRAY_LOG_LEVEL                                 //
+    // OSPRAY_LOG_OUTPUT                                //
+    // OSPRAY_SET_AFFINITY                              //
+    //                                                  //
+    // We define one more environmental variable here   //
+    //                                                  //
+    // OSPRAY_VERBOSE                                   //
+    //                                                  //
+    //////////////////////////////////////////////////////
+    inline bool InitVerbose() {
+        const char* env_verbose   = std::getenv("OSPRAY_VERBOSE");
+        const char* env_debug     = std::getenv("OSPRAY_DEBUG");
+        const char* env_log_level = std::getenv("OSPRAY_LOG_LEVEL");	
+        bool verbose = false;
+        if (env_verbose) { if (atoi(env_verbose) > 0) { verbose = true; } }
+        if (env_debug) { if (atoi(env_debug) > 0) { verbose = true; } }
+        if (env_log_level) { if (atoi(env_log_level) > 0) { verbose = true; } }
+        if (verbose) {
+            ospray::osp_out = &std::cout;
+            ospray::osp_err = &std::cerr;
+            return true;
+	} else { return false; }
+    }
+    inline int InitOSPRaySpp() {
+        int spp = 1;
+        const char* env_spp = std::getenv("OSPRAY_SPP");
+        if (env_spp) { if (atoi(env_spp) > 0) { spp = atoi(env_spp); } }
+        return spp;
+    }
+    inline bool CheckVerbose() { // initialize OSPRAY_VERBOSE    
+        static bool OSPRAY_VERBOSE = ospray::InitVerbose();
+        return OSPRAY_VERBOSE;
+    }
+    inline int CheckOSPRaySpp() {
+        static int spp = InitOSPRaySpp();
+        return spp;
+    }
+};
+
+// ****************************************************************************
+//  Struct:  OSPVisItVolume
+//
+//  Purpose:
+//    
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+class OSPVisItContext;
+class OSPVisItVolume 
+{
+ private:
+    friend class OSPVisItContext;
+
+    OSPVisItContext *parent;
+
+    // objects owned by the struct
+    // -- ospray model ---
+    OSPModel            world;
+    unsigned char       worldType;
+    // --- ospray framebuffer ---
+    OSPFrameBuffer      framebuffer;
+    float              *framebufferData;
+    OSPTexture2D        framebufferBg;
+    osp::vec2i imageSize;
+    // --- ospray volume ---
+    OSPVolume           volume;
+    unsigned char       volumeType;
+    // --- ospray data ---
+    OSPDataType         voxelDataType;
+    OSPData             voxelData;
+    size_t              voxelSize;
+    void*               dataPtr;
+    std::string         dataType;
+
+    // metadata for volume
+    int                 patchId;       // volume patch id
+    bool                finished;      // check if this volume is initialized
+    bool                enableShading;
+    bool                enableDVR;     // Distributed Volume Renderer
+    float               specularKs;
+    float               specularNs;
+    float               samplingRate;
+
+    // geometric parameters for volume
+    osp::vec3i          regionSize;
+    osp::vec3f          regionStart;
+    osp::vec3f          regionStop;
+    osp::vec3f          regionSpacing;
+    osp::vec3f          regionUpperClip;
+    osp::vec3f          regionLowerClip;
+    osp::vec3f          regionScaling;
+    
+ public:
+    // constructor
+    OSPVisItVolume() {
+	// objects owned by the struct
+	world           = NULL;
+	worldType       = OSP_INVALID;
+	framebuffer     = NULL;
+	framebufferData = NULL;
+	framebufferBg   = NULL;
+	volume          = NULL;
+	volumeType      = OSP_INVALID;
+	voxelDataType   = OSP_VOID_PTR;
+	voxelData       = NULL;
+	voxelSize       = 0;
+	dataPtr         = NULL;
+	dataType        = "";
+	// metadata for volume
+	//patchId = id;    
+	finished      = false; 
+	enableShading = false;
+	enableDVR     = false;
+	specularKs    = 1.0f;
+	specularNs    = 15.0f;
+	samplingRate  = 3.0f;
+	// geometric parameters for volume
+	regionSize.x  = regionSize.y  = regionSize.z  = 0;
+	regionStart.x = regionStart.y = regionStart.z = 0.0f;
+	regionStop.x  = regionStop.y  = regionStop.z  = 0.0f;
+	regionSpacing.x   = regionSpacing.y   = regionSpacing.z   = 0.0f;
+	regionUpperClip.x = regionUpperClip.y = regionUpperClip.z = 0.0f;
+	regionLowerClip.x = regionLowerClip.y = regionLowerClip.z = 0.0f;
+	regionScaling.x   = regionScaling.y   = regionScaling.z   = 1.0f;
+    }
+
+    // destructor
+    ~OSPVisItVolume() { Clean(); }    
+    void Clean() {
+        CleanFB();
+        CleanVolume();	
+        CleanWorld();
+    }
+    
+    // other function
+    void Set(int type, void *ptr, 
+             double *X, double *Y, double *Z, 
+             int nX, int nY, int nZ, 
+             double volumePBox[6], double volumeBBox[6],
+             double mtl[4], float sr, bool shading);
+    bool GetDVRFlag() { return enableDVR; }
+    void SetDVRFlag(bool mode) { enableDVR = mode; }
+    bool GetFinishedFlag() { return finished; }
+    void SetFinishedFlag(bool f) { finished = f; } 
+
+    // ospModel component
+    OSPModel GetWorld() { return world; }
+    void InitWorld();
+    void SetWorld();
+    void CleanWorld() {
+        if (world != NULL) {	    
+            ospRelease(world);
+            world = NULL;
+        }
+        worldType = OSP_INVALID;
+    }
+	
+    // ospVolume component
+    void InitVolume(unsigned char type = OSP_SHARED_STRUCTURED_VOLUME); 
+    OSPVolume GetVolume() { return volume; }
+    void SetVolume(int type, void *ptr,
+                   double *X, double *Y, double *Z, 
+                   int nX, int nY, int nZ,
+                   double volumePBox[6], 
+                   double volumeBBox[6]);
+    void CleanVolume() {	
+        if (volume != NULL) { ospRelease(volume); volume = NULL; }
+        if (voxelData != NULL) { 
+            ospRelease(voxelData);
+            voxelData = NULL; 
+        }
+        volumeType = OSP_INVALID;
+    }
+
+    // framebuffer component     
+    void InitFB(unsigned int width, unsigned int height);
+    void RenderFB();
+    float* GetFBData();
+    void CleanFB() {
+        if (framebufferData != NULL) { 
+            ospUnmapFrameBuffer(framebufferData, framebuffer); 
+            framebufferData = NULL;
+        }
+        if (framebuffer != NULL) { 
+            ospRelease(framebuffer); 	    
+            framebuffer = NULL;
+        }
+        if (framebufferBg != NULL) {
+            ospRelease(framebufferBg); 	    
+            framebufferBg = NULL;
+        }
+    }
+};
+
+// ****************************************************************************
+//  Struct:  OSPVisItLight
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+struct OSPVisItLight
+{
+    OSPLight aLight;
+    OSPLight dLight;
+    OSPLight sLight; // constant sun light
+    OSPData  lightdata;
+    OSPVisItLight() {
+        aLight = NULL;
+        dLight = NULL;
+        sLight = NULL;
+        lightdata = NULL;
+    }
+    ~OSPVisItLight() { Clean(); }
+    void Clean() {/* TODO should we delete them? */}
+    void Init(const OSPRenderer& renderer);
+    void Set(double materialProperties[4], double viewDirection[3]);
+};
+
+// ****************************************************************************
+//  Struct:  OSPVisItRenderer
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+struct OSPVisItRenderer
+{
+public:
+    enum State {
+        INVALID, /* TODO do we need this actually ? */
+        SCIVIS,
+    } rendererType;
+    OSPRenderer renderer;
+    OSPVisItLight lights;
+    // properties
+    int aoSamples;
+    int spp; //!< samples per pixel
+    bool flagOneSidedLighting;
+    bool flagShadowsEnabled;
+    bool flagAoTransparencyEnabled;
+    float       *maxDepthBuffer;  // depth buffer (shared, never delete)
+    osp::vec2i   maxDepthSize;    // buffer extents (minX, maxX, minY, max)  
+public:
+    OSPVisItRenderer() {
+        renderer = NULL;
+        rendererType = INVALID;
+        aoSamples = 0;
+        spp = ospray::CheckOSPRaySpp();
+        flagOneSidedLighting = false;
+        flagShadowsEnabled = false;
+        flagAoTransparencyEnabled = false;
+    }
+    ~OSPVisItRenderer() { Clean(); }
+    void Clean() {
+        if (renderer != NULL) {
+            lights.Clean();
+            ospRelease(renderer);
+            renderer = NULL;
+            rendererType = INVALID;
+        }
+    }
+    void Init();
+    void Set(double materialProperties[4], double viewDirection[3], bool);
+    void SetCamera(const OSPCamera& camera);
+    void SetModel(const OSPModel& world);
+};
+
+// ****************************************************************************
+//  Struct:  OSPVisItCamera
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+struct OSPVisItCamera
+{
+public:
+    enum State {
+        INVALID,
+        PERSPECTIVE,
+        ORTHOGRAPHIC,
+    } cameraType;
+    OSPCamera camera;
+    float panx; // this is a ratio [0, 1]
+    float pany; // this is a ratio [0, 1]
+    float r_xl; 
+    float r_yl;
+    float r_xu;
+    float r_yu;
+    float zoom; 
+    int   size[2];
+    osp::vec2f imgS, imgE;
+public:
+    OSPVisItCamera() {
+        camera = NULL;
+        cameraType = INVALID;
+        panx = 0.0f;
+        pany = 0.0f;
+        zoom = 1.0f;
+        size[0] = size[1] = 0.0f;
+        imgS.x = 0.f;
+        imgS.y = 0.f;
+        imgE.x = 0.f;
+        imgE.y = 0.f;
+    }
+    ~OSPVisItCamera() { Clean(); }
+    void Clean() {
+        if (camera != NULL) {
+            ospRelease(camera);
+            camera = NULL;
+            cameraType = INVALID;
+        }
+    }
+    void Init(State type);
+    void Set(const double camp[3], 
+             const double camf[3], 
+             const double camu[3], 
+             const double camd[3],
+             const double sceneSize[2],
+             const double aspect, 
+             const double fovy, 
+             const double zoom_ratio, 
+             const double pan_ratio[2],
+             const int bufferExtents[4],
+             const int screenExtents[2]);
+    void SetScreen(float xMin, float xMax, float yMin, float yMax);
+};
+
+// ****************************************************************************
+//  Struct:  OSPVisItColor
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+struct OSPVisItColor { float R,G,B, A; };
+
+// ****************************************************************************
+//  Struct:  OSPVisItTransferFunction
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+struct OSPVisItTransferFunction
+{
+public:
+    enum State { INVALID, PIECEWISE_LINEAR, } transferfcnType;
+    OSPTransferFunction  transferfcn;
+public:
+    OSPVisItTransferFunction() {
+        transferfcn = NULL;
+        transferfcnType = INVALID;
+    }
+    void Clean() {
+        if (transferfcn != NULL) {
+            ospRelease(transferfcn);
+            transferfcn = NULL;
+            transferfcnType = INVALID;
+        }
+    }
+    void Init();
+    void Set(const OSPVisItColor* table,
+             const unsigned int size, 
+             const float datamin,
+             const float datamax);
+};
+
+// ****************************************************************************
+//  Struct:  OSPVisItContext
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+class OSPVisItContext
+{
+public:
+    // ************************************************************************
+    // We expose this in header because iy will be called in other components
+    // where we dont have direct library linkage
+    // ************************************************************************
+    OSPVisItContext() 
+    {
+        regionScaling.x = regionScaling.y = regionScaling.z = 1.0f;
+    }
+    ~OSPVisItContext() {	
+        volumes.clear();
+        renderer.Clean();
+        camera.Clean();
+        transferfcn.Clean();
+    }
+
+    // helper
+    void Render(float xMin, float xMax, float yMin, float yMax,
+                int imgWidth, int imgHeight, 
+                float*& dest, OSPVisItVolume* volume);
+    void InitOSP(int numThreads = 0);
+    void Finalize();
+    void InitPatch(int id);
+    OSPVisItVolume* GetPatch(int id) { return &volumes[id]; }
+
+    // parameters
+    void SetDataBounds(double dbounds[6]) {
+        for (int i = 0; i < 6; ++i) { bounds[i] = dbounds[i]; }
+    }
+    void SetBgBuffer(float* depth, int extents[4]) {
+        renderer.maxDepthBuffer = depth;
+        renderer.maxDepthSize.x = extents[1] - extents[0];
+        renderer.maxDepthSize.y = extents[3] - extents[2];
+    }
+    void SetScaling(double s[3]) { 
+        regionScaling.x = (float)s[0];
+        regionScaling.y = (float)s[1];
+        regionScaling.z = (float)s[2]; 
+    }
+
+    OSPVisItRenderer renderer;
+    OSPVisItCamera   camera;
+    OSPVisItTransferFunction transferfcn;
+    std::map<int, OSPVisItVolume> volumes;
+
+private:
+    
+    friend class OSPVisItVolume;
+    osp::vec3f     regionScaling;
+    double bounds[6];
+    static bool initialized;
+    
+};
+
+#endif//AVT_OSPRAY_COMMON_H
+
+
+// ****************************************************************************
+//
+//
+//
+//  Extra Functions Defined here
+//
+//
+//
+// ****************************************************************************
+
+#ifndef VISIT_OSPRAY_CONTEXT_ONLY
+
+#ifndef AVT_OSPRAY_COMMON_EXTRA_H
+#define AVT_OSPRAY_COMMON_EXTRA_H
+
+#include <DebugStream.h>
+#include <StackTimer.h>
+#include <TimingsManager.h>
+#include <ImproperUseException.h>
+#include <ospray/visit/VisItImageComposite.h>
+
+#ifndef CLAMP
+# define CLAMP(x, l, h) (x > l ? x < h ? x : h : l)
+#endif
+#ifndef M_MIN
+# define M_MIN(x, r) (x < r ? x : r)
+#endif
+#ifndef M_MAX
+# define M_MAX(x, r) (x > r ? x : r)
+#endif
+
+// ****************************************************************************
+//  Namespace:  ospray
+//
+//  Purpose:
+//    
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+namespace ospray
+{
+    // ************************************************************************
+    //  Struct:  ImgMetaData
+    //
+    //  Purpose:
+    //    Holds information about patches but not the image 
+    //
+    //  Programmer:  
+    //  Creation:   
+    //
+    // ************************************************************************
+
+    struct ImgMetaData
+    {
+        int procId;       // processor that produced the patch
+        int patchNumber;  // id of the patch on that processor
+        int destProcId;   // destination proc where this patch gets composited
+        int inUse;        // whether the patch is composed locally or not
+        int dims[2];      // height, width
+        int screen_ll[2]; // (lower left)  position in the final image
+        int screen_ur[2]; // (upper right)
+        float avg_z;      // camera space depth of the patch (average)
+        float eye_z;      // camera space z
+        float clip_z;     // clip space z
+    };
+
+    // ************************************************************************
+    //  Struct:  ImgData
+    //
+    //  Purpose:
+    //    Holds the image data generated
+    //
+    //  Programmer:  
+    //  Creation:    
+    //
+    // ************************************************************************
+    
+    struct ImgData
+    {
+        // acts as a key
+        int procId;        // processor that produced the patch
+        int patchNumber;   // id of the patch on that processor
+        float *imagePatch; // the image data - RGBA
+        ImgData() { imagePatch = NULL; }
+        bool operator==(const ImgData &a) {
+            return (patchNumber == a.patchNumber);
+        }
+    };
+
+    // ************************************************************************
+    //
+    //  Helper Functions
+    //
+    // ************************************************************************
+        
+    void CheckMemoryHere(const std::string& message, 
+                         std::string debugN = "debug5");
+    void CheckMemoryHere(const std::string& message, 
+                         std::ostream& out);
+
+    typedef int timestamp;
+    inline void CheckSectionStart(const std::string& c,
+                                  const std::string& f,
+                                  timestamp& timingDetail,
+                                  const std::string& str) 
+    {
+        debug5 << c << "::" << f << " " << str << " Start" << std::endl;
+        timingDetail = visitTimer->StartTimer();	    
+    }
+    
+    inline void CheckSectionStop(const std::string& c,
+                                 const std::string& f, 
+                                 timestamp& timingDetail,
+                                 const std::string& str) 
+    {
+        visitTimer->StopTimer(timingDetail, 
+                              (c + "::" + f + " " + str).c_str());
+        ospray::CheckMemoryHere(("[" + c + "]" + " " + f + " " + str).c_str(),
+                                "debug5");
+        debug5 << c << "::" << f << " " << str << " Done" << std::endl;
+    }
+
+    inline void Exception(const std::string str)
+    {
+        std::cerr << str << std::endl;
+        debug1    << str << std::endl;
+        EXCEPTION1(VisItException, str.c_str()); 
+    }
+
+    double ProjectWorldToScreen
+        (const double worldCoord[3], 
+         const int screenWidth, const int screenHeight,	 
+         const double panPercentage[2], const double imageZoom,
+         vtkMatrix4x4 *mvp, int screenCoord[2]);
+    
+    void ProjectScreenToWorld
+        (const int screenCoord[2], const double z,
+         const int screenWidth, const int screenHeight, 
+         const double panPercentage[2], const double imageZoom,
+         vtkMatrix4x4 *imvp, double worldCoord[3]);
+
+    void ProjectScreenToCamera
+        (const int screenCoord[2], const double z,
+         const int screenWidth, const int screenHeight,
+         vtkMatrix4x4 *imvp, double cameraCoord[3]);
+
+    inline void ProjectScreenToWorld
+        (const int x, const int y, const double z,
+         const int screenWidth, const int screenHeight, 
+         const double panPercentage[2], const double imageZoom,
+         vtkMatrix4x4 *imvp, double worldCoord[3]) 
+    {
+        int screen_coord[2] = {x, y};
+        ProjectScreenToWorld(screen_coord, z, screenWidth, screenHeight, 
+                             panPercentage, imageZoom, imvp, worldCoord);
+    }
+
+    void ProjectWorldToScreenCube
+        (const double cube[6], const int screenWidth, const int screenHeight, 
+         const double panPercentage[2], const double imageZoom, 
+         vtkMatrix4x4 *mvp,int screenExtents[4], double depthExtents[2]);
+
+    void CompositeBackground(int screen[2],
+                             int compositedImageExtents[4],
+                             int compositedImageWidth,
+                             int compositedImageHeight,
+                             float *compositedImageBuffer,
+                             unsigned char *opaqueImageColor,
+                             float         *opaqueImageDepth,
+                             unsigned char *&imgFinal);
+    
+    void WriteArrayToPPM
+        (std::string filename, const float *image, int dimX, int dimY);
+
+    void WriteArrayToPPM
+        (std::string filename, const unsigned char *image, int dimX, int dimY);
+
+    void WriteArrayGrayToPPM
+        (std::string filename, const float * image, int dimX, int dimY);
+};
+
+#endif//AVT_OSPRAY_COMMON_EXTRA_H
+
+#endif//VISIT_OSPRAY_CONTEXT_ONLY
+
diff --git a/avt/Filters/avtOSPRayImageCompositor.C b/avt/Filters/avtOSPRayImageCompositor.C
new file mode 100644
index 0000000000..c72baf7bb4
--- /dev/null
+++ b/avt/Filters/avtOSPRayImageCompositor.C
@@ -0,0 +1,2394 @@
+/*****************************************************************************
+ *
+ * Copyright (c) 2000 - 2017, Lawrence Livermore National Security, LLC
+ * Produced at the Lawrence Livermore National Laboratory
+ * LLNL-CODE-442911
+ * All rights reserved.
+ *
+ * This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+ * full copyright notice is contained in the file COPYRIGHT located at the root
+ * of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+ *
+ * Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  - Redistributions of  source code must  retain the above  copyright notice,
+ *    this list of conditions and the disclaimer below.
+ *  - Redistributions in binary form must reproduce the above copyright notice,
+ *    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+ *    documentation and/or other materials provided with the distribution.
+ *  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+ * ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+ * LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+ * DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+ * LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+ * OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ *****************************************************************************/
+
+// ************************************************************************ //
+//                        avtOSPRayImageCompositor.C                         //
+// ************************************************************************ //
+
+#include <avtOSPRayImageCompositor.h>
+
+#ifdef PARALLEL
+#  ifdef VISIT_OSPRAY_ICET
+#    include <IceT.h>
+#    include <IceTMPI.h>
+#  endif
+#endif
+
+#include <cmath>
+#include <ctime>
+#include <cstdio>
+#include <cstring>
+#include <cstdlib>
+#include <limits>
+#include <fstream>
+#include <algorithm>
+#include <set>
+
+#if defined (_MSC_VER) && (_MSC_VER < 1800) && !defined(round)
+inline double round(double x) {return (x-floor(x))>0.5?ceil(x):floor(x);}
+#endif
+
+enum blendDirection {FRONT_TO_BACK = 0, BACK_TO_FRONT = 1};
+
+// ***************************************************************************
+// Threaded Blending
+// ***************************************************************************
+
+bool CheckThreadedBlend_Communicator()
+{
+    bool use = true;
+    const char* env_use = std::getenv("OSPRAY_SERIAL_BLEND");
+    if (env_use) { 
+	use = atoi(env_use) <= 0; 
+    }
+    return use;
+}
+static bool UseThreadedBlend_Communicator = CheckThreadedBlend_Communicator();
+
+// ***************************************************************************
+//  Class: avtOSPRayIC_IceT
+// ***************************************************************************
+
+class avtOSPRayIC_IceT : public avtOSPRayIC_Implementation
+{
+public:
+    avtOSPRayIC_IceT(int mpiSize, int mpiRank);
+    ~avtOSPRayIC_IceT();
+    void Init(int, int);
+    void SetTile(const float*, const int*, const float&);
+    void Composite(float*&);
+    static bool Valid();
+private:
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    //---------------------------------------
+    IceTInt          screen[2];
+    IceTContext      context, prevContext;
+    IceTCommunicator comm;
+    IceTInt          MPISize;
+    IceTInt          MPIRank;
+    IceTImage        result;    
+    //---------------------------------------
+    static const bool       usage;
+    static const IceTDouble identity[16];
+    static const IceTFloat  bgColor[4];
+    static const IceTEnum   strategy;
+    //---------------------------------------
+    static const float* imgData;
+    static int          imgMeta[4];
+    //---------------------------------------
+    static bool     CheckUsage();
+    static IceTEnum CheckStrategy();
+    static void DrawCallback(const IceTDouble*, const IceTDouble*,  
+                             const IceTFloat*, const IceTInt*, 
+                             IceTImage img);
+#endif
+};
+
+/*! static functions */
+bool avtOSPRayIC_IceT::Valid() { 
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    return usage;
+#else
+    return false;
+#endif
+}
+
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+const bool avtOSPRayIC_IceT::usage =
+    avtOSPRayIC_IceT::CheckUsage(); 
+bool avtOSPRayIC_IceT::CheckUsage()
+{
+    bool use_icet = false;
+    const char* env_use_icet = std::getenv("OSPRAY_USE_ICET");
+    if (env_use_icet) { 
+	use_icet = atoi(env_use_icet) > 0; 
+    }
+    return use_icet;
+}
+const IceTDouble avtOSPRayIC_IceT::identity[16] = 
+    {
+        IceTDouble(1.0), IceTDouble(0.0), IceTDouble(0.0), IceTDouble(0.0),
+        IceTDouble(0.0), IceTDouble(1.0), IceTDouble(0.0), IceTDouble(0.0),
+        IceTDouble(0.0), IceTDouble(0.0), IceTDouble(1.0), IceTDouble(0.0),
+        IceTDouble(0.0), IceTDouble(0.0), IceTDouble(0.0), IceTDouble(1.0)
+    };
+const IceTFloat avtOSPRayIC_IceT::bgColor[4] = 
+    {
+        IceTFloat(0.0f), IceTFloat(0.0f), IceTFloat(0.0f), IceTFloat(0.0f)
+    };
+const float*   avtOSPRayIC_IceT::imgData = NULL;
+int            avtOSPRayIC_IceT::imgMeta[4] = {0,0,0,0};
+const IceTEnum avtOSPRayIC_IceT::strategy =
+    avtOSPRayIC_IceT::CheckStrategy();
+IceTEnum       avtOSPRayIC_IceT::CheckStrategy() 
+{
+    if (avtOSPRayIC_IceT::Valid()) {
+        IceTEnum ret;
+        int strategy = 3;
+        const char* env_icet_strategy = std::getenv("OSPRAY_ICET_STRATEGY");
+        if (env_icet_strategy) { strategy = atoi(env_icet_strategy); }
+        switch (strategy) {
+        case 0:
+            ret = ICET_STRATEGY_REDUCE;
+            break;
+        case 1:
+            ret = ICET_SINGLE_IMAGE_STRATEGY_TREE;
+            break;
+        case 2:
+            ret = ICET_SINGLE_IMAGE_STRATEGY_RADIXK;
+            break;
+        default:
+            ret = ICET_SINGLE_IMAGE_STRATEGY_BSWAP;
+            break;
+        }
+        return ret;
+    }
+    else {
+        return false;
+    }
+}
+#endif
+
+/*! regular member functions */
+avtOSPRayIC_IceT::avtOSPRayIC_IceT(int mpiSize, int mpiRank)
+    : avtOSPRayIC_Implementation(mpiSize, mpiRank)
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    MPISize = IceTInt(mpiSize);
+    MPIRank = IceTInt(mpiRank);
+    prevContext = icetGetContext();
+    comm = icetCreateMPICommunicator(VISIT_MPI_COMM);
+    context = icetCreateContext(comm);
+    icetDestroyMPICommunicator(comm);
+    // debug
+    if (avtOSPRayIC_IceT::Valid() && mpiRank == 0) {
+        switch (avtOSPRayIC_IceT::strategy) {
+        case 0:
+            ospout << "[avtOSPRayIC_IceT] Strategy Reduce" << std::endl;
+            break;
+        case 1:
+            ospout << "[avtOSPRayIC_IceT] Strategy Tree" << std::endl;
+            break;
+        case 2:
+            ospout << "[avtOSPRayIC_IceT] Strategy Radix-k" << std::endl;
+            break;
+        default:
+            ospout << "[avtOSPRayIC_IceT] Strategy BSwap" << std::endl;
+            break;
+        }
+    }
+#endif
+}
+
+avtOSPRayIC_IceT::~avtOSPRayIC_IceT()
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    icetDestroyContext(context);
+    icetSetContext(prevContext);
+#endif
+}
+
+void avtOSPRayIC_IceT::Init(int W, int H)
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    
+    if (MPIRank == 0) {
+        ospout << "avtOSPRayIC_IceT::Init Start";
+    }
+    //
+    // Initialization
+    //
+    screen[0] = W;
+    screen[1] = H;
+    //
+    // Setup IceT parameters
+    //
+    if (/*ospray::CheckVerbose()*/ false /*|| DebugStream::Level5()*/) {
+        icetDiagnostics(ICET_DIAG_FULL);
+    }
+    icetCompositeMode(ICET_COMPOSITE_MODE_BLEND);
+    icetSetColorFormat(ICET_IMAGE_COLOR_RGBA_FLOAT);
+    icetSetDepthFormat(ICET_IMAGE_DEPTH_NONE);
+    icetEnable(ICET_ORDERED_COMPOSITE);
+    icetDisable(ICET_INTERLACE_IMAGES);
+    //
+    // Safety
+    //
+    MPI_Barrier(MPI_COMM_WORLD);
+    if (MPIRank == 0) {
+        ospout << " ... Done" << std::endl;
+    }
+#endif
+}
+
+void avtOSPRayIC_IceT::SetTile(const float* d, 
+                                   const int*   e, /* xmin, xmax, ymin, ymax */
+                                   const float& z)
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    //
+    // Gather depths
+    //
+    if (MPIRank == 0) {
+        ospout << "avtOSPRayIC_IceT::SetTile Gather Depth";
+    }
+    std::vector<float>   all_depths(MPISize);
+    std::vector<IceTInt> all_orders(MPISize);
+    MPI_Allgather(&z, 1, MPI_FLOAT, all_depths.data(), 1, 
+                  MPI_FLOAT, MPI_COMM_WORLD);
+    if (MPIRank == 0) { ospout << " ... Done" << std::endl; }
+    //
+    // Sort depths in compositing order
+    //
+    if (MPIRank == 0) {
+        ospout << "avtOSPRayIC_IceT::SetTile Sort Depths";
+    }
+    std::multimap<float,int> ordered_depths;
+    for (int i = 0; i < MPISize; i++) {
+        ordered_depths.insert(std::pair<float, int>(all_depths[i], i));      
+    }
+    int i = 0;
+    for (std::multimap<float,int>::iterator it = ordered_depths.begin(); 
+	 it != ordered_depths.end(); ++it) {
+        all_orders[i] = (*it).second;
+        i++;
+    }
+    icetCompositeOrder(all_orders.data());
+    if (MPIRank == 0) { ospout << " ... Done" << std::endl; }
+    //
+    // Set IceT Tile Information
+    //
+    icetResetTiles();
+    icetAddTile(0, 0, screen[0], screen[1], 0);
+    icetPhysicalRenderSize(screen[0], screen[1]);
+    //
+    // Composite Stratagy
+    //
+    if (strategy == ICET_STRATEGY_REDUCE) {
+	icetStrategy(ICET_STRATEGY_REDUCE);
+    } else {	
+	icetStrategy(ICET_STRATEGY_SEQUENTIAL);
+	icetSingleImageStrategy(strategy);
+    }
+    //
+    // Bounding Box
+    //
+    icetBoundingBoxf(((float) e[0]   /(screen[0]-1) - 0.5f) * 2.f,
+    	             ((float)(e[1]-1)/(screen[0]-1) - 0.5f) * 2.f,
+		     ((float) e[2]   /(screen[1]-1) - 0.5f) * 2.f,
+		     ((float)(e[3]-1)/(screen[1]-1) - 0.5f) * 2.f,
+    		     0.0, 0.0);
+    //
+    // Compose
+    //
+    avtOSPRayIC_IceT::imgData = d;
+    avtOSPRayIC_IceT::imgMeta[0] = e[0];
+    avtOSPRayIC_IceT::imgMeta[1] = e[2];
+    avtOSPRayIC_IceT::imgMeta[2] = e[1] - e[0];
+    avtOSPRayIC_IceT::imgMeta[3] = e[3] - e[2];
+    icetDrawCallback(DrawCallback);
+#endif
+}
+
+void avtOSPRayIC_IceT::Composite(float*& output)
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    if (MPIRank == 0) { ospout << "avtOSPRayIC_IceT::Composite"; }
+    result = icetDrawFrame(identity, identity, bgColor);
+    if (MPIRank == 0) { ospout << " ... Done" << std::endl; }
+    if (MPIRank == 0) {
+	icetImageCopyColorf(result, output, ICET_IMAGE_COLOR_RGBA_FLOAT);
+    }
+#endif
+}
+
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+void avtOSPRayIC_IceT::DrawCallback(const IceTDouble*,
+					const IceTDouble*, 
+					const IceTFloat*, 
+					const IceTInt*,
+					IceTImage img) 
+{
+    float *o = icetImageGetColorf(img);
+    const int outputStride = icetImageGetWidth(img);
+    for (int j = 0; j < imgMeta[3]; ++j) {	
+	for (int i = 0; i < imgMeta[2]; ++i) {
+	    const int gIdx = 
+		i + imgMeta[0] + (j + imgMeta[1]) * outputStride;
+	    const int lIdx = i + j * imgMeta[2];
+	    o[4 * gIdx + 0] = imgData[4 * lIdx + 0];
+	    o[4 * gIdx + 1] = imgData[4 * lIdx + 1];
+	    o[4 * gIdx + 2] = imgData[4 * lIdx + 2];
+	    o[4 * gIdx + 3] = imgData[4 * lIdx + 3];
+	}
+    }
+}
+#endif
+
+// ***************************************************************************
+//  End Class: avtOSPRayIC_IceT
+// ***************************************************************************
+
+
+// ***************************************************************************
+//  Begin Class: avtOSPRayIC_OneNode
+// ***************************************************************************
+
+struct MetaData_OneNode {
+    int id;         // id of the patch on that processor
+    int dims[2];    // height, width
+    int extents[4]; // (lower left) (upper right)
+    float z;        // camera space depth of the patch (average)
+};
+
+class avtOSPRayIC_OneNode : public avtOSPRayIC_Implementation
+{
+private:
+    std::vector<MetaData_OneNode> allPatchMeta;
+    std::vector<const float*>     allPatchData;
+    int fullExtents[4];
+
+    static bool Predicate(MetaData_OneNode const& before,
+                          MetaData_OneNode const& after);
+public:
+    avtOSPRayIC_OneNode(int mpiSize, int mpiRank);
+    ~avtOSPRayIC_OneNode();
+    void Init(int, int);
+    void SetTile(const float*, const int*, const float&);
+    void Composite(float*&);
+    static bool Valid();
+};
+
+bool avtOSPRayIC_OneNode::Valid() { return true; };
+bool avtOSPRayIC_OneNode::Predicate(MetaData_OneNode const& before,
+                                        MetaData_OneNode const& after)
+{ return before.z > after.z; }
+
+avtOSPRayIC_OneNode::avtOSPRayIC_OneNode(int mpiSize, int mpiRank)
+    : avtOSPRayIC_Implementation(mpiSize, mpiRank)
+{
+}
+
+avtOSPRayIC_OneNode::~avtOSPRayIC_OneNode()
+{
+    allPatchMeta.clear();
+    allPatchData.clear();
+};
+
+void avtOSPRayIC_OneNode::Init(int W, int H)
+{
+    fullExtents[0] = 0;
+    fullExtents[1] = W;
+    fullExtents[2] = 0;
+    fullExtents[3] = H;
+};
+
+void avtOSPRayIC_OneNode::SetTile(const float* d,
+                                      /* xmin, xmax, ymin, ymax */ 
+                                      const int*   e,
+                                      const float& z)
+{
+    MetaData_OneNode m;
+    m.id = allPatchMeta.size();
+    m.dims[0] = e[1] - e[0];
+    m.dims[1] = e[3] - e[2];
+    m.extents[0] = e[0];
+    m.extents[1] = e[1];
+    m.extents[2] = e[2];
+    m.extents[3] = e[3];
+    m.z = z;
+    allPatchMeta.push_back(m);
+    allPatchData.push_back(d);
+}
+
+void avtOSPRayIC_OneNode::Composite(float*& output)
+{
+    // Sort with the largest z first
+    std::sort(allPatchMeta.begin(), allPatchMeta.end(),
+              &(avtOSPRayIC_OneNode::Predicate));
+    for (int i=0; i<allPatchMeta.size(); i++) {
+      MetaData_OneNode m = allPatchMeta[i];
+      avtOSPRayImageCompositor::BlendBackToFront(allPatchData[m.id],
+                                                m.extents,
+                                                output, 
+                                                fullExtents);
+    }
+}
+
+// ***************************************************************************
+//  End Class: avtOSPRayIC_OneNode
+// ***************************************************************************
+
+
+// ***************************************************************************
+//  Begin Class: avtOSPRayIC_Serial
+// ***************************************************************************
+
+// class avtOSPRayIC_Serial : public avtOSPRayIC_Implementation
+// {
+// public:
+//     avtOSPRayIC_Serial(int mpiSize, int mpiRank);
+//     ~avtOSPRayIC_Serial();
+//     void Init(int, int);
+//     void SetTile(const float*, const int*, const float&);
+//     void Composite(float*&);
+//     static bool Valid();
+// };
+
+// bool avtOSPRayIC_Serial::Valid() { return true; };
+
+// ***************************************************************************
+//  End Class: avtOSPRayIC_Serial
+// ***************************************************************************
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::avtOSPRayImageCompositor
+//
+//  Purpose: Constructor
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+avtOSPRayImageCompositor::avtOSPRayImageCompositor()
+{
+#ifdef PARALLEL
+    MPI_Comm_size(VISIT_MPI_COMM, &mpiSize);
+    MPI_Comm_rank(VISIT_MPI_COMM, &mpiRank);
+#else
+    mpiSize = 1;
+    mpiRank = 0;
+#endif
+    finalImage = NULL;
+    compositor = NULL;
+    // debug
+    if (mpiRank == 0) {
+        if (!UseThreadedBlend_Communicator) {
+            ospout << "[avtOSPRayImageCompositor] "
+                   << "Not Using Multi-Threading for Blending"
+                   << std::endl;
+        } else {
+            ospout << "[avtOSPRayImageCompositor] "
+                   << "Using Multi-Threading for Blending"
+                   << std::endl;
+        }
+        if (!avtOSPRayIC_IceT::Valid()) {
+            ospout << "[avtOSPRayImageCompositor] "
+                   << "Not Using IceT for Image Compositing"
+                   << std::endl;
+        } else {
+            ospout << "[avtOSPRayImageCompositor] "
+                   << "Using IceT for Image Compositing"
+                   << std::endl;
+        }
+    }
+    //////////////////////////////////////////////////////////////////////////
+    intermediateImageExtents[0] = intermediateImageExtents[1] = 0.0;
+    intermediateImageExtents[2] = intermediateImageExtents[3] = 0.0;
+    intermediateImageBBox[0] = intermediateImageBBox[1] = 0.0;
+    intermediateImageBBox[2] = intermediateImageBBox[3] = 0.0;
+    totalPatches = 0;
+    intermediateImage = NULL;
+    //////////////////////////////////////////////////////////////////////////
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::~avtOSPRayImageCompositor
+//
+//  Purpose:
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+avtOSPRayImageCompositor::~avtOSPRayImageCompositor()
+{
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendFrontToBack
+//
+//  Purpose:
+//      Blends tow patches in a front to back manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendFrontToBack(const float *srcImage,
+					       const int srcExtents[4],
+					       const int blendExtents[4], 
+					       float *&dstImage,
+					       const int dstExtents[4])
+{
+    if (UseThreadedBlend_Communicator) {
+	visit::BlendFrontToBack(blendExtents,
+				srcExtents,
+				srcImage,
+				dstExtents,
+				dstImage);
+    } else {
+        // image sizes
+        const int srcX = srcExtents[1] - srcExtents[0];
+        const int srcY = srcExtents[3] - srcExtents[2];
+        const int dstX = dstExtents[1] - dstExtents[0];
+        const int dstY = dstExtents[3] - dstExtents[2];
+        // determin the region to blend
+        const int startX = 
+            std::max(std::max(blendExtents[0], srcExtents[0]), dstExtents[0]);
+        const int startY = 
+            std::max(std::max(blendExtents[2], srcExtents[2]), dstExtents[2]);
+        const int endX = 
+            std::min(std::min(blendExtents[1], srcExtents[1]), dstExtents[1]);
+        const int endY = 
+            std::min(std::min(blendExtents[3], srcExtents[3]), dstExtents[3]);
+    
+        for (int y = startY; y < endY; ++y) {
+            for (int x = startX; x < endX; ++x) {
+                // get indices
+                int srcIndex = (srcX*(y-srcExtents[2]) + x-srcExtents[0])*4;
+                int dstIndex = (dstX*(y-dstExtents[2]) + x-dstExtents[0])*4;
+
+                // front to back compositing
+                if (dstImage[dstIndex + 3] < 1.0f) {
+                    float trans = 1.0f - dstImage[dstIndex + 3];
+                    dstImage[dstIndex+0] = 
+                        CLAMP(srcImage[srcIndex+0] * trans + 
+                              dstImage[dstIndex+0],
+                              0.0f, 1.0f);
+                    dstImage[dstIndex+1] = 
+                        CLAMP(srcImage[srcIndex+1] * trans + 
+                              dstImage[dstIndex+1],
+                              0.0f, 1.0f);
+                    dstImage[dstIndex+2] = 
+                        CLAMP(srcImage[srcIndex+2] * trans + 
+                              dstImage[dstIndex+2],
+                              0.0f, 1.0f);
+                    dstImage[dstIndex+3] = 
+                        CLAMP(srcImage[srcIndex+3] * trans + 
+                              dstImage[dstIndex+3],
+                              0.0f, 1.0f);
+                }
+            }
+        }
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendBackToFront
+//
+//  Purpose:
+//      Blends tow patches in a back to front manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendBackToFront(const float *srcImage,
+					       const int srcExtents[4],
+					       const int blendExtents[4], 
+					       float *&dstImage,
+					       const int dstExtents[4])
+{
+    if (UseThreadedBlend_Communicator) {
+	visit::BlendBackToFront(blendExtents,
+	                        srcExtents,
+	                        srcImage,
+	                        dstExtents,
+	                        dstImage);
+    } else {
+        // image sizes
+        const int srcX = srcExtents[1] - srcExtents[0];
+        const int srcY = srcExtents[3] - srcExtents[2];
+        const int dstX = dstExtents[1] - dstExtents[0];
+        const int dstY = dstExtents[3] - dstExtents[2];
+        // determin the region to blend
+        const int startX = 
+            std::max(std::max(blendExtents[0], srcExtents[0]), dstExtents[0]);
+        const int startY = 
+            std::max(std::max(blendExtents[2], srcExtents[2]), dstExtents[2]);
+        const int endX = 
+            std::min(std::min(blendExtents[1], srcExtents[1]), dstExtents[1]);
+        const int endY = 
+            std::min(std::min(blendExtents[3], srcExtents[3]), dstExtents[3]);
+    
+        for (int y = startY; y < endY; ++y) {
+            for (int x = startX; x < endX; ++x) {
+                // get indices
+                int srcIndex = (srcX*(y-srcExtents[2]) + x-srcExtents[0])*4;
+                int dstIndex = (dstX*(y-dstExtents[2]) + x-dstExtents[0])*4;
+                // back to front compositing	    
+                float trans = 1.0f - srcImage[srcIndex + 3];
+                dstImage[dstIndex+0] = 
+                    CLAMP(dstImage[dstIndex+0] * trans + srcImage[srcIndex+0],
+                          0.0f, 1.0f);
+                dstImage[dstIndex+1] = 
+                    CLAMP(dstImage[dstIndex+1] * trans + srcImage[srcIndex+1],
+                          0.0f, 1.0f);
+                dstImage[dstIndex+2] = 
+                    CLAMP(dstImage[dstIndex+2] * trans + srcImage[srcIndex+2],
+                          0.0f, 1.0f);
+                dstImage[dstIndex+3] = 
+                    CLAMP(dstImage[dstIndex+3] * trans + srcImage[srcIndex+3],
+                          0.0f, 1.0f);
+            }
+        }
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendFrontToBack
+//
+//  Purpose:
+//      Blends tow patches in a front to back manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendFrontToBack(const float * srcImage,
+					       const int srcExtents[4], 
+					       float *& dstImage,
+					       const int dstExtents[4])
+{
+    BlendFrontToBack(srcImage, srcExtents, srcExtents, dstImage, dstExtents);
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendBackToFront
+//
+//  Purpose:
+//      Blends tow patches in a back to front manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendBackToFront(const float * srcImage,
+					       const int srcExtents[4], 
+					       float *& dstImage, 
+					       const int dstExtents[4])
+{
+    BlendBackToFront(srcImage, srcExtents, srcExtents, dstImage, dstExtents);
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::Barrier
+//
+//  Purpose:
+//    Barrier, useful for debugging
+//
+//  Programmer: Pascal Grosset
+//  Creation: July 2013
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtOSPRayImageCompositor::Barrier() {
+#ifdef PARALLEL
+    MPI_Barrier(MPI_COMM_WORLD);
+#endif
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::ColorImage
+//
+//  Purpose:
+//       Fills a 4 channel image with a specific color
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtOSPRayImageCompositor::ColorImage(float *&srcImage,
+					 const int widthSrc,
+					 const int heightSrc,
+					 const float color[4])
+{
+    for (int i = 0; i < heightSrc * widthSrc; ++i) {
+	const int srcIndex = 4 * i;
+	srcImage[srcIndex+0] = color[0];
+	srcImage[srcIndex+1] = color[1];
+	srcImage[srcIndex+2] = color[2];
+	srcImage[srcIndex+3] = color[3];
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::PlaceImage
+//
+//  Purpose:
+//      Puts srcImage into dstImage
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtOSPRayImageCompositor::PlaceImage(const float *srcImage,
+					 const int srcExtents[4], 
+					 float *&dstImage,
+					 const int dstExtents[4])
+{
+    const int srcX = srcExtents[1] - srcExtents[0];
+    const int srcY = srcExtents[3] - srcExtents[2];
+    const int dstX = dstExtents[1] - dstExtents[0];
+    const int dstY = dstExtents[3] - dstExtents[2];
+    const int startingX = std::max(srcExtents[0], dstExtents[0]);
+    const int startingY = std::max(srcExtents[2], dstExtents[2]);
+    const int endingX = std::min(srcExtents[1], dstExtents[1]);
+    const int endingY = std::min(srcExtents[3], dstExtents[3]);
+    
+    for (int y = startingY; y < endingY; ++y) {
+	for (int x = startingX; x < endingX; ++x) {
+	    // index in the sub-image
+	    const int srcIndex = 
+		(srcX * (y-srcExtents[2]) + x-srcExtents[0]) * 4; 
+	    // index in the larger buffer
+	    const int dstIndex = 
+		(dstX * (y-dstExtents[2]) + x-dstExtents[0]) * 4;
+	    dstImage[dstIndex+0] = srcImage[srcIndex+0];
+	    dstImage[dstIndex+1] = srcImage[srcIndex+1];
+	    dstImage[dstIndex+2] = srcImage[srcIndex+2];
+	    dstImage[dstIndex+3] = srcImage[srcIndex+3];
+	}
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendWithBackground
+//
+//  Purpose:
+//      Blends _image with the backgroundColor
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendWithBackground(float *&image,
+						  const int extents[4],
+						  const float bgColor[4])
+{
+    const int pixelSize = (extents[3]-extents[2]) * (extents[1]-extents[0]);
+    // estimated potential speedup: 2.240
+    for (int i = 0; i < pixelSize; ++i)
+        {
+            const int   idx = i * 4;
+            const float alpha = (1.0 - image[idx+3]);
+            image[idx+0] = bgColor[0] * alpha + image[idx+0];
+            image[idx+1] = bgColor[1] * alpha + image[idx+1];
+            image[idx+2] = bgColor[2] * alpha + image[idx+2];
+            image[idx+3] = bgColor[3] * alpha + image[idx+3];
+        }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::IceT
+//
+//  Purpose:
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+//  Modifications:
+//
+// **************************************************************************
+
+bool avtOSPRayImageCompositor::IceTValid() 
+{
+    return avtOSPRayIC_IceT::Valid(); 
+}
+
+void avtOSPRayImageCompositor::IceTInit(int W, int H)
+{
+    if (!avtOSPRayIC_IceT::Valid()) {
+        std::cerr << "ERROR: IceT compositor is not valid. "
+		  << "Probably IceT is not compiled with VisIt"
+		  << std::endl;
+	ospray::Exception("ERROR: IceT compositor is not valid. "
+                          "Probably IceT is not compiled with VisIt");
+	return;
+    }
+    if (compositor) delete compositor;
+    compositor = new avtOSPRayIC_IceT(mpiSize, mpiRank);
+    compositor->Init(W, H);
+}
+
+void avtOSPRayImageCompositor::IceTSetTile(const float* d, 
+					  const int*   e,
+	                                  const float& z)
+{
+    ospray::timestamp timingDetail;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+			     "IceTSetTile", timingDetail,
+			     "IceT Setup Image Tile");
+    //---------------------------------------------------------------------//
+    compositor->SetTile(d, e, z);
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+			    "IceTSetTile", timingDetail,
+			    "IceT Setup Image Tile");
+    //---------------------------------------------------------------------//
+}
+
+void avtOSPRayImageCompositor::IceTComposite(float*& output)
+{
+    ospray::timestamp timingDetail;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+			     "IceTComposite", timingDetail,
+			     "IceT Image Composition");
+    //---------------------------------------------------------------------//
+    compositor->Composite(output);
+    if (compositor != NULL) { delete compositor; }
+    compositor = NULL;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+			    "IceTComposite", timingDetail,
+			    "IceT Image Composition");
+    //---------------------------------------------------------------------//
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::OneNode
+//
+//  Purpose:
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+//  Modifications:
+//
+// **************************************************************************
+
+bool avtOSPRayImageCompositor::OneNodeValid()
+{
+    return avtOSPRayIC_OneNode::Valid();    
+}
+void avtOSPRayImageCompositor::OneNodeInit(int W, int H)
+{
+    if (compositor) delete compositor;
+    compositor = new avtOSPRayIC_OneNode(mpiSize, mpiRank);
+    compositor->Init(W, H);    
+}
+void avtOSPRayImageCompositor::OneNodeSetTile(const float* d,
+                                             const int*   e, 
+                                             const float& z)
+{
+    compositor->SetTile(d, e, z);
+}
+void avtOSPRayImageCompositor::OneNodeComposite(float*& output)
+{
+    compositor->Composite(output);
+    if (compositor != NULL) { delete compositor; }
+    compositor = NULL;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::UpdateBoundingBox
+//
+//  Purpose:
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void
+avtOSPRayImageCompositor::UpdateBoundingBox(int currentBoundingBox[4],
+					   const int imageExtents[4])
+{
+    if ((currentBoundingBox[0] == 0 && currentBoundingBox[1] == 0) && 
+	(currentBoundingBox[2] == 0 && currentBoundingBox[3] == 0)) {
+        currentBoundingBox[0]=imageExtents[0];
+        currentBoundingBox[1]=imageExtents[1];
+        currentBoundingBox[2]=imageExtents[2];
+        currentBoundingBox[3]=imageExtents[3];
+        return;
+    }
+
+    if (imageExtents[0] < currentBoundingBox[0])
+        { currentBoundingBox[0] = imageExtents[0]; }
+
+    if (imageExtents[2] < currentBoundingBox[2])
+        { currentBoundingBox[2] = imageExtents[2]; }
+
+    if (imageExtents[1] > currentBoundingBox[1])
+        { currentBoundingBox[1] = imageExtents[1]; }
+
+    if (imageExtents[3] > currentBoundingBox[3])
+        { currentBoundingBox[3] = imageExtents[3]; }
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::GatherDepthAtRoot
+//
+//  Purpose:
+//      Used by Serial Direct Send
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void
+avtOSPRayImageCompositor::GatherDepthAtRoot(const int numlocalPatches,
+					   const float *localPatchesDepth,
+					   int &totalPatches,
+					   int *&patchCountPerRank,
+					   float *&allPatchesDepth)
+{
+#ifdef PARALLEL
+    // Get how many patches are coming from each MPI rank
+    totalPatches = 0;
+    int *patchesOffset = NULL;
+
+    if (mpiRank == 0) // root!
+        { patchCountPerRank = new int[mpiSize](); }
+
+    // reference
+    // https://www.mpich.org/static/docs/v3.1/www3/MPI_Gather.html
+    MPI_Gather(&numlocalPatches, /* send buffer */
+	       1, /* send count */
+	       MPI_INT, 
+	       patchCountPerRank, /* address of receive buffer (root) */
+	       1, /* number of elements for any single receive (root) */
+	       MPI_INT, 
+	       0, /* rank of receiving process (integer) */
+	       MPI_COMM_WORLD); /* communicator (handle) */
+
+    // gather number of patch group
+    if (mpiRank == 0)
+        {
+            patchesOffset = new int[mpiSize]();
+            patchesOffset[0] = 0; // a bit redundant
+
+            for (int i=0; i<mpiSize; i++)
+                {
+                    totalPatches += patchCountPerRank[i];
+                    if (i == 0)
+                        { patchesOffset[i] = 0; }
+                    else
+                        {
+                            patchesOffset[i] = 
+                                patchesOffset[i-1] + patchCountPerRank[i-1]; 
+                        }
+                }
+	
+            // allocate only at root
+            allPatchesDepth = new float[totalPatches];
+        }
+
+    // Gathers into specified locations from all processes in a group
+    MPI_Gatherv(localPatchesDepth, numlocalPatches, MPI_FLOAT, 
+		allPatchesDepth, /* receive all depth */
+		patchCountPerRank, patchesOffset, MPI_FLOAT, 
+		0, MPI_COMM_WORLD);
+
+    // Cleanup
+    if (mpiRank == 0 && patchesOffset != NULL)
+        { delete [] patchesOffset; }
+    patchesOffset = NULL;
+#endif
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::SerialDirectSend
+//
+//  Purpose:
+//      A very simple compositing that we can fall back to if parallel direct
+//      send is buggy.
+//      Works with convex patches though
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void
+avtOSPRayImageCompositor::SerialDirectSend(int localNumPatches,
+					  float *localPatchesDepth, 
+					  int *extents,
+					  float *imgData,
+					  float bgColor[4],
+					  int width, int height)
+{
+#ifdef PARALLEL
+    //
+    // Message
+    //
+    //debug5 << "-- Serial Direct Send --" << std::endl;
+
+    float *recvImage = NULL;
+    int tags[2] = {5781, 5782};
+    //
+    // Retrieve depth info through MPI
+    //
+    int    totalPatches; // total number of patches
+    int   *totalPatchCountsPerRank = NULL;
+    float *totalPatchDepths = NULL;
+    GatherDepthAtRoot(localNumPatches,
+		      localPatchesDepth,
+		      totalPatches, 
+		      totalPatchCountsPerRank,
+		      totalPatchDepths);
+    //
+    //
+    //
+    if (mpiRank == 0)
+        {
+            // Root
+            int srcSize[2] = {width, height};
+            int srcPos[2]  = {0, 0};
+            int dstSize[2], dstPos[2];
+
+            // Sort patches we will receive
+            std::multimap<float,int> sortedPatches;
+
+            int patchId = 0;
+            for (int i=0; i<mpiSize; i++) {
+                for (int j=0; j<totalPatchCountsPerRank[i]; j++) {
+                    sortedPatches.insert
+                        (std::make_pair(totalPatchDepths[patchId++],i));
+                }
+            }
+
+            // Create space for buffers
+            int recvParams[4]; // minX, maxX, minY, maxY
+            int imgExtents[4] = {0,width,0,height};
+
+            recvImage = new float[width*height*4]();
+            finalImage = new float[width*height*4]();
+	
+            int localIndex = 0;
+
+            // Compositing
+            for (std::multimap<float,int>::iterator it = sortedPatches.begin(); 
+                 it != sortedPatches.end(); ++it)
+                {
+                    int rank = (*it).second;
+                    if (rank != mpiRank)
+                        {
+                            // recv image info
+                            MPI_Recv(recvParams, 4, MPI_INT, rank, 
+                                     tags[0], MPI_COMM_WORLD, MPI_STATUS_IGNORE); 
+                            // recv image
+                            MPI_Recv(recvImage, width*height*4, MPI_FLOAT, rank,
+                                     tags[1],  MPI_COMM_WORLD, MPI_STATUS_IGNORE);
+                            dstPos[0]  = dstPos[0];                     
+                            dstPos[1]  = dstPos[1];
+                            dstSize[0] = recvParams[2]-recvParams[0];   
+                            dstSize[1] = recvParams[3]-recvParams[1];
+                        }
+                    else
+                        {
+                            // It's local
+                            recvParams[0] = extents[ localIndex*4 + 0];
+                            recvParams[1] = extents[ localIndex*4 + 1];
+                            recvParams[2] = extents[ localIndex*4 + 2];
+                            recvParams[3] = extents[ localIndex*4 + 3];
+                            recvImage = &imgData[ localIndex*(width*height*4) ];
+                            localIndex++;
+                        }
+                    BlendFrontToBack(recvImage, recvParams, finalImage, imgExtents);
+                }
+            BlendWithBackground(finalImage, imgExtents, bgColor);
+        }
+    else
+        {
+            // Sender
+            for (int i=0; i<localNumPatches; i++)
+                {
+                    int imgSize = 
+                        (extents[i*4 + 1] - extents[i*4 + 0]) *
+                        (extents[i*4 + 3] - extents[i*4 + 2]) * 4;	    
+                    if (imgSize > 0)
+                        {
+                            MPI_Send(&extents[i*4],
+                                     4, MPI_INT, 0, tags[0], MPI_COMM_WORLD);
+                            MPI_Send(&imgData[i*(width*height*4)], 
+                                     imgSize, MPI_FLOAT, 0, tags[1], MPI_COMM_WORLD);
+                        }
+                }
+        }
+
+    // Cleanup
+    if (totalPatchDepths != NULL)
+	delete []totalPatchDepths;
+
+    if (totalPatchCountsPerRank != NULL)
+        delete []totalPatchCountsPerRank;
+
+    if (recvImage != NULL)
+        delete []recvImage;
+
+    recvImage = NULL;
+    totalPatchCountsPerRank = NULL;
+    totalPatchDepths = NULL;
+#endif
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::regionAllocation
+//
+//  Purpose:
+//      Arbitrarily allocates regions to MPI ranks
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void
+avtOSPRayImageCompositor::RegionAllocation(int *& regions)
+{
+    regions = new int[mpiSize];
+    // Initial allocation: partition for section rank
+    for (int i=0; i<mpiSize; i++) { regions[i] = i; }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::parallelDirectSend
+//
+//  Purpose:
+//      Parallel Direct Send rendering that can blend convex patches from each
+//      MPI rank. However, since we are not guaranteed to have convex patches.
+//      It's not used.
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtOSPRayImageCompositor::parallelDirectSend(float *imgData,
+					    int imgExtents[4],
+					    int region[],
+					    int numRegions,
+					    int tags[2],
+					    int fullImageExtents[4])
+{
+#ifdef PARALLEL
+    //
+    // Determine position in region (myPositionInRegion)
+    int width  = fullImageExtents[1]-fullImageExtents[0];
+    int height = fullImageExtents[3]-fullImageExtents[2];
+
+    //debug5 << "fullImageExtents: " << fullImageExtents[0] << ", " << fullImageExtents[1] << "   " << fullImageExtents[2] << ", " << fullImageExtents[3] << endl;
+
+    compositingDone = false;
+    int myPositionInRegion = -1;
+    bool inRegion = true;
+    std::vector<int> regionVector(region, region+numRegions);
+    std::vector<int>::iterator it = std::find(regionVector.begin(),
+					      regionVector.end(),
+					      mpiRank);
+
+    if (it == regionVector.end())
+        {
+            inRegion = false;
+            //debug5 << mpiRank << " ~ SHOULD NOT HAPPEN: Not found " << mpiRank <<  " !!!" << std::endl;
+        }
+    else
+        myPositionInRegion = it - regionVector.begin();
+
+    //
+    // Region boundaries
+    int regionHeight = height/numRegions;
+    int lastRegionHeight = height - regionHeight*(numRegions-1);
+
+    // Extents of my region
+    int myStartingHeight =
+	fullImageExtents[2] +
+	myPositionInRegion *
+	regionHeight;
+    int myEndingHeight = myStartingHeight + regionHeight;
+    if (myPositionInRegion == numRegions-1)
+        myEndingHeight = fullImageExtents[3];
+
+    int myRegionHeight = myEndingHeight-myStartingHeight;
+
+    // Size of one buffer
+    int sizeOneBuffer = std::max(regionHeight,lastRegionHeight) * width * 4;
+
+    //debug5 << "myPositionInRegion: " << myPositionInRegion << std::endl;
+    //debug5 << "My extents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
+    //debug5 << "myRegionHeight: " << myRegionHeight << "  lastRegionHeight: " << lastRegionHeight << " regionHeight: " << regionHeight << "  myStartingHeight: " << myStartingHeight << "  myEndingHeight: " << myEndingHeight << std::endl;
+
+
+    //
+    // MPI Async
+
+    // Recv
+    MPI_Request *recvMetaRq = new MPI_Request[ numRegions-1 ];
+    MPI_Request *recvImageRq = new MPI_Request[ numRegions-1 ];
+
+    MPI_Status *recvMetaSt = new MPI_Status[ numRegions-1 ];
+    MPI_Status *recvImageSt = new MPI_Status[ numRegions-1 ];
+
+    // Send
+    MPI_Request *sendMetaRq = new MPI_Request[ numRegions-1 ];
+    MPI_Request *sendImageRq = new MPI_Request[ numRegions-1 ];
+
+    MPI_Status *sendMetaSt = new MPI_Status[ numRegions-1 ];
+    MPI_Status *sendImageSt = new MPI_Status[ numRegions-1 ];
+
+
+    //
+    // Create Buffers
+
+    // Create buffer for receiving images
+    float *recvDataBuffer;
+    recvDataBuffer = new float[ sizeOneBuffer * numRegions];
+
+    // Create buffer for receiving messages
+    std::vector<int> msgBuffer;
+    msgBuffer.clear();
+    msgBuffer.resize(5 * numRegions);
+
+    // Create buffer for sending messages
+    int *sendExtents = new int[numRegions*5];
+
+    //
+    // Async Recv
+    if (inRegion)
+        {
+            int recvCount=0;
+            for (int i=0; i<numRegions; i++)
+                {
+                    if ( regionVector[i] == mpiRank )
+                        continue;
+
+                    int src = regionVector[i];
+                    MPI_Irecv(&msgBuffer[i*5],                              5, MPI_INT,   src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvCount] );
+                    MPI_Irecv(&recvDataBuffer[i*sizeOneBuffer], sizeOneBuffer, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+                    recvCount++;
+                }
+        }
+
+    //debug5 << "Async Recv setup done " << std::endl;
+
+    //
+    // Async Send
+    int sendCount = 0;
+    int sendingOffset;
+    for (int i=0; i<numRegions; i++)
+        {
+            int regionStart, regionEnd, imgSize, dest;
+            dest = regionVector[i];
+
+            if ( dest == mpiRank )
+                continue;
+
+            regionStart = i*regionHeight;
+            regionEnd = regionStart + regionHeight;
+            if (i == numRegions-1) // the last one in region
+                regionEnd = height;
+
+            int startingYExtents = fullImageExtents[2] + regionStart;
+            int endingYExtents = fullImageExtents[2] + regionEnd;
+
+            //debug5 << "startingYExtents: " << startingYExtents <<"   endingYExtents: " << endingYExtents <<  std::endl;
+
+            if (startingYExtents < imgExtents[2])
+                startingYExtents = imgExtents[2];
+
+            if (endingYExtents > imgExtents[3])
+                endingYExtents = imgExtents[3];
+
+            bool hasData = true;
+            if (endingYExtents - startingYExtents <= 0 || imgExtents[1]-imgExtents[0] <= 0)
+                {
+                    hasData = false;
+
+                    sendingOffset = 0;
+                    imgSize = sendExtents[i*5 + 0] = sendExtents[i*5 + 1] = sendExtents[i*5 + 2] = sendExtents[i*5 + 3] =  sendExtents[i*5 + 4] = 0;
+                }
+            else
+                {
+                    imgSize = (endingYExtents-startingYExtents) * (imgExtents[1]-imgExtents[0]) * 4;
+                    sendingOffset = (startingYExtents-imgExtents[2]) * (imgExtents[1]-imgExtents[0]) * 4;
+
+                    sendExtents[i*5 + 0] = imgExtents[0];
+                    sendExtents[i*5 + 1] = imgExtents[1];
+                    sendExtents[i*5 + 2] = startingYExtents;
+                    sendExtents[i*5 + 3] = endingYExtents;
+                    sendExtents[i*5 + 4] = 0;
+                }
+
+            //std::cout << mpiRank << " ~ i: " << i << "   regionVector[index]: " << regionVector[index] << "  extents: " <<  sendExtents[index*5 + 0] << ", " << sendExtents[index*5 + 1]  << ", " << sendExtents[index*5 + 2] << ", " << sendExtents[index*5 + 3] << "  sending ... " << std::endl;
+            MPI_Isend(&sendExtents[i*5],             5,   MPI_INT, dest, tags[0], MPI_COMM_WORLD, &sendMetaRq[sendCount]);
+            MPI_Isend(&imgData[sendingOffset], imgSize, MPI_FLOAT, dest, tags[1], MPI_COMM_WORLD, &sendImageRq[sendCount]);
+
+            //debug5 << "dest: " << dest <<"   sendExtents: " << sendExtents[i*5 +0] << ", " << sendExtents[i*5 +1] << "    " << sendExtents[i*5 +2] << ", " << sendExtents[i*5 +3] << std::endl << std::endl;
+
+            sendCount++;
+        }
+
+    //debug5 << "Async Recv" << std::endl;
+
+    //
+    // Create buffer for region
+    intermediateImageExtents[0] = fullImageExtents[0];  intermediateImageExtents[1] = fullImageExtents[1];
+    intermediateImageExtents[2] = myStartingHeight;     intermediateImageExtents[3] = myEndingHeight;
+
+    intermediateImage = new float[width * (myEndingHeight-myStartingHeight) * 4]();
+
+    int recvImageExtents[4];
+    float *recvImageData;
+
+    //
+    // Blend
+    int numBlends = 0;
+    int countBlend = 0;
+
+    intermediateImageBBox[0] = intermediateImageBBox[2] = 0;
+    intermediateImageBBox[1] = intermediateImageBBox[3] = 0;
+
+    if (inRegion)
+        {
+            for (int i=0; i<numRegions; i++)
+                {
+                    int index = i;
+
+                    //debug5 << "regionVector[" << i << "] " << regionVector[index] << std::endl;
+
+                    if (regionVector[index] == mpiRank)
+                        {
+                            int startingYExtents = myStartingHeight;
+                            int endingYExtents = myEndingHeight;
+
+                            if (startingYExtents < imgExtents[2])
+                                startingYExtents = imgExtents[2];
+
+                            if (endingYExtents > imgExtents[3])
+                                endingYExtents = imgExtents[3];
+
+
+                            bool hasData = true;
+                            if (endingYExtents - startingYExtents <= 0)
+                                {
+                                    hasData = false;
+                                    endingYExtents = startingYExtents = 0;
+                                }
+
+                            if (hasData == true)
+                                {
+                                    int extentsSectionRecv[4];
+                                    extentsSectionRecv[0] = imgExtents[0];
+                                    extentsSectionRecv[1] = imgExtents[1];
+                                    extentsSectionRecv[2] = startingYExtents;
+                                    extentsSectionRecv[3] = endingYExtents;
+
+                                    BlendFrontToBack(imgData, imgExtents, extentsSectionRecv, intermediateImage, intermediateImageExtents);
+
+                                    UpdateBoundingBox(intermediateImageBBox, extentsSectionRecv);
+                                    numBlends++;
+                                }
+                        }
+                    else
+                        {
+                            MPI_Wait(&recvMetaRq[countBlend], &recvMetaSt[countBlend]);
+
+                            for (int j=0; j<4; j++)
+                                recvImageExtents[j] = msgBuffer[index*5 + j];
+
+                            bool hasData =  false;
+                            if (recvImageExtents[1]-recvImageExtents[0] > 0 && recvImageExtents[3]-recvImageExtents[2] > 0)
+                                {
+                                    hasData = true;
+                                    MPI_Wait(&recvImageRq[countBlend], &recvImageSt[countBlend]);
+                                    recvImageData = &recvDataBuffer[index*sizeOneBuffer];
+                                }
+
+                            if (hasData)
+                                {
+
+                                    BlendFrontToBack(recvImageData, recvImageExtents, intermediateImage, intermediateImageExtents);
+
+                                    UpdateBoundingBox(intermediateImageBBox, recvImageExtents);
+                                    numBlends++;
+                                }
+
+                            countBlend++;
+                        }
+                }
+        }
+    else
+        compositingDone = true;
+
+    //debug5 << "PDS blending done" << std::endl;
+
+    msgBuffer.clear();
+
+
+    if (recvDataBuffer != NULL)
+        delete []recvDataBuffer;
+    recvDataBuffer = NULL;
+
+
+    if (numBlends == 0)
+        intermediateImageBBox[0]=intermediateImageBBox[1]=intermediateImageBBox[2]=intermediateImageBBox[3] = 0;
+
+    delete []recvMetaRq;
+    delete []recvImageRq;
+    delete []recvMetaSt;
+    delete []recvImageSt;
+
+    delete []sendMetaRq;
+    delete []sendImageRq;
+    delete []sendMetaSt;
+    delete []sendImageSt;
+
+    recvMetaRq = NULL;
+    recvImageRq = NULL;
+    recvMetaSt = NULL;
+    recvImageSt = NULL;
+
+    sendMetaRq = NULL;
+    sendImageRq = NULL;
+    sendMetaSt = NULL;
+    sendImageSt = NULL;
+#endif
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::findRegionsForPatch
+//
+//  Purpose:
+//      Needed by Parallel Direct Send to determine the regions a patch will overlap
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+int
+avtOSPRayImageCompositor::findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to)
+{
+    from = to = 0;
+    if (patchExtents[1]-patchExtents[0] <=0 || patchExtents[3]-patchExtents[2] <=0)
+        return 0;
+
+    if ( patchExtents[0] > screenProjectedExtents[1])
+        return 0;
+
+    if ( patchExtents[1] < screenProjectedExtents[0])
+        return 0;
+
+    if ( patchExtents[2] > screenProjectedExtents[3])
+        return 0;
+
+    if ( patchExtents[3] < screenProjectedExtents[2])
+        return 0;
+
+
+    // find from
+    for (int i=numRegions-1; i>=0; i--)
+        if ( patchExtents[2] >= getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
+            {
+                from = i;
+                break;
+            }
+    
+
+    // find to
+    for (int i=numRegions-1; i>=0; i--)
+        if ( patchExtents[3] > getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
+            {
+                to = i;
+                break;
+            }
+
+    return ( std::max( (to - from) + 1, 0) );
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::computeRegionExtents
+//
+//  Purpose:
+//      Compute extents for each region
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtOSPRayImageCompositor::computeRegionExtents(int numRanks, int height)
+{
+    //debug5 << "computeRegionExtents height " << height << std::endl;
+
+    int regionHeight = round((float)height/numRanks);
+    regularRegionSize = regionHeight;
+    maxRegionHeight = 0;
+    regionRankExtents.resize(numRanks*3);
+    for (int i=0; i<numRanks; i++)
+        {
+            int startRegionExtents, endRegionExtents, _currentRegionHeight;
+
+            startRegionExtents = CLAMP(regionHeight * i, 0, height);
+            endRegionExtents = CLAMP(regionHeight * i + regionHeight, 0, height);
+
+            if ( i == numRanks -1 )
+                if ( endRegionExtents < height )
+                    endRegionExtents = height;
+
+            _currentRegionHeight = CLAMP(endRegionExtents-startRegionExtents, 0, height);
+            maxRegionHeight = std::max(maxRegionHeight, _currentRegionHeight);
+
+            regionRankExtents[i*3+0] = startRegionExtents;
+            regionRankExtents[i*3+1] = endRegionExtents;
+            regionRankExtents[i*3+2] = _currentRegionHeight;
+
+            //debug5 << i << " : (start, end, region): " << startRegionExtents << ", " << endRegionExtents << ", " << _currentRegionHeight << std::endl;
+        }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::ParallelDirectSendManyPatches
+//
+//  Purpose:
+//      Parallel Direct Send rendering that can blend individual patches
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+int
+avtOSPRayImageCompositor::ParallelDirectSendManyPatches
+(const std::multimap<int, ospray::ImgData> &imgDataHashMap, 
+ const std::vector<ospray::ImgMetaData>    &imageMetaPatchVector, 
+ int numPatches,
+ int *region,
+ int numRegions, 
+ int tags[2],
+ int fullImageExtents[4])
+{
+    int myRegionHeight = 0;
+#ifdef PARALLEL
+
+    //
+    // Some Initializations
+    //
+    //debug5 << "Parallel Direct Send" << endl;
+    ospray::timestamp timingDetail;
+    for (int i=0; i<4; i++)
+        {
+            intermediateImageExtents[i] = 0;
+            intermediateImageBBox[i] = 0;
+        }
+
+
+    //
+    // Find My Position in Regions
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Find My position in Regions");
+    //---------------------------------------------------------------------//
+    compositingDone = false;
+    int myPositionInRegion = -1;
+    bool inRegion = true;
+    std::vector<int> regionVector(region, region+numRegions);
+    const std::vector<int>::const_iterator it = 
+	std::find(regionVector.begin(),
+		  regionVector.end(), 
+		  mpiRank);
+    if (it == regionVector.end())
+        {
+            inRegion = false;
+            //ospout << mpiRank << " ~ SHOULD NOT HAPPEN!!!!: Not found " 
+            //       << mpiRank <<  " !!!" << std::endl;
+        }
+    else 
+        {
+            myPositionInRegion = it - regionVector.begin();
+        }
+    int width =  fullImageExtents[1]-fullImageExtents[0];
+    int height = fullImageExtents[3]-fullImageExtents[2];
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Find My position in Regions");
+    //ospout << mpiRank << " ~ myPositionInRegion: " 
+    //       << myPositionInRegion << ", numRanks: " << mpiSize << std::endl;
+    //ospout << "width: " << width << ", height : " << height 
+    //       << " | fullImageExtents: "
+    //       << fullImageExtents[0] << ", " 
+    //       << fullImageExtents[1] << ", " 
+    //       << fullImageExtents[2] << ", "
+    //       << fullImageExtents[3] << std::endl;
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Compute Region Boundaries
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Compute Region Boundaries");
+    //---------------------------------------------------------------------//
+    computeRegionExtents(mpiSize, height); // ?
+    int myStartingHeight = getScreenRegionStart
+	(myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
+    int myEndingHeight   = getScreenRegionEnd
+	(myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
+    myRegionHeight = CLAMP((myEndingHeight-myStartingHeight), 0, height);
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Compute Region Boundaries");
+    // ospout << "myStartingHeight: " << myStartingHeight << ", "
+    //        << "myEndingHeight: "   << myEndingHeight   << ", "
+    //	      << "myRegionHeight: "   << myRegionHeight   << std::endl;
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Size of one buffer
+    //
+    int sizeOneBuffer = getMaxRegionHeight() * width * 4;
+
+
+    //
+    // Determine How Many Patches and Pixel to Send to Each Region
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Determine How Many Patches and Pixel to Send "
+                              "to Each Region");
+    //---------------------------------------------------------------------//
+    std::vector<int> numPatchesPerRegion;
+    std::vector<int> areaPerRegion;
+    std::set<int> numOfRegions;
+    numPatchesPerRegion.resize(numRegions);
+    areaPerRegion.resize(numRegions);
+
+    // 2D array: extents for each partition
+    std::vector < std::vector<float> > extentsPerPartiton;
+    for (int i=0; i<numRegions; i++) { 
+	extentsPerPartiton.push_back(std::vector<float>()); 
+    }
+    // ospout << "Parallel Direct Send ~ numPatches " << numPatches << endl;
+    int totalSendBufferSize = 0;
+    for (int i=0; i<numPatches; i++)
+        {
+            int _patchExtents[4];
+            ospray::ImgMetaData temp;
+            temp = imageMetaPatchVector.at(i);
+            _patchExtents[0]=temp.screen_ll[0];   // minX
+            _patchExtents[1]=temp.screen_ur[0];   // maxX
+            _patchExtents[2]=temp.screen_ll[1];   // minY
+            _patchExtents[3]=temp.screen_ur[1];   // maxY
+            const std::multimap<int, ospray::ImgData>::const_iterator it = 
+                imgDataHashMap.find( i );
+            int from, to;
+            int numRegionIntescection = findRegionsForPatch(_patchExtents, 
+                                                            fullImageExtents,
+                                                            numRegions, 
+                                                            from, to);
+            if (numRegionIntescection <= 0) continue;
+            // ospout << "\nParallel Direct Send ~ patch " << i 
+            //        << "  from:" << from << "  to:" << to 
+            //        << "  numPatches: " << numPatches 
+            //        << "   _patchExtents: " 
+            //        << _patchExtents[0] << ", " 
+            //        << _patchExtents[1] << ", " 
+            //        << _patchExtents[2] << ", " 
+            //        << _patchExtents[3] 
+            //        << ", fullImageExtents[2]: " << fullImageExtents[2] 
+            //        << ", numRegions: " <<  numRegions 
+            //        << ", totalSendBufferSize: " << totalSendBufferSize << endl;
+            for (int j=from; j<=to; j++) numPatchesPerRegion[j]++;
+            for (int partition=from; partition<=to; partition++)
+                {
+                    int _extentsYStart = std::max( _patchExtents[2], getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) );
+                    int _extentsYEnd   = std::min( _patchExtents[3], getScreenRegionEnd(  partition, fullImageExtents[2], fullImageExtents[3]) );
+                    int _area = (_extentsYEnd-_extentsYStart)*(_patchExtents[1]-_patchExtents[0]);
+                    areaPerRegion[partition] += _area;
+                    totalSendBufferSize += _area;
+                    //debug5 << "_patchExtents[2]: " << _patchExtents[2] << ", region start: " << getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) <<  ", _extentsYStart: " << _extentsYStart<< endl;
+                    //debug5 << "_patchExtents[3]: " << _patchExtents[3] << ", region end: " << getScreenRegionEnd(partition, fullImageExtents[2], fullImageExtents[3]) << ", _extentsYEnd: " << _extentsYEnd << endl;
+                    //debug5 << "_area " << _area << endl;
+                    extentsPerPartiton[partition].push_back(i);
+                    extentsPerPartiton[partition].push_back(_patchExtents[0]);
+                    extentsPerPartiton[partition].push_back(_patchExtents[1]);
+                    extentsPerPartiton[partition].push_back(_extentsYStart);
+                    extentsPerPartiton[partition].push_back(_extentsYEnd);
+                    extentsPerPartiton[partition].push_back(temp.eye_z);
+                    numOfRegions.insert(partition);
+                }
+        }
+    totalSendBufferSize *= 4;                           // to account for RGBA
+    int numRegionsWithData = numOfRegions.size();
+    //debug5 << "\nParallel Direct Send ~ creating buffers" << endl;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Determine How Many Patches and Pixel to Send "
+                             "to Each Region");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Copy the Data for Each Region for Each Patch
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Copy the Data for Each Region for Each Patch");
+    //---------------------------------------------------------------------//
+    // Create buffer
+    float *sendDataBuffer = new float[totalSendBufferSize];     // contains all the data arranged by region
+    int   *sendDataBufferSize = new int[numRegionsWithData]();
+    int   *sendDataBufferOffsets = new int[numRegionsWithData]();
+    int   *sendBuffer = new int[numRegions*2]();
+    int regionWithDataCount = 0;
+    int numRegionsToSend = 0;
+    // Populate the buffer with data
+    int dataSendBufferOffset = 0;
+    for (int i=0; i<numRegions; i++)
+        {
+            int _dataSize = 0;
+            //ospout << "Region: " << i << "  size: " << extentsPerPartiton[i].size() << std::endl;
+            for (int j=0; j<extentsPerPartiton[i].size(); j+=6)
+                {
+                    int _patchID = extentsPerPartiton[i][j + 0];
+                    const std::multimap<int, ospray::ImgData>::const_iterator it = imgDataHashMap.find( _patchID );
+
+                    int _width = (extentsPerPartiton[i][j+2] - extentsPerPartiton[i][j+1]);
+                    int _bufferSize = _width * (extentsPerPartiton[i][j+4] - extentsPerPartiton[i][j+3]) * 4;
+                    int _dataOffset = extentsPerPartiton[i][j+3] - imageMetaPatchVector[_patchID].screen_ll[1];
+
+                    memcpy(&sendDataBuffer[dataSendBufferOffset], &(((*it).second).imagePatch[_width * _dataOffset * 4]), _bufferSize*sizeof(float) );
+
+                    dataSendBufferOffset += _bufferSize;
+                    _dataSize += _bufferSize;
+                }
+
+            if (_dataSize != 0){
+                sendDataBufferSize[regionWithDataCount] = _dataSize;
+
+                regionWithDataCount ++;
+                if (regionWithDataCount != numRegionsWithData)
+                    sendDataBufferOffsets[regionWithDataCount] = sendDataBufferOffsets[regionWithDataCount-1] + sendDataBufferSize[regionWithDataCount-1];
+
+                if (regionVector[i] != mpiRank)
+                    numRegionsToSend++;
+            }
+
+            sendBuffer[i*2+0] = numPatchesPerRegion[i];
+            sendBuffer[i*2+1] = areaPerRegion[i];
+
+            //ospout << "Region: " << i << "  numPatchesPerRegion: " << sendBuffer[i*2+0] << ", sendBuffer[i*2+1]: " << sendBuffer[i*2+1] << std::endl;
+        }
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Copy the Data for Each Region for Each Patch");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Exchange Information about Size to Recv
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Exchange Information about Size to Recv");
+    //---------------------------------------------------------------------//
+    int *recvInfoATABuffer = new int[numRegions*2]();
+    MPI_Alltoall(sendBuffer, 2, MPI_INT,  recvInfoATABuffer, 2, MPI_INT, MPI_COMM_WORLD);
+    delete []sendBuffer;
+    sendBuffer = NULL;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Exchange Information about Size to Recv");
+    //ospout << "Parallel Direct Send ~ Exchange information about size to recv" << endl;
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Calculate Buffer Size Needed
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Calculate Buffer Size Needed");
+    //---------------------------------------------------------------------//
+    int infoBufferSize = 0;
+    int dataBufferSize = 0;
+    int numRegionsToRecvFrom = 0;
+    for (int i=0; i<numRegions; i++)
+        {
+            infoBufferSize += recvInfoATABuffer[i*2 + 0];   // number of patches per region
+            dataBufferSize += recvInfoATABuffer[i*2 + 1];   // area per region
+            //ospout << "From: " << i << ", #patches: " << recvInfoATABuffer[i*2 + 0] << ", " << recvInfoATABuffer[i*2 + 1] << std::endl;
+            if (i == mpiRank) continue;
+            if (recvInfoATABuffer[i*2 + 0] != 0)
+                numRegionsToRecvFrom++;
+        }
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Calculate Buffer Size Needed");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Create Structure for MPI Async send/recv
+    //
+    // Send
+    MPI_Request *sendMetaRq = new MPI_Request[ numRegionsToSend ];
+    MPI_Status *sendMetaSt = new MPI_Status[ numRegionsToSend ];
+    MPI_Request *sendImageRq = new MPI_Request[ numRegionsToSend ];
+    MPI_Status *sendImageSt = new MPI_Status[ numRegionsToSend ];
+    // Recv
+    MPI_Request *recvMetaRq = NULL;
+    MPI_Status *recvMetaSt = NULL;
+    MPI_Request *recvImageRq = NULL;
+    MPI_Status *recvImageSt = NULL;
+    // counters
+    int recvInfoCount = 0;
+    int offsetMeta = 0;
+    int offsetData = 0;
+
+
+    //
+    // Create Recv Buffers
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Create Recv Buffers");
+    //---------------------------------------------------------------------//
+    float *recvInfoBuffer = new float[infoBufferSize*6];  // 6 - passing 6 parameters for each patch
+    float *recvDataBuffer =  new float[dataBufferSize*4]; // 4 - to account for RGBA
+
+    //debug5 << "infoBufferSize: " << infoBufferSize << ", dataBufferSize: " << dataBufferSize << std::endl;
+    if (myRegionHeight != 0)
+        {
+            // Recv
+            recvMetaRq = new MPI_Request[ numRegionsToRecvFrom ];
+            recvMetaSt = new MPI_Status[ numRegionsToRecvFrom ];
+
+            recvImageRq = new MPI_Request[ numRegionsToRecvFrom ];
+            recvImageSt = new MPI_Status[ numRegionsToRecvFrom ];
+
+            // Async Recv for info
+            for (int i=0; i<numRegions; i++)
+                {
+                    if (recvInfoATABuffer[i*2 + 0] == 0)
+                        continue;
+
+                    if ( regionVector[i] == mpiRank )
+                        continue;
+
+                    int src = regionVector[i];
+                    MPI_Irecv(&recvInfoBuffer[offsetMeta], recvInfoATABuffer[i*2 + 0]*6, MPI_FLOAT, src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvInfoCount] );
+                    MPI_Irecv(&recvDataBuffer[offsetData], recvInfoATABuffer[i*2 + 1]*4, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvInfoCount] );
+
+                    offsetMeta += recvInfoATABuffer[i*2 + 0]*6;
+                    offsetData += recvInfoATABuffer[i*2 + 1]*4;
+                    recvInfoCount++;
+                }
+            //ospout << "Async recv setup - numRegionsToRecvFrom: " << numRegionsToRecvFrom << "   recvInfoCount: " << recvInfoCount << endl;
+        }
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Create Recv Buffers");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Async Send
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Async Send");
+    //---------------------------------------------------------------------//
+    int offset = 0;
+    int sendCount = 0;
+    int mpiSendCount = 0;
+    for (int i=0; i<numRegions; i++) {
+            if ( extentsPerPartiton[i].size() != 0 ) {
+                    if ( regionVector[i] == mpiRank )
+                        {
+                            memcpy( &recvInfoBuffer[offsetMeta], &extentsPerPartiton[i][0], extentsPerPartiton[i].size()*sizeof(float) );
+                            memcpy( &recvDataBuffer[offsetData], &sendDataBuffer[offset],   sendDataBufferSize[ sendCount ]*sizeof(float) );
+
+                            offset += sendDataBufferSize[sendCount];
+                            sendCount++;
+                        }
+                    else
+                        {
+                            MPI_Isend(&extentsPerPartiton[i][0],  extentsPerPartiton[i].size(),  MPI_FLOAT, region[i], tags[0], MPI_COMM_WORLD, &sendMetaRq[mpiSendCount]);
+                            MPI_Isend(&sendDataBuffer[offset], sendDataBufferSize[ sendCount ], MPI_FLOAT, region[i], tags[1], MPI_COMM_WORLD, &sendImageRq[mpiSendCount]);
+
+                            offset += sendDataBufferSize[sendCount];
+                            sendCount++;
+                            mpiSendCount++;
+                        }
+                }
+        }
+
+    //ospout << "Asyn send setup done ~ numRegionsToSend: " << numRegionsToSend << "  mpiSendCount: " << mpiSendCount << endl;
+
+    if (myRegionHeight != 0)
+        {
+            //debug5 << "MPI_Waitall ..." << std::endl;
+            MPI_Waitall(recvInfoCount, recvImageRq, recvImageSt);   // Means that we have reveived everything!
+
+            //debug5 << "MAPI_WAITALL done!" << std::endl;
+
+            if (recvInfoATABuffer != NULL)
+                delete []recvInfoATABuffer;
+            recvInfoATABuffer = NULL;
+
+            //debug5 << "Sorting..." << std::endl;
+
+            //
+            // Sort the data
+            std::multimap<float,int> patchData;
+            std::vector<int> patchOffset;
+            patchOffset.push_back(0);
+            for (int i=0; i<infoBufferSize; i++)
+                {
+                    patchData.insert( std::pair<float,int> (recvInfoBuffer[i*6 + 5],i));
+                    int _patchSize = (recvInfoBuffer[i*6 + 4]-recvInfoBuffer[i*6 + 3]) * (recvInfoBuffer[i*6 + 2]-recvInfoBuffer[i*6 + 1]) * 4;
+                    int _offset = patchOffset[i] + _patchSize;
+
+                    if (i != infoBufferSize-1)
+                        patchOffset.push_back(_offset);
+                }
+
+            //
+            // Create buffer for current region
+            intermediateImageBBox[0] = intermediateImageExtents[0] = fullImageExtents[0];
+            intermediateImageBBox[1] = intermediateImageExtents[1] = fullImageExtents[1];
+            intermediateImageBBox[2] = intermediateImageExtents[2] = myStartingHeight;
+            intermediateImageBBox[3] = intermediateImageExtents[3] = myEndingHeight;
+            intermediateImage = new float[width * (myEndingHeight - myStartingHeight) * 4]();
+            //debug5 << "intermediate image size " << width << ", " << (myEndingHeight - myStartingHeight) << std::endl;
+
+            //
+            // Blend
+            int numBlends = 0;
+            for (std::multimap<float,int>::iterator it=patchData.begin(); it!=patchData.end(); ++it)
+                {
+                    int _id = (*it).second;
+                    int _extents[4];
+                    _extents[0] = recvInfoBuffer[_id*6 + 1];
+                    _extents[1] = recvInfoBuffer[_id*6 + 2];
+                    _extents[2] = recvInfoBuffer[_id*6 + 3];
+                    _extents[3] = recvInfoBuffer[_id*6 + 4];
+                    BlendFrontToBack(&recvDataBuffer[patchOffset[_id]], _extents, _extents, intermediateImage, intermediateImageExtents);
+                    numBlends++;
+                }
+
+            if (numBlends == 0) {
+                intermediateImageBBox[0]=intermediateImageBBox[1]=intermediateImageBBox[2]=intermediateImageBBox[3] = 0;
+            }
+        }
+
+    MPI_Waitall(numRegionsToSend, sendImageRq, sendImageSt);   // Means that we have sent everything!
+
+    if (myRegionHeight == 0) compositingDone = true;
+
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Async Send");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Cleanup
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Cleanup");
+    //---------------------------------------------------------------------//
+    if (sendDataBuffer != NULL)
+	delete []sendDataBuffer;
+    sendDataBuffer = NULL;
+
+    if (sendDataBufferSize != NULL)
+	delete []sendDataBufferSize;
+    sendDataBufferSize = NULL;
+
+    if (sendDataBufferOffsets != NULL)
+	delete []sendDataBufferOffsets;
+    sendDataBufferOffsets = NULL;
+
+
+    if (sendMetaRq != NULL)
+	delete []sendMetaRq;
+
+    if (sendImageRq != NULL)
+	delete []sendImageRq;
+
+    if (sendMetaSt != NULL)
+	delete []sendMetaSt;
+
+    if (sendImageSt != NULL)
+	delete []sendImageSt;
+
+    sendMetaRq = NULL;
+    sendImageRq = NULL;
+    sendMetaSt = NULL;
+    sendImageSt = NULL;
+
+    if (myRegionHeight != 0)
+        {
+            if (recvInfoBuffer != NULL)
+                delete []recvInfoBuffer;
+            recvInfoBuffer = NULL;
+
+            if (recvDataBuffer != NULL)
+                delete []recvDataBuffer;
+            recvDataBuffer = NULL;
+
+            if (recvMetaRq != NULL)
+                delete []recvMetaRq;
+
+            if (recvMetaSt != NULL)
+                delete []recvMetaSt;
+
+            if (recvImageRq != NULL)
+                delete []recvImageRq;
+
+            if (recvImageSt != NULL)
+                delete []recvImageSt;
+
+            recvMetaRq = NULL;
+            recvImageRq = NULL;
+            recvMetaSt = NULL;
+            recvImageSt = NULL;
+        }
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Cleanup");
+    //ospout << "All Parallel Direct Send is Done" << std::endl;
+    //---------------------------------------------------------------------//
+#endif
+    return myRegionHeight;
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::gatherImages
+//
+//  Purpose:
+//      Gather images from Parallel Direct Send
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtOSPRayImageCompositor::gatherImages(int regionGather[], int totalNumRanks, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight)
+{
+#ifdef PARALLEL
+    //debug5 << "gatherImages starting... totalNumRanks: " << totalNumRanks << ", compositingDone: " << compositingDone
+    //	   << ", imgExtents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
+
+    for (int i=0; i<4; i++)
+	finalImageExtents[i] = finalBB[i] = 0;
+
+    if (mpiRank == 0)
+        {
+            int width =  fullImageExtents[1]-fullImageExtents[0];
+            int height = fullImageExtents[3]-fullImageExtents[2];
+
+            //debug5 << "Gather Images at 0, final size: " << fullImageExtents[1]-fullImageExtents[0] << " x " << fullImageExtents[3]-fullImageExtents[2] << std::endl;
+
+            //
+            // Receive at root/display node!
+            finalImage = new float[width*height*4];
+            finalImageExtents[0] = fullImageExtents[0];
+            finalImageExtents[1] = fullImageExtents[1];
+            finalImageExtents[2] = fullImageExtents[2];
+            finalImageExtents[3] = fullImageExtents[3];
+
+            int numRegionsWithData = 0;
+            int numToRecv = 0;
+            for (int i=0; i<totalNumRanks; i++)
+                {
+                    if (getRegionSize(i) != 0)
+                        numRegionsWithData++;
+                }
+            numToRecv = numRegionsWithData;
+
+            // remove itself from the recv
+            if (getRegionSize(mpiRank) != 0) 
+                numToRecv--;
+
+
+            //
+            // Create buffers for async reciving
+            MPI_Request *recvImageRq = new MPI_Request[ numToRecv ];
+            MPI_Status  *recvImageSt = new MPI_Status[ numToRecv ];
+
+            int lastBufferSize    = getRegionSize(totalNumRanks-1) * width * 4;
+            int regularBufferSize = regularRegionSize * width * 4;
+
+            //debug5 << "numToRecv: " << numToRecv << ", numRegionsWithData: " << numRegionsWithData << std::endl;
+            //debug5 << "regularBufferSize: " << regularBufferSize << ", lastBufferSize: " << lastBufferSize << std::endl;
+
+            // Async Recv
+            int recvCount=0;
+            for (int i=0; i<numRegionsWithData; i++)
+                {
+                    int src = regionGather[i];
+
+                    if (src == mpiRank)
+                        continue;
+
+                    if (i == totalNumRanks-1)
+                        {
+                            if (lastBufferSize != 0)
+                                {
+                                    MPI_Irecv(&finalImage[i*regularBufferSize], lastBufferSize,     MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+                                }
+                        }
+                    else
+                        MPI_Irecv(&finalImage[i*regularBufferSize], regularBufferSize,  MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+			
+
+                    //debug5 << i << " ~ recvCount: " << recvCount << std::endl;
+                    recvCount++;
+                }
+
+            if (compositingDone == false)   // If root has data for the final image
+                PlaceImage(inputImg, imgExtents, finalImage, finalImageExtents);
+
+            MPI_Waitall(numToRecv, recvImageRq, recvImageSt);
+            compositingDone = true;
+
+            delete []recvImageRq;
+            recvImageRq = NULL;
+            delete []recvImageSt;
+            recvImageSt = NULL;
+        }
+    else
+        {
+            if (compositingDone == false)   
+                {
+                    int imgSize = (imgExtents[1]-imgExtents[0]) * (imgExtents[3]-imgExtents[2]) * 4;
+                    //debug5 << "imgSize: " << imgSize << std::endl;
+
+                    MPI_Send(inputImg, imgSize, MPI_FLOAT, 0, tag, MPI_COMM_WORLD);
+                    compositingDone = true;
+                }
+        }
+
+#endif
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::getcompositedImage
+//
+//  Purpose:
+//      Returns the whole image if needed
+//
+//  Programmer: Pascal Grosset
+//  Creation: July 2013
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtOSPRayImageCompositor::getcompositedImage
+(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage)
+{
+    for (int i=0; i< imgBufferHeight; i++) {
+        for (int j=0; j<imgBufferWidth; j++) {
+            int bufferIndex = (imgBufferWidth*4*i) + (j*4);
+            int wholeImgIndex = (imgBufferWidth*3*i) + (j*3);
+            wholeImage[wholeImgIndex+0] = (finalImage[bufferIndex+0] ) * 255;
+            wholeImage[wholeImgIndex+1] = (finalImage[bufferIndex+1] ) * 255;
+            wholeImage[wholeImgIndex+2] = (finalImage[bufferIndex+2] ) * 255;
+        }
+    }
+    if (finalImage != NULL)
+        { delete []finalImage; }
+    finalImage = NULL;
+}
diff --git a/avt/Filters/avtOSPRayImageCompositor.h b/avt/Filters/avtOSPRayImageCompositor.h
new file mode 100644
index 0000000000..d165fecf4c
--- /dev/null
+++ b/avt/Filters/avtOSPRayImageCompositor.h
@@ -0,0 +1,267 @@
+/*****************************************************************************
+ *
+ * Copyright (c) 2000 - 2017, Lawrence Livermore National Security, LLC
+ * Produced at the Lawrence Livermore National Laboratory
+ * LLNL-CODE-442911
+ * All rights reserved.
+ *
+ * This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+ * full copyright notice is contained in the file COPYRIGHT located at the root
+ * of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+ *
+ * Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  - Redistributions of  source code must  retain the above  copyright notice,
+ *    this list of conditions and the disclaimer below.
+ *  - Redistributions in binary form must reproduce the above copyright notice,
+ *    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+ *    documentation and/or other materials provided with the distribution.
+ *  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+ * ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+ * LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+ * DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+ * LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+ * OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ *****************************************************************************/
+
+// *************************************************************************//
+//                          avtOSPRayImageCompositor.h                       //
+// *************************************************************************//
+
+#ifndef AVT_OSPRAY_IMG_COMMUNICATOR_H
+#define AVT_OSPRAY_IMG_COMMUNICATOR_H
+
+#include <avtOSPRayCommon.h>
+
+#include <string>
+#include <vector>
+#include <map>
+#include <algorithm>
+#include <utility>
+
+#ifdef PARALLEL
+# include <mpi.h>
+#endif
+
+// ***************************************************************************
+//  Class: avtOSPRayImageCompositor
+//
+//  Purpose:
+//      Does the composition for Ray casting: OSPRay
+//
+//  Programmer: Pascal Grosset
+//  Creation:   Spetember 20, 2013
+//
+// ***************************************************************************
+
+class avtOSPRayIC_Implementation
+{
+ public:
+    avtOSPRayIC_Implementation(int mpiSize, int mpiRank) {};
+    virtual ~avtOSPRayIC_Implementation() {};
+    virtual void Init (int W, int H) = 0;
+    virtual void SetTile (const float* data, 
+			  const int* extents, 
+			  const float& depth) = 0;
+    virtual void Composite (float*& output) = 0;
+};
+
+// ***************************************************************************
+//  Class: avtOSPRayImageCompositor
+//
+//  Purpose:
+//      Does the composition for Ray casting: SLIVR
+//
+//  Programmer: Pascal Grosset
+//  Creation:   Spetember 20, 2013
+//
+// ***************************************************************************
+
+class avtOSPRayImageCompositor
+{ 
+ public:    
+    avtOSPRayImageCompositor();
+    ~avtOSPRayImageCompositor();
+
+    virtual const char *GetType(void)
+    { return "avtOSPRayImageCompositor"; }
+    virtual const char *GetDescription(void) 
+    { return "Doing compositing for ray casting OSPRay"; }
+
+    float* GetFinalImageBuffer () { return finalImage; }
+    int GetParSize ()             { return mpiSize;   }
+    int GetParRank ()             { return mpiRank;   }
+
+    // Those functions can be static
+    static void BlendFrontToBack(const float *, const int srcExtents[4],
+				 const int blendExtents[4], 
+				 float *&, const int dstExtents[4]);
+    static void BlendBackToFront(const float *, const int srcExtents[4], 
+				 const int blendExtents[4], 
+				 float *&, const int dstExtents[4]);
+    static void BlendFrontToBack(const float *, const int srcExtents[4], 
+				 float *&, const int dstExtents[4]);
+    static void BlendBackToFront(const float *, const int srcExtents[4], 
+				 float *&, const int dstExtents[4]);
+    void Barrier();
+
+ private:
+    //----------------------------------------------------------------------//
+    static void ColorImage(float *&, const int, const int, 
+			   const float color[4]);
+    static void PlaceImage(const float *, const int srcExtents[4], 
+			   float *&, const int dstExtents[4]);
+    static void BlendWithBackground(float *&, const int extents[4],
+				    const float bgColor[4]);
+ public:
+    //----------------------------------------------------------------------//
+    // Different Algorithms
+    //----------------------------------------------------------------------//
+
+    //----------------------------------------------------------------------//
+    // IceT: (export OSPRAY_USE_ICET=1)
+    //   Use IceT for compositing. This method only supports the case where 
+    //   each rank produces only one tile.
+    // Algorithms:
+    //   Reduce
+    //   Binary Swap
+    //    
+    //----------------------------------------------------------------------//
+    bool IceTValid();
+    void IceTInit(int W, int H);
+    void IceTSetTile(const float*, const int*, const float&);
+    void IceTComposite(float*&);
+
+    //----------------------------------------------------------------------//
+    // OneNode
+    //   There is only one VisIt process
+    //----------------------------------------------------------------------//
+    bool OneNodeValid();
+    void OneNodeInit(int W, int H);
+    void OneNodeSetTile(const float*, const int*, const float&);
+    void OneNodeComposite(float*&);
+
+    //----------------------------------------------------------------------//
+    // Serial
+    //----------------------------------------------------------------------//
+    //bool SerialValid();
+    //void SerialInit(int W, int H);
+    //void SerialSetTile(const float*, const int*, const float&);
+    //void SerialComposite(float*&);
+
+ private:
+    // Basic MPI information
+    int mpiSize; // total number of processes (# of ranks)
+    int mpiRank; // my rank id
+    // TODO this communicator shouldnt be in charge of this variable
+    // Final image is here
+    float *finalImage;
+    // Image Compisition Implementation
+    avtOSPRayIC_Implementation* compositor;
+
+
+
+
+
+
+
+
+
+
+
+
+
+    // CLEAN UP BELOW
+ private:
+    //----------------------------------------------------------------------//
+    void UpdateBoundingBox(int currentBoundingBox[4], 
+                           const int imageExtents[4]);
+    //----------------------------------------------------------------------//
+
+    //----------------------------------------------------------------------//
+    // Both currently unused but good for simple testing
+    //----------------------------------------------------------------------//
+ private:
+    void GatherDepthAtRoot(const int, const float *, int &, int *&, float *&);
+ public:
+    void SerialDirectSend
+	(int, float*, int*, float*, float bgColor[4], int, int);
+
+    //----------------------------------------------------------------------//
+    // Parallel Direct Send
+    //----------------------------------------------------------------------//
+ public:
+    void RegionAllocation(int *&);
+    int  ParallelDirectSendManyPatches
+	(const std::multimap<int, ospray::ImgData>&,
+	 const std::vector<ospray::ImgMetaData>&,
+	 int, int*, int, int tags[2], int fullImageExtents[4]);
+
+ private:
+    ///--------------------------------------
+    // flags for patch
+    int totalPatches;
+    bool compositingDone;
+
+    // image sizing for compositing
+    int maxRegionHeight;
+    int regularRegionSize;
+    std::vector<int> regionRankExtents;
+
+    //----------------------------------------------------------------------//
+      
+    void computeRegionExtents(int numRanks, int height);
+	
+    int getRegularRegionSize(){ return regularRegionSize; } 
+    int getRegionStart(int region){ return regionRankExtents[region*3+0]; }
+    int getRegionEnd(int region){ return regionRankExtents[region*3+1]; }
+    int getRegionSize(int region){ return regionRankExtents[region*3+2]; }
+    int getMaxRegionHeight(){ return maxRegionHeight; }
+	
+    int getScreenRegionStart(int region, int screenImgMinY, int screenImgMaxY)
+    {
+	return CLAMP(getRegionStart(region)+screenImgMinY, 
+		     screenImgMinY, screenImgMaxY); 
+    }
+    int getScreenRegionEnd(int region, int screenImgMinY, int screenImgMaxY)
+    {
+	return CLAMP(getRegionEnd(region)+screenImgMinY, 
+		     screenImgMinY, screenImgMaxY); 
+    }
+
+ public:
+    //----------------------------------------------------------------------//
+
+    void getcompositedImage(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage);  // get the final composited image
+
+
+    int findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to);
+
+
+    void parallelDirectSend(float *imgData, int imgExtents[4], int region[], int numRegions, int tags[2], int fullImageExtents[4]);	
+    void gatherImages(int regionGather[], int numToRecv, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight);
+
+ public:
+    // TODO: Remove all public fields
+    int finalImageExtents[4];
+    int finalBB[4];
+    float *intermediateImage; // Intermediate image, e.g. in parallel direct send
+    int intermediateImageExtents[4];
+    int intermediateImageBBox[4];
+
+
+};
+
+#endif//AVT_OSPRAY_IMG_COMMUNICATOR_H
diff --git a/avt/Filters/avtOSPRayRayTracer.C b/avt/Filters/avtOSPRayRayTracer.C
new file mode 100644
index 0000000000..f99469efbe
--- /dev/null
+++ b/avt/Filters/avtOSPRayRayTracer.C
@@ -0,0 +1,838 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                       avtOSPRayRayTracer.C                                //
+// ************************************************************************* //
+
+#include <avtOSPRayRayTracer.h>
+
+#include <visit-config.h>
+
+#include <avtDataset.h>
+#include <avtImage.h>
+#include <avtParallel.h>
+#include <avtRayCompositer.h>
+#include <avtOSPRaySamplePointExtractor.h>
+#include <avtWorldSpaceToImageSpaceTransform.h>
+
+#include <DebugStream.h>
+#include <ImproperUseException.h>
+#include <TimingsManager.h>
+#include <StackTimer.h>
+
+#include <vtkImageData.h>
+#include <vtkMatrix4x4.h>
+
+#include <vector>
+
+using     std::vector;
+
+bool OSPRaySortImgMetaDataByDepth(ospray::ImgMetaData const& before, 
+                                  ospray::ImgMetaData const& after)
+{ return before.avg_z > after.avg_z; }
+bool OSPRaySortImgMetaDataByEyeSpaceDepth(ospray::ImgMetaData const& before,
+                                          ospray::ImgMetaData const& after)
+{ return before.eye_z > after.eye_z; }
+
+// ****************************************************************************
+//  Method: avtOSPRayRayTracer constructor
+//
+//  Programmer: Hank Childs
+//  Creation:   November 27, 2000
+//
+//  Modifications:
+//    Brad Whitlock, Wed Dec 5 11:19:29 PDT 2001
+//    Added gradient backgrounds.
+//
+//    Hank Childs, Mon Jan 16 11:11:47 PST 2006
+//    Added kernel based sampling.
+//
+//    Pascal Grosset, Fri Sep 20 2013
+//    Added ray casting slivr & trilinear interpolation
+//
+//    Qi WU, Wed Jun 20 2018
+//    Added support for raycasting ospray
+//
+// ****************************************************************************
+
+avtOSPRayRayTracer::avtOSPRayRayTracer() : avtRayTracerBase()
+{
+    panPercentage[0] = 0;
+    panPercentage[1] = 0;
+    lighting = false;
+    lightPosition[0] = lightPosition[1] = lightPosition[2] = 0.0;
+    lightPosition[3] = 1.0;
+    materialProperties[0] = 0.4;
+    materialProperties[1] = 0.75;
+    materialProperties[2] = 0.0;
+    materialProperties[3] = 15.0;
+
+    ospray = NULL;
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRayRayTracer destructor
+//
+//  Purpose:
+//      Defines the destructor.  Note: this should not be inlined in the header
+//      because it causes problems for certain compilers.
+//
+//  Programmer: Hank Childs
+//  Creation:   February 5, 2004
+//
+// ****************************************************************************
+
+avtOSPRayRayTracer::~avtOSPRayRayTracer()
+{
+    ;
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRayRayTracer::Execute
+//
+//  Purpose:
+//      Executes the ray tracer.  
+//      This means:
+//      - Put the input mesh through a transform so it is in camera space.
+//      - Get the sample points.
+//      - Communicate the sample points (parallel only).
+//      - Composite the sample points along rays.
+//      - Communicate the pixels from each ray (parallel only).
+//      - Output the image.
+//
+//  Programmer: Hank Childs
+//  Creation:   November 27, 2000
+//
+//  Modifications:
+//
+//    Hank Childs, Fri Jan 26 17:00:07 PST 2001
+//    Added support for parallel ray tracing.
+//
+//    Hank Childs, Sat Jan 27 15:09:34 PST 2001
+//    Added support for sending cells when doing parallel ray tracing.
+//
+//    Hank Childs, Sun Mar  4 21:50:36 PST 2001
+//    Added image partition to aid parallel modules in minimizing
+//    communication by dynamically assigning the partitions.
+//
+//    Eric Brugger, Mon Nov  5 13:47:19 PST 2001
+//    Modified to always compile the timing code.
+//
+//    Brad Whitlock, Wed Dec 5 10:57:56 PDT 2001
+//    Added code to set the gradient background colors, background mode in
+//    the ray compositer.
+//
+//    Kathleen Bonnell, Tue Apr 30 12:34:54 PDT 2002  
+//    Use new version of CopyTo. 
+//
+//    Hank Childs, Fri Sep 13 12:04:04 PDT 2002
+//    Reverse arguments for CopyTo (we weren't sending in the input correctly).
+//
+//    Hank Childs, Fri Nov 19 13:47:20 PST 2004
+//    Added option to have sampling of rectilinear grids done efficiently
+//    by sample point extractor by not converting grid into image space.
+//
+//    Hank Childs, Thu Dec  2 09:26:28 PST 2004
+//    No longer tighten clipping planes ['5699].
+//
+//    Hank Childs, Thu Dec  9 17:15:44 PST 2004
+//    Cast rays in tiles for big images ['1948].
+//
+//    Hank Childs, Sun Mar 13 11:16:20 PST 2005
+//    Fix memory leak.
+//
+//    Hank Childs, Tue Mar 29 16:19:19 PST 2005
+//    If the image is large, force divisions of 512x512, even if we should
+//    theoretically have enough memory to cover it.
+//
+//    Hank Childs, Mon Jan 16 11:11:47 PST 2006
+//    Add support for kernel based sampling.
+//
+//    Hank Childs, Thu May 31 22:36:32 PDT 2007
+//    Remove code for setting number of variables for processors that don't
+//    have data, since that is now handled by the avtSamplePointExtractor's
+//    base class.
+//
+//    Hank Childs, Wed Dec 24 09:46:56 PST 2008
+//    Add code to convert the z-buffer of the background to the w-buffer.
+//    This is being done so the samples lie more evenly.
+//
+//    Hank Childs, Wed Dec 24 14:16:04 PST 2008
+//    Automatically tighten the clipping planes so we utilize our samples
+//    more effectively.
+//
+//    Hank Childs, Fri Jan  9 14:17:10 PST 2009
+//    Have each ray be randomly jittered forward or backwards along its
+//    direction.
+//
+//    Hank Childs, Tue Jan 13 14:26:44 PST 2009
+//    Fix oversight where parallel volume rendering was not being jittered.
+//
+//    Hank Childs, Sun Jan 24 15:35:50 PST 2010
+//    Automatically use the kernel based resampling for point data.
+//
+//    Pascal Grosset & Manasa Prasad, Fri Aug 20 2016
+//    Add the ray casting OSPRay code
+//
+//    Qi WU, Tue Aug 8 2017
+//    Fix camera matrices multiplication order for ray casting OSPRay
+//    Also fixed panning for ray casting OSPRay
+//
+//    Qi WU, Wed Jun 20 2018
+//    Added support for raycasting ospray
+//
+// ****************************************************************************
+
+void
+avtOSPRayRayTracer::Execute()
+{
+    //======================================================================//
+    // Initialization and Debug
+    //======================================================================//
+    // check memory in the beginning
+    ospout << "[avrRayTracer] entering execute" << std::endl;
+    ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute", "ospout");    
+
+    // initialize current time
+    StackTimer t0("Ray Tracing");
+
+    //======================================================================//
+    // Start of original pipeline
+    //======================================================================//
+    bool parallelOn = (imgComm.GetParSize() == 1) ? false : true;
+    if (rayfoo == NULL)
+    {
+        debug1 << "Never set ray function for ray tracer." << endl;
+        EXCEPTION0(ImproperUseException);
+    }
+
+    //
+    // First we need to transform all of domains into camera space.
+    //
+    ospout << "[avrRayTracer] compute camera" << std::endl;
+    double aspect = 1.;
+    if (screen[1] > 0)
+    {
+        aspect = (double)screen[0] / (double)screen[1];
+    }
+
+    double scale[3] = {1,1,1};
+    vtkMatrix4x4 *transform = vtkMatrix4x4::New();
+    avtWorldSpaceToImageSpaceTransform::CalculateTransform(view, transform,
+                                                           scale, aspect);
+    double newNearPlane, newFarPlane, oldNearPlane, oldFarPlane;
+    TightenClippingPlanes(view, transform, newNearPlane, newFarPlane);
+    oldNearPlane = view.nearPlane;  oldFarPlane  = view.farPlane;
+    view.nearPlane = newNearPlane;  view.farPlane  = newFarPlane;
+    transform->Delete();
+
+    avtWorldSpaceToImageSpaceTransform trans(view, aspect);
+    trans.SetInput(GetInput());
+
+    //
+    // Extract all of the samples from the dataset.
+    //
+    avtOSPRaySamplePointExtractor extractor(screen[0], screen[1],
+                                            samplesPerRay);
+    extractor.SetJittering(true);
+    extractor.SetTransferFn(transferFn1D);
+    extractor.SetInput(trans.GetOutput());
+	
+    //
+    // Before Rendering
+    //
+    double dbounds[6];  // Extents of the volume in world coordinates
+    vtkMatrix4x4  *model_to_screen_transform = vtkMatrix4x4::New();
+    vtkMatrix4x4  *screen_to_model_transform = vtkMatrix4x4::New();
+    vtkMatrix4x4  *screen_to_camera_transform = vtkMatrix4x4::New();
+    vtkImageData  *opaqueImageVTK = NULL;
+    unsigned char *opaqueImageData = NULL;
+    float         *opaqueImageZB = NULL;
+    std::vector<float> opaqueImageDepth(screen[0] * screen[1], oldFarPlane);
+    int            fullImageExtents[4];
+
+    //
+    // Camera Settings
+    //
+    vtkCamera *sceneCam = vtkCamera::New();
+    sceneCam->SetPosition(view.camera[0],view.camera[1],view.camera[2]);
+    sceneCam->SetFocalPoint(view.focus[0],view.focus[1],view.focus[2]);
+    sceneCam->SetViewUp(view.viewUp[0],view.viewUp[1],view.viewUp[2]);
+    sceneCam->SetViewAngle(view.viewAngle);
+    sceneCam->SetClippingRange(oldNearPlane, oldFarPlane);
+    if (view.orthographic) { sceneCam->ParallelProjectionOn(); }
+    else { sceneCam->ParallelProjectionOff(); }
+    sceneCam->SetParallelScale(view.parallelScale);	
+    // Clip planes
+    double oldclip[2] = {oldNearPlane, oldFarPlane};
+    panPercentage[0] = view.imagePan[0];
+    panPercentage[1] = view.imagePan[1];
+    // Scaling
+    vtkMatrix4x4 *matScale = vtkMatrix4x4::New();
+    matScale->Identity(); 
+    // Scale + Model + View Matrix
+    vtkMatrix4x4 *matViewModelScale = vtkMatrix4x4::New();
+    vtkMatrix4x4 *matViewModel = sceneCam->GetModelViewTransformMatrix();
+    vtkMatrix4x4::Multiply4x4(matViewModel, matScale, matViewModelScale);
+    // Zooming
+    vtkMatrix4x4 *matZoomViewModelScale = vtkMatrix4x4::New();
+    vtkMatrix4x4 *matZoom = vtkMatrix4x4::New();
+    matZoom->Identity(); 
+    matZoom->SetElement(0, 0, view.imageZoom); 
+    matZoom->SetElement(1, 1, view.imageZoom);
+    vtkMatrix4x4::Multiply4x4(matZoom, matViewModelScale, 
+                              matZoomViewModelScale);
+    // Projection:
+    //
+    // https://www.vtk.org/doc/release/6.1/html/classvtkCamera.html
+    // HASH: #a4d9a509bf60f1555a70ecdee758c2753
+    //
+    // The Z buffer that is passed from visit is in clip scape with z 
+    // limits of -1 and 1. However, using VTK 6.1.0, the z limits are 
+    // wired. So, the projection matrix from VTK is hijacked here and
+    // adjusted to be within -1 and 1 too
+    //
+    // Actually the correct way of using VTK GetProjectionTransformMatrix 
+    // is to set near and far plane as -1 and 1
+    //
+    vtkMatrix4x4 *matProj = 
+        sceneCam->GetProjectionTransformMatrix(aspect, -1, 1);
+    double sceneSize[2];
+    if (!view.orthographic) {
+        sceneSize[0] = 2.0 * oldNearPlane / matProj->GetElement(0, 0);
+        sceneSize[1] = 2.0 * oldNearPlane / matProj->GetElement(1, 1);
+    }
+    else {
+        sceneSize[0] = 2.0 / matProj->GetElement(0, 0);
+	    sceneSize[1] = 2.0 / matProj->GetElement(1, 1);
+    }
+    // Compute model_to_screen_transform matrix
+    vtkMatrix4x4::Multiply4x4(matProj,matZoomViewModelScale,
+                              model_to_screen_transform);
+    vtkMatrix4x4::Invert(model_to_screen_transform,
+                         screen_to_model_transform);
+    vtkMatrix4x4::Invert(matProj,
+                         screen_to_camera_transform);
+    // Debug
+    ospout << "[avrRayTracer] matZoom " << *matZoom << std::endl;
+    ospout << "[avrRayTracer] matViewModel " << *matViewModel << std::endl;
+    ospout << "[avrRayTracer] matScale " << *matScale << std::endl;
+    ospout << "[avrRayTracer] matProj " << *matProj << std::endl;
+    // Cleanup
+    matScale->Delete();
+    matViewModel->Delete();
+    matViewModelScale->Delete();
+    matZoom->Delete();
+    matZoomViewModelScale->Delete();
+    matProj->Delete();
+    // Get the full image extents of the volume
+    double depthExtents[2];
+    GetSpatialExtents(dbounds);
+    ospray::ProjectWorldToScreenCube(dbounds, screen[0], screen[1], 
+                                     panPercentage, view.imageZoom,
+                                     model_to_screen_transform,
+                                     fullImageExtents, depthExtents);
+    fullImageExtents[0] = std::max(fullImageExtents[0], 0);
+    fullImageExtents[2] = std::max(fullImageExtents[2], 0);
+    fullImageExtents[1] = std::min(1+fullImageExtents[1], screen[0]);
+    fullImageExtents[3] = std::min(1+fullImageExtents[3], screen[1]);
+    // Debug
+    ospout << "[avrRayTracer] View settings: " << endl
+           << "  inheriant view direction: "
+           << viewDirection[0] << " "
+           << viewDirection[1] << " "
+           << viewDirection[2] << std::endl
+           << "  camera: "       
+           << view.camera[0] << ", " 
+           << view.camera[1] << ", " 
+           << view.camera[2] << std::endl
+           << "  focus: "    
+           << view.focus[0] << ", " 
+           << view.focus[1] << ", " 
+           << view.focus[2] << std::endl
+           << "  viewUp: "    
+           << view.viewUp[0] << ", " 
+           << view.viewUp[1] << ", " 
+           << view.viewUp[2] << std::endl
+           << "  viewAngle: " << view.viewAngle << std::endl
+           << "  eyeAngle:  " << view.eyeAngle  << std::endl
+           << "  parallelScale: " << view.parallelScale  << std::endl
+           << "  setScale: " << view.setScale << std::endl
+           << "  scale:    " 
+           << scale[0] << " " 
+           << scale[1] << " " 
+           << scale[2] << " " 
+           << std::endl
+           << "  nearPlane: " << view.nearPlane << std::endl
+           << "  farPlane:  " << view.farPlane  << std::endl
+           << "  imagePan[0]: " << view.imagePan[0] << std::endl 
+           << "  imagePan[1]: " << view.imagePan[1] << std::endl
+           << "  imageZoom:   " << view.imageZoom   << std::endl
+           << "  orthographic: " << view.orthographic << std::endl
+           << "  shear[0]: " << view.shear[0] << std::endl
+           << "  shear[1]: " << view.shear[1] << std::endl
+           << "  shear[2]: " << view.shear[2] << std::endl
+           << "  oldNearPlane: " << oldNearPlane << std::endl
+           << "  oldFarPlane:  " << oldFarPlane  << std::endl
+           << "  aspect: " << aspect << std::endl
+           << "[avrRayTracer] sceneSize: " 
+           << sceneSize[0] << " " 
+           << sceneSize[1] << std::endl
+           << "[avrRayTracer] screen: " 
+           << screen[0] << " " << screen[1] << std::endl
+           << "[avrRayTracer] data bounds: " << std::endl
+           << "\t" << dbounds[0] << " " << dbounds[1] << std::endl
+           << "\t" << dbounds[2] << " " << dbounds[3] << std::endl
+           << "\t" << dbounds[4] << " " << dbounds[5] << std::endl
+           << "[avrRayTracer] full image extents: " << std::endl
+           << "\t" << fullImageExtents[0] << " "
+           << "\t" << fullImageExtents[1] << std::endl
+           << "\t" << fullImageExtents[2] << " "
+           << "\t" << fullImageExtents[3] << std::endl;
+    ospout << "[avrRayTracer] model_to_screen_transform: " 
+           << *model_to_screen_transform << std::endl;
+    ospout << "[avrRayTracer] screen_to_model_transform: " 
+           << *screen_to_model_transform << std::endl;
+    ospout << "[avrRayTracer] screen_to_camera_transform: " 
+           << *screen_to_camera_transform << std::endl;
+
+    //===================================================================//
+    // ospray stuffs
+    //===================================================================//   
+    ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute before ospray", 
+                            "ospout");
+    // initialize ospray
+    // -- multi-threading enabled
+    ospray->InitOSP();
+    // camera
+    ospout << "[avrRayTracer] make ospray camera" << std::endl;
+    if (!view.orthographic) {
+        ospray->camera.Init(OSPVisItCamera::PERSPECTIVE);
+    }
+    else {
+        ospray->camera.Init(OSPVisItCamera::ORTHOGRAPHIC);
+    }
+    ospray->camera.Set(view.camera,
+                       view.focus, 
+                       view.viewUp, 
+                       viewDirection,
+                       sceneSize, 
+                       aspect, 
+                       view.viewAngle, 
+                       view.imageZoom,
+                       view.imagePan, 
+                       fullImageExtents, 
+                       screen);
+    ospray->SetScaling(scale);
+    // transfer function
+    ospout  << "[avrRayTracer] make ospray transfer function" 
+            << std::endl;
+    ospray->transferfcn.Init();
+    ospray->transferfcn.Set
+        ((OSPVisItColor*)transferFn1D->GetTableFloat(), 
+         transferFn1D->GetNumberOfTableEntries(),
+         (float)transferFn1D->GetMin(),
+         (float)transferFn1D->GetMax());
+    // renderer
+    ospout << "[avrRayTracer] make ospray renderer" << std::endl;
+    ospray->renderer.Init();
+    ospray->renderer.Set(materialProperties, viewDirection, lighting);
+    ospray->SetDataBounds(dbounds);
+    // check memory
+    ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute after ospray",
+                            "ospout");    
+
+    // 
+    // Continuation of previous pipeline
+    //
+    extractor.SetJittering(false);
+    extractor.SetLighting(lighting);
+    extractor.SetLightDirection(lightDirection);
+    extractor.SetMatProperties(materialProperties);
+    extractor.SetViewDirection(viewDirection);
+    extractor.SetTransferFn(transferFn1D);
+    extractor.SetClipPlanes(oldclip);
+    extractor.SetPanPercentages(view.imagePan);
+    extractor.SetImageZoom(view.imageZoom);
+    extractor.SetRendererSampleRate(rendererSampleRate); 
+    extractor.SetDepthExtents(depthExtents);
+    extractor.SetMVPMatrix(model_to_screen_transform);
+    extractor.SetFullImageExtents(fullImageExtents);
+    extractor.SetOSPRay(ospray); // sending ospray
+
+    //
+    // Capture background
+    //
+    opaqueImageVTK  = opaqueImage->GetImage().GetImageVTK();
+    opaqueImageData = 
+        (unsigned char *)opaqueImageVTK->GetScalarPointer(0, 0, 0);
+    opaqueImageZB   = opaqueImage->GetImage().GetZBuffer();
+    int bufferScreenExtents[4] = {0,screen[0],0,screen[1]};
+    extractor.SetDepthBuffer(opaqueImageZB,   screen[0]*screen[1]);
+    extractor.SetRGBBuffer  (opaqueImageData, screen[0],screen[1]);
+    extractor.SetBufferExtents(bufferScreenExtents);
+    // Set the background to OSPRay
+    for (int y = 0; y < screen[1]; ++y) {
+        for (int x = 0; x < screen[0]; ++x) {
+            int index = x + y * screen[0];
+            int    screenCoord[2] = {x, y};
+            double screenDepth = opaqueImageZB[index] * 2 - 1;
+            double worldCoord[3];
+            ospray::ProjectScreenToCamera
+                (screenCoord, screenDepth, 
+                 screen[0], screen[1],
+                 screen_to_camera_transform, 
+                 worldCoord);
+            opaqueImageDepth[index] = -worldCoord[2];
+        }
+    }
+    ospray->SetBgBuffer(opaqueImageDepth.data(), 
+                        bufferScreenExtents);
+    
+    // TODO We cannot delete camera here, why ?
+    //sceneCam->Delete();
+    
+    //
+    // For curvilinear and unstructured meshes, it makes sense to convert the
+    // cells to image space.  But for rectilinear meshes, it is not the
+    // most efficient strategy.  So set some flags here that allow the
+    // extractor to do the extraction in world space.
+    //
+    trans.SetPassThruRectilinearGrids(true);
+    extractor.SetRectilinearGridsAreInWorldSpace(true, view, aspect);
+
+    // Qi debug
+    ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute "
+                            "raytracing setup done",
+                            "ospout");
+
+    // Execute raytracer
+    avtDataObject_p samples = extractor.GetOutput();
+
+    //
+    // Ray casting: SLIVR ~ After Rendering
+    //
+    // Only required to force an update 
+    // Need to find a way to get rid of that!!!!
+    avtRayCompositer rc(rayfoo);
+    rc.SetInput(samples);
+    avtImage_p image  = rc.GetTypedOutput();
+    
+    // Execute rendering
+    // This will call the execute function
+    {
+        StackTimer t1("AllPatchRendering");
+        image->Update(GetGeneralContract()); 
+    }
+
+    //
+    // Image Compositing
+    //
+    // Initialization
+    int timingIdx;
+    float *compositedData = NULL;
+    int compositedW, compositedH;
+    int compositedExtents[4];
+    // Debug
+    int numPatches = extractor.GetImgPatchSize();
+    ospout << "[avtOSPRayRayTracer] Total num of patches " 
+           << numPatches << std::endl;
+    for (int i=0; i<numPatches; i++) {
+        ospray::ImgMetaData currImgMeta = extractor.GetImgMetaPatch(i);
+        ospout << "[avtOSPRayRayTracer] Rank " << PAR_Rank() << " "
+               << "Idx " << i << " (" << currImgMeta.patchNumber << ") " 
+               << " depth " << currImgMeta.eye_z << std::endl
+               << "current patch size = " 
+               << currImgMeta.dims[0] << ", " 
+               << currImgMeta.dims[1] << std::endl
+               << "current patch starting" 
+               << " X = " << currImgMeta.screen_ll[0] 
+               << " Y = " << currImgMeta.screen_ll[1] << std::endl
+               << "current patch ending" 
+               << " X = " << currImgMeta.screen_ur[0] 
+               << " Y = " << currImgMeta.screen_ur[1] << std::endl;
+    }
+    //-------------------------------------------------------------------//
+    // IceT: If each rank has only one patch, we use IceT to composite
+    //-------------------------------------------------------------------//
+    if (imgComm.IceTValid() && extractor.GetImgPatchSize() == 1) {
+        //---------------------------------------------------------------//
+        // Setup Local Tile
+        ospray::ImgMetaData currMeta = extractor.GetImgMetaPatch(0);
+        ospray::ImgData     currData;
+        currData.imagePatch = NULL;
+        extractor.GetAndDelImgData /* do shallow copy inside */
+            (currMeta.patchNumber, currData);
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // First Composition
+        if (PAR_Size() > 1) { 
+            compositedW = fullImageExtents[1] - fullImageExtents[0];
+            compositedH = fullImageExtents[3] - fullImageExtents[2];
+            compositedExtents[0] = fullImageExtents[0];
+            compositedExtents[1] = fullImageExtents[1];
+            compositedExtents[2] = fullImageExtents[2];
+            compositedExtents[3] = fullImageExtents[3];
+            if (PAR_Rank() == 0) {
+                compositedData = 
+                    new float[4 * compositedW * compositedH]();
+            }
+            int currExtents[4] = 
+                {std::max(currMeta.screen_ll[0]-fullImageExtents[0], 0), 
+                 std::min(currMeta.screen_ur[0]-fullImageExtents[0], 
+                          compositedW), 
+                 std::max(currMeta.screen_ll[1]-fullImageExtents[2], 0),
+                 std::min(currMeta.screen_ur[1]-fullImageExtents[2],
+                          compositedH)};
+            imgComm.IceTInit(compositedW, compositedH);
+            imgComm.IceTSetTile(currData.imagePatch, 
+                                currExtents,
+                                currMeta.eye_z);
+            imgComm.IceTComposite(compositedData);
+            if (currData.imagePatch != NULL) {
+                delete[] currData.imagePatch;
+                currData.imagePatch = NULL;
+            }
+        } else {
+            compositedW = currMeta.dims[0];
+            compositedH = currMeta.dims[1];
+            compositedExtents[0] = fullImageExtents[0];
+            compositedExtents[1] = fullImageExtents[0] + compositedW;
+            compositedExtents[2] = fullImageExtents[2];
+            compositedExtents[3] = fullImageExtents[2] + compositedH;
+            compositedData = currData.imagePatch;
+            currData.imagePatch = NULL;
+        }
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Memory
+        ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute "
+                                "IceT Compositing Done", 
+                                "ospout");
+        //---------------------------------------------------------------//
+    }
+    //-------------------------------------------------------------------//
+    // SERIAL: Image Composition
+    //-------------------------------------------------------------------//
+    else if (parallelOn == false) {
+        //---------------------------------------------------------------//
+        // Get the Metadata for All Patches
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Serial-Composite: Get the Metadata for "
+                                  "All Patches");
+        // contains the metadata to composite the image
+        std::vector<ospray::ImgMetaData> allPatchMeta;
+        std::vector<ospray::ImgData>     allPatchData;
+        // get the number of patches
+        int numPatches = extractor.GetImgPatchSize();
+        for (int i=0; i<numPatches; i++)
+        {
+            allPatchMeta.push_back(extractor.GetImgMetaPatch(i));
+        }
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Serial-Composite: Get the Metadata for "
+                                 "All Patches");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Sort with the Largest z First
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Serial-Composite: Sort with the Largest "
+                                  "z First");
+        std::sort(allPatchMeta.begin(), allPatchMeta.end(), 
+                  &OSPRaySortImgMetaDataByEyeSpaceDepth);
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Serial-Composite: Sort with the Largest "
+                                 "z First");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Blend Images
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Serial-Composite: Blend Images");
+        compositedW = fullImageExtents[1] - fullImageExtents[0];
+        compositedH = fullImageExtents[3] - fullImageExtents[2];
+        compositedExtents[0] = fullImageExtents[0];
+        compositedExtents[1] = fullImageExtents[0] + compositedW;
+        compositedExtents[2] = fullImageExtents[2];
+        compositedExtents[3] = fullImageExtents[2] + compositedH;	    
+        if (PAR_Rank() == 0) {
+            compositedData = new float[compositedW * compositedH * 4]();
+        }
+        for (int i=0; i<numPatches; i++)
+        {
+            ospray::ImgMetaData currImgMeta = allPatchMeta[i];
+            ospray::ImgData     currImgData;
+            currImgData.imagePatch = NULL;
+            extractor.GetAndDelImgData /* do shallow copy inside */
+                (currImgMeta.patchNumber, currImgData);
+            const float* currData = currImgData.imagePatch;
+            const int currExtents[4] = 
+                {currImgMeta.screen_ll[0], currImgMeta.screen_ur[0], 
+                 currImgMeta.screen_ll[1], currImgMeta.screen_ur[1]};
+            // ospray::WriteArrayToPPM
+            // 	("/home/qwu/work/visit/build/img-"+std::to_string(i)+".ppm",
+            // 	 currData,
+            // 	 currImgMeta.screen_ur[0] - currImgMeta.screen_ll[0],
+            // 	 currImgMeta.screen_ur[1] - currImgMeta.screen_ll[1]);
+            avtOSPRayImageCompositor::BlendBackToFront(currData,
+                                                       currExtents,
+                                                       compositedData, 
+                                                       compositedExtents);
+            // Clean up data
+            if (currImgData.imagePatch != NULL) {
+                delete[] currImgData.imagePatch;
+            }
+            currImgData.imagePatch = NULL;
+        }
+        allPatchMeta.clear();
+        allPatchData.clear();
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Serial-Composite: Blend Images");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Memory
+        ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute "
+                                "Sequential Compositing Done", 
+                                "ospout");
+        //---------------------------------------------------------------//
+    } 
+    //
+    // PARALLEL: Image Composition
+    //
+    else { 
+        //---------------------------------------------------------------//
+        // Parallel Direct Send
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Parallel-Composite: "
+                                  "Parallel Direct Send");
+        int tags[2] = {1081, 1681};
+        int tagGather = 2681;
+        int *regions = NULL;
+        imgComm.RegionAllocation(regions);
+        int myRegionHeight =
+            imgComm.ParallelDirectSendManyPatches
+            (extractor.imgDataHashMap, extractor.imageMetaPatchVector,
+             numPatches, regions, imgComm.GetParSize(), tags, 
+             fullImageExtents);
+        imgComm.gatherImages(regions, imgComm.GetParSize(), 
+                             imgComm.intermediateImage, 
+                             imgComm.intermediateImageExtents, 
+                             imgComm.intermediateImageExtents, 
+                             tagGather, fullImageExtents, myRegionHeight);
+
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Parallel-Composite: "
+                                 "Parallel Direct Send");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Some Cleanup
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Parallel-Composite: Some Cleanup");
+        if (regions != NULL)
+            delete [] regions;
+        regions = NULL;
+        if (imgComm.intermediateImage != NULL)
+            delete [] imgComm.intermediateImage;
+        imgComm.intermediateImage = NULL;		
+        imgComm.Barrier();
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Parallel-Composite: Some Cleanup");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Setup for Final Composition
+        compositedW = 
+            imgComm.finalImageExtents[1] -
+            imgComm.finalImageExtents[0];
+        compositedH = 
+            imgComm.finalImageExtents[3] -
+            imgComm.finalImageExtents[2];
+        compositedExtents[0] = imgComm.finalImageExtents[0];
+        compositedExtents[1] = imgComm.finalImageExtents[1];
+        compositedExtents[2] = imgComm.finalImageExtents[2];
+        compositedExtents[3] = imgComm.finalImageExtents[3];
+        if (PAR_Rank() == 0) {
+            compositedData = imgComm.GetFinalImageBuffer();
+        }
+        //--------------------------------------------------------------//
+        //--------------------------------------------------------------//
+        // Memory
+        ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute "
+                                "Parallel Compositing Done", 
+                                "ospout");
+        //--------------------------------------------------------------//
+    }	
+
+    ///////////////////////////////////////////////////////////////////
+    //
+    // Final Composition for Displaying
+    //
+    ///////////////////////////////////////////////////////////////////
+    if (PAR_Rank() == 0) {
+        avtImage_p finalImage = new avtImage(this);
+        vtkImageData *finalVTKImage = 
+            avtImageRepresentation::NewImage(screen[0], screen[1]);
+        finalImage->GetImage() = finalVTKImage;
+        unsigned char *finalImageBuffer = 
+            finalImage->GetImage().GetRGBBuffer();
+        ospray::CompositeBackground(screen,
+                                    compositedExtents,
+                                    compositedW,
+                                    compositedH,
+                                    compositedData,
+                                    opaqueImageData,
+                                    opaqueImageZB,
+                                    finalImageBuffer);
+        finalVTKImage->Delete();
+        SetOutput(finalImage);
+    }
+    if (compositedData != NULL) { 
+        delete [] compositedData;
+    }
+    compositedData = NULL; 
+    ospout << "[avtOSPRayRayTracer] Raycasting OSPRay is Done !" << std::endl;
+
+    //
+    // Clean up
+    //
+    screen_to_model_transform->Delete();
+    model_to_screen_transform->Delete();
+    screen_to_camera_transform->Delete();
+    ospray->Finalize();
+}
diff --git a/avt/Filters/avtOSPRayRayTracer.h b/avt/Filters/avtOSPRayRayTracer.h
new file mode 100644
index 0000000000..0b7649423a
--- /dev/null
+++ b/avt/Filters/avtOSPRayRayTracer.h
@@ -0,0 +1,138 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                           avtOSPRayRayTracer.h                            //
+// ************************************************************************* //
+
+#ifndef AVT_OSPRAY_RAY_TRACER_H
+#define AVT_OSPRAY_RAY_TRACER_H
+
+#include <filters_exports.h>
+
+#include <avtRayTracerBase.h>
+
+#include <avtOSPRayCommon.h>
+#include <avtOSPRayImageCompositor.h>
+
+class   vtkMatrix4x4;
+
+// ****************************************************************************
+//  Class: avtOSPRayRayTracer
+//
+//  Purpose:
+//      Performs ray tracing, taking in a dataset as a source and has an
+//      image as an output.
+//
+//  Programmer: Hank Childs
+//  Creation:   November 27, 2000
+//
+//  Modifications:
+//
+//    Hank Childs, Mon Jan  8 16:52:26 PST 2001
+//    Added "Get" functions.
+//
+//    Hank Childs, Sat Feb  3 20:37:01 PST 2001
+//    Removed pixelizer and added mechanism to change background color.
+//
+//    Hank Childs, Tue Feb 13 15:15:50 PST 2001
+//    Added ability to insert an opaque image into the rendering.
+//
+//    Brad Whitlock, Wed Dec 5 11:13:18 PDT 2001
+//    Added gradient backgrounds.
+//
+//    Hank Childs, Thu Feb  5 17:11:06 PST 2004
+//    Moved inlined destructor definition to .C file because certain compilers
+//    have problems with them.
+//
+//    Hank Childs, Sun Dec  4 18:00:55 PST 2005
+//    Add method that estimates number of stages.
+//
+//    Hank Childs, Mon Jan 16 11:11:47 PST 2006
+//    Add support for kernel based sampling.
+//
+//    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
+//    Added support for rectilinear grids with an inherent transform.
+//
+//    Hank Childs, Wed Dec 24 14:17:03 PST 2008
+//    Add method TightenClippingPlanes.
+//
+//    Pascal Grosset, Fri Sep 20 2013
+//    Added ray casting slivr & trilinear interpolation
+//
+// ****************************************************************************
+
+class AVTFILTERS_API avtOSPRayRayTracer : public avtRayTracerBase
+{
+  public:
+                          avtOSPRayRayTracer();
+    virtual              ~avtOSPRayRayTracer();
+
+    virtual const char   *GetType(void) { return "avtOSPRayRayTracer"; };
+    virtual const char   *GetDescription(void) 
+                                        { return "OSPRay Ray tracing"; };
+
+    void                  SetLighting(bool l) { lighting = l; };
+    void                  SetLightPosition(double lp[4])
+                          { for (int i=0;i<4;i++) lightPosition[i] = lp[i]; };
+    void                  SetLightDirection(double ld[3]) 
+                         { for (int i=0;i<3;i++) lightDirection[i] = ld[i]; };
+    void                  SetMatProperties(double mp[4]) 
+                      { for (int i=0;i<4;i++) materialProperties[i] = mp[i]; };
+    void                  SetViewDirection(double *vd)
+                         { for (int i=0; i<3; i++) viewDirection[i] = vd[i]; };
+    void                  SetRendererSampleRate(double r)
+                                                    { rendererSampleRate = r; };
+    void                  SetOSPRay(OSPVisItContext *ptr) { ospray = ptr; };
+
+  protected:
+    OSPVisItContext *ospray;
+
+    virtual void          Execute(void);
+
+    avtOSPRayImageCompositor imgComm;
+    bool                  lighting;
+    double                lightPosition[4];
+    double                lightDirection[3];
+    double                materialProperties[4];
+    double                viewDirection[3];
+    double                panPercentage[2];
+    double                rendererSampleRate;
+};
+
+#endif
diff --git a/avt/Filters/avtOSPRaySamplePointExtractor.C b/avt/Filters/avtOSPRaySamplePointExtractor.C
new file mode 100644
index 0000000000..74467744a2
--- /dev/null
+++ b/avt/Filters/avtOSPRaySamplePointExtractor.C
@@ -0,0 +1,603 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                     avtOSPRaySamplePointExtractor.C                        //
+// ************************************************************************* //
+
+#include <avtOSPRaySamplePointExtractor.h>
+
+#include <float.h>
+
+#include <vtkCellData.h>
+#include <vtkDataSet.h>
+#include <vtkPointData.h>
+#include <vtkPoints.h>
+#include <vtkUnsignedCharArray.h>
+#include <vtkIdList.h>
+#include <vtkRectilinearGrid.h>
+
+#include <avtCellList.h>
+#include <avtOSPRayVoxelExtractor.h>
+#include <avtParallel.h>
+#include <avtSamplePoints.h>
+#include <avtVolume.h>
+
+#include <DebugStream.h>
+#include <TimingsManager.h>
+#include <StackTimer.h>
+
+#include <Utility.h>
+#include <DebugStream.h>
+
+#include <limits>
+#include <algorithm>
+#include <stack>
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor constructor
+//
+//  Arguments:
+//      w       The width.
+//      h       The height.
+//      d       The depth.
+//
+//  Programmer: Hank Childs
+//  Creation:   December 5, 2000
+//     
+//  Modifications:
+//
+//    Hank Childs, Thu Nov 15 15:39:48 PST 2001
+//    Moved construction of cell list to Execute to account new limitations of
+//    sample points involving multiple variables.
+//
+//    Hank Childs, Tue Jan  1 10:01:20 PST 2002
+//    Initialized sendCells.
+//
+//    Hank Childs, Sun Dec 14 11:07:56 PST 2003
+//    Initialized massVoxelExtractor.
+//
+//    Hank Childs, Fri Nov 19 13:57:02 PST 2004
+//    Initialized rectilinearGridsAreInWorldSpace.
+//
+//    Hank Childs, Fri Dec 10 09:59:57 PST 2004
+//    Initialized shouldDoTiling.
+//
+//    Hank Childs, Wed Feb  2 08:56:00 PST 2005
+//    Initialize modeIs3D.
+//
+//    Hank Childs, Sun Dec  4 19:12:42 PST 2005
+//    Initialize kernelBasedSampling.
+//
+//    Hank Childs, Tue Jan 24 16:42:40 PST 2006
+//    Added point extractor.
+//
+//    Timo Bremer, Thu Sep 13 14:02:40 PDT 2007
+//    Added hex20 extractor.
+//
+//    Hank Childs, Tue Jan 15 14:26:06 PST 2008
+//    Initialize members for sample point arbitration.
+//
+//    Hank Childs, Fri Jan  9 14:10:25 PST 2009
+//    Initialize jitter.
+//
+//    Mark C. Miller, Thu Oct  2 09:41:37 PDT 2014
+//    Initialize lightDirection.
+// ****************************************************************************
+
+avtOSPRaySamplePointExtractor::avtOSPRaySamplePointExtractor(int w, int h,
+                                                             int d)
+    : avtSamplePointExtractorBase(w, h, d)
+{
+    osprayVoxelExtractor = NULL;
+    modelViewProj = vtkMatrix4x4::New();
+    lighting = false;
+    lightPosition[0] = lightPosition[1] = lightPosition[2] = 0.0;
+    lightPosition[3] = 1.0;
+    lightDirection[0] = 0;
+    lightDirection[1] = 0;
+    lightDirection[2] = -1;
+    materialProperties[0] = 0.4;
+    materialProperties[1] = 0.75;
+    materialProperties[2] = 0.0;
+    materialProperties[3] = 15.0;
+
+    depthBuffer = NULL;
+    rgbColorBuffer = NULL;
+
+    ospray = NULL;    
+
+    patchCount = 0;
+    imageMetaPatchVector.clear();
+    imgDataHashMap.clear();
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor destructor
+//
+//  Programmer: Hank Childs
+//  Creation:   December 8, 2000
+//      
+//  Modifications:
+//
+//    Hank Childs, Sun Dec 14 11:07:56 PST 2003
+//    Deleted massVoxelExtractor.
+//
+//    Hank Childs, Tue Jan 24 16:42:40 PST 2006
+//    Deleted pointExtractor.
+//
+//    Timo Bremer, Thu Sep 13 14:02:40 PDT 2007
+//    Deleted hex20Extractor.
+//
+//    Hank Childs, Tue Jan 15 21:25:01 PST 2008
+//    Delete arbitrator.
+//
+// ****************************************************************************
+
+avtOSPRaySamplePointExtractor::~avtOSPRaySamplePointExtractor()
+{
+    if (osprayVoxelExtractor != NULL)
+    {
+        delete osprayVoxelExtractor;
+        osprayVoxelExtractor = NULL;
+    }
+
+    DelImgPatches();
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::SetUpExtractors
+//
+//  Purpose:
+//      Sets up the extractors and tell them which volume to extract into.
+//
+//  Programmer: Hank Childs
+//  Creation:   November 15, 2001
+//
+//  Modifications:
+//
+//    Hank Childs, Tue Jan  1 10:01:20 PST 2002
+//    Tell the extractors whether they should extract from large cells.
+//
+//    Hank Childs, Sun Dec 14 11:07:56 PST 2003
+//    Set up massVoxelExtractor.
+//
+//    Hank Childs, Fri Dec 10 09:59:57 PST 2004
+//    Do the sampling in tiles if necessary.
+//
+//    Hank Childs, Sun Dec  4 19:12:42 PST 2005
+//    Add support for kernel based sampling.
+//
+//    Timo Bremer, Thu Sep 13 14:02:40 PDT 2007
+//    Added hex20 extractor.
+//
+//    Hank Childs, Fri Jan  9 14:11:24 PST 2009
+//    Tell extractors whether or not to jitter.  Also remove call to 
+//    massVoxelExtractor regarding "sendCellsMode", as it does not participate
+//    in that mode ... so the call was worthless.
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::SetUpExtractors(void)
+{
+    StackTimer t0("avtOSPRaySamplePointExtractor::SetUpExtractors");
+    avtSamplePoints_p output = GetTypedOutput();
+
+    //
+    // This will always be NULL the first time through.  For subsequent tiles
+    // (provided we are doing tiling) will not have this issue.
+    //
+    if (output->GetVolume() == NULL)
+        output->SetVolume(width, height, depth);
+    else
+        output->GetVolume()->ResetSamples();
+    output->ResetCellList();
+    avtVolume *volume = output->GetVolume();
+    if (shouldDoTiling)
+        volume->Restrict(width_min, width_max-1, height_min, height_max-1);
+
+    //
+    // Set up the extractors and tell them which cell list to use.
+    //
+    avtCellList *cl = output->GetCellList();
+
+    if (osprayVoxelExtractor != NULL)
+    {
+        delete osprayVoxelExtractor;
+    }
+    osprayVoxelExtractor = new avtOSPRayVoxelExtractor(width, height, depth,
+                                                       volume,cl);
+    // osprayVoxelExtractor->SetJittering(jitter);
+    if (shouldDoTiling)
+    {
+        osprayVoxelExtractor->Restrict(width_min, width_max-1,
+                                      height_min, height_max-1);
+    }
+}
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::InitSampling
+//
+//  Purpose:
+//      Initialize sampling, called by base class ExecuteTree method before.
+//      the actual iteration starts. This function might be useful for
+//      children classes
+//
+//  Arguments:
+//      dt      The dataset tree that should be processed.
+//
+//  Programmer: Qi WU 
+//  Creation:   June 18, 2018
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::InitSampling(avtDataTree_p dt)
+{
+    for (int i = 0; i < dt->GetNChildren(); ++i)
+    { ospray->InitPatch(i); }
+    
+    patchCount = 0;
+    imageMetaPatchVector.clear();
+    imgDataHashMap.clear();
+}
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::DoSampling
+//
+//  Purpose:
+//      Performs sampling, called by base class ExecuteTree method.
+//
+//  Arguments:
+//      ds      The data set that should be processed.
+//      idx     The index of the dataset.
+//
+//  Programmer: Kathleen Biagas 
+//  Creation:   April 18, 2018
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::DoSampling(vtkDataSet *ds, int idx)
+{
+    // initialize ospray
+    StackTimer t0("avtOSPRaySamplePointExtractor::DoSampling "
+                  "OSPVisItContext::InitPatch");    
+    // volume scalar range
+    double scalarRange[2]; 
+    {
+        StackTimer t1("avtOSPRaySamplePointExtractor::DoSampling "
+                      "Retrieve Volume Scalar Range");
+        ds->GetScalarRange(scalarRange);
+    }
+
+    // transfer function visible range
+    double tfnVisibleRange[2];
+    {
+        StackTimer t2("avtOSPRaySamplePointExtractor::DoSampling "
+                      "Retrieve TFN Visible Range");
+        tfnVisibleRange[0] = transferFn1D->GetMinVisibleScalar();
+        tfnVisibleRange[1] = transferFn1D->GetMaxVisibleScalar();
+    }
+
+    osprayVoxelExtractor->SetScalarRange(scalarRange);
+    osprayVoxelExtractor->SetTFVisibleRange(tfnVisibleRange);
+    RasterBasedSample(ds, idx);
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::RasterBasedSample
+//
+//  Purpose:
+//      Does raster based sampling.
+//
+//  Programmer: Hank Childs
+//  Creation:   January 1, 2006
+//
+//  Modifications:
+//    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
+//    Added support for rectilinear grids with an inherent transform.
+//
+//    Hank Childs, Fri Jun  1 12:50:45 PDT 2007
+//    Added support for non-scalars.
+//
+//    Timo Bremer, Thu Sep 13 14:02:40 PDT 2007
+//    Added support for hex-20s.
+//
+//    Hank Childs, Mon Oct 29 20:29:55 PST 2007
+//    Ignore surface primitives in 3D.
+//
+//    Kevin Griffin, Fri Apr 22 16:31:57 PDT 2016
+//    Added support for polygons.
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
+{
+    StackTimer t0("avtOSPRaySamplePointExtractor::RasterBasedSample");
+
+    if (ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
+    {
+        avtDataAttributes &atts = GetInput()->GetInfo().GetAttributes();
+        const double *xform = NULL;
+        if (atts.GetRectilinearGridHasTransform())
+            xform = atts.GetRectilinearGridTransform();
+        avtSamplePoints_p samples = GetTypedOutput();
+        int numVars = samples->GetNumberOfRealVariables();
+        std::vector<std::string> varnames;
+        std::vector<int>         varsizes;
+        for (int i = 0 ; i < numVars ; i++)
+        {
+            varnames.push_back(samples->GetVariableName(i));
+            varsizes.push_back(samples->GetVariableSize(i));
+        }
+
+        //-----------------------------
+        // Compositing Setup
+        //-----------------------------	
+        osprayVoxelExtractor->SetGridsAreInWorldSpace
+            (rectilinearGridsAreInWorldSpace, viewInfo, aspect, xform);
+
+        osprayVoxelExtractor->SetDepthBuffer(depthBuffer,
+                                          bufferExtents[1] * bufferExtents[3]);
+        osprayVoxelExtractor->SetRGBBuffer(rgbColorBuffer,
+                                           bufferExtents[1], bufferExtents[3]);
+        osprayVoxelExtractor->SetBufferExtents(bufferExtents);
+
+        osprayVoxelExtractor->SetViewDirection(viewDirection);
+        osprayVoxelExtractor->SetMVPMatrix(modelViewProj);
+        osprayVoxelExtractor->SetClipPlanes(clipPlanes);
+        osprayVoxelExtractor->SetPanPercentages(panPercentage);
+        osprayVoxelExtractor->SetDepthExtents(depthExtents);
+
+        osprayVoxelExtractor->SetProcIdPatchID(PAR_Rank(), num);
+
+        osprayVoxelExtractor->SetLighting(lighting);
+        osprayVoxelExtractor->SetLightDirection(lightDirection);
+        osprayVoxelExtractor->SetMatProperties(materialProperties);
+        osprayVoxelExtractor->SetTransferFn(transferFn1D);
+
+        osprayVoxelExtractor->SetImageZoom(imageZoom);
+        osprayVoxelExtractor->SetRendererSampleRate(rendererSampleRate);       
+        osprayVoxelExtractor->SetFullImageExtents(fullImageExtents);
+
+        osprayVoxelExtractor->SetOSPRay(ospray);
+
+        //-----------------------------
+        // Extract
+        //-----------------------------
+        osprayVoxelExtractor->Extract((vtkRectilinearGrid *) ds, varnames,
+                                      varsizes);
+
+        //-----------------------------
+        // Get rendering results
+        // put them into a proper vector, sort them based on z value
+        //-----------------------------
+        ospray::ImgMetaData tmpImageMetaPatch;
+        tmpImageMetaPatch = InitMetaPatch(patchCount);
+
+        osprayVoxelExtractor->GetImageDimensions
+            (tmpImageMetaPatch.inUse,     tmpImageMetaPatch.dims, 
+             tmpImageMetaPatch.screen_ll, tmpImageMetaPatch.screen_ur, 
+             tmpImageMetaPatch.eye_z,     tmpImageMetaPatch.clip_z);
+        if (tmpImageMetaPatch.inUse == 1)
+        {
+            tmpImageMetaPatch.avg_z = tmpImageMetaPatch.eye_z;
+            tmpImageMetaPatch.destProcId = tmpImageMetaPatch.procId;
+            imageMetaPatchVector.push_back(tmpImageMetaPatch);
+
+            ospray::ImgData tmpImageDataHash;
+            tmpImageDataHash.procId = tmpImageMetaPatch.procId;
+            tmpImageDataHash.patchNumber = tmpImageMetaPatch.patchNumber;
+            tmpImageDataHash.imagePatch = 
+                new float[tmpImageMetaPatch.dims[0] * 
+                          tmpImageMetaPatch.dims[1] * 4];
+
+            osprayVoxelExtractor->GetComputedImage
+                                                (tmpImageDataHash.imagePatch);
+            imgDataHashMap.insert
+                (std::pair<int, ospray::ImgData> (tmpImageDataHash.patchNumber,
+                                                  tmpImageDataHash));
+
+            patchCount++;
+        }
+    } else {
+        //---------------------------------------------------------
+        // Other Grid
+        //---------------------------------------------------------
+        const std::string msg = 
+            "Warning: Dataset type " +
+            std::to_string((int)(ds->GetDataObjectType())) + " " 
+            "is not a VTK_RECTILINEAR_GRID,\n"
+            "         Currently the RayCasting:OSPRay renderer\n"
+            "         only supports rectilinear grid,\n" 
+            "         Thus request cannot be completed.";
+        ospray::Exception(msg);
+    }
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::SendJittering
+//
+//  Purpose:
+//      Tell the individual cell extractors whether or not to jitter.
+//
+//  Arguments:
+//      j     true if the cell extractors should jitter
+//
+//  Programmer: Hank Childs
+//  Creation:   January 9, 2009
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::SendJittering()
+{
+    if (osprayVoxelExtractor != NULL)
+    {
+        osprayVoxelExtractor->SetJittering(jitter);
+    }
+}
+
+
+// ****************************************************************************
+//  Method:  avtOSPRaySamplePointExtractor::FilterUnderstandsTransformedRectMesh
+//
+//  Purpose:
+//    If this filter returns true, this means that it correctly deals
+//    with rectilinear grids having an implied transform set in the
+//    data attributes.  It can do this conditionally if desired.
+//
+//  Arguments:
+//    none
+//
+//  Programmer:  Jeremy Meredith
+//  Creation:    February 15, 2007
+//
+// ****************************************************************************
+
+bool
+avtOSPRaySamplePointExtractor::FilterUnderstandsTransformedRectMesh()
+{
+    return true;
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::DelImgPatches
+//
+//  Purpose:
+//      allocates space to the pointer address and copy the image generated
+//      to it
+//
+//  Programmer: TODO
+//  Creation:   
+//
+//  Modifications:
+//
+//      Qi WU: TODO
+//      Rename based on VisIt naming convension
+//
+// ****************************************************************************
+void
+avtOSPRaySamplePointExtractor::DelImgPatches() {
+    imageMetaPatchVector.clear();
+    for (iter_t it=imgDataHashMap.begin(); it!=imgDataHashMap.end(); it++)
+    {
+        if ((*it).second.imagePatch != NULL) { 
+	    delete [](*it).second.imagePatch;
+	}
+        (*it).second.imagePatch = NULL;
+    }
+    imgDataHashMap.clear();
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::GetImgData
+//
+//  Purpose:
+//      Copies a patchover
+//
+//  Programmer: TODO
+//  Creation:   
+//
+//  Modifications:
+//
+//      Qi WU: TODO
+//      Rename based on VisIt naming convension
+//      Does shallow copy instead deep copy for efficiency
+//
+// ****************************************************************************
+void 
+avtOSPRaySamplePointExtractor::GetAndDelImgData(int patchId, 
+                                          ospray::ImgData &tempImgData) 
+{
+    size_t imagePatchSize = 
+	imageMetaPatchVector[patchId].dims[0] * 
+	imageMetaPatchVector[patchId].dims[1] * sizeof(float) * 4;
+    iter_t it = imgDataHashMap.find(patchId);
+    tempImgData.procId = it->second.procId;
+    tempImgData.patchNumber = it->second.patchNumber;
+    // do shallow copy instead of deep copy
+    tempImgData.imagePatch = it->second.imagePatch;
+    // memcpy(tempImgData.imagePatch,
+    // 	      it->second.imagePatch,
+    //        imagePatchSize);
+    // delete [](*it).second.imagePatch;
+    it->second.imagePatch = NULL;
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::InitMetaPatch
+//
+//  Purpose:
+//
+//  Programmer: 
+//  Creation:   
+//
+//  Modifications:
+//
+// ****************************************************************************
+ospray::ImgMetaData
+avtOSPRaySamplePointExtractor::InitMetaPatch(int id)
+{
+    ospray::ImgMetaData temp;
+    temp.inUse = 0;
+    temp.procId = PAR_Rank();
+    temp.destProcId = PAR_Rank();
+    temp.patchNumber = id;
+    temp.dims[0] = temp.dims[1] = -1;
+    temp.screen_ll[0] = temp.screen_ll[1] = -1;
+    temp.screen_ur[0] = temp.screen_ur[1] = -1;
+    temp.avg_z = -1.0;
+    temp.eye_z = -1.0;
+    temp.clip_z = -1.0;
+    return temp;
+}
diff --git a/avt/Filters/avtOSPRaySamplePointExtractor.h b/avt/Filters/avtOSPRaySamplePointExtractor.h
new file mode 100644
index 0000000000..289dd3b0a0
--- /dev/null
+++ b/avt/Filters/avtOSPRaySamplePointExtractor.h
@@ -0,0 +1,237 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                      avtOSPRaySamplePointExtractor.h                      //
+// ************************************************************************* //
+
+#ifndef AVT_OSPRAY_SAMPLE_POINT_EXTRACTOR_H
+#define AVT_OSPRAY_SAMPLE_POINT_EXTRACTOR_H
+
+#include <filters_exports.h>
+
+#include <avtSamplePointExtractorBase.h>
+#include <avtOSPRayCommon.h> // this ensures VISIT_OSPRAY is defined
+class     avtOSPRayVoxelExtractor;
+
+#include <vtkMatrix4x4.h>
+
+#include <vector>
+#include <map>
+
+// ****************************************************************************
+//  Class: avtOSPRaySamplePointExtractor
+//
+//  Purpose:
+//      This is a component that will take an avtDataset as an input and find
+//      all of the sample points from that dataset.
+//
+//  Programmer: Hank Childs
+//  Creation:   December 5, 2000
+//
+//  Modifications:
+//
+//    Hank Childs, Sat Jan 27 15:09:34 PST 2001
+//    Added support for sending cells when doing parallel volume rendering.
+//
+//    Kathleen Bonnell, Sat Apr 21, 13:09:27 PDT 2001 
+//    Added recursive Execute method to walk down input data tree. 
+//
+//    Hank Childs, Tue Nov 13 15:51:15 PST 2001
+//    Remove boolean argument to Extract<Cell> calls since it is no longer
+//    necessary when all of the variables are being extracted.
+//
+//    Hank Childs, Sun Dec 14 11:07:56 PST 2003
+//    Added mass voxel extractor.
+//
+//    Hank Childs, Fri Nov 19 13:41:56 PST 2004
+//    Added view conversion option.
+//
+//    Hank Childs, Sat Jan 29 13:32:54 PST 2005
+//    Added 2D extractors.
+//
+//    Hank Childs, Sun Dec  4 19:12:42 PST 2005
+//    Added support for kernel-based sampling.
+//
+//    Hank Childs, Sun Jan  1 10:56:19 PST 2006
+//    Added RasterBasedSample and KernelBasedSample.
+//
+//    Hank Childs, Tue Feb 28 08:25:33 PST 2006
+//    Added PreExecute.
+//
+//    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
+//    Added support for rectilinear grids with an inherent transform.
+//
+//    Hank Childs, Fri Jun  1 11:47:56 PDT 2007
+//    Add method GetLoadingInfoForArrays.
+//
+//    Hank Childs, Thu Sep 13 14:02:40 PDT 2007
+//    Added support for hex-20s.
+//
+//    Hank Childs, Tue Jan 15 14:17:15 PST 2008
+//    Have this class set up custom sample point arbitrators, since it has
+//    the most knowledge.
+//
+//    Hank Childs, Fri Jan  9 14:09:57 PST 2009
+//    Add support for jittering.
+//
+//    Kevin Griffin, Fri Apr 22 16:31:57 PDT 2016
+//    Added support for polygons.
+//
+// ****************************************************************************
+
+class AVTFILTERS_API avtOSPRaySamplePointExtractor 
+    : public avtSamplePointExtractorBase
+{
+  public:
+                              avtOSPRaySamplePointExtractor(int, int, int);
+    virtual                  ~avtOSPRaySamplePointExtractor();
+
+    virtual const char       *GetType(void)
+                                   { return "avtOSPRaySamplePointExtractor"; };
+    virtual const char       *GetDescription(void)
+                                         { return "Extracting sample points";};
+
+
+    void                      SetLighting(bool l) {lighting = l; };
+    void                      SetLightPosition(double lp[4])
+                     { for (int i = 0; i < 4; ++i) lightPosition[i] = lp[i]; };
+    void                      SetLightDirection(double ld[3]) 
+                    { for (int i = 0; i < 3; ++i) lightDirection[i] = ld[i]; };
+    void                      SetMatProperties(double _matProp[4]) 
+                  { for (int i=0;i<4;i++) materialProperties[i]=_matProp[i]; };
+    void                      SetTransferFn(avtOpacityMap *tfn1D) 
+                                                     { transferFn1D = tfn1D; };
+    void                      SetViewDirection(double *vD)
+                         { for (int i=0; i<3; i++) viewDirection[i] = vD[i]; };
+    void                      SetClipPlanes(double cp[2])
+                             { clipPlanes[0] = cp[0]; clipPlanes[1] = cp[1]; };
+    void                      SetPanPercentages(double p[2])
+                         { panPercentage[0] = p[0]; panPercentage[1] = p[1]; };
+    void                      SetDepthExtents(double de[2])
+                         { depthExtents[0] = de[0]; depthExtents[1] = de[1]; };
+    void                      SetMVPMatrix(vtkMatrix4x4 *mvp)
+                                             { modelViewProj->DeepCopy(mvp); };
+
+    void                      GetSpatialExtents(double se[6])
+                   { for (int i=0; i<6; i++) se[i] = minMaxSpatialBounds[i]; };
+    void                      GetAvgPatchExtents(double ae[6])
+                       { for (int i=0; i<3; i++) ae[i] = avgPatchExtents[i]; };
+    void                      GetCellDimension(double cd[6])
+                         { for (int i=0; i<3; i++) cd[i] = cellDimension[i]; };
+
+    int                       GetImgPatchSize() { return patchCount; };
+    ospray::ImgMetaData       GetImgMetaPatch(int patchId)
+                                  { return imageMetaPatchVector.at(patchId); };
+    void                      GetAndDelImgData(int patchId,
+                                               ospray::ImgData &tempImgData);
+    void                      DelImgPatches();
+
+
+    void                      SetImageZoom(double z) { imageZoom = z; }
+    void                      SetDepthBuffer(float *zBuffer, int size)
+                                                     { depthBuffer= zBuffer; };
+    void                      SetRGBBuffer(unsigned char *cb, int w, int h)
+                                                      { rgbColorBuffer = cb; };
+    void                      SetBufferExtents(int e[4])
+                          { for (int i=0; i<4; i++) bufferExtents[i] = e[i]; };
+
+    // Added by Qi (March 2018) for RayCasting:OSPRay  
+    void SetOSPRay(OSPVisItContext* o) { ospray = o; }
+    void SetRendererSampleRate(double r) { rendererSampleRate = r; }
+    void SetFullImageExtents(int extents[4]) 
+    {
+        fullImageExtents[0] = extents[0];
+        fullImageExtents[1] = extents[1];
+        fullImageExtents[2] = extents[2];
+        fullImageExtents[3] = extents[3];
+    }
+
+    // Output data for RayCasting OSPRay
+    std::vector<ospray::ImgMetaData>    imageMetaPatchVector;
+    std::multimap<int, ospray::ImgData> imgDataHashMap;
+    typedef std::multimap<int, ospray::ImgData>::iterator iter_t;
+
+  protected:
+    
+    virtual void              InitSampling(avtDataTree_p dt);
+    virtual void              DoSampling(vtkDataSet *, int);
+    virtual void              SetUpExtractors(void);
+    virtual void              SendJittering(void);
+    virtual bool              FilterUnderstandsTransformedRectMesh(void);
+    void                      RasterBasedSample(vtkDataSet *, int num = 0);
+    ospray::ImgMetaData       InitMetaPatch(int id); // initialize a patch
+    
+    avtOSPRayVoxelExtractor  *osprayVoxelExtractor;
+    
+    double                    minMaxSpatialBounds[6];
+    double                    avgPatchExtents[3];
+    double                    cellDimension[3];
+    int                       patchCount;
+    
+    // Background + other plots
+    //   depthBuffer    : depth buffer for the background and other plots
+    //   rgbColorBuffer : bounding box + pseudo color + ...
+    //   bufferExtents  : extents of the buffer (minX, maxX, minY, maxY)
+    float                    *depthBuffer; 
+    unsigned char            *rgbColorBuffer; 
+    int                       bufferExtents[4];
+
+    // Camera stuff
+    double                    viewDirection[3];
+    double                    depthExtents[2];
+    double                    clipPlanes[2];
+    double                    panPercentage[2];
+    double                    imageZoom;
+    vtkMatrix4x4             *modelViewProj;
+
+    // lighting & material
+    bool                      lighting;
+    double                    lightPosition[4];
+    double                    lightDirection[3];
+    double                    materialProperties[4];
+
+    // OSPRay
+    int                       fullImageExtents[4];
+    OSPVisItContext          *ospray;
+    double                    rendererSampleRate;
+
+};
+
+
+#endif
diff --git a/avt/Filters/avtOSPRayVoxelExtractor.C b/avt/Filters/avtOSPRayVoxelExtractor.C
new file mode 100644
index 0000000000..07bb6f1d12
--- /dev/null
+++ b/avt/Filters/avtOSPRayVoxelExtractor.C
@@ -0,0 +1,605 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                            avtOSPRayVoxelExtractor.C                      //
+// ************************************************************************* //
+
+#include <avtOSPRayVoxelExtractor.h>
+
+#include <float.h>
+
+#include <avtAccessor.h>
+#include <avtCellList.h>
+#include <avtVolume.h>
+
+#include <vtkDataArray.h>
+#include <vtkCamera.h>
+#include <vtkCellData.h>
+#include <vtkMatrix4x4.h>
+#include <vtkPointData.h>
+#include <vtkRectilinearGrid.h>
+#include <vtkTemplateAliasMacro.h>
+#include <vtkUnsignedCharArray.h>
+
+#include <DebugStream.h>
+#include <StackTimer.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+
+#include <iostream>
+#include <fstream>
+#include <string>
+#include <sstream>
+#include <algorithm>
+#include <limits>
+#include <math.h>
+
+#if defined (_MSC_VER) && (_MSC_VER < 1800) && !defined(round)
+inline double round(double x) {return (x-floor(x)) > 0.5 ? ceil(x) : floor(x);}
+#endif
+
+// ****************************************************************************
+//  Method: avtOSPRayVoxelExtractor constructor
+//
+//  Arguments:
+//     w     The number of sample points in the x direction (width).
+//     h     The number of sample points in the y direction (height).
+//     d     The number of sample points in the z direction (depth).
+//     vol   The volume to put samples into.
+//     cl    The cell list to put cells whose sampling was deferred.
+//
+//  Programmer: Hank Childs
+//  Creation:   December 14, 2003
+//
+//  Modifications:
+//
+//    Hank Childs, Fri Nov 19 14:50:58 PST 2004
+//    Initialize gridsAreInWorldSpace.
+//
+//    Jeremy Meredith, Thu Feb 15 13:11:34 EST 2007
+//    Added an ability to extract voxels using the world-space version
+//    even when they're really in image space.
+//
+//    Hank Childs, Wed Aug 27 11:11:28 PDT 2008
+//    Initialize spatial coordinates array.
+//
+//    Hank Childs, Wed Dec 24 11:22:43 PST 2008
+//    Remove reference to ProportionSpaceToZBufferSpace data member.
+//
+//    Kathleen Biagas, Fri Jul 13 09:23:55 PDT 2012
+//    Use double instead of float.
+//
+// ****************************************************************************
+
+avtOSPRayVoxelExtractor::avtOSPRayVoxelExtractor(int w, int h, int d,
+                                             avtVolume *vol, avtCellList *cl)
+    : avtVoxelExtractor(w, h, d, vol, cl)
+{
+    fullImgWidth = w;
+    fullImgHeight = h;
+
+    debug5 << "fullImgWidth: "  << fullImgWidth << " "
+           << "fullImgHeight: " << fullImgHeight << std::endl;
+
+    rayCastingOSPRay = true;
+
+    model_to_screen_transform = vtkMatrix4x4::New();
+    screen_to_model_transform = vtkMatrix4x4::New();
+
+    lighting = false;
+    lightPosition[0] = lightPosition[1] = lightPosition[2] = 0.0;   
+    lightPosition[3] = 1.0;
+    materialProperties[0] = 0.4; materialProperties[1] = 0.75;
+    materialProperties[3] = 0.0; materialProperties[3] = 15.0;
+    gradient[0] = gradient[1] = gradient[2] = 0;
+
+    proc = patch = 0;
+    patchDrawn = 0;
+    imgDims[0] = imgDims[1] = 0;             // size of the patch
+    imgLowerLeft[0] = imgLowerLeft[1] = 0;   // coordinates in the whole image
+    imgUpperRight[0] = imgUpperRight[1] = 0; // coordinates in the whole image
+    eyeSpaceDepth = -1;
+    clipSpaceDepth = -1;
+    imgArray = NULL;                         // the image data
+
+    depthBuffer = NULL;
+    rgbColorBuffer = NULL;
+
+    ospray = NULL;
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRayVoxelExtractor destructor
+//
+//  Purpose:
+//      Defines the destructor.  Note: this should not be inlined in the header
+//      because it causes problems for certain compilers.
+//
+//  Programmer: Hank Childs
+//  Creation:   February 5, 2004
+//
+//  Modifications:
+//
+//    Hank Childs, Sun Nov 21 10:35:40 PST 2004
+//    Delete the view to world transform.
+//
+//    Hank Childs, Wed Aug 27 11:10:51 PDT 2008
+//    Delete the spatial coordinate arrays.
+//
+//    Hank Childs, Wed Dec 24 11:22:43 PST 2008
+//    Remove reference to ProportionSpaceToZBufferSpace data member.
+//
+// ****************************************************************************
+
+avtOSPRayVoxelExtractor::~avtOSPRayVoxelExtractor()
+{
+    model_to_screen_transform->Delete();
+    screen_to_model_transform->Delete();
+
+    if (imgArray != NULL)
+        delete []imgArray;
+
+    imgArray = NULL;
+}
+
+// ****************************************************************************
+//  Method: avtOSPRayVoxelExtractor::Extract
+//
+//  Purpose:
+//      Extracts the grid into the sample points.
+//
+//  Programmer: Hank Childs
+//  Creation:   November 19, 2004
+//
+//  Modifications:
+//    Jeremy Meredith, Thu Feb 15 13:11:34 EST 2007
+//    Added an ability to extract voxels using the world-space version
+//    even when they're really in image space.
+//
+//    Hank Childs, Fri Jun  1 16:40:10 PDT 2007
+//    Added support for non-scalars.
+//
+// ****************************************************************************
+
+void
+avtOSPRayVoxelExtractor::Extract(vtkRectilinearGrid *rgrid,
+                std::vector<std::string> &varnames, std::vector<int> &varsizes)
+{
+    if (gridsAreInWorldSpace || pretendGridsAreInWorldSpace)
+        ExtractWorldSpaceGridOSPRay(rgrid, varnames, varsizes);
+    else
+        ExtractImageSpaceGrid(rgrid, varnames, varsizes);
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay
+//
+//  Purpose:
+//      Compute region that patch covers
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 14, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay(vtkRectilinearGrid *rgrid,
+                 std::vector<std::string> &varnames, std::vector<int> &varsize)
+{
+    StackTimer t0("Calling avtOSPRayVoxelExtractor::"
+                  "ExtractWorldSpaceGridOSPRay");
+    //=======================================================================//
+    // Initialization
+    //=======================================================================//
+    // Flag to indicate if the patch is drawn
+    patchDrawn = 0;
+    
+    //=======================================================================//
+    // Register data and early skipping
+    //=======================================================================//
+    int w_min;
+    int w_max;
+    int h_min;
+    int h_max;
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Register Data (VisIt preparation)");
+        // Some of our sampling routines need a chance to pre-process the data.
+        // Register the grid here so we can do that.
+        // Stores the values in a structure so that it can be used
+        RegisterGrid(rgrid, varnames, varsize);
+        // Determine what range we are dealing with on this iteration.
+        w_min = restrictedMinWidth;
+        w_max = restrictedMaxWidth + 1;
+        h_min = restrictedMinHeight;
+        h_max = restrictedMaxHeight + 1;
+        imgWidth = imgHeight = 0;
+        // Let's find out if this range can even intersect the dataset.
+        // If not, just skip it.
+        if (!FrustumIntersectsGrid(w_min, w_max, h_min, h_max)) { return; }
+    }
+
+    //=======================================================================//
+    // obtain data pointers & ghost region information
+    //=======================================================================//
+    void* volumePointer = NULL;
+    int   volumeDataType;
+    int nX = 0, nY = 0, nZ = 0;
+    bool ghost_bound[6] = {false};
+    double volumeCube[6];
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Compute metadata & ghost boundary "
+                      "(Pre-OSPRay preparation)");
+        // Calculate patch dimensions for point array and cell array
+        //   This is to check if the patch is a cell data or a point data
+        //   I have to assume cell dataset has a higher priority
+        if (ncell_arrays > 0) {
+            ospout << "[avtOSPRayVoxelExtractor] Cell Dataset " << std::endl;
+            if (ncell_arrays != 1 || cell_size[0] != 1) {
+                ospray::Exception("Trying to plot more than one field, "
+                                  "which is not supported by OSPRay. "
+                                  "Use other render type instead.");
+            }
+            nX = dims[0] - 1;
+            nY = dims[1] - 1;
+            nZ = dims[2] - 1;
+            volumePointer = cell_arrays[0];
+            volumeDataType = cell_vartypes[0];
+        }
+        else if (npt_arrays > 0) {
+            ospout << "[avtOSPRayVoxelExtractor] Point Dataset " << std::endl;
+            if (npt_arrays != 1 || pt_size[0] != 1) {
+                ospray::Exception("Trying to plot more than one field, "
+                                  "which is not supported by OSPRay. "
+                                  "Use other render type instead.");
+            }
+            nX = dims[0];
+            nY = dims[1];
+            nZ = dims[2];
+            volumePointer = pt_arrays[0];
+            volumeDataType = pt_vartypes[0];	
+        } else {
+            osperr << "WARNING: Empty dataset." << std::endl;
+        }
+        ospout << "[avtOSPRayVoxelExtractor] patch dimension "
+               << nX << " " << nY << " " << nZ << std::endl;
+        // Calculate ghost region boundaries
+        //   ghost_boundaries is an array to indicate if the patch contains
+        //   any ghost regions in six different directions
+        // Here I assume the patch is larger than 3-cube
+        // If not then you might want to dig into this code and see if
+        // there will be any special boundary cases
+        //
+        // debug5 << "VAR: ghost value " << (int)ghosts[0] << std::endl;
+        //
+        if (ghosts != NULL) {
+            int gnX = 0, gnY = 0, gnZ = 0;
+            gnX = dims[0] - 1;
+            gnY = dims[1] - 1;
+            gnZ = dims[2] - 1;	
+            for (int y = 1; y < (gnY-1); ++y) {
+                for (int z = 1; z < (gnZ-1); ++z) {
+                    if (!ghost_bound[0]) {
+                        if (ghosts[z*gnY*gnX+y*gnX        ] != 0)
+                            { ghost_bound[0] = true; }
+                    }
+                    if (!ghost_bound[3]) {
+                        if (ghosts[z*gnY*gnX+y*gnX+(gnX-1)] != 0)
+                            { ghost_bound[3] = true; }
+                    }
+                    if (ghost_bound[0] && ghost_bound[3]) { break; }
+                }
+            }
+            for (int x = 1; x < (gnX-1); ++x) {
+                for (int z = 1; z < (gnZ-1); ++z) {
+                    if (!ghost_bound[1]) {
+                        if (ghosts[z*gnY*gnX            +x] != 0)
+                            { ghost_bound[1] = true; }
+                    }
+                    if (!ghost_bound[4]) {
+                        if (ghosts[z*gnY*gnX+(gnY-1)*gnX+x] != 0)
+                            { ghost_bound[4] = true; }
+                    }
+                    if (ghost_bound[1] && ghost_bound[4]) { break; }
+                }
+            }
+            for (int x = 1; x < (gnX-1); ++x) {
+                for (int y = 1; y < (gnY-1); ++y) {
+                    if (!ghost_bound[2]) {
+                        if (ghosts[                y*gnX+x] != 0) 
+                            { ghost_bound[2] = true; }
+                    }
+                    if (!ghost_bound[5]) {
+                        if (ghosts[(gnZ-1)*gnY*gnX+y*gnX+x] != 0)
+                            { ghost_bound[5] = true; }
+                    }
+                    if (ghost_bound[2] && ghost_bound[5]) { break; }
+                }
+            }
+        }
+        // Data bounding box
+        volumeCube[0] = X[0];
+        volumeCube[1] = X[nX-1];
+        volumeCube[2] = Y[0];
+        volumeCube[3] = Y[nY-1];
+        volumeCube[4] = Z[0];
+        volumeCube[5] = Z[nZ-1];
+    }
+
+    //=======================================================================//
+    // Determine the screen size of the patch being processed
+    //=======================================================================//
+    int patchScreenExtents[4];
+    double patch_center[3];
+    double patch_depth;
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Get screen size of the patch (Pre-OSPRay preparation)");
+        ospray::ProjectWorldToScreenCube(volumeCube, w_max, h_max, 
+                                         panPercentage, imageZoom,
+                                         model_to_screen_transform, 
+                                         patchScreenExtents, 
+                                         renderingDepthsExtents);
+        xMin = patchScreenExtents[0];
+        xMax = patchScreenExtents[1];
+        yMin = patchScreenExtents[2];
+        yMax = patchScreenExtents[3];
+        ospout << "[avtOSPRayVoxelExtractor] patch ghost bounds:"
+               << "   " << ghost_bound[0] << " " << ghost_bound[3] 
+               << " | " << ghost_bound[1] << " " << ghost_bound[4] 
+               << " | " << ghost_bound[2] << " " << ghost_bound[5]
+               << std::endl;   
+    
+        // calculate patch depth
+        patch_center[0] = (volumeCube[0] + volumeCube[1])/2.0;
+        patch_center[1] = (volumeCube[2] + volumeCube[3])/2.0;
+        patch_center[2] = (volumeCube[4] + volumeCube[5])/2.0;        
+        patch_depth = // use the norm of patch center as patch depth
+            std::sqrt((patch_center[0]-view.camera[0])*
+                      (patch_center[0]-view.camera[0])+
+                      (patch_center[1]-view.camera[1])*
+                      (patch_center[1]-view.camera[1])+
+                      (patch_center[2]-view.camera[2])*
+                      (patch_center[2]-view.camera[2]));
+        eyeSpaceDepth = patch_depth;
+        clipSpaceDepth = renderingDepthsExtents[0];
+    }
+
+    //=======================================================================//
+    // create framebuffer
+    //=======================================================================//
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Create ImgArray (Pre-OSPRay preparation)");
+        // assign data to the class
+        //xMax+=1; yMax+=1;
+        ospout << "[avtOSPRayVoxelExtractor] patch extents " 
+               << xMin << " " << xMax << " "
+               << yMin << " " << yMax << std::endl;
+        if (xMin < fullImageExtents[0]) { xMin = fullImageExtents[0]; }
+        if (yMin < fullImageExtents[2]) { yMin = fullImageExtents[2]; }    
+        if (xMax > fullImageExtents[1]) { xMax = fullImageExtents[1]; }
+        if (yMax > fullImageExtents[3]) { yMax = fullImageExtents[3]; }
+        imgWidth  = xMax-xMin;
+        imgHeight = yMax-yMin;
+
+        // Initialize memory (framebuffer) no initialization
+        imgArray = new float[((imgWidth)*4) * imgHeight];
+    }
+
+    //=======================================================================//
+    // Render using OSPRay
+    //=======================================================================//
+    double volumePBox[6];
+    double volumeBBox[6];
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Using OSPRay");
+        {
+            StackTimer t2("avtOSPRayVoxelExtractor::"
+                          "ExtractWorldSpaceGridOSPRay "
+                          "OSPRay bbox and clip (OSPRay preparation)");
+            if (!((npt_arrays == 1)^(ncell_arrays == 1))) {
+                std::cerr << "WARNING: Multiple data found within one "
+                          << "patch, We don't know what to do !! " 
+                          << std::endl
+                          << "         One of the dataset might be missing "
+                          << std::endl;
+            }
+            // shift grid and make it cel centered for cell data
+            // for cell centered data, we put the voxel on its left boundary
+            volumePBox[0] = X[0];
+            volumePBox[1] = Y[0];
+            volumePBox[2] = Z[0];
+            volumePBox[3] = X[nX-1];
+            volumePBox[4] = Y[nY-1];
+            volumePBox[5] = Z[nZ-1];
+            // compute boundingbox and clipping plane for ospray
+            if (ncell_arrays > 0) {
+                volumeBBox[0] = ghost_bound[0]?(X[0]+X[1])/2.:volumePBox[0];
+                volumeBBox[1] = ghost_bound[1]?(Y[0]+Y[1])/2.:volumePBox[1];
+                volumeBBox[2] = ghost_bound[2]?(Z[0]+Z[1])/2.:volumePBox[2];
+                volumeBBox[3] = 
+                    ghost_bound[3] ? (X[nX-1]+X[nX-2])/2. : volumePBox[3];
+                volumeBBox[4] = 
+                    ghost_bound[4] ? (Y[nY-1]+Y[nY-2])/2. : volumePBox[4];
+                volumeBBox[5] = 
+                    ghost_bound[5] ? (Z[nZ-1]+Z[nZ-2])/2. : volumePBox[5];
+            }
+            else {
+                volumeBBox[0] = ghost_bound[0] ? X[1] : volumePBox[0];
+                volumeBBox[1] = ghost_bound[1] ? Y[1] : volumePBox[1];
+                volumeBBox[2] = ghost_bound[2] ? Z[1] : volumePBox[2];
+                volumeBBox[3] = ghost_bound[3] ? X[nX-2] : volumePBox[3];
+                volumeBBox[4] = ghost_bound[4] ? Y[nY-2] : volumePBox[4];
+                volumeBBox[5] = ghost_bound[5] ? Z[nZ-2] : volumePBox[5];
+            }
+            ospout << "[avtOSPRayVoxelExtractor] patch data position:" 
+                   << " " << volumePBox[0]
+                   << " " << volumePBox[1]
+                   << " " << volumePBox[2]
+                   << " |"
+                   << " " << volumePBox[3]
+                   << " " << volumePBox[4]
+                   << " " << volumePBox[5]
+                   << std::endl;  
+            ospout << "[avtOSPRayVoxelExtractor] patch data bbox:" 
+                   << " " << volumeBBox[0]
+                   << " " << volumeBBox[1]
+                   << " " << volumeBBox[2]
+                   << " |"
+                   << " " << volumeBBox[3]
+                   << " " << volumeBBox[4]
+                   << " " << volumeBBox[5]
+                   << std::endl; 
+	}
+
+	// Create volume and model
+        {
+            StackTimer t2("avtOSPRayVoxelExtractor::"
+                          "ExtractWorldSpaceGridOSPRay "
+                          "OSPRay Create Volume");
+            ospray->GetPatch(patch)->Set(volumeDataType, volumePointer,
+                                         X, Y, Z, nX, nY, nZ,
+                                         volumePBox, volumeBBox, 
+                                         materialProperties, 
+                                         (float)rendererSampleRate,
+                                         lighting);
+        }
+
+	// Render Volume
+        {
+            StackTimer t2("avtOSPRayVoxelExtractor::"
+                          "ExtractWorldSpaceGridOSPRay "
+                          "OSPRay Render Volume");	
+            if ((scalarRange[1] >= tFVisibleRange[0]) &&
+                (scalarRange[0] <= tFVisibleRange[1])) {
+                ospray->Render(xMin, xMax, yMin, yMax,
+                               imgWidth, imgHeight, imgArray,
+                               ospray->GetPatch(patch));
+                patchDrawn = 1;
+                
+            }
+        }
+    }
+
+    //=======================================================================//
+    // Send rays
+    //=======================================================================//
+    imgDims[0] = imgWidth;
+    imgDims[1] = imgHeight;
+    imgLowerLeft[0] = xMin;
+    imgLowerLeft[1] = yMin;
+    imgUpperRight[0] = xMax; 
+    imgUpperRight[1] = yMax;
+
+    //=======================================================================//
+    // Deallocate memory if not used
+    //=======================================================================//
+    if (patchDrawn == 0)
+    { 
+	if (imgArray != NULL) 
+	{ 
+	    delete []imgArray; imgArray = NULL; 
+	} 
+    }
+    // else {
+    // 	WriteArrayToPPM("patch-after-render"+
+    // 			std::to_string(proc), imgArray, 
+    // 			imgWidth, imgHeight);
+    // }
+}
+
+
+// ****************************************************************************
+//  Method: avtSLIVRVoxelExtractor::getImageDimensions
+//
+//  Purpose:
+//      Transfers the metadata of the patch
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 14, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRayVoxelExtractor::GetImageDimensions(int &inUse, int dims[2], int screen_ll[2], int screen_ur[2], float &eyeDepth, float &clipDepth)
+{
+    inUse = patchDrawn;
+
+    dims[0] = imgDims[0];    dims[1] = imgDims[1];
+
+    screen_ll[0] = imgLowerLeft[0];     screen_ll[1] = imgLowerLeft[1];
+    screen_ur[0] = imgUpperRight[0];    screen_ur[1] = imgUpperRight[1];
+
+    eyeDepth = eyeSpaceDepth;
+    clipDepth = clipSpaceDepth;
+}
+
+// ****************************************************************************
+//  Method: avtSLIVRVoxelExtractor::getComputedImage
+//
+//  Purpose:
+//      Allocates space to the pointer address and copy the image generated to it
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 14, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRayVoxelExtractor::GetComputedImage(float *image)
+{
+    memcpy(image, imgArray, imgDims[0]*4*imgDims[1]*sizeof(float));
+
+    if (imgArray != NULL)
+        delete []imgArray;
+    imgArray = NULL;
+}
diff --git a/avt/Filters/avtOSPRayVoxelExtractor.h b/avt/Filters/avtOSPRayVoxelExtractor.h
new file mode 100644
index 0000000000..5d429f8faf
--- /dev/null
+++ b/avt/Filters/avtOSPRayVoxelExtractor.h
@@ -0,0 +1,242 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                            avtOSPRayVoxelExtractor.h                      //
+// ************************************************************************* //
+
+#ifndef AVT_OSPRAY_VOXEL_EXTRACTOR_H
+#define AVT_OSPRAY_VOXEL_EXTRACTOR_H
+
+#include <filters_exports.h>
+
+#include <avtVoxelExtractor.h>
+#include <avtOSPRayCommon.h>
+#include <avtOpacityMap.h>
+
+#include <DebugStream.h>
+
+#include <vtkMatrix3x3.h>
+#include <vtkMatrix4x4.h>
+#include <vtkCamera.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <algorithm>
+
+class     vtkRectilinearGrid;
+class     vtkMatrix4x4;
+
+// ****************************************************************************
+//  Class: avtOSPRayVoxelExtractor
+//
+//  Purpose:
+//      Extracts sample points from a collection of voxels.  It assumes that 
+//      the voxels it has been given are in camera space and does not try to
+//      populate points that are not in the cube [-1, 1], [-1, 1], [-1, 1].
+//
+//  Programmer: Hank Childs
+//  Creation:   December 14, 2003
+//
+//  Modifications:
+//
+//    Hank Childs, Thu Feb  5 17:11:06 PST 2004
+//    Moved inlined constructor and destructor definitions to .C files
+//    because certain compilers have problems with them.
+//
+//    Hank Childs, Fri Nov 19 14:50:58 PST 2004
+//    Added support for accepting grids that need to do a world space to
+//    image space conversion as well.  Also changed API to AVTFILTERS_API.
+//
+//    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
+//    Added support for rectilinear grids with an inherent transform.
+//
+//    Hank Childs, Fri Jun  1 15:28:14 PDT 2007
+//    Added support for non-scalars.
+//
+//    Hank Childs, Wed Aug 27 11:24:53 PDT 2008
+//    Add support for non-floats.
+//
+//    Hank Childs, Wed Dec 24 11:24:47 PST 2008
+//    Remove data member ProportionSpaceToZBufferSpace, as we now do our
+//    sampling in even intervals (wbuffer).
+//
+//    Kathleen Biagas, Fri Jul 13 09:44:45 PDT 2012
+//    Use double internally instead of float.
+//
+// ****************************************************************************
+using namespace ospray;
+class AVTFILTERS_API avtOSPRayVoxelExtractor : public avtVoxelExtractor
+{
+  public:
+                     avtOSPRayVoxelExtractor(int, int, int, avtVolume *,
+                                            avtCellList *);
+    virtual         ~avtOSPRayVoxelExtractor();
+
+    void             Extract(vtkRectilinearGrid *,
+                             std::vector<std::string> &varnames,
+                             std::vector<int> &varsize);
+
+    // void             SetVariableInformation(std::vector<std::string> &names,
+    //                                         std::vector<int> varsize);
+
+    // RC OSPRay Specific
+    //void             SetRayCastingSLIVR(bool s) { rayCastingSLIVR = s; };
+    void             SetLighting(bool l) { lighting = l; };
+    void             SetLightDirection(double ld[3])
+                    { for (int i=0;i <3; i++) { lightDirection[i] = ld[i]; } };
+    void             SetLightPosition(double lp[4]) 
+                     { for (int i=0; i<4; i++) { lightPosition[i] = lp[i]; } };
+    void             SetMatProperties(double matProp[4]) 
+           { for (int i=0; i<4; i++) { materialProperties[i] = matProp[i]; } };
+    void             SetScalarRange(double range[2])
+                     { scalarRange[0] = range[0]; scalarRange[1] = range[1]; };
+    void             SetTFVisibleRange(double tfRange[2])
+           { tFVisibleRange[0] = tfRange[0]; tFVisibleRange[1] = tfRange[1]; };
+    void             SetTransferFn(avtOpacityMap *tf1D) 
+                                                      { transferFn1D = tf1D; };
+    void             SetViewDirection(double *vD)
+                     { for (int i=0; i<3; i++) { viewDirection[i] = vD[i]; } };
+    void             SetCameraPosition(double *cp) 
+                                    { std::copy(cp, cp + 3, cameraPosition); };
+    void             SetCameraUpVector(double *cu)
+                                    { std::copy(cu, cu + 3, cameraUpVector); };
+    void             SetCameraAspect(double a) { cameraAspect = a; };
+    void             SetClipPlanes(double cc[2])
+                             { clipPlanes[0] = cc[0]; clipPlanes[1] = cc[1]; };
+    void             SetPanPercentages(double p[2])
+                         { panPercentage[0] = p[0]; panPercentage[1] = p[1]; };
+    void             SetImageZoom(double z) { imageZoom = z; };
+    void             SetDepthExtents(double d[2])
+       { fullVolumeDepthExtents[0] = d[0]; fullVolumeDepthExtents[1] = d[1]; };
+    void             SetMVPMatrix(vtkMatrix4x4 *mvp)
+    {
+	model_to_screen_transform->DeepCopy(mvp); 
+	vtkMatrix4x4::Invert(model_to_screen_transform, 
+			     screen_to_model_transform); 
+    }
+
+    // Getting the image
+    void             GetImageDimensions
+    (int &, int dims[2], int screen_ll[2], int screen_ur[2], float &, float &);
+    void             GetComputedImage(float *image);
+    void             SetProcIdPatchID(int c, int p){ proc = c; patch = p; };
+
+    // Set the background information
+    void             SetDepthBuffer(float *z, int size){ depthBuffer = z; };
+    void             SetRGBBuffer(unsigned char *cb, int width, int height)
+                                                      { rgbColorBuffer = cb; };
+    void             SetBufferExtents(int e[4])
+                           { for (int i=0;i<4; i++) bufferExtents[i] = e[i]; };
+    void             SetRendererSampleRate(double r) 
+                                                   { rendererSampleRate = r; };
+    void             SetOSPRay(OSPVisItContext* o) { ospray = o; };
+    void             SetFullImageExtents(int extents[4]) 
+    {
+	fullImageExtents[0] = extents[0];
+	fullImageExtents[1] = extents[1];
+	fullImageExtents[2] = extents[2];	
+	fullImageExtents[3] = extents[3];
+    }
+
+  protected:
+    bool            rayCastingOSPRay;
+
+    //vtkMatrix4x4    *modelViewProj;
+    //vtkMatrix4x4    *invModelViewProj;
+    vtkMatrix4x4    *model_to_screen_transform;
+    vtkMatrix4x4    *screen_to_model_transform;
+
+    double           clipPlanes[2];
+    double           panPercentage[2];
+    double           imageZoom;
+    double           fullVolumeDepthExtents[2];
+    double           viewDirection[3];
+    double           cameraPosition[3]; // (Qi) camera location in world space
+    double           cameraUpVector[3]; // (Qi) camera up vector direction
+    double           cameraAspect;
+    int              fullImageExtents[4];
+
+    // Color computation
+    bool             lighting;
+    double           lightPosition[4];
+    float            lightDirection[3];
+    double           materialProperties[4];
+    avtOpacityMap   *transferFn1D;
+    float            gradient[3];
+    double           scalarRange[2];
+    double           tFVisibleRange[2];
+
+    // Background + other plots
+    float           *depthBuffer; // depth for the background and other plots
+    unsigned char   *rgbColorBuffer;   // bounding box + pseudo color + ...
+    int              bufferExtents[4]; // (minX, maxX, minY, maxY)
+
+    // Rendering
+    //int            renderingAreaExtents[4];
+    double           renderingDepthsExtents[2];
+
+
+    // Patch details for one image
+    int              patchDrawn;       // whether the patch is drawn or not
+    int              imgWidth;
+    int              imgHeight;
+    int              imgDims[2];       // size of the patch
+    int              imgLowerLeft[2];  // coordinates in the whole image
+    int              imgUpperRight[2]; // coordinates in the whole image
+    float            eyeSpaceDepth;    // for blending patches
+    float            clipSpaceDepth;   // clip space depth for blending with bg
+
+    float            *imgArray;        // the final framebuffer
+    int              proc;             // id of the processor
+    int              patch;            // id of the patch
+
+    int              fullImgWidth, fullImgHeight;
+    int              xMin, xMax, yMin, yMax;
+
+    // OSPRay stuffs
+    OSPVisItContext *ospray;
+    double           rendererSampleRate;
+
+    // Added for RayCasting OSPRay
+    void             ExtractWorldSpaceGridOSPRay(vtkRectilinearGrid *,  
+                             std::vector<std::string> &varnames,
+                             std::vector<int> &varsize);
+};
+
+#endif
diff --git a/avt/Filters/avtSLIVRCommon.C b/avt/Filters/avtSLIVRCommon.C
new file mode 100644
index 0000000000..fba43591d1
--- /dev/null
+++ b/avt/Filters/avtSLIVRCommon.C
@@ -0,0 +1,38 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+#include <avtSLIVRCommon.h>
diff --git a/avt/Filters/avtSLIVRCommon.h b/avt/Filters/avtSLIVRCommon.h
new file mode 100644
index 0000000000..641ae817c0
--- /dev/null
+++ b/avt/Filters/avtSLIVRCommon.h
@@ -0,0 +1,138 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+#ifndef AVT_SLIVR_COMMON_H
+#define AVT_SLIVR_COMMON_H
+#include <stdio.h>
+#include <string>
+#include <iostream>
+
+// ****************************************************************************
+//  Struct:  imgMetaData
+//
+//  Purpose:
+//    Holds information about patches but not the image 
+//
+//  Programmer:  
+//  Creation:   
+//
+// ****************************************************************************
+struct imgMetaData
+{
+    int procId;       // processor that produced the patch
+    int patchNumber;  // id of the patch on that processor - with procId, acts as a key
+
+    int destProcId;   // destination proc where this patch gets composited
+
+    int inUse;   // whether the patch is composed locally or not
+    int dims[2];      // height, width
+    int screen_ll[2]; // position in the final image
+    int screen_ur[2];
+
+    float avg_z;        // camera space z = depth of the patch - used for compositing
+    float eye_z;        // camera space z
+    float clip_z;       // clip space z
+};
+
+
+// ****************************************************************************
+//  Struct:  imgData
+//
+//  Purpose:
+//    Holds the image data generated
+//
+//  Programmer:  
+//  Creation:    
+//
+// ****************************************************************************
+struct imgData
+{
+    int procId;         // processor that produced the patch
+    int patchNumber;    // id of the patch on that processor  - with procId, acts as a key
+
+    float *imagePatch;  // the image data - RGBA
+
+    bool operator==(const imgData &a){
+        return (patchNumber == a.patchNumber);
+    }
+};
+
+
+// ****************************************************************************
+//  Struct:  convexHull
+//
+//  Purpose:
+//    Holds the image data generated
+//
+//  Programmer:  
+//  Creation:    
+//
+// ****************************************************************************
+struct convexHull
+{
+    int numPatches;
+    int arrangement[3];     // [0] rows along x axis, [1] rows along y axis, [2] rows along z axis
+
+    float extents[6];       // minX, maxX   minY, maxY   minZ, maxZ
+    float cellDims[3];      // x, y, z
+    float tolerance;        // amount of overlap that is considered ok - typically 2 cells for cell centered data
+
+
+    // 0: no overlap    1: overlpa in Z    2: overlap in Y    3: overlap in Z
+    int overlap(convexHull _hull)
+    {
+
+        if ( (_hull.extents[1] < extents[0]) || (_hull.extents[0] > extents[1]) )   // No overlap in X
+        {
+            if ( (_hull.extents[3] < extents[2]) || (_hull.extents[2] > extents[3]) )   // No overlap in Y
+            {
+                if ( (_hull.extents[5] < extents[4]) || (_hull.extents[4] > extents[5]) )   // No overlap in Z
+                {
+                    return 0;
+                }
+                else
+                    return 3;
+            }
+            else
+                return 2;
+        }
+        else
+            return 1;
+    }
+};
+
+#endif
diff --git a/avt/Filters/avtSLIVRImageCompositor.C b/avt/Filters/avtSLIVRImageCompositor.C
new file mode 100644
index 0000000000..fc7cfd12af
--- /dev/null
+++ b/avt/Filters/avtSLIVRImageCompositor.C
@@ -0,0 +1,1651 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                         avtSLIVRImageCompositor.C                         //
+// ************************************************************************* //
+
+#include <avtParallel.h>
+#include <avtSLIVRImageCompositor.h>
+#include <ImproperUseException.h>
+#include <DebugStream.h>
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>     /* srand, rand */
+#include <time.h>       /* time */
+
+#include <algorithm>
+#include <cmath>
+#include <fstream>
+#include <limits>
+#include <set>
+
+#if defined (_MSC_VER) && (_MSC_VER < 1800) && !defined(round)
+inline double round(double x) {return (x-floor(x)) > 0.5 ? ceil(x) : floor(x);}
+#endif
+
+enum blendDirection {FRONT_TO_BACK = 0, BACK_TO_FRONT = 1};
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::avtSLIVRImageCompositor
+//
+//  Purpose: Constructor
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+avtSLIVRImageCompositor::avtSLIVRImageCompositor()
+{
+  #ifdef PARALLEL
+    MPI_Comm_size(VISIT_MPI_COMM, &num_procs);
+    MPI_Comm_rank(VISIT_MPI_COMM, &my_id);
+
+  #else
+    num_procs = 1;
+    my_id = 0;
+  #endif
+
+    totalPatches = 0;
+
+    intermediateImage = NULL;
+    imgBuffer = NULL;
+
+    for (int i=0; i<4; i++)
+    {
+        intermediateImageExtents[i] = 0;
+        intermediateImageBB[i] = 0;
+    }
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::~avtSLIVRImageCompositor
+//
+//  Purpose:
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+avtSLIVRImageCompositor::~avtSLIVRImageCompositor()
+{
+    if (my_id == 0)
+    {
+        if (imgBuffer != NULL)
+            delete []imgBuffer;
+    }
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//    Barrier, useful for debugging
+//
+//  Programmer: Pascal Grosset
+//  Creation: July 2013
+//
+//  Modifications:
+//
+// ****************************************************************************
+void avtSLIVRImageCompositor::barrier(){
+  #ifdef PARALLEL
+    MPI_Barrier( MPI_COMM_WORLD );
+  #endif
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::getcompositedImage
+//
+//  Purpose:
+//      Returns the whole image if needed
+//
+//  Programmer: Pascal Grosset
+//  Creation: July 2013
+//
+//  Modifications:
+//
+// ****************************************************************************
+void avtSLIVRImageCompositor::getcompositedImage(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage)
+{
+    for (int i=0; i< imgBufferHeight; i++)
+        for (int j=0; j<imgBufferWidth; j++){
+            int bufferIndex = (imgBufferWidth*4*i) + (j*4);
+            int wholeImgIndex = (imgBufferWidth*3*i) + (j*3);
+
+            wholeImage[wholeImgIndex+0] = (imgBuffer[bufferIndex+0] ) * 255;
+            wholeImage[wholeImgIndex+1] = (imgBuffer[bufferIndex+1] ) * 255;
+            wholeImage[wholeImgIndex+2] = (imgBuffer[bufferIndex+2] ) * 255;
+        }
+
+    if (imgBuffer != NULL)
+        delete []imgBuffer;
+    imgBuffer = NULL;
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//       Fills an image with a specific color
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+void
+avtSLIVRImageCompositor::colorImage(float *& srcImage, int widthSrc, int heightSrc, float _color[4])
+{
+    for (int _y=0; _y<heightSrc; _y++)
+        for (int _x=0; _x<widthSrc; _x++)
+        {
+            int srcIndex = widthSrc*_y*4 + _x*4;
+
+            srcImage[srcIndex+0] = _color[0];
+            srcImage[srcIndex+1] = _color[1];
+            srcImage[srcIndex+2] = _color[2];
+            srcImage[srcIndex+3] = _color[3];
+        }
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::placeInImage
+//
+//  Purpose:
+//      Puts srcImage into dstImage
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+void
+avtSLIVRImageCompositor::placeInImage(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
+{
+    int widthSrc, heightSrc, widthDst;
+    widthSrc  = srcExtents[1] - srcExtents[0];
+    heightSrc = srcExtents[3] - srcExtents[2];
+
+    widthDst  = dstExtents[1] - dstExtents[0];
+
+    for (int _y=0; _y<heightSrc; _y++)
+        for (int _x=0; _x<widthSrc; _x++)
+        {
+            int startingX = srcExtents[0];
+            int startingY = srcExtents[2];
+
+            int srcIndex = widthSrc*_y*4 + _x*4;                                                                  // index in the subimage
+            int dstIndex = ( (startingY+_y - dstExtents[2])*widthDst*4  + (startingX+_x - dstExtents[0])*4 );     // index in the big buffer
+
+            dstImage[dstIndex+0] = srcImage[srcIndex+0];
+            dstImage[dstIndex+1] = srcImage[srcIndex+1];
+            dstImage[dstIndex+2] = srcImage[srcIndex+2];
+            dstImage[dstIndex+3] = srcImage[srcIndex+3];
+        }
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::blendWithBackground
+//
+//  Purpose:
+//      Blends _image with the backgroundColor
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::blendWithBackground(float *_image, int extents[4], float backgroundColor[4])
+{
+    int numPixels = (extents[3]-extents[2]) * (extents[1]-extents[0]);
+
+    for (int index=0; index<numPixels; index++)      // estimated potential speedup: 2.240
+    {
+        int indexSrc = index*4;
+        float alpha = (1.0 - _image[indexSrc+3]);
+
+        _image[indexSrc+0] = backgroundColor[0] * alpha +  _image[indexSrc+0];
+        _image[indexSrc+1] = backgroundColor[1] * alpha +  _image[indexSrc+1];
+        _image[indexSrc+2] = backgroundColor[2] * alpha +  _image[indexSrc+2];
+        _image[indexSrc+3] = backgroundColor[3] * alpha +  _image[indexSrc+3];
+    }
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//      Blends tow patches in a front to back manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::blendFrontToBack(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4])
+{
+    int widthSrc, heightSrc, widthDst;
+    widthSrc  = srcExtents[1] - srcExtents[0];
+    heightSrc = srcExtents[3] - srcExtents[2];
+
+    widthDst  = dstExtents[1] - dstExtents[0];
+
+    #if defined(VISIT_THREADS)
+    #endif
+
+    for (int _y=blendExtents[2]; _y<blendExtents[3]; _y++)
+        for (int _x=blendExtents[0]; _x<blendExtents[1]; _x++)
+        {
+
+            int srcIndex = (_y-srcExtents[2]) * widthSrc * 4 + (_x-srcExtents[0]) * 4;
+            int dstIndex = (_y-dstExtents[2]) * widthDst * 4 + (_x-dstExtents[0]) * 4;
+
+            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
+            float alpha = 1.0 - dstImage[dstIndex+3];
+            dstImage[dstIndex+0] = clamp( (srcImage[srcIndex+0] * alpha) + dstImage[dstIndex+0] );
+            dstImage[dstIndex+1] = clamp( (srcImage[srcIndex+1] * alpha) + dstImage[dstIndex+1] );
+            dstImage[dstIndex+2] = clamp( (srcImage[srcIndex+2] * alpha) + dstImage[dstIndex+2] );
+            dstImage[dstIndex+3] = clamp( (srcImage[srcIndex+3] * alpha) + dstImage[dstIndex+3] );
+        }
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//      Blends tow patches in a back to front manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::blendBackToFront(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4])
+{
+    int widthSrc, heightSrc, widthDst;
+    widthSrc  = srcExtents[1] - srcExtents[0];
+    heightSrc = srcExtents[3] - srcExtents[2];
+
+    widthDst  = dstExtents[1] - dstExtents[0];
+
+    for (int _y=blendExtents[2]; _y<blendExtents[3]; _y++)
+        for (int _x=blendExtents[0]; _x<blendExtents[1]; _x++)
+        {
+
+            int srcIndex = (_y-srcExtents[2]) * widthSrc * 4 + (_x-srcExtents[0]) * 4;
+            int dstIndex = (_y-dstExtents[2]) * widthDst * 4 + (_x-dstExtents[0]) * 4;
+
+            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
+            float alpha = 1.0 - srcImage[srcIndex+3];
+            dstImage[dstIndex+0] = clamp( (dstImage[dstIndex+0] * alpha) + srcImage[srcIndex+0] );
+            dstImage[dstIndex+1] = clamp( (dstImage[dstIndex+1] * alpha) + srcImage[srcIndex+1] );
+            dstImage[dstIndex+2] = clamp( (dstImage[dstIndex+2] * alpha) + srcImage[srcIndex+2] );
+            dstImage[dstIndex+3] = clamp( (dstImage[dstIndex+3] * alpha) + srcImage[srcIndex+3] );
+        }
+}
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//      Blends tow patches in a front to back manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::blendFrontToBack(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
+{
+    int widthSrc, heightSrc, widthDst;
+    widthSrc  = srcExtents[1] - srcExtents[0];
+    heightSrc = srcExtents[3] - srcExtents[2];
+
+    widthDst  = dstExtents[1] - dstExtents[0];
+
+    for (int _y=0; _y<heightSrc; _y++)
+        for (int _x=0; _x<widthSrc; _x++)
+        {
+            int startingX = srcExtents[0];
+            int startingY = srcExtents[2];
+
+            if ((startingX + _x) > dstExtents[1])
+                continue;
+
+            if ((startingY + _y) > dstExtents[3])
+                continue;
+
+            int srcIndex = widthSrc*_y*4 + _x*4;                                                                  // index in the subimage
+            int dstIndex = ( (startingY+_y - dstExtents[2])*widthDst*4  + (startingX+_x - dstExtents[0])*4 );     // index in the big buffer
+
+            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
+            float alpha = 1.0 - dstImage[dstIndex+3];
+            dstImage[dstIndex+0] = clamp( (srcImage[srcIndex+0] * alpha) + dstImage[dstIndex+0] );
+            dstImage[dstIndex+1] = clamp( (srcImage[srcIndex+1] * alpha) + dstImage[dstIndex+1] );
+            dstImage[dstIndex+2] = clamp( (srcImage[srcIndex+2] * alpha) + dstImage[dstIndex+2] );
+            dstImage[dstIndex+3] = clamp( (srcImage[srcIndex+3] * alpha) + dstImage[dstIndex+3] );
+        }
+}
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//      Blends tow patches in a back to front manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::blendBackToFront(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
+{
+    int widthSrc, heightSrc, widthDst;
+    widthSrc  = srcExtents[1] - srcExtents[0];
+    heightSrc = srcExtents[3] - srcExtents[2];
+
+    widthDst  = dstExtents[1] - dstExtents[0];
+
+    for (int _y=0; _y<heightSrc; _y++)
+        for (int _x=0; _x<widthSrc; _x++)
+        {
+            int startingX = srcExtents[0];
+            int startingY = srcExtents[2];
+
+            if ((startingX + _x) > dstExtents[1])
+                continue;
+
+            if ((startingY + _y) > dstExtents[3])
+                continue;
+
+            int srcIndex = widthSrc*_y*4 + _x*4;                                                                  // index in the subimage
+            int dstIndex = ( (startingY+_y - dstExtents[2])*widthDst*4  + (startingX+_x - dstExtents[0])*4 );     // index in the big buffer
+
+            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
+            float alpha = 1.0 - srcImage[srcIndex+3];
+            dstImage[dstIndex+0] = clamp( (dstImage[dstIndex+0] * alpha) + srcImage[srcIndex+0] );
+            dstImage[dstIndex+1] = clamp( (dstImage[dstIndex+1] * alpha) + srcImage[srcIndex+1] );
+            dstImage[dstIndex+2] = clamp( (dstImage[dstIndex+2] * alpha) + srcImage[srcIndex+2] );
+            dstImage[dstIndex+3] = clamp( (dstImage[dstIndex+3] * alpha) + srcImage[srcIndex+3] );
+        }
+}
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::regionAllocation
+//
+//  Purpose:
+//      Arbitrarily allocates regions to MPI ranks
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+void
+avtSLIVRImageCompositor::regionAllocation(int numMPIRanks, int *& regions)
+{
+    regions = new int[numMPIRanks];
+
+    // Initial allocation: partition for section rank
+    for (int i=0; i<numMPIRanks; i++)
+        regions[i] = i;
+}
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::
+//
+//  Purpose:
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::updateBoundingBox(int currentBoundingBox[4], int imageExtents[4])
+{
+    if ( (currentBoundingBox[0] == 0 && currentBoundingBox[1] == 0) && (currentBoundingBox[2] == 0 && currentBoundingBox[3] == 0))
+    {
+        currentBoundingBox[0]=imageExtents[0];
+        currentBoundingBox[1]=imageExtents[1];
+        currentBoundingBox[2]=imageExtents[2];
+        currentBoundingBox[3]=imageExtents[3];
+
+        return;
+    }
+
+    if (imageExtents[0] < currentBoundingBox[0])
+        currentBoundingBox[0] = imageExtents[0];
+
+    if (imageExtents[2] < currentBoundingBox[2])
+        currentBoundingBox[2] = imageExtents[2];
+
+    if (imageExtents[1] > currentBoundingBox[1])
+        currentBoundingBox[1] = imageExtents[1];
+
+    if (imageExtents[3] > currentBoundingBox[3])
+        currentBoundingBox[3] = imageExtents[3];
+}
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::gatherDepthAtRoot
+//
+//  Purpose:
+//      Used by Serial Direct Send
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::gatherDepthAtRoot(int numlocalPatches, float *localPatchesDepth, int &totalPatches, int *& patchCountPerRank, float *& allPatchesDepth)
+{
+  #ifdef PARALLEL
+    //
+    // Get how many patches are coming from each MPI rank
+    totalPatches = 0;
+    int *patchesOffset = NULL;
+
+
+    if (my_id == 0) // root!
+        patchCountPerRank = new int[num_procs]();
+
+    MPI_Gather(&numlocalPatches, 1, MPI_INT,   patchCountPerRank, 1, MPI_INT,    0, MPI_COMM_WORLD);
+
+
+    //
+    // Gather number of patch group
+    if (my_id == 0)
+    {
+        patchesOffset = new int[num_procs]();
+        patchesOffset[0] = 0;
+
+        for (int i=0; i<num_procs; i++)
+        {
+            totalPatches += patchCountPerRank[i];
+
+            if (i == 0)
+                patchesOffset[i] = 0;
+            else
+                patchesOffset[i] = patchesOffset[i-1] + patchCountPerRank[i-1];
+        }
+
+        allPatchesDepth = new float[totalPatches];
+    }
+
+    MPI_Gatherv(localPatchesDepth, numlocalPatches, MPI_FLOAT,   allPatchesDepth, patchCountPerRank, patchesOffset,    MPI_FLOAT, 0, MPI_COMM_WORLD);
+
+    //
+    // Cleanup
+    if (my_id == 0)
+        if (patchesOffset != NULL)
+            delete []patchesOffset;
+
+    patchesOffset = NULL;
+  #endif
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::serialDirectSend
+//
+//  Purpose:
+//      A very simple compositing that we can fall back to if Parallel direct send is buggy.
+//      Works with convex patches though
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::serialDirectSend(int numPatches, float *localPatchesDepth, int *extents, float *imgData, float backgroundColor[4], int width, int height)
+{
+  #ifdef PARALLEL
+    //debug5 << "serialDirectSend" << std::endl;
+
+    float *recvImage = NULL;
+
+    int tags[2] = {5781, 5782};
+
+    int totalPatches;
+    int *patchCountPerRank = NULL;
+    float *patchesDepth = NULL;
+    gatherDepthAtRoot(numPatches, localPatchesDepth, totalPatches, patchCountPerRank, patchesDepth);
+
+    if (my_id == 0)
+    {
+        //
+        // Root
+        int srcSize[2], srcPos[2], dstSize[2], dstPos[2];
+        srcSize[0] = width;  srcSize[1] = height;
+        srcPos[0] = 0;       srcPos[1] = 0;
+
+        //
+        // Sort patches we will receive
+        std::multimap<float,int> depthRankPatches;
+
+        int index = 0;
+        for (int i=0; i<num_procs; i++)
+            for (int j=0; j<patchCountPerRank[i]; j++)
+            {
+                depthRankPatches.insert( std::pair<float,int>(patchesDepth[index],i) );
+                index++;
+            }
+
+
+        //
+        // Create space for buffers
+        int recvParams[4];                          // minX, maxX, minY, maxY
+        int imgExtents[4];
+        imgExtents[0] = 0;  imgExtents[1] = width;
+        imgExtents[2] = 0;  imgExtents[3] = height;
+
+        recvImage = new float[width*height*4]();
+        imgBuffer = new float[width*height*4]();
+
+        int localIndex = 0;
+
+        //
+        // Compositing
+        for (std::multimap<float,int>::iterator it=depthRankPatches.begin(); it!=depthRankPatches.end(); ++it)
+        {
+            int rank = (*it).second;
+
+            //debug5 << "\nRecv and blend from " << rank << " depth: " << (*it).first << std::endl;
+
+            if (rank != my_id)
+            {
+                MPI_Recv(recvParams,             4, MPI_INT,   rank, tags[0],  MPI_COMM_WORLD, MPI_STATUS_IGNORE);  // recv image info
+                MPI_Recv(recvImage, width*height*4, MPI_FLOAT, rank, tags[1],  MPI_COMM_WORLD, MPI_STATUS_IGNORE);  // recv image
+
+                dstPos[0]  = dstPos[0];                      dstPos[1]  = dstPos[1];
+                dstSize[0] = recvParams[2]-recvParams[0];    dstSize[1] = recvParams[3]-recvParams[1];
+            }
+            else
+            {
+                // It's local
+                recvParams[0] = extents[ localIndex*4 + 0];
+                recvParams[1] = extents[ localIndex*4 + 1];
+                recvParams[2] = extents[ localIndex*4 + 2];
+                recvParams[3] = extents[ localIndex*4 + 3];
+
+                recvImage = &imgData[ localIndex*(width*height*4) ];
+                localIndex++;
+            }
+
+            blendFrontToBack(recvImage, recvParams, imgBuffer, imgExtents);
+        }
+        blendWithBackground(imgBuffer, imgExtents, backgroundColor);
+
+        //writeArrayToPPM("/home/pascal/Desktop/debugImages/full_with back_" + toStr(__index), imgBuffer, imgExtents[1]-imgExtents[0], imgExtents[3]-imgExtents[2]);
+    }
+    else
+    {
+        //
+        // Sender
+        for (int i=0; i<numPatches; i++)
+        {
+            int imgSize = (extents[i*4 + 1] - extents[i*4 + 0]) * (extents[i*4 + 3] - extents[i*4 + 2]) * 4;
+
+            if (imgSize > 0)
+            {
+                //debug5 << "Sending: Extents " <<  extents[i*4 + 0] << ", " << extents[i*4 + 1] << ", " << extents[i*4 + 2] << ", " << extents[i*4 + 3] << std::endl;
+                //writeArrayToPPM("/home/pascal/Desktop/debugImages/sending_to_root_from_" + toStr(my_id), &imgData[i*(width*height*4)], (extents[i*4 + 1] - extents[i*4 + 0]), (extents[i*4 + 3] - extents[i*4 + 2]) );
+
+                MPI_Send( &extents[i*4],                       4, MPI_INT,   0, tags[0], MPI_COMM_WORLD);
+                MPI_Send( &imgData[i*(width*height*4)],  imgSize, MPI_FLOAT, 0, tags[1], MPI_COMM_WORLD);
+            }
+        }
+    }
+
+    //debug5 << "Free memory" << std::endl;
+
+    //
+    // Cleanup
+    if (patchesDepth != NULL)
+      delete []patchesDepth;
+
+    if (patchCountPerRank != NULL)
+        delete []patchCountPerRank;
+
+    if (recvImage != NULL)
+        delete []recvImage;
+
+    recvImage = NULL;
+    patchCountPerRank = NULL;
+    patchesDepth = NULL;
+
+  #endif
+}
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::parallelDirectSend
+//
+//  Purpose:
+//      Parallel Direct Send rendering that can blend convex patches from each MPI rank.
+//      However, since we are not guaranteed to have convex patches. It's not used.
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::parallelDirectSend(float *imgData, int imgExtents[4], int region[], int numRegions, int tags[2], int fullImageExtents[4])
+{
+  #ifdef PARALLEL
+    //
+    // Determine position in region (myPositionInRegion)
+    int width =  fullImageExtents[1]-fullImageExtents[0];
+    int height = fullImageExtents[3]-fullImageExtents[2];
+
+    //debug5 << "fullImageExtents: " << fullImageExtents[0] << ", " << fullImageExtents[1] << "   " << fullImageExtents[2] << ", " << fullImageExtents[3] << endl;
+
+    compositingDone = false;
+    int myPositionInRegion = -1;
+    bool inRegion = true;
+    std::vector<int> regionVector(region, region+numRegions);
+    std::vector<int>::iterator it = std::find(regionVector.begin(), regionVector.end(), my_id);
+
+    if (it == regionVector.end())
+    {
+        inRegion = false;
+        //debug5 << my_id << " ~ SHOULD NOT HAPPEN: Not found " << my_id <<  " !!!" << std::endl;
+    }
+    else
+        myPositionInRegion = it - regionVector.begin();
+
+    //
+    // Region boundaries
+    int regionHeight = height/numRegions;
+    int lastRegionHeight = height - regionHeight*(numRegions-1);
+
+    // Extents of my region
+    int myStartingHeight = fullImageExtents[2] + myPositionInRegion * regionHeight;
+    int myEndingHeight = myStartingHeight + regionHeight;
+    if (myPositionInRegion == numRegions-1)
+        myEndingHeight = fullImageExtents[3];
+
+    int myRegionHeight = myEndingHeight-myStartingHeight;
+
+    // Size of one buffer
+    int sizeOneBuffer = std::max(regionHeight,lastRegionHeight) * width * 4;
+
+    //debug5 << "myPositionInRegion: " << myPositionInRegion << std::endl;
+    //debug5 << "My extents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
+    //debug5 << "myRegionHeight: " << myRegionHeight << "  lastRegionHeight: " << lastRegionHeight << " regionHeight: " << regionHeight << "  myStartingHeight: " << myStartingHeight << "  myEndingHeight: " << myEndingHeight << std::endl;
+
+
+    //
+    // MPI Async
+
+    // Recv
+    MPI_Request *recvMetaRq = new MPI_Request[ numRegions-1 ];
+    MPI_Request *recvImageRq = new MPI_Request[ numRegions-1 ];
+
+    MPI_Status *recvMetaSt = new MPI_Status[ numRegions-1 ];
+    MPI_Status *recvImageSt = new MPI_Status[ numRegions-1 ];
+
+    // Send
+    MPI_Request *sendMetaRq = new MPI_Request[ numRegions-1 ];
+    MPI_Request *sendImageRq = new MPI_Request[ numRegions-1 ];
+
+    MPI_Status *sendMetaSt = new MPI_Status[ numRegions-1 ];
+    MPI_Status *sendImageSt = new MPI_Status[ numRegions-1 ];
+
+
+    //
+    // Create Buffers
+
+    // Create buffer for receiving images
+    float *recvDataBuffer;
+    recvDataBuffer = new float[ sizeOneBuffer * numRegions];
+
+    // Create buffer for receiving messages
+    std::vector<int> msgBuffer;
+    msgBuffer.clear();
+    msgBuffer.resize(5 * numRegions);
+
+    // Create buffer for sending messages
+    int *sendExtents = new int[numRegions*5];
+
+    //
+    // Async Recv
+    if (inRegion)
+    {
+        int recvCount=0;
+        for (int i=0; i<numRegions; i++)
+        {
+            if ( regionVector[i] == my_id )
+                continue;
+
+            int src = regionVector[i];
+            MPI_Irecv(&msgBuffer[i*5],                              5, MPI_INT,   src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvCount] );
+            MPI_Irecv(&recvDataBuffer[i*sizeOneBuffer], sizeOneBuffer, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+            recvCount++;
+        }
+    }
+
+    //debug5 << "Async Recv setup done " << std::endl;
+
+    //
+    // Async Send
+    int sendCount = 0;
+    int sendingOffset;
+    for (int i=0; i<numRegions; i++)
+    {
+        int regionStart, regionEnd, imgSize, dest;
+        dest = regionVector[i];
+
+        if ( dest == my_id )
+            continue;
+
+        regionStart = i*regionHeight;
+        regionEnd = regionStart + regionHeight;
+        if (i == numRegions-1) // the last one in region
+            regionEnd = height;
+
+        int startingYExtents = fullImageExtents[2] + regionStart;
+        int endingYExtents = fullImageExtents[2] + regionEnd;
+
+        //debug5 << "startingYExtents: " << startingYExtents <<"   endingYExtents: " << endingYExtents <<  std::endl;
+
+        if (startingYExtents < imgExtents[2])
+            startingYExtents = imgExtents[2];
+
+        if (endingYExtents > imgExtents[3])
+            endingYExtents = imgExtents[3];
+
+        bool hasData = true;
+        if (endingYExtents - startingYExtents <= 0 || imgExtents[1]-imgExtents[0] <= 0)
+        {
+            hasData = false;
+
+            sendingOffset = 0;
+            imgSize = sendExtents[i*5 + 0] = sendExtents[i*5 + 1] = sendExtents[i*5 + 2] = sendExtents[i*5 + 3] =  sendExtents[i*5 + 4] = 0;
+        }
+        else
+        {
+            imgSize = (endingYExtents-startingYExtents) * (imgExtents[1]-imgExtents[0]) * 4;
+            sendingOffset = (startingYExtents-imgExtents[2]) * (imgExtents[1]-imgExtents[0]) * 4;
+
+            sendExtents[i*5 + 0] = imgExtents[0];
+            sendExtents[i*5 + 1] = imgExtents[1];
+            sendExtents[i*5 + 2] = startingYExtents;
+            sendExtents[i*5 + 3] = endingYExtents;
+            sendExtents[i*5 + 4] = 0;
+        }
+
+        //std::cout << my_id << " ~ i: " << i << "   regionVector[index]: " << regionVector[index] << "  extents: " <<  sendExtents[index*5 + 0] << ", " << sendExtents[index*5 + 1]  << ", " << sendExtents[index*5 + 2] << ", " << sendExtents[index*5 + 3] << "  sending ... " << std::endl;
+        MPI_Isend(&sendExtents[i*5],             5,   MPI_INT, dest, tags[0], MPI_COMM_WORLD, &sendMetaRq[sendCount]);
+        MPI_Isend(&imgData[sendingOffset], imgSize, MPI_FLOAT, dest, tags[1], MPI_COMM_WORLD, &sendImageRq[sendCount]);
+
+        //debug5 << "dest: " << dest <<"   sendExtents: " << sendExtents[i*5 +0] << ", " << sendExtents[i*5 +1] << "    " << sendExtents[i*5 +2] << ", " << sendExtents[i*5 +3] << std::endl << std::endl;
+
+        sendCount++;
+    }
+
+    //debug5 << "Async Recv" << std::endl;
+
+    //
+    // Create buffer for region
+    intermediateImageExtents[0] = fullImageExtents[0];  intermediateImageExtents[1] = fullImageExtents[1];
+    intermediateImageExtents[2] = myStartingHeight;     intermediateImageExtents[3] = myEndingHeight;
+
+    intermediateImage = new float[width * (myEndingHeight-myStartingHeight) * 4]();
+
+    int recvImageExtents[4];
+    float *recvImageData;
+
+    //
+    // Blend
+    int numBlends = 0;
+    int countBlend = 0;
+
+    intermediateImageBB[0] = intermediateImageBB[2] = 0;
+    intermediateImageBB[1] = intermediateImageBB[3] = 0;
+
+    if (inRegion)
+    {
+        for (int i=0; i<numRegions; i++)
+        {
+            int index = i;
+
+            //debug5 << "regionVector[" << i << "] " << regionVector[index] << std::endl;
+
+            if (regionVector[index] == my_id)
+            {
+                int startingYExtents = myStartingHeight;
+                int endingYExtents = myEndingHeight;
+
+                if (startingYExtents < imgExtents[2])
+                    startingYExtents = imgExtents[2];
+
+                if (endingYExtents > imgExtents[3])
+                    endingYExtents = imgExtents[3];
+
+
+                bool hasData = true;
+                if (endingYExtents - startingYExtents <= 0)
+                {
+                    hasData = false;
+                    endingYExtents = startingYExtents = 0;
+                }
+
+                if (hasData == true)
+                {
+                    int extentsSectionRecv[4];
+                    extentsSectionRecv[0] = imgExtents[0];
+                    extentsSectionRecv[1] = imgExtents[1];
+                    extentsSectionRecv[2] = startingYExtents;
+                    extentsSectionRecv[3] = endingYExtents;
+
+                    blendFrontToBack(imgData, imgExtents, extentsSectionRecv, intermediateImage, intermediateImageExtents);
+                    //debug5 << "Blend with: " << regionVector[index]  << "  extentsSectionRecv: " << extentsSectionRecv[0] << ", " << extentsSectionRecv[1] << "    " << extentsSectionRecv[2] << ", " << extentsSectionRecv[3] << ", "  << std::endl;
+                    //writeArrayToPPM("/home/pascal/Desktop/debugImages/composited_AFTER_recv_from_" + toStr(regionVector[index]) + "_at_" + toStr(my_id), intermediateImage, intermediateImageExtents[1]-intermediateImageExtents[0], intermediateImageExtents[3]-intermediateImageExtents[2]);
+
+
+                    updateBoundingBox(intermediateImageBB, extentsSectionRecv);
+                    numBlends++;
+                }
+            }
+            else
+            {
+                MPI_Wait(&recvMetaRq[countBlend], &recvMetaSt[countBlend]);
+
+                for (int j=0; j<4; j++)
+                    recvImageExtents[j] = msgBuffer[index*5 + j];
+
+                bool hasData =  false;
+                if (recvImageExtents[1]-recvImageExtents[0] > 0 && recvImageExtents[3]-recvImageExtents[2] > 0)
+                {
+                    hasData = true;
+                    MPI_Wait(&recvImageRq[countBlend], &recvImageSt[countBlend]);
+                    recvImageData = &recvDataBuffer[index*sizeOneBuffer];
+                }
+
+                if (hasData)
+                {
+
+                    blendFrontToBack(recvImageData, recvImageExtents, intermediateImage, intermediateImageExtents);
+
+                    updateBoundingBox(intermediateImageBB, recvImageExtents);
+                    numBlends++;
+                }
+
+                countBlend++;
+            }
+        }
+    }
+    else
+        compositingDone = true;
+
+    //debug5 << "PDS blending done" << std::endl;
+
+    msgBuffer.clear();
+
+
+    if (recvDataBuffer != NULL)
+        delete []recvDataBuffer;
+    recvDataBuffer = NULL;
+
+
+    if (numBlends == 0)
+        intermediateImageBB[0]=intermediateImageBB[1]=intermediateImageBB[2]=intermediateImageBB[3] = 0;
+
+    delete []recvMetaRq;
+    delete []recvImageRq;
+    delete []recvMetaSt;
+    delete []recvImageSt;
+
+    delete []sendMetaRq;
+    delete []sendImageRq;
+    delete []sendMetaSt;
+    delete []sendImageSt;
+
+    recvMetaRq = NULL;
+    recvImageRq = NULL;
+    recvMetaSt = NULL;
+    recvImageSt = NULL;
+
+    sendMetaRq = NULL;
+    sendImageRq = NULL;
+    sendMetaSt = NULL;
+    sendImageSt = NULL;
+  #endif
+}
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::findRegionsForPatch
+//
+//  Purpose:
+//      Needed by Parallel Direct Send to determine the regions a patch will overlap
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+int
+avtSLIVRImageCompositor::findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to)
+{
+    from = to = 0;
+    if (patchExtents[1]-patchExtents[0] <=0 || patchExtents[3]-patchExtents[2] <=0)
+        return 0;
+
+    if ( patchExtents[0] > screenProjectedExtents[1])
+        return 0;
+
+    if ( patchExtents[1] < screenProjectedExtents[0])
+        return 0;
+
+    if ( patchExtents[2] > screenProjectedExtents[3])
+        return 0;
+
+    if ( patchExtents[3] < screenProjectedExtents[2])
+        return 0;
+
+
+    // find from
+    for (int i=numRegions-1; i>=0; i--)
+        if ( patchExtents[2] >= getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
+        {
+            from = i;
+            break;
+        }
+    
+
+    // find to
+    for (int i=numRegions-1; i>=0; i--)
+        if ( patchExtents[3] > getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
+        {
+            to = i;
+            break;
+        }
+
+    return ( std::max( (to - from) + 1, 0) );
+}
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::computeRegionExtents
+//
+//  Purpose:
+//      Compute extents for each region
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::computeRegionExtents(int numRanks, int height)
+{
+    int regionHeight = round((float)height/numRanks);
+    regularRegionSize = regionHeight;
+    maxRegionHeight = 0;
+    regionRankExtents.resize(numRanks*3);
+    for (int i=0; i<numRanks; i++)
+    {
+        int startRegionExtents, endRegionExtents, _currentRegionHeight;
+
+        startRegionExtents = clamp(regionHeight * i, 0, height);
+        endRegionExtents = clamp(regionHeight * i + regionHeight, 0, height);
+
+        if ( i == numRanks -1 )
+            if ( endRegionExtents < height )
+                endRegionExtents = height;
+
+        _currentRegionHeight = clamp(endRegionExtents-startRegionExtents, 0, height);
+        maxRegionHeight = std::max(maxRegionHeight, _currentRegionHeight);
+
+        regionRankExtents[i*3+0] = startRegionExtents;
+        regionRankExtents[i*3+1] = endRegionExtents;
+        regionRankExtents[i*3+2] = _currentRegionHeight;
+
+        debug5 << i << " : (start, end, region): " << startRegionExtents << ", " << endRegionExtents << ", " << _currentRegionHeight << std::endl;
+    }
+}
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::parallelDirectSendManyPatches
+//
+//  Purpose:
+//      Parallel Direct Send rendering that can blend individual patches
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+int
+avtSLIVRImageCompositor::parallelDirectSendManyPatches(std::multimap<int, imgData> imgDataHashMap, std::vector<imgMetaData> imageMetaPatchVector, int numPatches, int region[], int numRegions, int tags[2], int fullImageExtents[4])
+{
+    int myRegionHeight = 0;
+  #ifdef PARALLEL
+    debug5 << "Parallel Direct Send" << endl;
+
+    //
+    // Some initializations
+    for (int i=0; i<4; i++)
+    {
+        intermediateImageExtents[i] = 0;
+        intermediateImageBB[i] = 0;
+    }
+
+    //
+    // Find my position in region
+    compositingDone = false;
+    int myPositionInRegion = -1;
+    bool inRegion = true;
+    std::vector<int> regionVector(region, region+numRegions);
+    std::vector<int>::iterator it = std::find(regionVector.begin(), regionVector.end(), my_id);
+
+    if (it == regionVector.end())
+    {
+        inRegion = false;
+        debug5 << my_id << " ~ SHOULD NOT HAPPEN!!!!: Not found " << my_id <<  " !!!" << std::endl;
+    }
+    else
+        myPositionInRegion = it - regionVector.begin();
+
+    int width =  fullImageExtents[1]-fullImageExtents[0];
+    int height = fullImageExtents[3]-fullImageExtents[2];
+
+    debug5 << my_id << " ~ myPositionInRegion: " << myPositionInRegion << ", num_procs: " << num_procs << std::endl;
+    debug5 << "width: " << width << ", height : " << height 
+           << " | fullImageExtents: " << fullImageExtents[0] << ", " << fullImageExtents[1] << ", " << fullImageExtents[2] << ", " << fullImageExtents[3] << std::endl;
+    
+    //
+    // Region boundaries
+    computeRegionExtents(num_procs,height);
+    int myStartingHeight = getScreenRegionStart(myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
+    int myEndingHeight   = getScreenRegionEnd(myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
+    myRegionHeight = clamp( (myEndingHeight-myStartingHeight), 0, height);
+
+    debug5 << "myStartingHeight: " << myStartingHeight << ", myEndingHeight: " << myEndingHeight << ", myRegionHeight: " << myRegionHeight << std::endl;
+
+
+    // Size of one buffer
+    int sizeOneBuffer = getMaxRegionHeight() * width * 4;
+
+
+    //
+    // Determine how many patches and pixel to send to each region
+    std::vector<int> numPatchesPerRegion;
+    std::vector<int> areaPerRegion;
+    std::set<int> numOfRegions;
+
+    numPatchesPerRegion.resize(numRegions);
+    areaPerRegion.resize(numRegions);
+
+
+    // 2D array: extents for each partition
+    std::vector < std::vector<float> > extentsPerPartiton;
+    for (int i=0; i<numRegions; i++)
+        extentsPerPartiton.push_back( std::vector<float>() );
+
+    debug5 << "Parallel Direct Send ~ numPatches " << numPatches << endl;
+
+    int totalSendBufferSize = 0;
+    for (int i=0; i<numPatches; i++)
+    {
+        int _patchExtents[4];
+        imgMetaData temp;
+        temp = imageMetaPatchVector.at(i);
+
+        _patchExtents[0]=temp.screen_ll[0];   // minX
+        _patchExtents[1]=temp.screen_ur[0];   // maxX
+        _patchExtents[2]=temp.screen_ll[1];   // minY
+        _patchExtents[3]=temp.screen_ur[1];   // maxY
+
+        std::multimap<int, imgData>::iterator it = imgDataHashMap.find( i );
+
+        int from, to;
+        int numRegionIntescection = findRegionsForPatch(_patchExtents, fullImageExtents, numRegions, from, to);
+        if (numRegionIntescection <= 0)
+            continue;
+
+        debug5 << "\nParallel Direct Send ~ patch " << i << "  from:" << from << "  to:" << to << "  numPatches: " << numPatches 
+        << "   _patchExtents: " << _patchExtents[0] << ", " << _patchExtents[1] << ", " << _patchExtents[2] << ", " << _patchExtents[3] 
+        << ", fullImageExtents[2]: " << fullImageExtents[2] << ", numRegions: " <<  numRegions << ", totalSendBufferSize: " << totalSendBufferSize << endl;
+
+        for (int j=from; j<=to; j++)
+            numPatchesPerRegion[j]++;
+
+        for (int partition=from; partition<=to; partition++)
+        {
+            int _extentsYStart = std::max( _patchExtents[2], getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) );
+            int _extentsYEnd   = std::min( _patchExtents[3], getScreenRegionEnd(  partition, fullImageExtents[2], fullImageExtents[3]) );
+
+            int _area = (_extentsYEnd-_extentsYStart)*(_patchExtents[1]-_patchExtents[0]);
+            areaPerRegion[partition] += _area;
+            totalSendBufferSize += _area;
+
+            debug5 << "_patchExtents[2]: " << _patchExtents[2] << ", region start: " << getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) <<  ", _extentsYStart: " << _extentsYStart<< endl;
+            debug5 << "_patchExtents[3]: " << _patchExtents[3] << ", region end: " << getScreenRegionEnd(partition, fullImageExtents[2], fullImageExtents[3]) << ", _extentsYEnd: " << _extentsYEnd << endl;
+            debug5 << "_area " << _area << endl;
+
+            extentsPerPartiton[partition].push_back(i);
+            extentsPerPartiton[partition].push_back(_patchExtents[0]);
+            extentsPerPartiton[partition].push_back(_patchExtents[1]);
+            extentsPerPartiton[partition].push_back(_extentsYStart);
+            extentsPerPartiton[partition].push_back(_extentsYEnd);
+            extentsPerPartiton[partition].push_back(temp.eye_z);
+
+            numOfRegions.insert(partition);
+        }
+    }
+    totalSendBufferSize *= 4;                           // to account for RGBA
+    int numRegionsWithData = numOfRegions.size();
+
+    debug5 << "\nParallel Direct Send ~ creating buffers" << endl;
+
+    //
+    // Copy the data for each region for each patch
+
+    // Create buffer
+    float *sendDataBuffer = new float[totalSendBufferSize];     // contains all the data arranged by region
+    int *sendDataBufferSize = new int[numRegionsWithData]();
+    int *sendDataBufferOffsets = new int[numRegionsWithData]();
+
+    int *sendBuffer = new int[numRegions*2]();
+    int regionWithDataCount = 0;
+    int numRegionsToSend = 0;
+
+    // Populate the buffer with data
+    int dataSendBufferOffset = 0;
+    for (int i=0; i<numRegions; i++)
+    {
+        int _dataSize = 0;
+        debug5 << "Region: " << i << "  size: " << extentsPerPartiton[i].size() << std::endl;
+        for (int j=0; j<extentsPerPartiton[i].size(); j+=6)
+        {
+            int _patchID = extentsPerPartiton[i][j + 0];
+            std::multimap<int, imgData>::iterator it = imgDataHashMap.find( _patchID );
+
+            int _width = (extentsPerPartiton[i][j+2] - extentsPerPartiton[i][j+1]);
+            int _bufferSize = _width * (extentsPerPartiton[i][j+4] - extentsPerPartiton[i][j+3]) * 4;
+            int _dataOffset = extentsPerPartiton[i][j+3] - imageMetaPatchVector[_patchID].screen_ll[1];
+
+            memcpy(&sendDataBuffer[dataSendBufferOffset], &(((*it).second).imagePatch[_width * _dataOffset * 4]), _bufferSize*sizeof(float) );
+
+            dataSendBufferOffset += _bufferSize;
+            _dataSize += _bufferSize;
+        }
+
+        if (_dataSize != 0){
+            sendDataBufferSize[regionWithDataCount] = _dataSize;
+
+            regionWithDataCount ++;
+            if (regionWithDataCount != numRegionsWithData)
+                sendDataBufferOffsets[regionWithDataCount] = sendDataBufferOffsets[regionWithDataCount-1] + sendDataBufferSize[regionWithDataCount-1];
+
+            if (regionVector[i] != my_id)
+                numRegionsToSend++;
+        }
+
+        sendBuffer[i*2+0] = numPatchesPerRegion[i];
+        sendBuffer[i*2+1] = areaPerRegion[i];
+
+        debug5 << "Region: " << i << "  numPatchesPerRegion: " << sendBuffer[i*2+0] << ", sendBuffer[i*2+1]: " << sendBuffer[i*2+1] << std::endl;
+    }
+
+    
+
+    //
+    // Exchange information about size to recv
+    int *recvInfoATABuffer = new int[numRegions*2]();
+    MPI_Alltoall(sendBuffer, 2, MPI_INT,  recvInfoATABuffer, 2, MPI_INT, MPI_COMM_WORLD);
+    delete []sendBuffer;
+    sendBuffer = NULL;
+
+    debug5 << "\nParallel Direct Send ~ Exchange information about size to recv" << endl;
+
+    //
+    // Calculate buffer size needed
+    int infoBufferSize = 0;
+    int dataBufferSize = 0;
+    int numRegionsToRecvFrom = 0;
+    for (int i=0; i<numRegions; i++)
+    {
+        infoBufferSize += recvInfoATABuffer[i*2 + 0];   // number of patches per region
+        dataBufferSize += recvInfoATABuffer[i*2 + 1];   // area per region
+
+        debug5 << "From: " << i << ", #patches: " << recvInfoATABuffer[i*2 + 0] << ", " << recvInfoATABuffer[i*2 + 1] << std::endl;
+
+        if (i == my_id)
+            continue;
+
+        if (recvInfoATABuffer[i*2 + 0] != 0)
+            numRegionsToRecvFrom++;
+    }
+
+
+    //
+    // Create structure for MPI Async send/recv
+
+    // Send
+    MPI_Request *sendMetaRq = new MPI_Request[ numRegionsToSend ];
+    MPI_Status *sendMetaSt = new MPI_Status[ numRegionsToSend ];
+
+    MPI_Request *sendImageRq = new MPI_Request[ numRegionsToSend  ];
+    MPI_Status *sendImageSt = new MPI_Status[ numRegionsToSend  ];
+
+    // Recv
+    MPI_Request *recvMetaRq = NULL;
+    MPI_Status *recvMetaSt = NULL;
+
+    MPI_Request *recvImageRq = NULL;
+    MPI_Status *recvImageSt = NULL;
+
+    int recvInfoCount = 0;
+    int offsetMeta = 0;
+    int offsetData = 0;
+    
+    //
+    // Create recv buffers
+    float *recvInfoBuffer = new float[infoBufferSize*6];  // 6 - passing 6 parameters for each patch
+    float *recvDataBuffer =  new float[dataBufferSize*4]; // 4 - to account for RGBA
+
+    debug5 << "infoBufferSize: " << infoBufferSize << ", dataBufferSize: " << dataBufferSize << std::endl;
+    if (myRegionHeight != 0)
+    {
+
+        // Recv
+        recvMetaRq = new MPI_Request[ numRegionsToRecvFrom ];
+        recvMetaSt = new MPI_Status[ numRegionsToRecvFrom ];
+
+        recvImageRq = new MPI_Request[ numRegionsToRecvFrom  ];
+        recvImageSt = new MPI_Status[ numRegionsToRecvFrom  ];
+
+
+        //
+        // Async Recv for info
+        for (int i=0; i<numRegions; i++)
+        {
+            if (recvInfoATABuffer[i*2 + 0] == 0)
+                continue;
+
+            if ( regionVector[i] == my_id )
+                continue;
+
+
+            int src = regionVector[i];
+            MPI_Irecv(&recvInfoBuffer[offsetMeta], recvInfoATABuffer[i*2 + 0]*6, MPI_FLOAT, src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvInfoCount] );
+            MPI_Irecv(&recvDataBuffer[offsetData], recvInfoATABuffer[i*2 + 1]*4, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvInfoCount] );
+
+            offsetMeta += recvInfoATABuffer[i*2 + 0]*6;
+            offsetData += recvInfoATABuffer[i*2 + 1]*4;
+            recvInfoCount++;
+        }
+
+        debug5 << "Async recv setup - numRegionsToRecvFrom: " << numRegionsToRecvFrom << "   recvInfoCount: " << recvInfoCount << endl;
+    }
+
+
+    //
+    // Async Send
+    int offset = 0;
+    int sendCount = 0;
+    int mpiSendCount = 0;
+
+    for (int i=0; i<numRegions; i++)
+    {
+        if ( extentsPerPartiton[i].size() != 0 ){
+            if ( regionVector[i] == my_id )
+            {
+                memcpy( &recvInfoBuffer[offsetMeta], &extentsPerPartiton[i][0], extentsPerPartiton[i].size()*sizeof(float) );
+                memcpy( &recvDataBuffer[offsetData], &sendDataBuffer[offset],   sendDataBufferSize[ sendCount ]*sizeof(float) );
+
+                offset += sendDataBufferSize[sendCount];
+                sendCount++;
+            }
+            else
+            {
+                MPI_Isend(&extentsPerPartiton[i][0],  extentsPerPartiton[i].size(),  MPI_FLOAT, region[i], tags[0], MPI_COMM_WORLD, &sendMetaRq[mpiSendCount]);
+                MPI_Isend(&sendDataBuffer[offset], sendDataBufferSize[ sendCount ], MPI_FLOAT, region[i], tags[1], MPI_COMM_WORLD, &sendImageRq[mpiSendCount]);
+
+                offset += sendDataBufferSize[sendCount];
+                sendCount++;
+                mpiSendCount++;
+            }
+        }
+    }
+
+    debug5 << "Asyn send setup done ~ numRegionsToSend: " << numRegionsToSend << "  mpiSendCount: " << mpiSendCount << endl;
+
+    if (myRegionHeight != 0)
+    {
+        debug5 << "MPI_Waitall ..." << std::endl;
+        MPI_Waitall(recvInfoCount, recvImageRq, recvImageSt);   // Means that we have reveived everything!
+
+        debug5 << "MAPI_WAITALL done!" << std::endl;
+
+        if (recvInfoATABuffer != NULL)
+            delete []recvInfoATABuffer;
+        recvInfoATABuffer = NULL;
+
+
+        debug5 << "Sorting..." << std::endl;
+
+        //
+        // Sort the data
+        std::multimap<float,int> patchData;
+        std::vector<int> patchOffset;
+        patchOffset.push_back(0);
+        for (int i=0; i<infoBufferSize; i++)
+        {
+            patchData.insert( std::pair<float,int> (recvInfoBuffer[i*6 + 5],i));
+            int _patchSize = (recvInfoBuffer[i*6 + 4]-recvInfoBuffer[i*6 + 3]) * (recvInfoBuffer[i*6 + 2]-recvInfoBuffer[i*6 + 1]) * 4;
+            int _offset = patchOffset[i] + _patchSize;
+
+            if (i != infoBufferSize-1)
+                patchOffset.push_back(_offset);
+        }
+
+
+        //
+        // Create buffer for current region
+        intermediateImageBB[0] = intermediateImageExtents[0] = fullImageExtents[0];
+        intermediateImageBB[1] = intermediateImageExtents[1] = fullImageExtents[1];
+        intermediateImageBB[2] = intermediateImageExtents[2] = myStartingHeight;
+        intermediateImageBB[3] = intermediateImageExtents[3] = myEndingHeight;
+
+        intermediateImage = new float[width * (myEndingHeight-myStartingHeight) * 4]();
+
+
+        //
+        // Blend
+        int numBlends = 0;
+        for (std::multimap<float,int>::iterator it=patchData.begin(); it!=patchData.end(); ++it)
+        {
+            int _id = (*it).second;
+            int _extents[4];
+            _extents[0] = recvInfoBuffer[_id*6 + 1];
+            _extents[1] = recvInfoBuffer[_id*6 + 2];
+            _extents[2] = recvInfoBuffer[_id*6 + 3];
+            _extents[3] = recvInfoBuffer[_id*6 + 4];
+
+            blendFrontToBack(&recvDataBuffer[ patchOffset[_id] ], _extents, _extents, intermediateImage, intermediateImageExtents);
+
+            //writeArrayToPPM("/home/pascal/Desktop/debugImages/blending_" + toStr(my_id) + "_"+ toStr(numBlends), intermediateImage, intermediateImageExtents[1]-intermediateImageExtents[0], intermediateImageExtents[3]-intermediateImageExtents[2]);
+            numBlends++;
+        }
+
+        if (numBlends == 0)
+            intermediateImageBB[0]=intermediateImageBB[1]=intermediateImageBB[2]=intermediateImageBB[3] = 0;
+    }
+
+
+    MPI_Waitall(numRegionsToSend, sendImageRq, sendImageSt);   // Means that we have sent everything!
+
+
+    if (myRegionHeight == 0)
+        compositingDone = true;
+
+    //
+    // Cleanup
+    if (sendDataBuffer != NULL)
+        delete []sendDataBuffer;
+    sendDataBuffer = NULL;
+
+    if (sendDataBufferSize != NULL)
+        delete []sendDataBufferSize;
+    sendDataBufferSize = NULL;
+
+    if (sendDataBufferOffsets != NULL)
+        delete []sendDataBufferOffsets;
+    sendDataBufferOffsets = NULL;
+
+
+    if (sendMetaRq != NULL)
+        delete []sendMetaRq;
+
+    if (sendImageRq != NULL)
+        delete []sendImageRq;
+
+    if (sendMetaSt != NULL)
+        delete []sendMetaSt;
+
+    if (sendImageSt != NULL)
+        delete []sendImageSt;
+
+    sendMetaRq = NULL;
+    sendImageRq = NULL;
+    sendMetaSt = NULL;
+    sendImageSt = NULL;
+
+    if (myRegionHeight != 0)
+    {
+        if (recvInfoBuffer != NULL)
+            delete []recvInfoBuffer;
+        recvInfoBuffer = NULL;
+
+        if (recvDataBuffer != NULL)
+            delete []recvDataBuffer;
+        recvDataBuffer = NULL;
+
+        if (recvMetaRq != NULL)
+            delete []recvMetaRq;
+
+        if (recvMetaSt != NULL)
+            delete []recvMetaSt;
+
+        if (recvImageRq != NULL)
+            delete []recvImageRq;
+
+        if (recvImageSt != NULL)
+            delete []recvImageSt;
+
+        recvMetaRq = NULL;
+        recvImageRq = NULL;
+        recvMetaSt = NULL;
+        recvImageSt = NULL;
+    }
+
+    debug5 << "All PDS done" << std::endl;
+  #endif
+    return myRegionHeight;
+}
+
+
+
+
+// ****************************************************************************
+//  Method: avtSLIVRImageCompositor::gatherImages
+//
+//  Purpose:
+//      Gather images from Parallel Direct Send
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImageCompositor::gatherImages(int regionGather[], int totalNumRanks, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight)
+{
+  #ifdef PARALLEL
+    debug5 << "gatherImages starting... totalNumRanks: " << totalNumRanks << ", compositingDone: " << compositingDone
+           << ", imgExtents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
+
+    for (int i=0; i<4; i++)
+        finalImageExtents[i] = finalBB[i] = 0;
+
+    if (my_id == 0)
+    {
+        int width =  fullImageExtents[1]-fullImageExtents[0];
+        int height = fullImageExtents[3]-fullImageExtents[2];
+
+        debug5 << "Gather Images at 0, final size: " << fullImageExtents[1]-fullImageExtents[0] << " x " << fullImageExtents[3]-fullImageExtents[2] << std::endl;
+
+        //
+        // Receive at root/display node!
+        imgBuffer = new float[width*height*4];
+        finalImageExtents[0] = fullImageExtents[0];
+        finalImageExtents[1] = fullImageExtents[1];
+        finalImageExtents[2] = fullImageExtents[2];
+        finalImageExtents[3] = fullImageExtents[3];
+
+        int numRegionsWithData = 0;
+        int numToRecv = 0;
+        for (int i=0; i<totalNumRanks; i++)
+        {
+            if (getRegionSize(i) != 0)
+                numRegionsWithData++;
+        }
+        numToRecv = numRegionsWithData;
+
+        // remove itself from the recv
+        if (getRegionSize(my_id) != 0) 
+            numToRecv--;
+
+
+        //
+        // Create buffers for async reciving
+        MPI_Request *recvImageRq = new MPI_Request[ numToRecv ];
+        MPI_Status  *recvImageSt = new MPI_Status[ numToRecv ];
+
+        int lastBufferSize    = getRegionSize(totalNumRanks-1) * width * 4;
+        int regularBufferSize = regularRegionSize * width * 4;
+
+        debug5 << "numToRecv: " << numToRecv << ", numRegionsWithData: " << numRegionsWithData << std::endl;
+        debug5 << "regularBufferSize: " << regularBufferSize << ", lastBufferSize: " << lastBufferSize << std::endl;
+
+        // Async Recv
+        int recvCount=0;
+        for (int i=0; i<numRegionsWithData; i++)
+        {
+            int src = regionGather[i];
+
+            if (src == my_id)
+                continue;
+
+            if (i == totalNumRanks-1)
+            {
+                if (lastBufferSize != 0)
+                {
+                    MPI_Irecv(&imgBuffer[i*regularBufferSize], lastBufferSize,     MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+                }
+            }
+            else
+                MPI_Irecv(&imgBuffer[i*regularBufferSize], regularBufferSize,  MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+            
+
+            debug5 << i << " ~ recvCount: " << recvCount << std::endl;
+            recvCount++;
+        }
+
+        if (compositingDone == false)   // If root has data for the final image
+            placeInImage(inputImg, imgExtents, imgBuffer, finalImageExtents);
+
+        MPI_Waitall(numToRecv, recvImageRq, recvImageSt);
+        compositingDone = true;
+
+        delete []recvImageRq;
+        recvImageRq = NULL;
+        delete []recvImageSt;
+        recvImageSt = NULL;
+    }
+    else
+    {
+        if (compositingDone == false)   
+        {
+            int imgSize = (imgExtents[1]-imgExtents[0]) * (imgExtents[3]-imgExtents[2]) * 4;
+            debug5 << "imgSize: " << imgSize << std::endl;
+
+            MPI_Send(inputImg, imgSize, MPI_FLOAT, 0, tag, MPI_COMM_WORLD);
+            compositingDone = true;
+        }
+    }
+
+  #endif
+}
diff --git a/avt/Filters/avtSLIVRImageCompositor.h b/avt/Filters/avtSLIVRImageCompositor.h
new file mode 100644
index 0000000000..b413d6ffa5
--- /dev/null
+++ b/avt/Filters/avtSLIVRImageCompositor.h
@@ -0,0 +1,163 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                          avtSLIVRImageCompositor.h                        //
+// ************************************************************************* //
+
+#ifndef AVT_SLIVR_IMAGE_COMPOSITOR_H
+#define AVT_SLIVR_IMAGE_COMPOSITOR_H
+
+#include <filters_exports.h>
+#include <pipeline_exports.h>
+
+#include <avtSLIVRCommon.h>
+
+#include <algorithm>
+#include <string>
+#include <map>
+
+#ifdef PARALLEL
+#   include <mpi.h>
+#endif
+
+#define MSG_DATA 100
+#define MSG_RESULT 101
+
+const int SEND = 1;
+const int RECEIVE = 2;
+
+struct imageBuffer{
+    float *image;
+    float depth;
+};
+
+// ****************************************************************************
+//  Class: avtRayTracer
+//
+//  Purpose:
+//      Does the composition for Ray casting: SLIVR
+//
+//  Programmer: Pascal Grosset
+//  Creation:   Spetember 20, 2013
+//
+// ****************************************************************************
+
+class avtSLIVRImageCompositor
+{
+    int num_procs;
+    int my_id;
+    int totalPatches;
+    bool compositingDone;
+
+    // image sizing for compositing
+    int maxRegionHeight;
+    int regularRegionSize;
+    std::vector<int>regionRankExtents;
+
+    void placeInImage(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4]);
+    void colorImage(float *& srcImage, int widthSrc, int heightSrc, float _color[4]);
+    void updateBoundingBox(int currentBoundingBox[4], int imageExtents[4]);
+
+    void gatherDepthAtRoot(int numlocalPatches, float *localPatchesDepth, int &totalPatches, int *& patchCountPerRank, float *& allPatchesDepth);
+    void blendWithBackground(float *_image, int extents[4], float backgroundColor[4]);
+
+    void blendFrontToBack(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4]);
+    void blendBackToFront(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4]);
+
+    void blendFrontToBack(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4]);
+    void blendBackToFront(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4]);
+
+    
+
+    void computeRegionExtents(int numRanks, int height);
+    
+    int getRegularRegionSize(){ return regularRegionSize; } 
+    int getRegionStart(int region){ return regionRankExtents[region*3+0]; }
+    int getRegionEnd(int region){ return regionRankExtents[region*3+1]; }
+    int getRegionSize(int region){ return regionRankExtents[region*3+2]; }
+    int getMaxRegionHeight(){ return maxRegionHeight; }
+    
+    int getScreenRegionStart(int region, int screenImgMinY, int screenImgMaxY){
+        return clamp( getRegionStart(region)+screenImgMinY, screenImgMinY, screenImgMaxY); 
+    }
+    int getScreenRegionEnd(int region, int screenImgMinY, int screenImgMaxY){
+        return clamp( getRegionEnd(region)+screenImgMinY, screenImgMinY, screenImgMaxY); 
+    }
+
+    
+
+public:
+    float *imgBuffer;                   // Final image is here
+    int finalImageExtents[4];
+    int finalBB[4];
+
+    float *intermediateImage;           // Intermediate image, e.g. in parallel direct send
+    int intermediateImageExtents[4];
+    int intermediateImageBB[4];
+
+
+    avtSLIVRImageCompositor();
+    ~avtSLIVRImageCompositor();
+
+    virtual const char *GetType(void) { return "avtSLIVRImageCompositor"; };
+    virtual const char *GetDescription(void) { return "Doing compositing for ray casting SLIVR";};
+
+    int clamp(int value, int _min, int _max){ return std::max( std::min(value,_max), _min); }
+    float clamp(float x){ return std::min( std::max(x, 0.0f), 1.0f); }
+    
+    void barrier();
+
+    int GetNumProcs(){ return num_procs;};
+    int GetMyId(){ return my_id;};
+
+    void getcompositedImage(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage);  // get the final composited image
+    void regionAllocation(int numMPIRanks, int *& regions);
+
+    int findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to);
+
+    // Both currently unused but good for simple testing
+    void serialDirectSend(int numPatches, float *localPatchesDepth, int *extents, float *imgData, float backgroundColor[4], int width, int height);
+    void parallelDirectSend(float *imgData, int imgExtents[4], int region[], int numRegions, int tags[2], int fullImageExtents[4]);
+    
+    int parallelDirectSendManyPatches(std::multimap<int, imgData> imgDataHashMap, std::vector<imgMetaData> imageMetaPatchVector, int numPatches, int region[], int numRegions, int tags[2], int fullImageExtents[4]);
+    void gatherImages(int regionGather[], int numToRecv, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight);
+};
+
+
+#endif
diff --git a/avt/Filters/avtSLIVRRayTracer.C b/avt/Filters/avtSLIVRRayTracer.C
index d4eef7ac12..68b393ec9b 100644
--- a/avt/Filters/avtSLIVRRayTracer.C
+++ b/avt/Filters/avtSLIVRRayTracer.C
@@ -85,7 +85,6 @@ bool SLIVRsortImgMetaDataByEyeSpaceDepth(imgMetaData const& before, imgMetaData
 
 avtSLIVRRayTracer::avtSLIVRRayTracer() : avtRayTracerBase()
 {
-
     panPercentage[0] = 0;
     panPercentage[1] = 0;
     lighting = false;
@@ -250,7 +249,6 @@ avtSLIVRRayTracer::Execute()
     extractor.SetTransferFn(transferFn1D);
     extractor.SetInput(trans.GetOutput());
 
-
     //
     // Ray casting: SLIVR ~ Before Rendering
     //
@@ -271,6 +269,7 @@ avtSLIVRRayTracer::Execute()
 
     //
     // Camera Settings
+    //
     vtkCamera *sceneCam = vtkCamera::New();
     sceneCam->SetPosition(view.camera[0],view.camera[1],view.camera[2]);
     sceneCam->SetFocalPoint(view.focus[0],view.focus[1],view.focus[2]);
diff --git a/avt/Filters/avtSLIVRRayTracer.h b/avt/Filters/avtSLIVRRayTracer.h
index cd1b4abfc7..7082831d3a 100644
--- a/avt/Filters/avtSLIVRRayTracer.h
+++ b/avt/Filters/avtSLIVRRayTracer.h
@@ -46,7 +46,7 @@
 #include <filters_exports.h>
 
 #include <avtRayTracerBase.h>
-#include <avtImgCommunicator.h>
+#include <avtSLIVRImageCompositor.h>
 
 class   vtkMatrix4x4;
 
@@ -116,7 +116,7 @@ class AVTFILTERS_API avtSLIVRRayTracer : public avtRayTracerBase
 
     virtual void          Execute(void);
 
-    avtImgCommunicator    imgComm;
+    avtSLIVRImageCompositor    imgComm;
     bool                  lighting;
     double                lightPosition[4];
     double                lightDirection[3];
diff --git a/avt/Filters/avtSLIVRSamplePointExtractor.C b/avt/Filters/avtSLIVRSamplePointExtractor.C
index 6c15476ff7..592adf0878 100644
--- a/avt/Filters/avtSLIVRSamplePointExtractor.C
+++ b/avt/Filters/avtSLIVRSamplePointExtractor.C
@@ -124,7 +124,10 @@ avtSLIVRSamplePointExtractor::avtSLIVRSamplePointExtractor(int w, int h, int d)
     : avtSamplePointExtractorBase(w, h, d)
 {
     slivrVoxelExtractor = NULL;
+
     patchCount = 0;
+    imageMetaPatchVector.clear();
+    imgDataHashMap.clear();
 
     modelViewProj = vtkMatrix4x4::New();
 
@@ -177,7 +180,6 @@ avtSLIVRSamplePointExtractor::~avtSLIVRSamplePointExtractor()
     delImgPatches();
 }
 
-
 // ****************************************************************************
 //  Method: avtSLIVRSamplePointExtractor::SetUpExtractors
 //
@@ -239,8 +241,9 @@ avtSLIVRSamplePointExtractor::SetUpExtractors(void)
     {
         delete slivrVoxelExtractor;
     }
-    slivrVoxelExtractor = new avtSLIVRVoxelExtractor(width, height, depth, volume,cl);
-//    slivrVoxelExtractor->SetJittering(jitter);
+    slivrVoxelExtractor = new avtSLIVRVoxelExtractor(width, height, depth,
+													 volume,cl);
+    //slivrVoxelExtractor->SetJittering(jitter);
     if (shouldDoTiling)
     {
         slivrVoxelExtractor->Restrict(width_min, width_max-1,
@@ -249,6 +252,32 @@ avtSLIVRSamplePointExtractor::SetUpExtractors(void)
 }
 
 // ****************************************************************************
+//  Method: avtSLIVRSamplePointExtractor::InitSampling
+//
+//  Purpose:
+//      Initialize sampling, called by base class ExecuteTree method before.
+//      the actual iteration starts. This function might be useful for
+//      children classes
+//
+//  Arguments:
+//      dt      The dataset tree that should be processed.
+//
+//  Programmer: Qi WU 
+//  Creation:   April 18, 2018
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtSLIVRSamplePointExtractor::InitSampling(avtDataTree_p dt)
+{
+    patchCount = 0;
+    imageMetaPatchVector.clear();
+    imgDataHashMap.clear();
+}
+
+// ****************************************************************************
 //  Method: avtSLIVRSamplePointExtractor::DoSampling
 //
 //  Purpose:
@@ -268,18 +297,9 @@ avtSLIVRSamplePointExtractor::SetUpExtractors(void)
 void
 avtSLIVRSamplePointExtractor::DoSampling(vtkDataSet *ds, int idx)
 {
-    //initialize sampling state
-    patchCount = 0;
-    imageMetaPatchVector.clear();
-    imgDataHashMap.clear();
-
     double _scalarRange[2];
     ds->GetScalarRange(_scalarRange);
 
-    double _tfRange[2];
-    _tfRange[0] = transferFn1D->GetMin();
-    _tfRange[1] = transferFn1D->GetMax();
-
     double _tfVisibleRange[2];
     _tfVisibleRange[0] = transferFn1D->GetMinVisibleScalar();
     _tfVisibleRange[1] = transferFn1D->GetMaxVisibleScalar();
@@ -322,7 +342,7 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
 {
     StackTimer t0("avtSLIVRSamplePointExtractor::RasterBasedSample");
 
-    //debug5 << PAR_Rank() << " avtSLIVRSamplePointExtractor::RasterBasedSample  " << num << std::endl;
+    
     if (ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
     {
         avtDataAttributes &atts = GetInput()->GetInfo().GetAttributes();
@@ -339,15 +359,16 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
             varsizes.push_back(samples->GetVariableSize(i));
         }
 
-        // Use SLIVR mass voxel extractor.
-
         //
         // Compositing Setup
+		//
         slivrVoxelExtractor->SetGridsAreInWorldSpace(
             rectilinearGridsAreInWorldSpace, viewInfo, aspect, xform);
 
-        slivrVoxelExtractor->setDepthBuffer(depthBuffer, bufferExtents[1]*bufferExtents[3]);
-        slivrVoxelExtractor->setRGBBuffer(rgbColorBuffer, bufferExtents[1],bufferExtents[3]);
+        slivrVoxelExtractor->setDepthBuffer(depthBuffer,
+									 bufferExtents[1]*bufferExtents[3]);
+        slivrVoxelExtractor->setRGBBuffer(rgbColorBuffer,
+									 bufferExtents[1],bufferExtents[3]);
         slivrVoxelExtractor->setBufferExtents(bufferExtents);
 
         slivrVoxelExtractor->SetViewDirection(view_direction);
@@ -363,11 +384,9 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
         slivrVoxelExtractor->SetMatProperties(materialProperties);
         slivrVoxelExtractor->SetTransferFn(transferFn1D);
 
-        //debug5 << PAR_Rank() << " avtSLIVRSamplePointExtractor::RasterBasedSample extract ...  " << num << std::endl;
-
-        slivrVoxelExtractor->Extract((vtkRectilinearGrid *) ds, varnames, varsizes);
 
-        //debug5 << PAR_Rank() << " avtSLIVRSamplePointExtractor::RasterBasedSample extract done!" << num << std::endl;
+        slivrVoxelExtractor->Extract((vtkRectilinearGrid *) ds,
+									 varnames, varsizes);
 
         //
         // Get rendering results
@@ -375,7 +394,12 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
         imgMetaData      tmpImageMetaPatch;
         tmpImageMetaPatch = initMetaPatch(patchCount);
 
-        slivrVoxelExtractor->getImageDimensions(tmpImageMetaPatch.inUse, tmpImageMetaPatch.dims, tmpImageMetaPatch.screen_ll, tmpImageMetaPatch.screen_ur, tmpImageMetaPatch.eye_z, tmpImageMetaPatch.clip_z);
+        slivrVoxelExtractor->getImageDimensions(tmpImageMetaPatch.inUse,
+												tmpImageMetaPatch.dims,
+												tmpImageMetaPatch.screen_ll,
+												tmpImageMetaPatch.screen_ur,
+												tmpImageMetaPatch.eye_z,
+												tmpImageMetaPatch.clip_z);
         if (tmpImageMetaPatch.inUse == 1)
         {
             tmpImageMetaPatch.avg_z = tmpImageMetaPatch.eye_z;
@@ -385,11 +409,14 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
             imgData tmpImageDataHash;
             tmpImageDataHash.procId = tmpImageMetaPatch.procId;
             tmpImageDataHash.patchNumber = tmpImageMetaPatch.patchNumber;
-            tmpImageDataHash.imagePatch = new float[ tmpImageMetaPatch.dims[0]*tmpImageMetaPatch.dims[1] * 4 ];
+            tmpImageDataHash.imagePatch =
+				new float[tmpImageMetaPatch.dims[0] *
+						  tmpImageMetaPatch.dims[1] * 4];
 
             slivrVoxelExtractor->getComputedImage(tmpImageDataHash.imagePatch);
-            imgDataHashMap.insert( std::pair<int, imgData> (tmpImageDataHash.patchNumber , tmpImageDataHash) );
-            //writeArrayToPPM("/home/pascal/Desktop/debugImages/local_" + toStr(tmpImageMetaPatch.procId) + "_"+ toStr(tmpImageMetaPatch.patchNumber), tmpImageDataHash.imagePatch, tmpImageMetaPatch.dims[0], tmpImageMetaPatch.dims[1]);
+            imgDataHashMap.insert
+				(std::pair<int, imgData>(tmpImageDataHash.patchNumber,
+										 tmpImageDataHash));
 
             patchCount++;
         }
diff --git a/avt/Filters/avtSLIVRSamplePointExtractor.h b/avt/Filters/avtSLIVRSamplePointExtractor.h
index 371d231158..e4e13d9209 100644
--- a/avt/Filters/avtSLIVRSamplePointExtractor.h
+++ b/avt/Filters/avtSLIVRSamplePointExtractor.h
@@ -52,7 +52,7 @@
 
 #include <vtkMatrix4x4.h>
 
-#include <imgMetaData.h>
+#include <avtSLIVRCommon.h>
 
 class  avtSLIVRVoxelExtractor;
 
@@ -163,10 +163,13 @@ class AVTFILTERS_API avtSLIVRSamplePointExtractor
     typedef std::multimap<int, imgData>::iterator iter_t;
 
   protected:
+    virtual void              InitSampling(avtDataTree_p dt);
     virtual void              DoSampling(vtkDataSet *, int);
     virtual void              SetUpExtractors(void);
     virtual void              SendJittering(void);
-    virtual bool              FilterUnderstandsTransformedRectMesh(void);
+    virtual bool              FilterUnderstandsTransformedRectMesh(void);   
+    void                      RasterBasedSample(vtkDataSet *, int num=0);
+    imgMetaData               initMetaPatch(int id);    // initialize a patch
 
     double                    minMaxSpatialBounds[6];
     double                    avgPatchExtents[3];
@@ -192,9 +195,6 @@ class AVTFILTERS_API avtSLIVRSamplePointExtractor
     double                    lightDirection[3];
     double                    materialProperties[4];
 
-    imgMetaData               initMetaPatch(int id);    // initialize a patch
-
-    void                      RasterBasedSample(vtkDataSet *, int num=0);
 };
 
 
diff --git a/avt/Filters/avtSLIVRVoxelExtractor.C b/avt/Filters/avtSLIVRVoxelExtractor.C
index a35f629c9b..31d376a0ae 100644
--- a/avt/Filters/avtSLIVRVoxelExtractor.C
+++ b/avt/Filters/avtSLIVRVoxelExtractor.C
@@ -37,7 +37,7 @@
 *****************************************************************************/
 
 // ************************************************************************* //
-//                            avtSLIVRVoxelExtractor.C                        //
+//                            avtSLIVRVoxelExtractor.C                       //
 // ************************************************************************* //
 
 #include <avtSLIVRVoxelExtractor.h>
diff --git a/avt/Filters/avtSLIVRVoxelExtractor.h b/avt/Filters/avtSLIVRVoxelExtractor.h
index 3e17c52e5b..3fd3dd3133 100644
--- a/avt/Filters/avtSLIVRVoxelExtractor.h
+++ b/avt/Filters/avtSLIVRVoxelExtractor.h
@@ -46,7 +46,7 @@
 #include <filters_exports.h>
 
 #include <avtVoxelExtractor.h>
-
+#include <avtSLIVRCommon.h>
 #include <avtOpacityMap.h>
 
 #include <DebugStream.h>
@@ -59,7 +59,7 @@ class     vtkMatrix4x4;
 #include <stdlib.h>
 #include <stdio.h>
 #include <algorithm>
-#include "imgMetaData.h"
+
 
 // ****************************************************************************
 //  Class: avtSLIVRVoxelExtractor
diff --git a/avt/Filters/avtSamplePointExtractorBase.C b/avt/Filters/avtSamplePointExtractorBase.C
index 15a70c1348..f19679fcfb 100644
--- a/avt/Filters/avtSamplePointExtractorBase.C
+++ b/avt/Filters/avtSamplePointExtractorBase.C
@@ -207,7 +207,8 @@ avtSamplePointExtractorBase::SetRectilinearGridsAreInWorldSpace(bool val,
 // ****************************************************************************
 
 void
-avtSamplePointExtractorBase::RestrictToTile(int wmin, int wmax, int hmin, int hmax)
+avtSamplePointExtractorBase::RestrictToTile(int wmin, int wmax,
+											int hmin, int hmax)
 {
     shouldDoTiling = true;
     width_min  = wmin;
@@ -338,28 +339,38 @@ struct datatree_childindex
 void
 avtSamplePointExtractorBase::ExecuteTree(avtDataTree_p dt)
 {
+	/////////////////////////
+	// Check memory before //
+	/////////////////////////
+	if (DebugStream::Level5())
+	{ 
+		unsigned long m_size, m_rss;
+		avtMemory::GetMemorySize(m_size, m_rss);
+		debug5 << "RAR_Rank: " << PAR_Rank() << " "
+			   << GetType() << "::ExecuteTree " 
+			   << " Initial Memory Usage: "
+			   << m_size << " rss (MB): "
+			   << m_rss/(1024*1024) << endl;
+	}
+
+	//
+	// Start timing
+	//
     StackTimer t0(std::string(GetType()) + std::string("::ExecuteTree"));
 
-    //check memory
-    unsigned long m_size, m_rss;
-    avtMemory::GetMemorySize(m_size, m_rss);
-    debug5 << PAR_Rank() << " ~ " << GetType() << "::ExecuteTree  .. .  " 
-           << "    Memory use before: " << m_size << "  rss (MB): "
-           << m_rss/(1024*1024) << endl;
-
+	//
+	// Call this function for initialization if necessary by children classes
+	//
+	InitSampling(dt);	
 
     if (*dt == NULL || (dt->GetNChildren() <= 0 && (!(dt->HasData()))))
         return;
 
-    debug5 << " ~ " << GetType() << "::dt->GetNChildren()  "
-           << dt->GetNChildren() << endl;
-
     //
     // Process tree
-    std::stack<datatree_childindex*> nodes;
-
-    //iterative depth-first sampling
-    nodes.push(new datatree_childindex(dt,0));
+	//
+    std::stack<datatree_childindex*> nodes;    
+    nodes.push(new datatree_childindex(dt,0)); //iterative depth-first sampling
     while (!nodes.empty())
     {
         datatree_childindex *ci=nodes.top();
@@ -372,7 +383,8 @@ avtSamplePointExtractorBase::ExecuteTree(avtDataTree_p dt)
             {
                 if (ch->ChildIsPresent(i))
                 {
-                    if (*ch == NULL || (ch->GetNChildren() <= 0 && (!(ch->HasData()))))
+                    if (*ch == NULL || (ch->GetNChildren() <= 0 &&
+										(!(ch->HasData()))))
                         continue;
                     nodes.push(new datatree_childindex(ch->GetChild(i),i));
                 }
@@ -381,15 +393,12 @@ avtSamplePointExtractorBase::ExecuteTree(avtDataTree_p dt)
             continue;
         }
 
-        //do the work
         nodes.pop();
 
         if (*ch == NULL || (ch->GetNChildren() <= 0 && (!(ch->HasData()))))
             continue;
 
-        //
         // Get the dataset for this leaf in the tree.
-        //
         vtkDataSet *ds = ch->GetDataRepresentation().GetDataVTK();
 
         // Performed by derived classes
@@ -399,12 +408,19 @@ avtSamplePointExtractorBase::ExecuteTree(avtDataTree_p dt)
         currentNode++;
     }
 
-
-    //check memory after
-    avtMemory::GetMemorySize(m_size, m_rss);
-    debug5 << PAR_Rank() << " ~ Memory use after: " << m_size
-           << "  rss (MB): " << m_rss/(1024*1024)
-           <<  "   ... " << GetType() << "::ExecuteTree done@!!!" << endl;
+	/////////////////////////
+	// Check memory before //
+	/////////////////////////
+	if (DebugStream::Level5())
+	{ 
+		unsigned long m_size, m_rss;
+		avtMemory::GetMemorySize(m_size, m_rss);
+		debug5 << "RAR_Rank: " << PAR_Rank() << " "
+			   << GetType() << "::ExecuteTree " 
+			   << " Final Memory Usage: "
+			   << m_size << " rss (MB): "
+			   << m_rss/(1024*1024) << endl;
+	}
 }
 
 
diff --git a/avt/Filters/avtSamplePointExtractorBase.h b/avt/Filters/avtSamplePointExtractorBase.h
index ce7fc8b00c..333ebce31b 100644
--- a/avt/Filters/avtSamplePointExtractorBase.h
+++ b/avt/Filters/avtSamplePointExtractorBase.h
@@ -186,12 +186,14 @@ class AVTFILTERS_API avtSamplePointExtractorBase
       int                               nVars;
     } LoadingInfo;
 
-    void                      GetLoadingInfoForArrays(vtkDataSet *, LoadingInfo &);
+    void                      GetLoadingInfoForArrays(vtkDataSet *,
+													  LoadingInfo &);
 
     virtual bool              FilterUnderstandsTransformedRectMesh() = 0;
     virtual void              SetUpExtractors(void) = 0;
     virtual void              SendJittering(void) = 0;
     virtual void              DoSampling(vtkDataSet *ds, int idx) = 0;
+	virtual void              InitSampling(avtDataTree_p dt) {};
 
 };
 
diff --git a/avt/Pipeline/Data/avtOpacityMap.C b/avt/Pipeline/Data/avtOpacityMap.C
index a35f50db81..1bf94c14bd 100644
--- a/avt/Pipeline/Data/avtOpacityMap.C
+++ b/avt/Pipeline/Data/avtOpacityMap.C
@@ -78,7 +78,7 @@ avtOpacityMap::avtOpacityMap(int te)
     tableEntries = te;
     table = new RGBA[tableEntries];
   
-    transferFn1D = new _RGBA[tableEntries]();
+    transferFn1D = new RGBAF[tableEntries]();
     // RGBA contains a padded byte after the B and before the A.  Use a memset
     // to make sure this inaccessible byte is initialized.  This will allow
     // us to avoid purify issues.
@@ -104,8 +104,8 @@ avtOpacityMap::avtOpacityMap(const avtOpacityMap &obj)
     tableEntries = obj.tableEntries;
     table = new RGBA[tableEntries];
     memcpy(table, obj.table, tableEntries * sizeof(RGBA));
-    transferFn1D = new _RGBA[tableEntries];
-    memcpy(transferFn1D, obj.transferFn1D, tableEntries * sizeof(_RGBA));
+    transferFn1D = new RGBAF[tableEntries];
+    memcpy(transferFn1D, obj.transferFn1D, tableEntries * sizeof(RGBAF));
     min = obj.min;
     max = obj.max;
     range = obj.range;
@@ -122,8 +122,8 @@ void avtOpacityMap::operator = (const avtOpacityMap &obj)
     tableEntries = obj.tableEntries;
     table = new RGBA[tableEntries];
     memcpy(table, obj.table, tableEntries * sizeof(RGBA));
-    transferFn1D = new _RGBA[tableEntries];
-    memcpy(transferFn1D, obj.transferFn1D, tableEntries * sizeof(_RGBA));
+    transferFn1D = new RGBAF[tableEntries];
+    memcpy(transferFn1D, obj.transferFn1D, tableEntries * sizeof(RGBAF));
     min = obj.min;
     max = obj.max;
     range = obj.range;
@@ -270,7 +270,7 @@ avtOpacityMap::SetTable(unsigned char *arr, int te, double attenuation)
 
     tableEntries = te;
     table = new RGBA[tableEntries];
-    transferFn1D = new _RGBA[tableEntries];
+    transferFn1D = new RGBAF[tableEntries];
     for (int i = 0 ; i < tableEntries ; i++)
     {
         table[i].R = arr[i*4];
@@ -378,7 +378,7 @@ avtOpacityMap::SetTableFloat(unsigned char *arr, int te, double attenuation, flo
     }
 
     tableEntries = te;
-    transferFn1D = new _RGBA[tableEntries]();
+    transferFn1D = new RGBAF[tableEntries]();
     minVisibleScalarIndex =  maxVisibleScalarIndex = -1;
     for (int i = 0 ; i < tableEntries ; i++)
     {
@@ -392,21 +392,76 @@ avtOpacityMap::SetTableFloat(unsigned char *arr, int te, double attenuation, flo
         transferFn1D[i].A = alpha;
         if (alpha != 0 && minVisibleScalarIndex == -1){
             minVisibleScalarIndex = i;
-            //debug5 << "starting alpha = 0 at i= " << i << std::endl;
         }
 
-        //debug5 << i << " : " << transferFn1D[i].R << ", " << transferFn1D[i].G << ", " << transferFn1D[i].B <<  ", " << transferFn1D[i].A << std::endl;
     }
     for (int i=tableEntries-1; i>=0; i--)
     {
         if (transferFn1D[i].A != 0 && maxVisibleScalarIndex == -1){
             maxVisibleScalarIndex = i;
-            //debug5 << "ending alpha = 0 at i= " << i << std::endl;
         }
     }
 
+    //
+    // We need to set the intermediate vars again since the table size has
+    // potentially changed.
+    //
+    SetIntermediateVars();
+}
+
+
+// ****************************************************************************
+//  Method: avtOpacityMap::SetTableFloatNOC
+//
+//  Purpose:
+//      A version of function SetTableFloat that does not apply the opacity
+//      correction term to it
+//
+//  Arguments:
+//      arr             The new table in RGBA format.
+//      te              The number of entries in arr.
+//      attenuation     The attenuation parameter specified
+//      over            Reducing based on the number of slices
+//
+//  Programmer: Qi WU
+//  Creation:   Sat Jun 10 22:21:27 MST 2018
+//
+// ****************************************************************************
+void
+avtOpacityMap::SetTableFloatNOC(unsigned char *arr, int te, double attenuation)
+{
+    if (attenuation < -1. || attenuation > 1.)
+    {
+        debug1 << "Bad attenuation value " << attenuation << std::endl;
+        EXCEPTION0(ImproperUseException);
+    }
+
+    if (transferFn1D != NULL) { delete [] transferFn1D; }
 
-    //debug5 << "minVisibleScalarIndex: " << minVisibleScalarIndex << "   maxVisibleScalarIndex: " << maxVisibleScalarIndex << std::endl;
+    tableEntries = te;
+    transferFn1D = new RGBAF[tableEntries]();
+    minVisibleScalarIndex = maxVisibleScalarIndex = -1;
+
+    for (int i = 0 ; i < tableEntries ; i++)
+    {
+	double bp = tan(1.570796327 * (0.5 - attenuation*0.49999));
+	double alpha = pow((float) arr[i*4+3]/255.0f, (float)bp);
+        transferFn1D[i].R = (float)arr[i*4+0]/255.0f;
+        transferFn1D[i].G = (float)arr[i*4+1]/255.0f;
+        transferFn1D[i].B = (float)arr[i*4+2]/255.0f;
+        transferFn1D[i].A = alpha;
+        if (transferFn1D[i].A != 0 && minVisibleScalarIndex == -1) {
+            minVisibleScalarIndex = i;
+        }
+
+    }
+
+    for (int i=tableEntries-1; i>=0; i--)
+    {
+        if (transferFn1D[i].A != 0 && maxVisibleScalarIndex == -1){
+            maxVisibleScalarIndex = i;
+        }
+    }
 
     //
     // We need to set the intermediate vars again since the table size has
@@ -414,6 +469,8 @@ avtOpacityMap::SetTableFloat(unsigned char *arr, int te, double attenuation, flo
     //
     SetIntermediateVars();
 }
+
+
 // ****************************************************************************
 //  Method: avtOpacityMap::GetMinVisibleScalar
 //
@@ -455,26 +512,35 @@ double avtOpacityMap::GetMaxVisibleScalar()
 //  Programmer: Pascal Grosset
 //  Creation:   July 14, 2016
 //
+//  Modifications:
+//
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Code formatting
+//
 // ****************************************************************************
-void avtOpacityMap::computeVisibleRange()
+void avtOpacityMap::ComputeVisibleRange()
 {
     double scalarRange = max - min;
     if (minVisibleScalarIndex == 0)
         minVisibleScalar =  min;
     else
-        minVisibleScalar = ( ((float)minVisibleScalarIndex/(tableEntries-1)) * scalarRange) + min;
+        minVisibleScalar = (((float)minVisibleScalarIndex/(tableEntries-1)) *
+                            scalarRange) + min;
     
-
-
     if (maxVisibleScalarIndex == tableEntries-1)
         maxVisibleScalar =  max;
     else
-        maxVisibleScalar = ( ((float)maxVisibleScalarIndex/(tableEntries-1)) * scalarRange) + min;
-
-
-     debug5 << "max: " << max << "  min: " << min << "  scalarRange: " << scalarRange << "  minVisibleScalarIndex: " << minVisibleScalarIndex <<
-             "  maxVisibleScalarIndex: " << maxVisibleScalarIndex << "   tableEntries: " << tableEntries << 
-             "  maxVisibleScalar: " << maxVisibleScalar << "   minVisibleScalar: " << minVisibleScalar << std::endl;
+        maxVisibleScalar = (((float)maxVisibleScalarIndex/(tableEntries-1)) * 
+                            scalarRange) + min;
+
+     debug5 << " max: " << max << " min: " << min 
+	    << " scalarRange: " << scalarRange 
+            << " minVisibleScalarIndex: " << minVisibleScalarIndex 
+	    << " maxVisibleScalarIndex: " << maxVisibleScalarIndex 
+            << " tableEntries: " << tableEntries
+	    << " maxVisibleScalar: " << maxVisibleScalar 
+            << " minVisibleScalar: " << minVisibleScalar 
+	    << std::endl;
 }
 
 // ****************************************************************************
@@ -535,9 +601,6 @@ avtOpacityMap::SetTable(RGBA *arr, int te, double attenuation)
 }
 
 
-
-
-
 // ****************************************************************************
 //  Method: avtOpacityMap::GetOpacity
 //
diff --git a/avt/Pipeline/Data/avtOpacityMap.h b/avt/Pipeline/Data/avtOpacityMap.h
index 3a430c1807..ccd31c74bf 100644
--- a/avt/Pipeline/Data/avtOpacityMap.h
+++ b/avt/Pipeline/Data/avtOpacityMap.h
@@ -54,7 +54,7 @@ struct RGBA
     float         A;
 };
 
-struct _RGBA
+struct RGBAF
 {
     float R;
     float G;
@@ -62,6 +62,8 @@ struct _RGBA
     float A;
 };
 
+// added by Qi, for using RGBAF nicely outside the function
+
 // ****************************************************************************
 //  Class: avtOpacityMap
 //
@@ -87,6 +89,11 @@ struct _RGBA
 //    Define private copy constructor and assignment operator to prevent
 //    accidental use of default, bitwise copy implementations.
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Add function 'SetTableFloatNOC' to generate a transfer function without
+//    the opacity correction term. This function will be used for OSPRay 
+//    volume rendering
+//
 // ****************************************************************************
 
 class PIPELINE_API avtOpacityMap
@@ -99,9 +106,14 @@ class PIPELINE_API avtOpacityMap
     void operator = (const avtOpacityMap &obj);
 
     const RGBA                  *GetTable(void) { return table; };
+    const RGBAF                 *GetTableFloat(void) { return transferFn1D; };
     void                         SetTable(unsigned char *, int, double = 1.);
-    void                         SetTable(unsigned char *arr, int te, double attenuation, float over);
-    void                         SetTableFloat(unsigned char *arr, int te, double attenuation, float over);
+    void                         SetTable(unsigned char *arr, int te, 
+                                               double attenuation, float over);
+    void                         SetTableFloat(unsigned char *arr, int te,
+                                               double attenuation, float over);
+    void                         SetTableFloatNOC(unsigned char *arr, int te,
+                                                           double attenuation);
     void                         SetTable(RGBA *, int, double = 1.);
     const RGBA                  &GetOpacity(double);
 
@@ -114,20 +126,21 @@ class PIPELINE_API avtOpacityMap
     double                       GetMinVisibleScalar();
     double                       GetMaxVisibleScalar();
     
-    void                         computeVisibleRange();
+    void                         ComputeVisibleRange();
 
     inline int                   Quantize(const double &);
     int                          GetNumberOfTableEntries(void)
                                                       { return tableEntries; };
 
     float                        QuantizeValF(const double &val);
-    int                          QueryTF(double scalarValue, double color[4]) const;
+    int                          QueryTF(double scalarValue, 
+                                         double color[4]) const;
     float                        QueryAlpha(double scalarValue) const;
 
-    friend PIPELINE_API ostream &operator << (ostream &, const avtOpacityMap &);
+    friend PIPELINE_API ostream &operator <<(ostream &, const avtOpacityMap &);
   protected:
     RGBA                        *table;
-    _RGBA                       *transferFn1D;
+    RGBAF                       *transferFn1D;
     int                          tableEntries;
 
     double                       max, min;
@@ -214,11 +227,13 @@ avtOpacityMap::QuantizeValF(const double &val){
 //  Method: avtOpacityMap::QueryTF
 //
 //  Purpose:
-//      Queries a Transfer function for the color based on the scalr value passed in 
+//      Queries a Transfer function for the color based on the scalr value
+//      passed in 
 //
 //  Arguments:
 //      scalarValue     scalar value
-//      color           the color queried from the transfer function based on the scalar value
+//      color           the color queried from the transfer function based on
+//                      the scalar value
 //
 //  Returns: 
 //
@@ -230,6 +245,9 @@ avtOpacityMap::QuantizeValF(const double &val){
 //    Qi Wu, Tue Aug 8 12:47:52 MT 2017
 //    Fixed index overflow problem when the scalar value reaches its maximum
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Fix bad coding formats
+//
 // ****************************************************************************
 inline int
 avtOpacityMap::QueryTF(double scalarValue, double color[4]) const
@@ -237,7 +255,7 @@ avtOpacityMap::QueryTF(double scalarValue, double color[4]) const
     if (scalarValue <= min){
         int index = 0;
 
-        _RGBA colorRGBA = transferFn1D[index];
+        RGBAF colorRGBA = transferFn1D[index];
         color[0] = colorRGBA.R;
         color[1] = colorRGBA.G;
         color[2] = colorRGBA.B;
@@ -248,7 +266,7 @@ avtOpacityMap::QueryTF(double scalarValue, double color[4]) const
 
     if (scalarValue >= max){
         int index = tableEntries-1;
-        _RGBA colorRGBA = transferFn1D[index];
+        RGBAF colorRGBA = transferFn1D[index];
         color[0] = colorRGBA.R;
         color[1] = colorRGBA.G;
         color[2] = colorRGBA.B;
@@ -258,11 +276,12 @@ avtOpacityMap::QueryTF(double scalarValue, double color[4]) const
     }
 
     int indexLow, indexHigh;
-    _RGBA colorRGBALow, colorRGBAHigh;
+    RGBAF colorRGBALow, colorRGBAHigh;
     double colorLow[4], colorHigh[4];
     float indexPos, indexDiff;
 
-    indexPos  = (scalarValue-min)/(max-min) * (tableEntries-1);    // multiplier = 1.0/(max-min) * tableEntries
+    indexPos  = (scalarValue-min)/(max-min) * (tableEntries-1); 
+    // ^^^^ multiplier = 1.0/(max-min) * tableEntries
     indexLow  = (int)indexPos;
     indexHigh = (int)(indexPos+1.0);
 
diff --git a/avt/Plotter/CMakeLists.txt b/avt/Plotter/CMakeLists.txt
index 4ca2625d9b..79a18e9f03 100644
--- a/avt/Plotter/CMakeLists.txt
+++ b/avt/Plotter/CMakeLists.txt
@@ -77,6 +77,12 @@
 #   Remove vtkRenderingVolumeOpenGL2 from link line. Moved module init back
 #   into volume plot.
 #
+#   Qi WU, Sat Jun 10 22:21:27 MST 2018
+#   Remove the old VISIT_OSPRAY configurations because they are too old. 
+#   Additional Note: The FindOSPRay.cmake file is broken for a recent version
+#                    of OSPRay. We should use the built-inosprayConfig.cmake
+#                    file to find OSPRay instead.
+#
 #****************************************************************************/
 
 #if(VISIT_OSPRAY)
@@ -217,14 +223,9 @@ TARGET_LINK_LIBRARIES(avtplotter_ser
     visitcommon avtmath avtview avtfilters_ser avtpipeline_ser visit_vtk 
     lightweight_visit_vtk vtkFiltersHybrid vtkRenderingOpenGL2 
     vtkRenderingFreeType ${OPENGL_LIBRARIES})
-
 IF(VISIT_OSPRAY)
-    MESSAGE(STATUS "OSPRAY_TARGET_LINK_LIBRARIES: " ${OSPRAY_TARGET_LINK_LIBRARIES})
-    MESSAGE(STATUS "OSPRAY_LIBRARIES: " ${OSPRAY_LIBRARIES})
-    MESSAGE(STATUS "OSPRAY_INCLUDE_DIRS: " ${OSPRAY_INCLUDE_DIRS})
-    TARGET_LINK_LIBRARIES(avtplotter_ser ${OSPRAY_TARGET_LINK_LIBRARIES}
-        ${OSPRAY_LIBRARIES} ${VTK_LIBRARIES})
-    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS} ${VISIT_SOURCE_DIR}/../../VTK-6.1.0/Parallel/Core)
+    TARGET_LINK_LIBRARIES(avtplotter_ser ${OSPRAY_LIBRARIES} ${VTK_LIBRARIES})
+    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS})
 ENDIF(VISIT_OSPRAY)
 VISIT_INSTALL_TARGETS(avtplotter_ser)
 
@@ -233,12 +234,9 @@ IF(VISIT_PARALLEL)
     ADD_PARALLEL_LIBRARY(avtplotter_par ${AVTPLOTTER_SOURCES})
     TARGET_LINK_LIBRARIES(avtplotter_par visitcommon avtmath avtview avtfilters_par avtpipeline_par visit_vtk lightweight_visit_vtk vtkFiltersHybrid vtkRenderingOpenGL2 vtkRenderingFreeType ${OPENGL_LIBRARIES})
     IF(VISIT_OSPRAY)
-        TARGET_LINK_LIBRARIES(avtplotter_par ${OSPRAY_TARGET_LINK_LIBRARIES}
-            ${OSPRAY_LIBRARIES} ${VTK_LIBRARIES})
-        INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS})
+      TARGET_LINK_LIBRARIES(avtplotter_par ${OSPRAY_LIBRARIES})
+      INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS})
     ENDIF(VISIT_OSPRAY)
-
     VISIT_INSTALL_TARGETS(avtplotter_par)
 ENDIF(VISIT_PARALLEL)
 
-
diff --git a/avt/Plotter/vtk/InitVTKRendering.C b/avt/Plotter/vtk/InitVTKRendering.C
index f99371412f..2d3927c953 100644
--- a/avt/Plotter/vtk/InitVTKRendering.C
+++ b/avt/Plotter/vtk/InitVTKRendering.C
@@ -188,6 +188,9 @@ vtkVisItGraphicsFactory::vtkVisItGraphicsFactory()
 //    Carson Brownlee, Sun May  6 16:25:28 PDT 2012
 //    Add support for Manta.
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Remove the old VISIT_OSPRAY configurations because they are too old. 
+//
 // ****************************************************************************
 
 void
diff --git a/plots/Volume/CMakeLists.txt b/plots/Volume/CMakeLists.txt
index 725a48f704..f4e7e2244f 100644
--- a/plots/Volume/CMakeLists.txt
+++ b/plots/Volume/CMakeLists.txt
@@ -97,6 +97,11 @@ IF(VISIT_SLIVR)
     ADD_DEFINITIONS(-DVISIT_SLIVR)
 ENDIF(VISIT_SLIVR)
 
+IF(VISIT_OSPRAY)
+    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIR})
+    ADD_DEFINITIONS(-DVISIT_OSPRAY)
+ENDIF ()
+
 LINK_DIRECTORIES(${VISIT_LIBRARY_DIR} ${EAVL_LIBRARY_DIR} ${VTKM_LIBRARY_DIR} )
 
 ADD_LIBRARY(IVolumePlot ${LIBI_SOURCES})
@@ -111,6 +116,10 @@ IF(NOT VISIT_SERVER_COMPONENTS_ONLY AND NOT VISIT_ENGINE_ONLY AND NOT VISIT_DBIO
     ADD_LIBRARY(VVolumePlot ${LIBV_SOURCES})
     TARGET_LINK_LIBRARIES(VVolumePlot visitcommon viewer vtkRenderingVolumeOpenGL2 )
 
+    IF(VISIT_OSPRAY)
+      TARGET_LINK_LIBRARIES(VVolumePlot ${OSPRAY_LIBRARIES})
+    ENDIF()
+
     SET(INSTALLTARGETS ${INSTALLTARGETS} GVolumePlot VVolumePlot)
 
     IF(VISIT_PYTHON_SCRIPTING)
@@ -134,12 +143,18 @@ ENDIF(NOT VISIT_SERVER_COMPONENTS_ONLY AND NOT VISIT_ENGINE_ONLY AND NOT VISIT_D
 
 ADD_LIBRARY(EVolumePlot_ser ${LIBE_SOURCES})
 TARGET_LINK_LIBRARIES(EVolumePlot_ser visitcommon avtplotter_ser avtpipeline_ser avtexpressions_ser vtkRenderingVolumeOpenGL2 )
+IF(VISIT_OSPRAY)
+    TARGET_LINK_LIBRARIES(EVolumePlot_ser ${OSPRAY_LIBRARIES})
+ENDIF()
 SET(INSTALLTARGETS ${INSTALLTARGETS} EVolumePlot_ser)
 ADD_TARGET_DEFINITIONS(EVolumePlot_ser ENGINE)
 
 IF(VISIT_PARALLEL)
     ADD_PARALLEL_LIBRARY(EVolumePlot_par ${LIBE_SOURCES})
     TARGET_LINK_LIBRARIES(EVolumePlot_par visitcommon avtplotter_par avtpipeline_par avtexpressions_par vtkRenderingVolumeOpenGL2 )
+    IF(VISIT_OSPRAY)
+        TARGET_LINK_LIBRARIES(EVolumePlot_par ${OSPRAY_LIBRARIES})
+    ENDIF()
     SET(INSTALLTARGETS ${INSTALLTARGETS} EVolumePlot_par)
     ADD_TARGET_DEFINITIONS(EVolumePlot_par ENGINE)
 ENDIF(VISIT_PARALLEL)
diff --git a/plots/Volume/PyVolumeAttributes.C b/plots/Volume/PyVolumeAttributes.C
index 4880d99ad7..13ceba600d 100644
--- a/plots/Volume/PyVolumeAttributes.C
+++ b/plots/Volume/PyVolumeAttributes.C
@@ -54,6 +54,11 @@
 // Programmer: xml2python
 // Creation:   omitted
 //
+// Modifications:
+//
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Add function 'RayCastingOSPRay' as a new volume renderer type
+//
 // ****************************************************************************
 
 //
@@ -181,7 +186,7 @@ PyVolumeAttributes_ToString(const VolumeAttributes *atts, const char *prefix)
     str += tmpStr;
     SNPRINTF(tmpStr, 1000, "%ssamplesPerRay = %d\n", prefix, atts->GetSamplesPerRay());
     str += tmpStr;
-    const char *rendererType_names = "Default, RayCasting, RayCastingIntegration, RayCastingSLIVR";
+    const char *rendererType_names = "Default, RayCasting, RayCastingIntegration, RayCastingSLIVR, RayCastingOSPRay";
     switch (atts->GetRendererType())
     {
       case VolumeAttributes::Default:
@@ -200,6 +205,10 @@ PyVolumeAttributes_ToString(const VolumeAttributes *atts, const char *prefix)
           SNPRINTF(tmpStr, 1000, "%srendererType = %sRayCastingSLIVR  # %s\n", prefix, prefix, rendererType_names);
           str += tmpStr;
           break;
+      case VolumeAttributes::RayCastingOSPRay:
+          SNPRINTF(tmpStr, 1000, "%srendererType = %sRayCastingOSPRay  # %s\n", prefix, prefix, rendererType_names);
+          str += tmpStr;
+          break;
       default:
           break;
     }
@@ -957,14 +966,15 @@ VolumeAttributes_SetRendererType(PyObject *self, PyObject *args)
         return NULL;
 
     // Set the rendererType in the object.
-    if(ival >= 0 && ival < 4)
+    if(ival >= 0 && ival < 5)
         obj->data->SetRendererType(VolumeAttributes::Renderer(ival));
     else
     {
         fprintf(stderr, "An invalid rendererType value was given. "
-                        "Valid values are in the range of [0,3]. "
+                        "Valid values are in the range of [0,4]. "
                         "You can also use the following names: "
-                        "Default, RayCasting, RayCastingIntegration, RayCastingSLIVR.");
+                        "Default, RayCasting, RayCastingIntegration, "
+                        "RayCastingSLIVR, RayCastingOSPRay.");
         return NULL;
     }
 
@@ -1452,6 +1462,8 @@ PyVolumeAttributes_getattr(PyObject *self, char *name)
         return PyInt_FromLong(long(VolumeAttributes::RayCastingIntegration));
     if(strcmp(name, "RayCastingSLIVR") == 0)
         return PyInt_FromLong(long(VolumeAttributes::RayCastingSLIVR));
+    if(strcmp(name, "RayCastingOSPRay") == 0)
+        return PyInt_FromLong(long(VolumeAttributes::RayCastingOSPRay));
 
     if(strcmp(name, "gradientType") == 0)
         return VolumeAttributes_GetGradientType(self, NULL);
diff --git a/plots/Volume/QvisVolumePlotWindow.C b/plots/Volume/QvisVolumePlotWindow.C
index 077c86d290..4fb00f81a7 100644
--- a/plots/Volume/QvisVolumePlotWindow.C
+++ b/plots/Volume/QvisVolumePlotWindow.C
@@ -1067,7 +1067,7 @@ void QvisVolumePlotWindow::UpdateSamplingGroup()
     lightMaterialPropGroup->setEnabled(true);
     lightingToggle->setEnabled(true);
 
-    //disable material properties (only enabled with lighting for SLIVR, RayCasting w/ Trilinear Sampling)
+    //disable material properties (only enabled with lighting for RayCasting w/ Trilinear Sampling)
     materialProperties->setEnabled(false);
 
     //enable/disable resampleTarget
@@ -1137,6 +1137,22 @@ void QvisVolumePlotWindow::UpdateSamplingGroup()
         break;
 #endif
 
+#ifdef VISIT_OSPRAY
+    case VolumeAttributes::RayCastingOSPRay:
+        raycastingGroup->setVisible(true);
+        UpdateLowGradientGroup(false);
+        materialProperties->setEnabled(volumeAtts->GetLightingFlag());
+        EnableSamplingMethods(false);
+        samplesPerRayWidget->setEnabled(true);
+        rendererSamplesWidget->setEnabled(true);
+        rendererSamples->setEnabled(true);
+        rendererSamplesLabel->setEnabled(true);
+        centeredDiffButton->setEnabled(true);
+        centeredDiffButton->setChecked(true);
+        sobelButton->setEnabled(false);
+        break;
+#endif
+
     default:
         EXCEPTION1(ImproperUseException, "No such renderer type.");
     }        
@@ -1176,6 +1192,9 @@ QvisVolumePlotWindow::CreateRendererOptionsGroup(int maxWidth)
 #ifdef VISIT_SLIVR
     rendererTypesComboBox->addItem(tr("Ray casting: SLIVR"));
 #endif
+#ifdef VISIT_OSPRAY
+    rendererTypesComboBox->addItem(tr("Ray casting: OSPRay"));
+#endif
     connect(rendererTypesComboBox, SIGNAL(activated(int)),
             this, SLOT(rendererTypeChanged(int)));
 
@@ -1689,6 +1708,12 @@ QvisVolumePlotWindow::UpdateWindow(bool doAll)
                 rendererTypesComboBox->setCurrentIndex(3);
             }
 #endif
+#ifdef VISIT_OSPRAY
+            else if (volumeAtts->GetRendererType() == VolumeAttributes::RayCastingOSPRay)
+            {
+                rendererTypesComboBox->setCurrentIndex(4);
+            }
+#endif
 
             opacityVariable->setEnabled(true);
             rendererTypesComboBox->blockSignals(false);
@@ -3405,6 +3430,11 @@ QvisVolumePlotWindow::rendererTypeChanged(int val)
         volumeAtts->SetRendererType(VolumeAttributes::RayCastingSLIVR);
         break;
 #endif
+#ifdef VISIT_OSPRAY
+      case 4:
+        volumeAtts->SetRendererType(VolumeAttributes::RayCastingOSPRay);
+        break;
+#endif
       default:
         EXCEPTION1(ImproperUseException,
                    "The Volume plot received a signal for a renderer "
diff --git a/plots/Volume/Volume.xml b/plots/Volume/Volume.xml
index e5d5b42d25..6bd0037470 100644
--- a/plots/Volume/Volume.xml
+++ b/plots/Volume/Volume.xml
@@ -37,6 +37,7 @@
         RayCasting
         RayCastingIntegration
         RayCastingSLIVR
+        RayCastingOSPRay
       </Enum>
       <Enum name="GradientType">
         CenteredDifferences
diff --git a/plots/Volume/VolumeAttributes.C b/plots/Volume/VolumeAttributes.C
index ba300dabea..fff34f157a 100644
--- a/plots/Volume/VolumeAttributes.C
+++ b/plots/Volume/VolumeAttributes.C
@@ -47,20 +47,20 @@
 
 static const char *Renderer_strings[] = {
 "Default", "RayCasting", "RayCastingIntegration", 
-"RayCastingSLIVR"};
+"RayCastingSLIVR", "RayCastingOSPRay"};
 
 std::string
 VolumeAttributes::Renderer_ToString(VolumeAttributes::Renderer t)
 {
     int index = int(t);
-    if(index < 0 || index >= 4) index = 0;
+    if(index < 0 || index >= 5) index = 0;
     return Renderer_strings[index];
 }
 
 std::string
 VolumeAttributes::Renderer_ToString(int t)
 {
-    int index = (t < 0 || t >= 4) ? 0 : t;
+    int index = (t < 0 || t >= 5) ? 0 : t;
     return Renderer_strings[index];
 }
 
@@ -68,7 +68,7 @@ bool
 VolumeAttributes::Renderer_FromString(const std::string &s, VolumeAttributes::Renderer &val)
 {
     val = VolumeAttributes::Default;
-    for(int i = 0; i < 4; ++i)
+    for(int i = 0; i < 5; ++i)
     {
         if(s == Renderer_strings[i])
         {
@@ -1124,7 +1124,7 @@ VolumeAttributes::SetFromNode(DataNode *parentNode)
         if(node->GetNodeType() == INT_NODE)
         {
             int ival = node->AsInt();
-            if(ival >= 0 && ival < 4)
+            if(ival >= 0 && ival < 5)
                 SetRendererType(Renderer(ival));
         }
         else if(node->GetNodeType() == STRING_NODE)
@@ -2138,6 +2138,9 @@ VolumeAttributes::FieldsEqual(int index_, const AttributeGroup *rhs) const
 //    Allen Harvey, Thurs Nov 3 7:21:13 EST 2011
 //    Added checks for not doing resampling
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Added RayCastingOSPRay option for volume rendering
+//
 // ****************************************************************************
 
 bool
@@ -2157,6 +2160,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
 
     if (rendererType == VolumeAttributes::RayCasting ||
         rendererType == VolumeAttributes::RayCastingSLIVR ||
+        rendererType == VolumeAttributes::RayCastingOSPRay ||
         rendererType == VolumeAttributes::RayCastingIntegration)
     {
         // Trilinear requires ghost zone while Rasterization and KernelBased do not
@@ -2185,6 +2189,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
         // modes does not require a reexecute.
         if(obj.rendererType == VolumeAttributes::RayCasting ||
            obj.rendererType == VolumeAttributes::RayCastingSLIVR ||
+           obj.rendererType == VolumeAttributes::RayCastingOSPRay ||
            obj.rendererType == VolumeAttributes::RayCastingIntegration)
         {
             return true;
diff --git a/plots/Volume/VolumeAttributes.code b/plots/Volume/VolumeAttributes.code
index 8873455ad1..e8ecb65a5c 100644
--- a/plots/Volume/VolumeAttributes.code
+++ b/plots/Volume/VolumeAttributes.code
@@ -52,6 +52,9 @@ Definition:
 //    Allen Harvey, Thurs Nov 3 7:21:13 EST 2011
 //    Added checks for not doing resampling
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Added RayCastingOSPRay option for volume rendering
+//
 // ****************************************************************************
 
 bool
@@ -71,6 +74,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
 
     if (rendererType == VolumeAttributes::RayCasting ||
         rendererType == VolumeAttributes::RayCastingSLIVR ||
+        rendererType == VolumeAttributes::RayCastingOSPRay ||
         rendererType == VolumeAttributes::RayCastingIntegration)
     {
         // Trilinear requires ghost zone while Rasterization and KernelBased do not
@@ -99,6 +103,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
         // modes does not require a reexecute.
         if(obj.rendererType == VolumeAttributes::RayCasting ||
            obj.rendererType == VolumeAttributes::RayCastingSLIVR ||
+           obj.rendererType == VolumeAttributes::RayCastingOSPRay ||
            obj.rendererType == VolumeAttributes::RayCastingIntegration)
         {
             return true;
@@ -664,3 +669,7 @@ Target: xml2cmake
 Condition: VISIT_SLIVR
 Definitions: -DVISIT_SLIVR
 
+Target: xml2cmake
+Condition: VISIT_OSPRAY
+Definitions: -DVISIT_OSPRAY
+
diff --git a/plots/Volume/VolumeAttributes.h b/plots/Volume/VolumeAttributes.h
index ac9aa85353..3ee403d011 100644
--- a/plots/Volume/VolumeAttributes.h
+++ b/plots/Volume/VolumeAttributes.h
@@ -67,7 +67,8 @@ public:
         Default,
         RayCasting,
         RayCastingIntegration,
-        RayCastingSLIVR
+        RayCastingSLIVR,
+        RayCastingOSPRay
     };
     enum GradientType
     {
diff --git a/plots/Volume/VolumeAttributes.java b/plots/Volume/VolumeAttributes.java
index 129f5a16d6..da3b6e3399 100644
--- a/plots/Volume/VolumeAttributes.java
+++ b/plots/Volume/VolumeAttributes.java
@@ -68,6 +68,7 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
     public final static int RENDERER_RAYCASTING = 1;
     public final static int RENDERER_RAYCASTINGINTEGRATION = 2;
     public final static int RENDERER_RAYCASTINGSLIVR = 3;
+    public final static int RENDERER_RAYCASTINGOSPRAY = 4;
 
     public final static int GRADIENTTYPE_CENTEREDDIFFERENCES = 0;
     public final static int GRADIENTTYPE_SOBELOPERATOR = 1;
@@ -749,6 +750,8 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
             str = str + "RENDERER_RAYCASTINGINTEGRATION";
         if(rendererType == RENDERER_RAYCASTINGSLIVR)
             str = str + "RENDERER_RAYCASTINGSLIVR";
+        if(rendererType == RENDERER_RAYCASTINGOSPRAY)
+            str = str + "RENDERER_RAYCASTINGOSPRAY";
         str = str + "\n";
         str = str + indent + "gradientType = ";
         if(gradientType == GRADIENTTYPE_CENTEREDDIFFERENCES)
diff --git a/plots/Volume/avtVolumeFilter.C b/plots/Volume/avtVolumeFilter.C
index 23a1e585db..22ee122df0 100644
--- a/plots/Volume/avtVolumeFilter.C
+++ b/plots/Volume/avtVolumeFilter.C
@@ -79,6 +79,10 @@
 #include <avtSLIVRRayTracer.h>
 #endif
 
+#ifdef VISIT_OSPRAY
+#include <avtOSPRayRayTracer.h>
+#endif
+
 //
 // Function Prototypes
 //
@@ -103,6 +107,9 @@ static void CreateViewInfoFromViewAttributes(avtViewInfo &,
 avtVolumeFilter::avtVolumeFilter()
 {
     primaryVariable = NULL;
+#ifdef VISIT_OSPRAY
+    ospray = NULL;
+#endif
 }
 
 
@@ -126,6 +133,11 @@ avtVolumeFilter::~avtVolumeFilter()
         delete [] primaryVariable;
         primaryVariable = NULL;
     }
+#ifdef VISIT_OSPRAY
+    if (ospray != NULL) {
+	delete ospray;
+    }
+#endif
 }
 
 
@@ -292,20 +304,36 @@ avtVolumeFilter::CreateOpacityMap(double range[2])
     if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR)
     {
         // Set the opacity map. This modifies the opacities though.
-        om.SetTable(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0, atts.GetRendererSamples());
-        om.SetTableFloat(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0, atts.GetRendererSamples());
+        om.SetTable(vtf, 256, atts.GetOpacityAttenuation() * 2.0 - 1.0,
+                    atts.GetRendererSamples());
+        om.SetTableFloat(vtf, 256, atts.GetOpacityAttenuation() * 2.0 - 1.0,
+                         atts.GetRendererSamples());
     }
     else
 #endif
     {
-        if ((atts.GetRendererType() == VolumeAttributes::RayCasting) && (atts.GetSampling() == VolumeAttributes::Trilinear))
-            om.SetTable(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0, atts.GetRendererSamples());
+#ifdef VISIT_OSPRAY
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay)
+    {
+        om.SetTable(vtf, 256, atts.GetOpacityAttenuation() * 2.0 - 1.0, 
+                    atts.GetRendererSamples());
+	om.SetTableFloatNOC(vtf, 256,
+			    atts.GetOpacityAttenuation() * 2.0 - 1.0); 
+    }
+    else
+#endif
+    {
+        if ((atts.GetRendererType() == VolumeAttributes::RayCasting) && 
+            (atts.GetSampling() == VolumeAttributes::Trilinear))
+            om.SetTable(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0,
+			atts.GetRendererSamples());
         else
         {
             // Set the opacity map just using the transfer function.
             om.SetTable(vtf, 256, atts.GetOpacityAttenuation());
         }
     }
+    }
 
     double actualRange[2];
     bool artificialMin = atts.GetUseColorVarMin();
@@ -345,7 +373,7 @@ avtVolumeFilter::CreateOpacityMap(double range[2])
     }
     om.SetMin(range[0]);
     om.SetMax(range[1]);
-    om.computeVisibleRange();
+    om.ComputeVisibleRange();
 
     if (atts.GetRendererType() == VolumeAttributes::RayCastingIntegration)
     {
@@ -370,11 +398,13 @@ avtVolumeFilter::CreateOpacityMap(double range[2])
     return om;
 }
 
-extern bool GetLogicalBounds(avtDataObject_p input,int &width,int &height, int &depth);
+extern bool GetLogicalBounds(avtDataObject_p input,
+			     int &width,int &height, int &depth);
+
+#if defined(VISIT_SLIVR) || defined(VISIT_OSPRAY)
 
-#ifdef VISIT_SLIVR
 // ****************************************************************************
-//  Method: avtVolumeFilter::RenderImageRaycastingSLIVR
+//  Method: avtVolumeFilter::RenderImageRayCasting
 //
 //  Purpose:
 //      Do SW rendering with SLIVR.
@@ -389,8 +419,8 @@ extern bool GetLogicalBounds(avtDataObject_p input,int &width,int &height, int &
 // ****************************************************************************
 
 avtImage_p
-avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
-                             const WindowAttributes &window)
+avtVolumeFilter::RenderImageRayCasting(avtImage_p opaque_image,
+                                 const WindowAttributes &window)
 {
     //
     // We need to create a dummy pipeline with the volume renderer that we
@@ -401,7 +431,22 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     //
     // Set up the volume renderer.
     //
-    avtSLIVRRayTracer *software = new avtSLIVRRayTracer;
+    avtRayTracerBase *software = nullptr;
+#ifdef VISIT_SLIVR
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) {        
+        software = new avtSLIVRRayTracer;
+    }
+    else
+#endif
+    {
+#ifdef VISIT_OSPRAY
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay) {
+        software = new avtOSPRayRayTracer;
+	if (ospray == NULL) { ospray = new OSPVisItContext; }
+	((avtOSPRayRayTracer*)software)->SetOSPRay(ospray);
+    }
+#endif
+    }
     software->SetInput(termsrc.GetOutput());
     software->InsertOpaqueImage(opaque_image);
 
@@ -410,7 +455,7 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     //
     double range[2] = {0., 0.};
     avtOpacityMap om(CreateOpacityMap(range));
-    om.computeVisibleRange();
+    om.ComputeVisibleRange();
 
     avtFlatLighting fl;
     avtLightingModel *lm = &fl;
@@ -418,9 +463,9 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     avtCompositeRF *compositeRF = new avtCompositeRF(lm, &om, &om);
     software->SetTransferFn(&om);
 
-    debug5 << "Min visible scalar range:" << om.GetMinVisibleScalar() << "  Max visible scalar range: "  <<  om.GetMaxVisibleScalar() << std::endl;
-
-
+    debug5 << "Min visible scalar range: " << om.GetMinVisibleScalar() << " "
+           << "Max visible scalar range: " << om.GetMaxVisibleScalar()
+           << std::endl;
 
     //
     // Determine which variables to use and tell the ray function.
@@ -437,7 +482,8 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     const char *gradvar = atts.GetOpacityVariable().c_str();
     if (strcmp(gradvar, "default") == 0)
         gradvar = primaryVariable;
-    // This name is explicitly sent to the avtGradientExpression in avtVolumePlot.
+    // This name is explicitly sent to the avtGradientExpression in
+    // avtVolumePlot.
     SNPRINTF(gradName, 128, "_%s_gradient", gradvar);
 
     for (int i = 0 ; i < vl.nvars ; i++)
@@ -454,10 +500,10 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
         {
             opacIndex = count;
         }
-       // if (vl.varnames[i] == gradName)
-       // {
-       //     gradIndex = count;
-       // }
+	// if (vl.varnames[i] == gradName)
+	// {
+	//     gradIndex = count;
+	// }
         count += vl.varsizes[i];
     }
 
@@ -494,16 +540,12 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
         }
     }
 
-
     //
     // Unsure about this one??? RayFunction seems important
     //
     software->SetRayFunction(compositeRF);
     software->SetSamplesPerRay(atts.GetSamplesPerRay());
-
-    debug5 << "Sampling rate: "  << atts.GetRendererSamples() << std::endl;
-
-
+    debug5 << "Sampling rate: " << atts.GetRendererSamples() << std::endl;
 
     //
     // Set camera parameters
@@ -521,17 +563,20 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     {
         double viewDirection[3];
         int numSlices;
-
-        viewDirection[0] = (view.GetViewNormal()[0] > 0)? view.GetViewNormal()[0]: -view.GetViewNormal()[0];
-        viewDirection[1] = (view.GetViewNormal()[1] > 0)? view.GetViewNormal()[1]: -view.GetViewNormal()[1];
-        viewDirection[2] = (view.GetViewNormal()[2] > 0)? view.GetViewNormal()[2]: -view.GetViewNormal()[2];
-
-        numSlices = (width_*viewDirection[0] + height_*viewDirection[1] + depth_*viewDirection[2]) * atts.GetRendererSamples();
-
+        viewDirection[0] = (view.GetViewNormal()[0] > 0)?
+	    view.GetViewNormal()[0]:
+            -view.GetViewNormal()[0];
+        viewDirection[1] = (view.GetViewNormal()[1] > 0)?
+	    view.GetViewNormal()[1]:
+            -view.GetViewNormal()[1];
+        viewDirection[2] = (view.GetViewNormal()[2] > 0)?
+	    view.GetViewNormal()[2]: 
+            -view.GetViewNormal()[2];
+        numSlices = (width_ * viewDirection[0] +
+                     height_* viewDirection[1] + 
+                     depth_ * viewDirection[2]) * atts.GetRendererSamples();
         software->SetSamplesPerRay(numSlices);
-        debug5 << "RayCastingSLIVR - slices: "<< numSlices << " : " << width_ << " ,  " << height_  << " , " << depth_ << endl;
     }
-
     software->SetView(vi);
 
     double view_dir[3];
@@ -546,21 +591,14 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
         view_dir[1] /= mag;
         view_dir[2] /= mag;
     }
-    software->SetViewDirection(view_dir);
 
     //
     // Set up lighting and material properties
     //
-    if (atts.GetLightingFlag())
-        software->SetLighting(true);
-    else
-        software->SetLighting(false);
-
     double tempLightDir[3];
     tempLightDir[0] = ((window.GetLights()).GetLight(0)).GetDirection()[0];
     tempLightDir[1] = ((window.GetLights()).GetLight(0)).GetDirection()[1];
     tempLightDir[2] = ((window.GetLights()).GetLight(0)).GetDirection()[2];
-    software->SetLightDirection(tempLightDir);
 
     double *matProp = atts.GetMaterialProperties();
     double materialPropArray[4];
@@ -568,19 +606,37 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     materialPropArray[1] = matProp[1];
     materialPropArray[2] = matProp[2];
     materialPropArray[3] = matProp[3];
-    software->SetMatProperties(materialPropArray);
-
-
+    
+#ifdef VISIT_SLIVR
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) {
+	avtSLIVRRayTracer* s = (avtSLIVRRayTracer*)software;
+	s->SetViewDirection(view_dir);
+	s->SetLighting(atts.GetLightingFlag());
+	s->SetLightDirection(tempLightDir);
+	s->SetMatProperties(materialPropArray);
+    } else
+#endif
+    {
+#ifdef VISIT_OSPRAY
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay) {
+	avtOSPRayRayTracer* s = (avtOSPRayRayTracer*)software;
+	s->SetViewDirection(view_dir);
+	s->SetLighting(atts.GetLightingFlag());
+        s->SetLightDirection(tempLightDir);
+	s->SetMatProperties(materialPropArray);
+	s->SetRendererSampleRate(atts.GetRendererSamples());
+    }
+#endif
+    }
 
     //
     // Set the volume renderer's background color and mode from the
     // window attributes.
     //
-    //software->SetBackgroundMode(window.GetBackgroundMode());
     software->SetBackgroundColor(window.GetBackground());
+    //software->SetBackgroundMode(window.GetBackgroundMode());
     //software->SetGradientBackgroundColors(window.GetGradBG1(), window.GetGradBG2());
 
-
     //
     // Do the funny business to force an update. ... and called avtDataObject
     //
@@ -592,7 +648,6 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     //
     delete software;
     avtRay::SetArbitrator(NULL);
-
     delete compositeRF;
 
     //
@@ -715,9 +770,10 @@ avtImage_p
 avtVolumeFilter::RenderImage(avtImage_p opaque_image,
                              const WindowAttributes &window)
 {
-#ifdef VISIT_SLIVR
-    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR){
-        return RenderImageRaycastingSLIVR(opaque_image,window);
+#if defined(VISIT_SLIVR) || defined(VISIT_SLIVR)
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+        atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay){
+        return RenderImageRayCasting(opaque_image,window);
     }
 #endif
 
@@ -1247,7 +1303,8 @@ avtVolumeFilter::ModifyContract(avtContract_p contract)
     {
         if (((atts.GetRendererType() == VolumeAttributes::RayCasting) &&
             (atts.GetSampling() == VolumeAttributes::Trilinear)) ||
-            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR))
+            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) ||
+            (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay))
             ds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
         newcontract = new avtContract(contract, ds);
         primaryVariable = new char[strlen(var)+1];
@@ -1272,7 +1329,8 @@ avtVolumeFilter::ModifyContract(avtContract_p contract)
 
         if (((atts.GetRendererType() == VolumeAttributes::RayCasting) &&
             (atts.GetSampling() == VolumeAttributes::Trilinear)) ||
-            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR))
+            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) ||
+            (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay))
             nds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
         newcontract = new avtContract(contract, nds);
         primaryVariable = new char[exprName.size()+1];
@@ -1289,7 +1347,8 @@ avtVolumeFilter::ModifyContract(avtContract_p contract)
         nds->AddSecondaryVariable(var);
         if (((atts.GetRendererType() == VolumeAttributes::RayCasting) &&
             (atts.GetSampling() == VolumeAttributes::Trilinear)) ||
-            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR))
+            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) ||
+            (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay))
             nds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
         newcontract = new avtContract(contract, nds);
         primaryVariable = new char[strlen(exprName.c_str())+1];
diff --git a/plots/Volume/avtVolumeFilter.h b/plots/Volume/avtVolumeFilter.h
index d60df439ed..efe7d987d9 100644
--- a/plots/Volume/avtVolumeFilter.h
+++ b/plots/Volume/avtVolumeFilter.h
@@ -44,11 +44,17 @@
 #define AVT_VOLUME_FILTER_H
 
 #include <avtDatasetToDatasetFilter.h>
-#include <avtOpacityMap.h>
 
 #include <VolumeAttributes.h>
 
 #include <avtImage.h>
+#include <avtOpacityMap.h>
+
+#ifdef VISIT_OSPRAY
+# define VISIT_OSPRAY_CONTEXT_ONLY /*dont have to include helper funcitons*/
+# include <avtOSPRayCommon.h>
+# undef VISIT_OSPRAY_CONTEXT_ONLY
+#endif
 
 class     WindowAttributes;
 
@@ -89,15 +95,22 @@ class avtVolumeFilter : public avtDatasetToDatasetFilter
                                   { return "Volume rendering"; };
 
     avtImage_p               RenderImage(avtImage_p, const WindowAttributes &);
-#ifdef VISIT_SLIVR
-    avtImage_p               RenderImageRaycastingSLIVR(avtImage_p opaque_image, const WindowAttributes &);
+    
+#if defined(VISIT_SLIVR) || defined(VISIT_OSPRAY)
+    avtImage_p               RenderImageRayCasting(avtImage_p,
+                                                   const WindowAttributes &);
 #endif
+
     int                      GetNumberOfStages(const WindowAttributes &);
 
   protected:
     VolumeAttributes         atts;
     char                    *primaryVariable;
 
+#ifdef VISIT_OSPRAY
+    OSPVisItContext *ospray;
+#endif
+
     avtOpacityMap            CreateOpacityMap(double range[2]);
 
     virtual void             Execute(void);
diff --git a/plots/Volume/avtVolumePlot.C b/plots/Volume/avtVolumePlot.C
index ecdf4b192e..6ef3990c6a 100644
--- a/plots/Volume/avtVolumePlot.C
+++ b/plots/Volume/avtVolumePlot.C
@@ -233,7 +233,8 @@ avtVolumePlot::PlotIsImageBased(void)
 {
     return (atts.GetRendererType() == VolumeAttributes::RayCasting ||
             atts.GetRendererType() == VolumeAttributes::RayCastingIntegration ||
-            atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR);
+            atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+            atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay);
 }
 
 
@@ -689,7 +690,8 @@ avtVolumePlot::ApplyRenderingTransformation(avtDataObject_p input)
 
     if (atts.GetRendererType() == VolumeAttributes::RayCasting ||
         atts.GetRendererType() == VolumeAttributes::RayCastingIntegration ||
-        atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR)
+        atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+        atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay)
     {
 #ifdef ENGINE
         // gradient calc for raycasting integration not needed, but
diff --git a/svn_bin/bv_support/bv_embree.sh b/svn_bin/bv_support/bv_embree.sh
new file mode 100644
index 0000000000..d8c52aec5d
--- /dev/null
+++ b/svn_bin/bv_support/bv_embree.sh
@@ -0,0 +1,172 @@
+function bv_embree_initialize
+{
+    export DO_EMBREE="no"
+    export USE_SYSTEM_EMBREE="no"
+    export EMBREE_INSTALL_DIR=""
+    add_extra_commandline_args "embree" "alt-embree-dir" 1 "Use alternative directory for embree"
+}
+
+function bv_embree_enable
+{
+    DO_EMBREE="yes"
+}
+
+function bv_embree_disable
+{
+    DO_EMBREE="no"
+}
+
+function bv_embree_alt_embree_dir
+{
+    echo "Using alternate embree directory"
+    bv_embree_enable
+    USE_SYSTEM_EMBREE="yes"
+    EMBREE_INSTALL_DIR="$1"
+}
+
+function bv_embree_depends_on
+{
+    echo ""
+}
+
+function bv_embree_initialize_vars
+{
+    info "initializing embree vars"
+    if [[ "$DO_EMBREE" == "yes" ]] ; then
+        if [[ "$USE_SYSTEM_EMBREE" == "no" ]]; then
+            EMBREE_INSTALL_DIR=$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH
+        fi
+    fi
+}
+
+function bv_embree_info
+{
+    export EMBREE_VERSION=${EMBREE_VERSION:-"3.2.0"}
+    if [[ "$OPSYS" == "Darwin" ]] ; then
+        export EMBREE_FILE=${EMBREE_FILE:-"embree-${EMBREE_VERSION}.x86_64.macosx.tar.gz"}
+    else
+        export EMBREE_FILE=${EMBREE_FILE:-"embree-${EMBREE_VERSION}.x86_64.linux.tar.gz"}
+    fi
+    export EMBREE_COMPATIBILITY_VERSION=${EMBREE_COMPATIBILITY_VERSION:-"${EMBREE_VERSION}"}
+    export EMBREE_BUILD_DIR=${EMBREE_BUILD_DIR:-"${EMBREE_VERSION}"}
+    export EMBREE_URL=${EMBREE_URL:-"https://github.com/embree/embree/releases/download/v${EMBREE_VERSION}/"}
+    export EMBREE_INSTALL_DIR_NAME=embree-$EMBREE_VERSION.x86_64.linux
+    export EMBREE_MD5_CHECKSUM=""
+    export EMBREE_SHA256_CHECKSUM=""
+}
+
+function bv_embree_print
+{
+    printf "%s%s\n" "EMBREE_FILE=" "${EMBREE_FILE}"
+    printf "%s%s\n" "EMBREE_VERSION=" "${EMBREE_VERSION}"
+    printf "%s%s\n" "EMBREE_COMPATIBILITY_VERSION=" "${EMBREE_COMPATIBILITY_VERSION}"
+    printf "%s%s\n" "EMBREE_BUILD_DIR=" "${EMBREE_BUILD_DIR}"
+}
+
+function bv_embree_host_profile
+{
+    if [[ "$DO_EMBREE" == "yes" ]] ; then
+        echo >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        echo "## EMBREE" >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        if [[ "$USE_SYSTEM_EMBREE" == "no" ]]; then
+            echo "VISIT_OPTION_DEFAULT(VISIT_EMBREE_ROOT \${VISITHOME}/embree/$EMBREE_VERSION/\${VISITARCH})" >> $HOSTCONF
+        else
+            echo "VISIT_OPTION_DEFAULT(VISIT_EMBREE_ROOT ${EMBREE_INSTALL_DIR})" >> $HOSTCONF
+        fi
+    fi
+}
+
+function bv_embree_print_usage
+{
+    #embree does not have an option, it is only dependent on embree.
+    printf "%-15s %s [%s]\n" "--embree" "Build embree" "$DO_EMBREE"
+}
+
+function bv_embree_ensure
+{
+    if [[ "$DO_EMBREE" == "yes" && "$USE_SYSTEM_EMBREE" == "no" ]] ; then
+        ensure_built_or_ready "embree" $EMBREE_VERSION $EMBREE_BUILD_DIR $EMBREE_FILE $EMBREE_URL
+        if [[ $? != 0 ]] ; then
+            ANY_ERRORS="yes"
+            DO_EMBREE="no"
+            error "Unable to build embree.  ${EMBREE_FILE} not found."
+        fi
+    elif [[ "$USE_SYSTEM_EMBREE" == "yes" ]] ; then
+        if [[ ! -d $EMBREE_INSTALL_DIR/include/embree3 ]]; then
+            error "Unable to find embree v3.+ in the alternative path, perhaps a wrong embree version is provided."
+        fi
+    fi
+}
+
+function bv_embree_dry_run
+{
+    if [[ "$DO_EMBREE" == "yes" ]] ; then
+        echo "Dry run option not set for embree."
+    fi
+}
+
+# ***************************************************************************
+# build_embree
+#
+# Modifications:
+#
+# ***************************************************************************
+
+function build_embree
+{
+    # Unzip the EMBREE tarball and copy it to the VisIt installation.
+    info "Installing prebuilt embree"    
+    tar zxvf $EMBREE_FILE
+    rm $EMBREE_INSTALL_DIR_NAME/lib/libtbbmalloc.so.2
+    rm $EMBREE_INSTALL_DIR_NAME/lib/libtbb.so.2
+    mkdir -p $VISITDIR/embree/$EMBREE_VERSION/$VISITARCH
+    cp -R $EMBREE_INSTALL_DIR_NAME/* "$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH"
+    rm -rf $EMBREE_INSTALL_DIR_NAME
+    if [[ "$DO_GROUP" == "yes" ]] ; then
+        chmod -R ug+w,a+rX "$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH"
+        chgrp -R ${GROUP} "$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH"
+    fi
+    cd "$START_DIR"
+    info "Done with embree"
+    return 0
+}
+
+function bv_embree_is_enabled
+{
+    if [[ $DO_EMBREE == "yes" ]]; then
+        return 1    
+    fi
+    return 0
+}
+
+function bv_embree_is_installed
+{
+    if [[ "$USE_SYSTEM_EMBREE" == "yes" ]]; then   
+        return 1
+    fi
+
+    check_if_installed "embree" $EMBREE_VERSION
+    if [[ $? == 0 ]] ; then
+        return 1
+    fi
+    return 0
+}
+
+function bv_embree_build
+{
+    if [[ "$DO_EMBREE" == "yes" && "$USE_SYSTEM_EMBREE" == "no" ]] ; then
+        check_if_installed "embree" $EMBREE_VERSION
+        if [[ $? == 0 ]] ; then
+            info "Skipping build of embree"
+        else
+            build_embree
+            if [[ $? != 0 ]] ; then
+                error "Unable to build or install embree.  Bailing out."
+            fi
+            info "Done building embree"
+        fi
+    fi
+}
+
diff --git a/svn_bin/bv_support/bv_ispc.sh b/svn_bin/bv_support/bv_ispc.sh
new file mode 100644
index 0000000000..89690c4fe9
--- /dev/null
+++ b/svn_bin/bv_support/bv_ispc.sh
@@ -0,0 +1,167 @@
+function bv_ispc_initialize
+{
+    export DO_ISPC="no"
+    export USE_SYSTEM_ISPC="no"
+    export ISPC_INSTALL_DIR=""
+    add_extra_commandline_args "ispc" "alt-ispc-dir" 1 "Use alternative directory for ispc"
+}
+
+function bv_ispc_enable
+{
+    DO_ISPC="yes"
+}
+
+function bv_ispc_disable
+{
+    DO_ISPC="no"
+}
+
+function bv_ispc_alt_ispc_dir
+{
+    echo "Using alternate ispc directory"
+    bv_ispc_enable
+    USE_SYSTEM_ISPC="yes"
+    ISPC_INSTALL_DIR="$1"
+}
+
+function bv_ispc_depends_on
+{
+    echo ""
+}
+
+function bv_ispc_initialize_vars
+{
+    info "initializing ispc vars"
+    if [[ "$DO_ISPC" == "yes" ]] ; then
+        if [[ "$USE_SYSTEM_ISPC" == "no" ]]; then
+            ISPC_INSTALL_DIR=$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH
+        fi
+    fi
+}
+
+function bv_ispc_info
+{
+    export ISPC_VERSION=${ISPC_VERSION:-"1.9.2"}
+    if [[ "$OPSYS" == "Darwin" ]] ; then
+        export ISPC_FILE=${ISPC_FILE:-"ispc-v${ISPC_VERSION}-osx.tar.gz"}
+        export ISPC_URL=${ISPC_URL:-"http://sdvis.org/ospray/download/dependencies/osx/"}
+    else
+        export ISPC_FILE=${ISPC_FILE:-"ispc-v${ISPC_VERSION}-linux.tar.gz"}
+        export ISPC_URL=${ISPC_URL:-"http://sdvis.org/ospray/download/dependencies/linux/"}
+    fi
+    export ISPC_COMPATIBILITY_VERSION=${ISPC_COMPATIBILITY_VERSION:-"${ISPC_VERSION}"}
+    export ISPC_BUILD_DIR=${ISPC_BUILD_DIR:-"${ISPC_VERSION}"}
+    export ISPC_INSTALL_DIR_NAME=ispc-v$ISPC_VERSION-linux
+    export ISPC_MD5_CHECKSUM=""
+    export ISPC_SHA256_CHECKSUM=""
+}
+
+function bv_ispc_print
+{
+    printf "%s%s\n" "ISPC_FILE=" "${ISPC_FILE}"
+    printf "%s%s\n" "ISPC_VERSION=" "${ISPC_VERSION}"
+    printf "%s%s\n" "ISPC_COMPATIBILITY_VERSION=" "${ISPC_COMPATIBILITY_VERSION}"
+    printf "%s%s\n" "ISPC_BUILD_DIR=" "${ISPC_BUILD_DIR}"
+}
+
+function bv_ispc_host_profile
+{
+    if [[ "$DO_ISPC" == "yes" ]]; then
+        echo >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        echo "## ISPC" >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        if [[ "$USE_SYSTEM_ISPC" == "no" ]]; then
+            echo "VISIT_OPTION_DEFAULT(VISIT_ISPC_ROOT \${VISITHOME}/ispc/$ISPC_VERSION/\${VISITARCH})" >> $HOSTCONF
+        else
+            echo "VISIT_OPTION_DEFAULT(VISIT_ISPC_ROOT ${ISPC_INSTALL_DIR})" >> $HOSTCONF
+        fi
+    fi
+}
+
+function bv_ispc_print_usage
+{
+    #ispc does not have an option, it is only dependent on ispc.
+    printf "%-15s %s [%s]\n" "--ispc" "Build ISPC" "$DO_ISPC"
+}
+
+function bv_ispc_ensure
+{
+    if [[ "$DO_ISPC" == "yes" && "$USE_SYSTEM_ISPC" == "no" ]] ; then
+        ensure_built_or_ready "ispc" $ISPC_VERSION $ISPC_BUILD_DIR $ISPC_FILE $ISPC_URL
+        if [[ $? != 0 ]] ; then
+            ANY_ERRORS="yes"
+            DO_ISPC="no"
+            error "Unable to build ISPC.  ${ISPC_FILE} not found."
+        fi
+    fi
+}
+
+function bv_ispc_dry_run
+{
+    if [[ "$DO_ISPC" == "yes" ]] ; then
+        echo "Dry run option not set for ISPC."
+    fi
+}
+
+# ***************************************************************************
+# build_ispc
+#
+# Modifications:
+#
+# ***************************************************************************
+
+function build_ispc
+{
+    # Unzip the ISPC tarball and copy it to the VisIt installation.
+    info "Installing prebuilt ISPC"    
+    tar zxvf $ISPC_FILE
+    mkdir -p $VISITDIR/ispc/$ISPC_VERSION/$VISITARCH
+    cp -R $ISPC_INSTALL_DIR_NAME/* "$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH"
+    rm -rf $ISPC_INSTALL_DIR_NAME
+    if [[ "$DO_GROUP" == "yes" ]] ; then
+        chmod -R ug+w,a+rX "$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH"
+        chgrp -R ${GROUP} "$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH"
+    fi
+    cd "$START_DIR"
+    info "Done with ISPC"
+    return 0
+}
+
+function bv_ispc_is_enabled
+{
+    if [[ $DO_ISPC == "yes" ]]; then
+        return 1    
+    fi
+    return 0
+}
+
+function bv_ispc_is_installed
+{
+    if [[ "$USE_SYSTEM_ISPC" == "yes" ]]; then   
+        return 1
+    fi
+
+    check_if_installed "ispc" $ISPC_VERSION
+    if [[ $? == 0 ]] ; then
+        return 1
+    fi
+    return 0
+}
+
+function bv_ispc_build
+{
+    if [[ "$DO_ISPC" == "yes" && "$USE_SYSTEM_ISPC" == "no" ]] ; then
+        check_if_installed "ispc" $ISPC_VERSION
+        if [[ $? == 0 ]] ; then
+            info "Skipping build of ISPC"
+        else
+            build_ispc
+            if [[ $? != 0 ]] ; then
+                error "Unable to build or install ISPC.  Bailing out."
+            fi
+            info "Done building ISPC"
+        fi
+    fi
+}
+
diff --git a/svn_bin/bv_support/bv_ospray.sh b/svn_bin/bv_support/bv_ospray.sh
index 0db31d3517..921562a5e3 100644
--- a/svn_bin/bv_support/bv_ospray.sh
+++ b/svn_bin/bv_support/bv_ospray.sh
@@ -1,3 +1,5 @@
+# Module automatically read in from construct_build_visit
+# Insert header and comments
 function bv_ospray_initialize
 {
     export DO_OSPRAY="no"
@@ -15,24 +17,39 @@ function bv_ospray_disable
 
 function bv_ospray_depends_on
 {
-    depends_on=""
-
+    depends_on="cmake ispc embree tbb"
+    #echo | cpp -fopenmp -dM | grep -i open
+    #if [[ "$DO_TBB" == "yes" ]]; then
+    #    depends_on="${depends_on} tbb"
+    #fi
     echo ${depends_on}
 }
 
 function bv_ospray_info
 {
+    # versions
     export OSPRAY_VERSION=${OSPRAY_VERSION:-"1.6.1"}
-    export OSPRAY_FILE=${OSPRAY_FILE:-"ospray-${OSPRAY_VERSION}.x86_64.linux.tar.gz"}
-    export OSPRAY_BUILD_DIR=${OSPRAY_BUILD_DIR:-"ospray-${OSPRAY_VERSION}.x86_64.linux"}
-    export OSPRAY_URL=${OSPRAY_URL:-"https://github.com/ospray/ospray/releases/download/v${OSPRAY_VERSION}/"}
+    export OSPRAY_VISIT_MODULE_VERSION=${OSPRAY_VISIT_MODULE_VERSION:-"1.6.x"}
+    
+    # ospray source
+    export OSPRAY_TARBALL=${OSPRAY_TARBALL:-"ospray-${OSPRAY_VERSION}.tar.gz"}
+    export OSPRAY_BUILD_DIR=${OSPRAY_BUILD_DIR:-"ospray-${OSPRAY_VERSION}"}
+    export OSPRAY_DOWNLOAD_URL=${OSPRAY_DOWNLOAD_URL:-"https://github.com/wilsonCernWq/module_visit/releases/download/v1.6.x/"}
+
+    # ospray module
+    export OSPRAY_VISIT_MODULE_TARBALL=${OSPRAY_VISIT_MODULE_TARBALL:-"ospray-module-visit-release-${OSPRAY_VISIT_MODULE_VERSION}.zip"}
+    export OSPRAY_VISIT_MODULE_UNTAR_DIR=${OSPRAY_VISIT_MODULE_UNTAR_DIR:-"module_visit-release-${OSPRAY_VISIT_MODULE_VERSION}"}
+    export OSPRAY_VISIT_MODULE_BUILD_DIR=${OSPRAY_VISIT_MODULE_BUILD_DIR:-"${OSPRAY_BUILD_DIR}/modules/module_visit"}
+    export OSPRAY_VISIT_MODULE_DOWNLOAD_URL=${OSPRAY_VISIT_MODULE_DOWNLOAD_URL:-"https://github.com/wilsonCernWq/module_visit/releases/download/v1.6.x/"}
+    
+    # checksum
     export OSPRAY_MD5_CHECKSUM=""
     export OSPRAY_SHA256_CHECKSUM=""
 }
 
 function bv_ospray_print
 {
-    print "%s%s\n" "OSPRAY_FILE=" "${OSPRAY_FILE}"
+    print "%s%s\n" "OSPRAY_TARBALL=" "${OSPRAY_TARBALL}"
     print "%s%s\n" "OSPRAY_VERSION=" "${OSPRAY_VERSION}"
     print "%s%s\n" "OSPRAY_TARGET=" "${OSPRAY_TARGET}"
     print "%s%s\n" "OSPRAY_BUILD_DIR=" "${OSPRAY_BUILD_DIR}"
@@ -45,13 +62,19 @@ function bv_ospray_print_usage
 
 function bv_ospray_host_profile
 {
-    if [[ "$DO_OSPRAY" == "yes" ]] ; then
+    if [[ "$DO_OSPRAY" == "yes" ]]; then
         echo >> $HOSTCONF
         echo "##" >> $HOSTCONF
         echo "## OSPRay" >> $HOSTCONF
         echo "##" >> $HOSTCONF
         echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY ON TYPE BOOL)" >> $HOSTCONF
-        echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY_DIR \${VISITHOME}/ospray/$OSPRAY_VERSION/\${VISITARCH})" >> $HOSTCONF
+        if [[ -d $OSPRAY_INSTALL_DIR/lib ]]; then
+            echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY_DIR \${VISITHOME}/ospray/$OSPRAY_VERSION/\${VISITARCH}/lib/cmake/ospray-${OSPRAY_VERSION})" >> $HOSTCONF
+        elif [[ -d $OSPRAY_INSTALL_DIR/lib64 ]]; then
+            echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY_DIR \${VISITHOME}/ospray/$OSPRAY_VERSION/\${VISITARCH}/lib64/cmake/ospray-${OSPRAY_VERSION})" >> $HOSTCONF
+        else
+            error "No library path for OSPRay has been found."
+        fi
     fi
 }
 
@@ -69,18 +92,27 @@ function bv_ospray_ensure
         ensure_built_or_ready "ospray" \
             $OSPRAY_VERSION \
             $OSPRAY_BUILD_DIR \
-            $OSPRAY_FILE \
-            $OSPRAY_URL
+            $OSPRAY_TARBALL \
+            $OSPRAY_DOWNLOAD_URL 
         if [[ $? != 0 ]] ; then
             return 1
         fi
+        ensure_built_or_ready "ospray-visit-module" \
+            $OSPRAY_VISIT_MODULE_VERSION \
+            $OSPRAY_VISIT_MODULE_BUILD_DIR \
+            $OSPRAY_VISIT_MODULE_TARBALL \
+            $OSPRAY_VISIT_MODULE_DOWNLOAD_URL
+        if [[ $? != 0 ]] ; then
+            return 1
+        fi
+
     fi
 }
 
 function bv_ospray_initialize_vars
 {
     info "initializing ospray vars"
-    if [[ "$DO_OSPRAY" == "yes" ]] ; then
+    if [[ "$DO_OSPRAY" == "yes" ]]; then
         OSPRAY_INSTALL_DIR="${VISITDIR}/ospray/${OSPRAY_VERSION}/${VISITARCH}"
         OSPRAY_INCLUDE_DIR="${OSPRAY_INSTALL_DIR}/include"
         OSPRAY_LIB_DIR="${OSPRAY_INSTALL_DIR}/lib"
@@ -106,28 +138,77 @@ function bv_ospray_is_installed
     return 0
 }
 
+function build_ospray_in_source
+{
+    # set compiler if the user hasn't explicitly set CC and CXX
+    if [ -z $CC ]; then
+        echo "***NOTE: using compiler $C_COMPILER/$CXX_COMPILER!"
+        export CC=$C_COMPILER
+        export CXX=$CXX_COMPILER
+    fi
+
+    #### Build OSPRay ####
+    mkdir -p build
+    cd build
+
+    # Clean out build directory to be sure we are doing a fresh build
+    rm -rf *
+
+    # set release and RPM settings
+    info "Configure OSPRay . . . "
+    CMAKE_INSTALL=${CMAKE_INSTALL:-"$VISITDIR/cmake/${CMAKE_VERSION}/$VISITARCH/bin"}
+    ${CMAKE_INSTALL}/cmake -D CMAKE_INSTALL_PREFIX=$OSPRAY_INSTALL_DIR \
+        -D embree_DIR=$EMBREE_INSTALL_DIR \
+        -D TBB_ROOT=$TBB_INSTALL_DIR \
+        -D ISPC_EXECUTABLE=$ISPC_INSTALL_DIR/ispc \
+        -D OSPRAY_BUILD_ISA=ALL \
+        -D OSPRAY_MODULE_VISIT=ON \
+        -D OSPRAY_MODULE_MPI=OFF \
+        -D OSPRAY_MODULE_MPI_APPS=OFF \
+        -D OSPRAY_APPS_EXAMPLEVIEWER=OFF \
+        -D OSPRAY_APPS_BENCHMARK=OFF \
+        -D OSPRAY_SG_CHOMBO=OFF \
+        -D OSPRAY_SG_OPENIMAGEIO=OFF \
+        -D OSPRAY_SG_VTK=OFF \
+        -D OSPRAY_ZIP_MODE=OFF \
+        .. || error "OSPRay did not configure correctly.  Giving up."
+
+    #
+    # Now build OSPRay
+    #
+    info "Building OSPRay (~10 minute)"
+    env DYLD_LIBRARY_PATH=`pwd`/bin $MAKE $MAKE_OPT_FLAGS || \
+        error "OSPRay did not build correctly.  Giving up."
+
+    info "Installing OSPRay . . . "
+    $MAKE install || error "OSPRay did not install correctly."
+}
+
 function build_ospray
 {
-    prepare_build_dir $OSPRAY_BUILD_DIR $OSPRAY_FILE
+    # prepare directories
+    prepare_build_dir $OSPRAY_BUILD_DIR $OSPRAY_TARBALL
     untarred_ospray=$?
-    if [[ $untarred_ospray == -1 ]] ; then
+    if [[ $untarred_ospray == -1 ]]; then
         warn "Unable to prepare OSPRay build directory. Giving up!"
         return 1
     fi
-
-    cd $OSPRAY_BUILD_DIR || error "Couldn't cd to OSPRay build dir."
-    info "Installing OSPRay . . ."
-    echo mkdir -p ${OSPRAY_INSTALL_DIR}
-    mkdir -p ${OSPRAY_INSTALL_DIR}
-    echo cp -a include lib ${OSPRAY_INSTALL_DIR}
-    cp -a include lib ${OSPRAY_INSTALL_DIR}
-
-    if [[  $? != 0 ]] ; then
-        warn "OSPRay install failed. Giving up"
+    prepare_build_dir $OSPRAY_VISIT_MODULE_BUILD_DIR $OSPRAY_VISIT_MODULE_TARBALL
+    untarred_ospray_visit_module=$?
+    if [[ $untarred_ospray_visit_module == -1 ]]; then
+        warn "Unable to prepare OSPRay build directory. Giving up!"
         return 1
+    elif [[ $untarred_ospray_visit_module == 1 ]]; then
+        rm -fr $OSPRAY_VISIT_MODULE_BUILD_DIR
+        mv $OSPRAY_VISIT_MODULE_UNTAR_DIR $OSPRAY_VISIT_MODULE_BUILD_DIR
     fi
-    
-    if [[ "$DO_GROUP" == "yes" ]] ; then
+
+    # build and install
+    cd $OSPRAY_BUILD_DIR || error "Couldn't cd to OSPRay build dir."
+    build_ospray_in_source
+
+    # others
+    if [[ "$DO_GROUP" == "yes" ]]; then
         chmod -R ug+w,a+rX "$VISITDIR/ospray"
         chgrp -R ${GROUP} "$VISITDIR/ospray"
     fi
@@ -144,12 +225,11 @@ function bv_ospray_build
         if [[ $? == 0 ]] ; then
             info "Skipping OSPRay build. OSPRay is already installed."
         else
-            info "Building OSPRay (~1 minute)"
             build_ospray
-            if [[ $? != 0 ]] ; then
+            if [[ $? != 0 ]]; then
                 error "Unable to build or install OSPRay. Bailing out."
             fi
-            info "Done building OSPRay"
         fi
     fi
 }
+
diff --git a/svn_bin/bv_support/bv_tbb.sh b/svn_bin/bv_support/bv_tbb.sh
index e353018811..4b247dcc9f 100644
--- a/svn_bin/bv_support/bv_tbb.sh
+++ b/svn_bin/bv_support/bv_tbb.sh
@@ -1,6 +1,9 @@
 function bv_tbb_initialize
 {
     export DO_TBB="no"
+    export USE_SYSTEM_TBB="no"
+    export TBB_INSTALL_DIR=""
+    add_extra_commandline_args "tbb" "alt-tbb-dir" 1 "Use alternative directory for tbb"
 }
 
 function bv_tbb_enable
@@ -13,9 +16,32 @@ function bv_tbb_disable
     DO_TBB="no"
 }
 
+function bv_tbb_alt_tbb_dir
+{
+    echo "Using alternate TBB directory"
+    bv_tbb_enable
+    USE_SYSTEM_TBB="yes"
+    TBB_INSTALL_DIR="$1"
+}
+
 function bv_tbb_depends_on
 {
-    echo ""
+    if [[ "$USE_SYSTEM_TBB" == "yes" ]] ; then
+        echo ""
+    else
+        echo ""
+    fi
+}
+
+function bv_tbb_initialize_vars
+{
+    info "initializing TBB vars"
+    if [[ "$DO_TBB" == "yes" ]] ; then
+        if [[ "$USE_SYSTEM_TBB" == "no" ]]; then
+            TBB_INSTALL_DIR=$VISITDIR/tbb/$TBB_VERSION/$VISITARCH
+        fi
+    fi
+    export TBB_ROOT="${TBB_INSTALL_DIR}"
 }
 
 function bv_tbb_info
@@ -47,8 +73,11 @@ function bv_tbb_host_profile
         echo "##" >> $HOSTCONF
         echo "## TBB" >> $HOSTCONF
         echo "##" >> $HOSTCONF
-        echo "VISIT_OPTION_DEFAULT(TBB_ROOT \${VISITHOME}/tbb/\${VISITARCH}/$TBB_VERSION)" \
-            >> $HOSTCONF
+        if [[ "$USE_SYSTEM_TBB" == "no" ]]; then
+            echo "VISIT_OPTION_DEFAULT(TBB_ROOT \${VISITHOME}/tbb/$TBB_VERSION/\${VISITARCH})" >> $HOSTCONF
+        else
+            echo "VISIT_OPTION_DEFAULT(TBB_ROOT ${TBB_INSTALL_DIR})" >> $HOSTCONF
+        fi
     fi
 }
 
@@ -60,7 +89,7 @@ function bv_tbb_print_usage
 
 function bv_tbb_ensure
 {
-    if [[ "$DO_TBB" == "yes" ]] ; then
+    if [[ "$DO_TBB" == "yes" && "$USE_SYSTEM_TBB" == "no" ]] ; then
         ensure_built_or_ready "tbb" $TBB_VERSION $TBB_BUILD_DIR $TBB_FILE
         if [[ $? != 0 ]] ; then
             ANY_ERRORS="yes"
@@ -89,14 +118,14 @@ function build_tbb
     # Unzip the TBB tarball and copy it to the VisIt installation.
     info "Installing prebuilt TBB"
     tar zxvf $TBB_FILE
-    mkdir $VISITDIR/tbb
-    mkdir $VISITDIR/tbb/$VISITARCH
-    cp -R $TBB_VERSION "$VISITDIR/tbb/$VISITARCH"
+    mkdir -p $VISITDIR/tbb/$TBB_VERSION/$VISITARCH
+    cp -R $TBB_VERSION/* "$VISITDIR/tbb/$TBB_VERSION/$VISITARCH"
     rm -rf $TBB_VERSION
 
+    # others
     if [[ "$DO_GROUP" == "yes" ]] ; then
-        chmod -R ug+w,a+rX "$VISITDIR/tbb/$VISITARCH"
-        chgrp -R ${GROUP} "$VISITDIR/tbb/$VISITARCH"
+        chmod -R ug+w,a+rX "$VISITDIR/tbb/$TBB_VERSION/$VISITARCH"
+        chgrp -R ${GROUP} "$VISITDIR/tbb/$TBB_VERSION/$VISITARCH"
     fi
     cd "$START_DIR"
     info "Done with TBB"
@@ -113,7 +142,11 @@ function bv_tbb_is_enabled
 
 function bv_tbb_is_installed
 {
-    check_if_installed "tbb"
+    if [[ "$USE_SYSTEM_TBB" == "yes" ]]; then   
+        return 1
+    fi
+
+    check_if_installed "tbb" $TBB_VERSION
     if [[ $? == 0 ]] ; then
         return 1
     fi
@@ -122,8 +155,8 @@ function bv_tbb_is_installed
 
 function bv_tbb_build
 {
-    if [[ "$DO_TBB" == "yes" ]] ; then
-        check_if_installed "tbb"
+    if [[ "$DO_TBB" == "yes" && "$USE_SYSTEM_TBB" == "no" ]] ; then
+        check_if_installed "tbb" $TBB_VERSION
         if [[ $? == 0 ]] ; then
             info "Skipping build of TBB"
         else
diff --git a/svn_bin/bv_support/bv_vtk.sh b/svn_bin/bv_support/bv_vtk.sh
index 0516822c9c..4160290ce4 100644
--- a/svn_bin/bv_support/bv_vtk.sh
+++ b/svn_bin/bv_support/bv_vtk.sh
@@ -51,7 +51,7 @@ function bv_vtk_depends_on
     fi
 
     if [[ "$DO_OSPRAY" == "yes" ]]; then
-        depends_on="${depends_on} ospray"
+        depends_on="${depends_on} embree ospray"
     fi
 
     # Only depend on Qt if we're not doing server-only builds.
@@ -803,6 +803,7 @@ function build_vtk
     if [[ "$DO_OSPRAY" == "yes" ]] ; then
         vopts="${vopts} -DModule_vtkRenderingOSPRay:BOOL=ON"
         vopts="${vopts} -DOSPRAY_INSTALL_DIR=${OSPRAY_INSTALL_DIR}"
+        vopts="${vopts} -Dembree_DIR=${EMBREE_INSTALL_DIR}"
     fi
 
     CMAKE_BIN="${CMAKE_INSTALL}/cmake"
diff --git a/svn_bin/bv_support/modules.xml b/svn_bin/bv_support/modules.xml
index f662420992..8af931c196 100644
--- a/svn_bin/bv_support/modules.xml
+++ b/svn_bin/bv_support/modules.xml
@@ -20,6 +20,7 @@
             <lib name="conduit"/>
             <lib name="cgns"/>
             <lib name="eavl"/>
+            <lib name="embree"/>
             <lib name="fastbit"/>
             <lib name="fastquery"/>
             <lib name="gdal"/>
@@ -28,6 +29,7 @@
             <lib name="hdf4"/>
             <lib name="hdf5"/>
             <lib name="icet"/>
+            <lib name="ispc"/>
             <lib name="llvm"/>
 <!--        <lib name="mdsplus"/>    Removed for now by Allen Sanderson-->
             <lib name="mesagl"/>
@@ -39,10 +41,10 @@
             <lib name="nektarpp"/>
             <lib name="netcdf"/>
             <lib name="openexr"/>
-            <lib name="pidx"/>
             <lib name="openssl"/>
             <lib name="osmesa"/>
             <lib name="ospray"/>
+            <lib name="pidx"/>
             <lib name="pyside"/>
             <lib name="silo"/>
             <lib name="szip"/>
@@ -73,11 +75,13 @@
             <lib name="cfitsio"/>
             <lib name="conduit"/>
             <lib name="cgns"/>
+            <lib name="embree"/>
             <lib name="gdal"/>
             <lib name="fastbit"/>
             <lib name="fastquery"/>
             <lib name="hdf5"/>
             <lib name="h5part"/>
+            <lib name="ispc"/>
             <lib name="mpich"/>
             <lib name="mxml"/>
             <lib name="netcdf"/>
@@ -89,6 +93,7 @@
             <lib name="pyside"/>
             <lib name="silo"/>
             <lib name="szip"/>
+            <lib name="tbb"/>
             <lib name="uintah"/>
             <lib name="visus"/>
             <lib name="xdmf"/>
@@ -169,6 +174,9 @@
         -->
         <group name="nonio" comment="Build non I/O libraries" enabled="no">
             <lib name="icet"/>
+            <lib name="embree"/>
+            <lib name="ispc"/>
+            <lib name="tbb"/>
             <lib name="ospray"/>
         </group>
 
