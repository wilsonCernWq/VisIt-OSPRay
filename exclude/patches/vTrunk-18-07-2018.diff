diff --git a/CMakeLists.txt b/CMakeLists.txt
index a2b91e962e..9ae29cdbd1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -426,6 +426,9 @@
 #    icons. Previously, this resulted in a couple of invalid symbolic links
 #    ending up in the distribution file.
 #
+#    Qi WU, Sat Jun 10 22:21:27 MST 2018
+#    I added support to find OSPRay
+#
 #****************************************************************************/
 
 CMAKE_MINIMUM_REQUIRED(VERSION 3.8 FATAL_ERROR)
@@ -694,8 +697,8 @@ SET(CXX_TEST_PATH ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
 # configure options
 #-----------------------------------------------------------------------------
 OPTION(VISIT_PARALLEL "Build VisIt's parallel compute engine." OFF)
-
 OPTION(VISIT_SLIVR    "Build VisIt with support for the SLIVR volume rendering library." ON)
+OPTION(VISIT_OSPRAY   "Build VisIt with support for the OSPRay volume rendering library." OFF)
 OPTION(VISIT_STATIC   "Build VisIt statically." OFF)
 IF(VISIT_STATIC)
     ADD_DEFINITIONS(-DVISIT_STATIC)
@@ -871,6 +874,11 @@ VISIT_3RDPARTY_VAR(ZLIB_DIR      "Path containing the zlib library's include and
 VISIT_3RDPARTY_VAR(MOAB_DIR      "Path containing the MOAB library's include and lib")
 VISIT_3RDPARTY_VAR(MOAB_MPI_DIR  "Path containing the parallel MOAB library's include and lib")
 
+VISIT_3RDPARTY_VAR(OSPRAY_DIR    "Path containing the OSPRay library's include and lib")
+VISIT_3RDPARTY_VAR(EMBREE_ROOT   "Path containing the embree library's include and lib")
+VISIT_3RDPARTY_VAR(ISPC_ROOT     "Path containing the ISPC library's include and lib")
+VISIT_3RDPARTY_VAR(TBB_ROOT      "Path containing the TBB library's include and lib")
+
 #-----------------------------------------------------------------------------
 # Read the version
 #-----------------------------------------------------------------------------
@@ -1154,11 +1162,83 @@ ELSE(VISIT_THREAD)
     MESSAGE(STATUS "Threading for VisIt: OFF")
 ENDIF(VISIT_THREAD)
 
+# Enable OSPRay for VisIt
 IF(VISIT_OSPRAY)
+    # setup variables 
+    SET(OSPRAY_USE_EXTERNAL_EMBREE ON)
+    SET(ospray_DIR ${OSPRAY_DIR})
+    SET(embree_DIR ${EMBREE_ROOT})
+    SET(ISPC_EXECUTABLE ${ISPC_ROOT})
+    IF(NOT DEFINED TBB_ROOT)
+      SET(TBB_ROOT ${VISIT_TBB_ROOT})
+    ENDIF(NOT DEFINED TBB_ROOT)     
+    FIND_PACKAGE(ospray REQUIRED)
+    # setup ospray
     ADD_DEFINITIONS(-DVISIT_OSPRAY)
-    MESSAGE(STATUS "OSPRAY for VisIt: ON")
+    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIR})
+    LINK_DIRECTORIES(${VISIT_OSPRAY_DIR}/../..)
+    # additional module library
+    SET(OSPRAY_LIBRARIES
+      ${OSPRAY_LIBRARIES}
+      ${LIBRARY_PATH_PREFIX}ospray_module_ispc${LIBRARY_SUFFIX}
+      ${LIBRARY_PATH_PREFIX}ospray_module_visit${LIBRARY_SUFFIX}
+      ${LIBRARY_PATH_PREFIX}ospray_module_visit_common${LIBRARY_SUFFIX})
+    # install
+    # on linux ospray have libraries in a form of: 
+    #      libospray[xxx].so
+    #      libospray[xxx].so.0
+    #      libospray[xxx].so.[version]
+    #
+    # on mac ospray have libraries in a form of: 
+    #      libospray[xxx].dylib
+    #      libospray[xxx].0.dylib
+    #      libospray[xxx].[version].dylib
+    #
+    # on windows
+    #      libospray[xxx].lib
+    #      libospray[xxx].dll
+    #
+    IF(NOT VISIT_HEADERS_SKIP_INSTALL)
+      INSTALL(DIRECTORY ${OSPRAY_INCLUDE_DIR}
+        DESTINATION 
+        DESTINATION ${VISIT_INSTALLED_VERSION_INCLUDE}/ospray
+        FILE_PERMISSIONS OWNER_WRITE OWNER_READ
+                         GROUP_WRITE GROUP_READ
+                         WORLD_READ
+        DIRECTORY_PERMISSIONS OWNER_WRITE OWNER_READ OWNER_EXECUTE
+                              GROUP_WRITE GROUP_READ GROUP_EXECUTE
+                                          WORLD_READ WORLD_EXECUTE
+        PATTERN ".svn" EXCLUDE)
+    ENDIF(NOT VISIT_HEADERS_SKIP_INSTALL)
+    IF(VISIT_OSPRAY_SKIP_INSTALL)
+      FOREACH(l ${OSPRAY_LIBRARIES})
+        # GET_FILENAME_COMPONENT(_ext_ ${l} EXT)
+        # GET_FILENAME_COMPONENT(_name_ ${l} NAME_WE)
+        # GET_FILENAME_COMPONENT(_path_ ${l} DIRECTORY)
+        # MESSAGE(STATUS ${l})
+        # MESSAGE(STATUS ${_ext_})
+        # MESSAGE(STATUS ${_name_})
+        # MESSAGE(STATUS ${_path_})
+        IF( (NOT "${l}" STREQUAL "optimized") AND 
+            (NOT "${l}" STREQUAL "debug"))
+          GET_FILENAME_COMPONENT(_name_ ${l} NAME_WE)
+          IF( (NOT "${_name_}" STREQUAL "libtbb_debug") AND
+              (NOT "${_name_}" STREQUAL "libtbbmalloc_debug") AND
+              (NOT "${_name_}" STREQUAL "libtbb") AND
+              (NOT "${_name_}" STREQUAL "libtbbmalloc") AND
+              (NOT "${_name_}" STREQUAL "libembree3") )
+            THIRD_PARTY_INSTALL_LIBRARY(${l}.0)  
+          ENDIF()
+          THIRD_PARTY_INSTALL_LIBRARY(${l})
+        ENDIF()
+      ENDFOREACH()
+    ENDIF(VISIT_OSPRAY_SKIP_INSTALL)
+    # debug
+    MESSAGE(STATUS "OSPRAY_INCLUDE_DIR: " ${OSPRAY_INCLUDE_DIR})
+    MESSAGE(STATUS "OSPRAY_LIBRARIES: " ${OSPRAY_LIBRARIES})
+    MESSAGE(STATUS "OSPRay for VisIt: ON")
 ELSE(VISIT_OSPRAY)
-    MESSAGE(STATUS "OSPRAY for VisIt: OFF")
+    MESSAGE(STATUS "OSPRay for VisIt: OFF")
 ENDIF(VISIT_OSPRAY)
 
 #-----------------------------------------------------------------------------
diff --git a/avt/Filters/CMakeLists.txt b/avt/Filters/CMakeLists.txt
index e0f4d336e3..6ca4ddbe38 100644
--- a/avt/Filters/CMakeLists.txt
+++ b/avt/Filters/CMakeLists.txt
@@ -131,14 +131,42 @@ avtWorldSpaceToImageSpaceTransform.C
 avtXRayFilter.C
 )
 
-if (VISIT_SLIVR)
-    list(APPEND AVTFILTERS_SOURCES
-         avtImgCommunicator.C
+IF(VISIT_SLIVR)
+    LIST(APPEND AVTFILTERS_SOURCES
+         avtSLIVRCommon.C
+         avtSLIVRImageCompositor.C
          avtSLIVRRayTracer.C
          avtSLIVRSamplePointExtractor.C
          avtSLIVRVoxelExtractor.C)
-    add_definitions(-DVISIT_SLIVR)
-endif()
+    ADD_DEFINITIONS(-DVISIT_SLIVR)
+ENDIF()
+
+IF(VISIT_OSPRAY)
+    LIST(APPEND AVTFILTERS_SOURCES
+         avtOSPRayCommon.C
+         avtOSPRayImageCompositor.C
+         avtOSPRayRayTracer.C
+         avtOSPRaySamplePointExtractor.C
+         avtOSPRayVoxelExtractor.C
+         )
+    ADD_DEFINITIONS(-DVISIT_OSPRAY)
+    IF(ICET_FOUND)
+        # If we have Ice-T then add -DHAVE_ICET to the compilation flags.
+        # We need to link with OpenGL on Mac when we have IceT.
+        IF(APPLE)
+            SET(ICET_OPENGL ${OPENGL_gl_LIBRARY})
+        ENDIF(APPLE)
+        # Link icet libraries using absolute pathes
+        SET(ICET_FULLPATH_LIB ${ICET_OPENGL})
+        FOREACH(X ${ICET_LIB})
+            LIST(APPEND ICET_FULLPATH_LIB "${ICET_LIBRARY_DIR}/${X}")
+        ENDFOREACH()
+        # Other setups
+        INCLUDE_DIRECTORIES(${ICET_INCLUDE_DIR})
+        LINK_DIRECTORIES(${ICET_LIBRARY_DIR})
+        ADD_DEFINITIONS(-DVISIT_OSPRAY_ICET)
+    ENDIF()
+ENDIF()
 
 INCLUDE_DIRECTORIES(
 ${CMAKE_CURRENT_SOURCE_DIR}
@@ -178,11 +206,23 @@ ENDIF()
 #********************************* SERIAL ************************************
 ADD_LIBRARY(avtfilters_ser ${AVTFILTERS_SOURCES})
 TARGET_LINK_LIBRARIES(avtfilters_ser visitcommon lightweight_visit_vtk visit_vtk avtmath avtview avtpipeline_ser avtdatabase_ser avtdbatts ${EAVL_LIB} ${VISIT_VTKM_LIB} vtkFiltersModeling)
+IF(VISIT_OSPRAY) 
+    TARGET_LINK_LIBRARIES(avtfilters_ser ${OSPRAY_LIBRARIES})
+    IF(ICET_FOUND)
+        TARGET_LINK_LIBRARIES(avtfilters_ser ${ICET_FULLPATH_LIB})
+    ENDIF()
+ENDIF() 
 VISIT_INSTALL_TARGETS(avtfilters_ser)
 
 #********************************* PARALLEL **********************************
 IF(VISIT_PARALLEL)
     ADD_PARALLEL_LIBRARY(avtfilters_par ${AVTFILTERS_SOURCES})
     TARGET_LINK_LIBRARIES(avtfilters_par visitcommon lightweight_visit_vtk visit_vtk avtmath avtview avtpipeline_par avtdatabase_par avtdbatts ${EAVL_LIB} ${VISIT_VTKM_LIB} vtkFiltersModeling)
+    IF(VISIT_OSPRAY) 
+        TARGET_LINK_LIBRARIES(avtfilters_par ${OSPRAY_LIBRARIES})
+        IF(ICET_FOUND)
+            TARGET_LINK_LIBRARIES(avtfilters_par ${ICET_FULLPATH_LIB})
+        ENDIF()
+    ENDIF()
     VISIT_INSTALL_TARGETS(avtfilters_par)
 ENDIF(VISIT_PARALLEL)
diff --git a/avt/Filters/avtOSPRayCommon.C b/avt/Filters/avtOSPRayCommon.C
new file mode 100644
index 0000000000..84960e10d1
--- /dev/null
+++ b/avt/Filters/avtOSPRayCommon.C
@@ -0,0 +1,1099 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2017, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+#include <avtOSPRayCommon.h>
+
+#include <avtParallel.h>
+#include <avtMemory.h>
+
+#include <DebugStream.h>
+#include <StackTimer.h>
+#include <TimingsManager.h>
+#include <ImproperUseException.h>
+
+#include <vtkCamera.h>
+#include <vtkMatrix4x4.h>
+
+#include <ospray/ospray.h>
+#include <ospray/visit/VisItModuleCommon.h>
+#include <ospray/visit/VisItExtraLibraries.h>
+#include <ospray/visit/VisItImageComposite.h>
+#include <ospray/ospcommon/vec.h>
+#include <cmath>
+#include <vector>
+
+#ifdef __unix__
+# include <unistd.h>
+#endif
+
+static bool CheckThreadedBlend_MetaData() {
+    bool use = true;
+    const char* env_use = std::getenv("OSPRAY_SERIAL_BLEND");
+    if (env_use) { use = atoi(env_use) <= 0; }
+    return use;
+}
+
+static bool UseThreadedBlend_MetaData = CheckThreadedBlend_MetaData();
+
+std::ostream *ospray::osp_out = (ospray::visit::CheckVerbose()) ?
+    &std::cout : &DebugStream::Stream5();
+std::ostream *ospray::osp_err = (ospray::visit::CheckVerbose()) ?
+    &std::cerr : &DebugStream::Stream1();
+
+// ***************************************************************************
+//
+// OSPRay
+//
+// ***************************************************************************
+
+using namespace ospcommon;
+
+namespace ospray {
+  namespace visit {
+    
+    template<typename T> 
+    void ospray_check(const T& obj, const std::string s) {
+      if (!obj) { 
+        if (CheckVerbose()) {
+          std::cerr << s << " is invalid" << std::endl; 
+        }
+        throw std::runtime_error(s + " is invalid");
+      }
+    }
+    
+    // =====================================================================//
+    //
+    // =====================================================================//
+    struct Color { float R,G,B,A; };
+
+    // =====================================================================//
+    //
+    // =====================================================================//
+    TransferFunction::TransferFunction(TransferFunctionCore& other)
+      : Manipulator<CoreType, OSPType>(other) {}
+    void TransferFunction::Set(const void *_table,
+                               const unsigned int size, 
+                               const double datamin, 
+                               const double datamax) 
+    {
+      // initialize it once
+      if (!core->init) 
+      {
+        ospray_rm(core->self);
+        core->self = ospNewTransferFunction("piecewise_linear");
+        ospray_check(core->self, "transfer function");
+        core->init = true;
+      }
+      // create OSP data
+      const Color* table = reinterpret_cast<const Color*>(_table);
+      std::vector<vec3f> cdata;
+      std::vector<float> odata;
+      for (unsigned int i = 0; i < size; ++i)
+      {
+        cdata.emplace_back(table[i].R, table[i].G, table[i].B);
+        odata.emplace_back(table[i].A);
+      }
+      OSPData osp_cdata = ospNewData(cdata.size(), OSP_FLOAT3, cdata.data());
+      OSPData osp_odata = ospNewData(odata.size(), OSP_FLOAT,  odata.data());
+      ospray_check(osp_cdata,"TFN color data");
+      ospray_check(osp_odata,"TFN opacity data");
+      // commit
+      ospSetData(core->self, "colors",    osp_cdata);
+      ospSetData(core->self, "opacities", osp_odata);
+      ospSet2f(core->self, "valueRange", datamin, datamax);
+      ospCommit(core->self);
+      // cleanup
+      ospray_rm(osp_cdata);
+      ospray_rm(osp_odata);
+    }
+
+    // =====================================================================//
+    //
+    // =====================================================================//
+    Camera::Camera(CameraCore& other) 
+      : Manipulator<CoreType, OSPType>(other) {}
+    void Camera::Set(const bool ortho,
+                     const double camera_p[3], 
+                     const double camera_f[3], 
+                     const double camera_u[3], 
+                     const double fovy,
+                     const double pan_ratio[2],
+                     const double zoom_ratio,
+                     const double near_clip,
+                     const double canvas_size[2],
+                     const int screen_size[2], /* overall screen size */
+                     const int tile_extents[4] /*      tile size      */)
+    {
+      // create camera
+      if (!core->init || (ortho != core->orthographic))
+      {
+        core->orthographic = ortho;
+        ospray_rm(core->self);
+        core->self = core->orthographic ? 
+          ospNewCamera("orthographic") : 
+          ospNewCamera("perspective");
+        ospray_check(core->self, "camera");
+        core->init = true;
+      }
+      // compute camera
+      core->zoom = zoom_ratio;
+      core->pan[0] = pan_ratio[0];
+      core->pan[1] = pan_ratio[1];
+      core->screenSize[0] = screen_size[0];
+      core->screenSize[1] = screen_size[1];
+      // commit
+      ospSet1f(core->self, "nearClip", near_clip);
+      ospSet3f(core->self, "pos", 
+               camera_p[0], 
+               camera_p[1], 
+               camera_p[2]);
+      ospSet3f(core->self, "dir", 
+               camera_f[0] - camera_p[0], 
+               camera_f[1] - camera_p[1], 
+               camera_f[2] - camera_p[2]);
+      ospSet3f(core->self, "up",
+               camera_u[0],
+               camera_u[1], 
+               camera_u[2]);
+      ospSet1f(core->self, "aspect", 
+               static_cast<double>(screen_size[0]) /
+               static_cast<double>(screen_size[1]));
+      if (!ortho)
+        ospSet1f(core->self, "fovy", fovy / core->zoom);
+      else
+        ospSet1f(core->self, "height", canvas_size[1]);
+      SetScreen(tile_extents[0], tile_extents[1],
+                tile_extents[2], tile_extents[3]);
+    }
+    void Camera::SetScreen(const double xMin, const double xMax,
+                           const double yMin, const double yMax) 
+    {
+      core->windowExts[0] = std::max(static_cast<int>(std::round(xMin)), 0);
+      core->windowExts[1] = std::min(static_cast<int>(std::round(xMax)), 
+                                     core->screenSize[0]);
+      core->windowExts[2] = std::max(static_cast<int>(std::round(yMin)), 0);
+      core->windowExts[3] = std::min(static_cast<int>(std::round(yMax)), 
+                                     core->screenSize[1]);
+      const double r_xl = xMin/core->screenSize[0] - core->pan[0];
+      const double r_yl = yMin/core->screenSize[1] - core->pan[1];
+      const double r_xu = xMax/core->screenSize[0] - core->pan[0];
+      const double r_yu = yMax/core->screenSize[1] - core->pan[1];
+      ospSet2f(core->self, "imageStart", r_xl, r_yl);
+      ospSet2f(core->self, "imageEnd",   r_xu, r_yu);
+      ospCommit(core->self);
+    }
+
+    // =====================================================================//
+    //
+    // =====================================================================//
+    Light::Light(LightCore& other) 
+      : Manipulator<CoreType, OSPType>(other) {}
+    void Light::Set(const bool ambient, const double i, 
+                    const double c, const double* d)
+    {
+      Set(ambient, i, c, c, c, d);
+    }
+    void Light::Set(const bool ambient, const double i, 
+                    const double cr, const double cg, const double cb,
+                    const double* d)
+    {
+      const double c[3] = {cr, cg, cb};
+      Set(ambient, i, c, d);
+    }
+    void Light::Set(const bool ambient, const double i, 
+                    const double c[3], const double* d)
+    {
+      // create light
+      if (!core->init || ambient != core->isAmbient) {
+        ospray_rm(core->self);
+        core->self = ospNewLight2("scivis", "distant");
+        ospray_check(core->self, "light");
+        ospSet1i(core->self, "isVisible", 0);
+        ospSet1f(core->self, "angularDiameter", 0.53f);
+        core->init = true;
+      }
+      // commit light
+      ospSet1f(core->self, "intensity", i);
+      ospSet3f(core->self, "color", c[0], c[1], c[2]);
+      if (!ambient) {
+        ospSet3f(core->self, "direction", d[0], d[1], d[2]);
+      }
+      ospCommit(core->self);
+    }
+
+    // =====================================================================//
+    //
+    // =====================================================================//
+    Renderer::Renderer(RendererCore& other) 
+      : Manipulator<CoreType, OSPType>(other) {}
+    void Renderer::Init()
+    {
+      if (!core->init) {
+        ospray_rm(core->self);
+        core->self = ospNewRenderer("scivis");
+        ospray_check(core->self, "SCIVIS Renderer");
+        core->init = true;
+      }
+    }
+    void Renderer::ResetLights()
+    {
+      if (!core->init) { Init(); }
+      ospray_rm(core->lightData);
+      core->lightList.clear();
+    }
+    Light Renderer::AddLight()
+    {
+      core->lightList.emplace_back();
+      return Light(core->lightList.back());
+    }
+    void Renderer::FinalizeLights()
+    {
+      std::vector<OSPLight> osp_light_list;
+      for (auto& l : core->lightList) { osp_light_list.emplace_back(*l); }
+      ospray_rm(core->lightData);
+      core->lightData = ospNewData(osp_light_list.size(), OSP_OBJECT, 
+                                   osp_light_list.data());
+      ospray_check(core->lightData, "light list");
+    }
+    void Renderer::Set(const int aoSamples, const int spp, 
+                       const bool oneSidedLighting,
+                       const bool shadowsEnabled,
+                       const bool aoTransparencyEnabled)
+    {
+      if (!core->init) { Init(); }   
+      ospSet1i(core->self, "aoSamples", aoSamples);
+      ospSet1i(core->self, "spp", spp);
+      ospSet1i(core->self, "oneSidedLighting", oneSidedLighting);
+      ospSet1i(core->self, "shadowsEnabled", shadowsEnabled);
+      ospSet1i(core->self, "aoTransparencyEnabled", aoTransparencyEnabled);
+      ospSetData(core->self, "lights", core->lightData);
+      ospCommit(core->self);
+    }
+    void Renderer::Set(OSPCamera osp_camera)
+    {
+      if (!core->init) { Init(); }
+      ospSetObject(core->self, "camera", osp_camera);
+      ospCommit(core->self);
+    }
+    void Renderer::Set(OSPModel osp_world)
+    {
+      if (!core->init) { Init(); }
+      ospSetObject(core->self, "model", osp_world);
+      ospCommit(core->self);
+    }
+    
+    // =====================================================================//
+    //
+    // =====================================================================//
+    Model::Model(ModelCore& other)
+      : Manipulator<CoreType, OSPType>(other) {}
+    void Model::Reset()
+    {
+      core->init = false;
+    }
+    void Model::Init()
+    {
+      if (!core->init) {
+        ospray_rm(core->self);
+        core->self = ospNewModel();
+        ospray_check(core->self, "Model");
+        core->init = true;
+      }
+    }
+    void Model::Set(OSPVolume volume)
+    {
+      if (!core->init) { Init(); }
+      ospAddVolume(core->self, volume);
+      ospCommit(core->self);
+    }
+
+    // =====================================================================//
+    //
+    // =====================================================================//
+    Volume::Volume(VolumeCore& other)
+      : Manipulator<CoreType, OSPType>(other) {}
+    bool Volume::Init(const std::string volume_type, 
+                      const OSPDataType data_type, 
+                      const std::string data_char,
+                      const size_t data_size, 
+                      const void* data_ptr,
+                      const bool use_grid_accelerator)
+    {
+      if (!core->init || 
+          volume_type != core->volumeType ||
+          data_type   != core->dataType   ||
+          data_size   != core->dataSize   ||
+          data_ptr    != core->dataPtr    ||
+          use_grid_accelerator != core->useGridAccelerator)
+          
+      {
+        core->volumeType = volume_type;
+        core->dataType = data_type;
+        core->dataSize = data_size;
+        core->dataPtr  = data_ptr;
+        core->useGridAccelerator = use_grid_accelerator;
+        ospray_rm(core->self);
+        core->self = ospNewVolume(volume_type.c_str());
+        ospray_check(core->self, volume_type);
+        if (volume_type == "visit_shared_structured_volume" ||
+            volume_type == "shared_structured_volume") 
+        {
+          OSPData osp_data = ospNewData(data_size, data_type,
+                                        data_ptr, OSP_DATA_SHARED_BUFFER);
+          ospSetString(core->self, "voxelType", data_char.c_str());
+          ospSetData(core->self, "voxelData", osp_data);
+          ospray_rm(osp_data);
+        }
+        // TODO: there is a bug inside the module_visit, therefore we cannot enable grid
+        //       accelerator currently
+        ospSet1i(core->self, "useGridAccelerator", /*(int)use_grid_accelerator*/false);
+        core->init = true;
+        return true;
+      }
+      return false;
+    }
+    void Volume::Set(const bool adaptiveSampling,
+                     const bool preIntegration, 
+                     const bool singleShade, 
+                     const bool gradientShadingEnabled, 
+                     const double samplingRate, 
+                     const double Ks, const double Ns,
+                     const double *X, const double *Y, const double *Z, 
+                     const int nX, const int nY, const int nZ,
+                     const double dbox[6], const double cbox[6], 
+                     const osp::vec3f& global_upper,
+                     const osp::vec3f& global_lower,
+                     const osp::vec3f& scale,
+                     OSPTransferFunction tfn)
+    {
+      const vec3i dims(nX, nY, nZ);
+      const vec3f data_lower(vec3f(dbox[0], dbox[1], dbox[2]) * (const vec3f&)scale);
+      const vec3f data_upper(vec3f(dbox[3], dbox[4], dbox[5]) * (const vec3f&)scale);
+      const vec3f clip_lower(vec3f(cbox[0], cbox[1], cbox[2]) * (const vec3f&)scale);
+      const vec3f clip_upper(vec3f(cbox[3], cbox[4], cbox[5]) * (const vec3f&)scale);
+      const vec3f spacing = (data_upper - data_lower)/((const vec3f)dims - 1.0f);
+      ospSetVec3f(core->self, "volumeGlobalBoundingBoxLower", 
+                  (const osp::vec3f&) global_upper);
+      ospSetVec3f(core->self, "volumeGlobalBoundingBoxUpper",
+                  (const osp::vec3f&) global_lower);
+      ospSetVec3f(core->self, "volumeClippingBoxLower", (const osp::vec3f&)clip_lower);
+      ospSetVec3f(core->self, "volumeClippingBoxUpper", (const osp::vec3f&)clip_upper);
+      ospSetVec3f(core->self, "gridSpacing", (const osp::vec3f&)spacing);
+      ospSetVec3f(core->self, "gridOrigin",  (const osp::vec3f&)data_lower);
+      ospSetVec3i(core->self, "dimensions",  (const osp::vec3i&)dims);
+      ospSet1f(core->self, "samplingRate", samplingRate);
+      ospSet3f(core->self, "Ks", Ks, Ks, Ks);
+      ospSet1f(core->self, "Ns", Ns);
+      ospSet1i(core->self, "gradientShadingEnabled", (int)gradientShadingEnabled);
+      ospSet1i(core->self, "adaptiveSampling", (int)adaptiveSampling);
+      ospSet1i(core->self, "preIntegration", (int)preIntegration);
+      ospSet1i(core->self, "singleShade", (int)singleShade);
+      ospSetObject(core->self, "transferFunction", tfn);
+      ospCommit(core->self);
+    }  
+
+  // =====================================================================//
+  //
+  // =====================================================================//
+  FrameBuffer::FrameBuffer(FrameBufferCore& other)
+    : Manipulator<CoreType, OSPType>(other) {}
+  void FrameBuffer::Render(const int tile_w, const int tile_h,
+                           const int tile_x, const int tile_y,
+                           const int    global_stride, 
+                           const float* global_depth,
+                           OSPRenderer renderer,
+                           float*& dest)
+  {
+    const vec2i fb_size(tile_w, tile_h);
+    // prepare the maxDepthDexture
+    {
+      // The reason I use round(r * (N-1)) instead of floor(r * N) is that
+      // during the composition phase, there will be a wired offset between
+      // rendered image and the background, which is about one pixel in size.
+      // Using round(r * (N - 1)) can remove the problem
+      std::vector<float> local_depth(tile_w * tile_h);
+      for (int i = 0; i < tile_w; ++i) {
+        for (int j = 0; j < tile_h; ++j) {
+          local_depth[i + j * tile_w] = 
+            global_depth[tile_x + i + (tile_y + j) * global_stride];
+        }
+      }
+      OSPTexture2D maxDepthTexture
+        = ospNewTexture2D((const osp::vec2i&)fb_size, OSP_TEXTURE_R32F,
+                          local_depth.data(), OSP_TEXTURE_FILTER_NEAREST);    
+      ospCommit(maxDepthTexture);
+      ospSetObject(renderer, "maxDepthTexture", maxDepthTexture);
+      ospCommit(renderer);
+      ospray_rm(maxDepthTexture);
+    }    
+    // do the rendering
+    // ALWAYS create a new framebuffer
+    {
+      ospray_rm(core->self);
+      core->self = 
+        ospNewFrameBuffer((const osp::vec2i&)fb_size, OSP_FB_RGBA32F, OSP_FB_COLOR);
+      ospray_check(core->self, "framebuffer");
+      ospRenderFrame(core->self, renderer, OSP_FB_COLOR);
+      const float* image = (float*)ospMapFrameBuffer(core->self, OSP_FB_COLOR);
+      std::copy(image, image + (tile_w * tile_h) * 4, dest);
+      ospUnmapFrameBuffer(image, core->self);
+      ospray_rm(core->self);      
+    }
+  }
+
+  
+};
+};
+
+static void OSPContext_ErrorFunc(OSPError, const char* msg)
+{ 
+    osperr << "#osp: (rank " << PAR_Rank() << ")" << msg; 
+}
+static void OSPContext_StatusFunc(const char* msg)
+{ 
+    osperr << "#osp: (rank " << PAR_Rank() << ")" << msg; 
+}
+
+static bool ospray_initialized = false;
+
+void ospray::InitOSP(int numThreads) 
+{   
+    if (!ospray_initialized) 
+    {
+#ifdef __unix__
+        // check hostname
+        char hname[200];
+        gethostname(hname, 200);
+        ospout << "[ospray] on host >> " << hname << "<<" << std::endl;;
+#endif
+        // load ospray device
+        ospout << "[ospray] Initialize OSPRay" << std::endl;    
+        OSPDevice device = ospGetCurrentDevice();
+        // check if ospray has been initialized already
+        if (!device) {
+            ospout << "[ospray] device not found, creating one" << std::endl;
+            device = ospNewDevice("default"); 
+            if (DebugStream::Level5()) { 
+                ospout << "[ospray] --> debug mode" << std::endl;
+                ospDeviceSet1i(device, "debug", 0);
+            }   
+            if (numThreads > 0) {
+                ospout << "[ospray] --> numThreads: " << numThreads 
+                       << std::endl;
+                ospDeviceSet1i(device, "numThreads", numThreads);
+            }
+            ospDeviceSetErrorFunc(device, OSPContext_ErrorFunc);
+            ospDeviceSetStatusFunc(device, OSPContext_StatusFunc);
+            ospDeviceCommit(device);
+            ospSetCurrentDevice(device);
+        }
+        // load ospray module
+        OSPError err = ospLoadModule("visit");
+        if (err != OSP_NO_ERROR) {
+            osperr << "[Error] can't load visit module" << std::endl;
+        }
+        ospray_initialized = true;
+    }
+}
+
+void ospray::Finalize()
+{
+}
+
+// ***************************************************************************
+//
+// OSPRay::Context
+//
+// ***************************************************************************
+
+void ospray::Context::InitPatch(const int patchID)
+{
+    if (patches.find(patchID) == patches.end()) {
+        patches[patchID] = ospray::Patch();
+    }
+}
+void ospray::Context::SetBackgroundBuffer(const unsigned char* color, 
+                                          const float* depth, 
+                                          const int size[2])
+{
+    bgColorBuffer = color;
+    bgDepthBuffer = depth;
+    bgSize[0] = size[0];
+    bgSize[1] = size[1];
+}
+void ospray::Context::SetupPatch(const int patchID,
+                                 const int vtk_type,
+                                 const size_t data_size, 
+                                 const void* data_ptr,
+                                 const double *X,
+                                 const double *Y,
+                                 const double *Z, 
+                                 const int nX, const int nY, const int nZ,
+                                 const double dbox[6], const double cbox[6])
+    
+{
+    std::string str_type;
+    OSPDataType osp_type;
+    CheckVolumeFormat(vtk_type, str_type, osp_type);
+    Volume volume(patches[patchID].volume);
+    volume.Init("visit_shared_structured_volume",
+                osp_type, str_type, data_size, data_ptr,
+                useGridAccelerator);
+    volume.Set(adaptiveSampling,
+               preIntegration,
+               singleShade,
+               gradientShadingEnabled,
+               samplingRate, 
+               Ks, Ns,
+               X, Y, Z, nX, nY, nZ,
+               dbox, cbox,
+               osp::vec3f{(float)gbbox[0],(float)gbbox[1],(float)gbbox[2]},
+               osp::vec3f{(float)gbbox[3],(float)gbbox[4],(float)gbbox[5]},
+               osp::vec3f{(float)scale[0],(float)scale[1],(float)scale[2]},
+               tfn);    
+    Model model(patches[patchID].model);
+    model.Reset();
+    model.Init();
+    model.Set(patches[patchID].volume);
+}
+void ospray::Context::RenderPatch(const int patchID,
+                                  const float xMin, const float xMax, 
+                                  const float yMin, const float yMax,
+                                  const int tile_w, const int tile_h,
+                                  float*& dest)
+{
+    Camera      cam(camera);
+    Renderer    ren(renderer);
+    FrameBuffer fb(patches[patchID].fb);
+    cam.SetScreen(xMin, xMax, yMin, yMax);
+    ren.Set(patches[patchID].model);
+    ren.Set(camera);
+    fb.Render(tile_w, tile_h,
+              cam.GetWindowExts(0),
+              cam.GetWindowExts(2),
+              bgSize[0],
+              bgDepthBuffer,
+              renderer, dest);
+}
+
+// ***************************************************************************
+//
+//  Extra Functions Defined here
+//
+// ***************************************************************************
+
+void
+ospray::CheckMemoryHere(const std::string& message, std::string debugN)
+{
+    if (debugN.compare("ospout") == 0) {        
+        ospray::CheckMemoryHere(message, *osp_out);
+    }
+    else if (debugN.compare("debug5") == 0) {
+        if (DebugStream::Level5()) {
+            ospray::CheckMemoryHere(message, DebugStream::Stream5());
+        }       
+    }
+    else if (debugN.compare("debug4") == 0) {
+        if (DebugStream::Level4()) {
+            ospray::CheckMemoryHere(message, DebugStream::Stream4());
+        }       
+    }
+    else if (debugN.compare("debug3") == 0) {
+        if (DebugStream::Level3()) {
+            ospray::CheckMemoryHere(message, DebugStream::Stream3());
+        }       
+    }
+    else if (debugN.compare("debug2") == 0) {
+        if (DebugStream::Level2()) {
+            ospray::CheckMemoryHere(message, DebugStream::Stream2());
+        }       
+    }
+    else if (debugN.compare("debug1") == 0) {
+        if (DebugStream::Level1()) {
+            ospray::CheckMemoryHere(message, DebugStream::Stream1());
+        }       
+    }
+}
+
+void
+ospray::CheckMemoryHere(const std::string& message, std::ostream& out)
+{
+    unsigned long m_size, m_rss;
+    avtMemory::GetMemorySize(m_size, m_rss);
+    out << message << std::endl << "\t"
+        << " Rank " << PAR_Rank()
+        << " Memory use begin " << m_size 
+        << " rss " << m_rss/(1024*1024) << " (MB)"
+        << std::endl;
+}
+
+void
+ospray::CheckVolumeFormat(const int dt,
+                          std::string& str_type,
+                          OSPDataType& osp_type)
+{
+    if (dt == VTK_UNSIGNED_CHAR) {
+        str_type = "uchar";
+        osp_type = OSP_UCHAR;
+    } else if (dt == VTK_SHORT) {
+        str_type = "short";
+        osp_type = OSP_SHORT;
+    } else if (dt == VTK_UNSIGNED_SHORT) {
+        str_type = "ushort";
+        osp_type = OSP_USHORT;
+    } else if (dt == VTK_FLOAT) {
+        str_type = "float";
+        osp_type = OSP_FLOAT;
+    } else if (dt == VTK_DOUBLE) {
+        str_type = "double";
+        osp_type = OSP_DOUBLE;
+    } else {
+        ospray::Exception("Unsupported ospray volume type.");
+    }
+    ospout << "[ospray] data type " << str_type << std::endl;
+}
+
+void
+ospray::ComputeProjections(const avtViewInfo &view, 
+                           const double      &aspect,
+                           const double      &old_near_plane,
+                           const double      &old_far_plane,
+                           const double       data_scale[3],
+                           const double       data_bound[6],
+                           const int          screen_size[2],
+                           vtkMatrix4x4 *model_to_screen_transform, 
+                           vtkMatrix4x4 *screen_to_model_transform, 
+                           vtkMatrix4x4 *screen_to_camera_transform,
+                           double        canvas_size[2],
+                           int           rendering_extents[4]) 
+{
+    //----------------------------------------------------------------------//
+    // see avt/View/avtViewInfo::SetCameraFromView
+    //----------------------------------------------------------------------//
+    /* view.SetCameraFromView(vtkcamera); */
+    vtkCamera *vtkcamera = vtkCamera::New();
+    vtkcamera->SetViewAngle(view.viewAngle);
+    vtkcamera->SetEyeAngle(view.eyeAngle);
+    if (view.setScale)
+    {
+        vtkcamera->SetParallelScale(view.parallelScale);
+    }
+    vtkcamera->SetParallelProjection(view.orthographic ? 1 : 0);
+    vtkcamera->SetViewShear(view.shear[0],view.shear[1],view.shear[2]);
+    vtkcamera->SetFocalPoint(view.focus);
+    vtkcamera->SetPosition(view.camera);
+    vtkcamera->SetViewUp(view.viewUp);
+    vtkcamera->SetFocalDisk(view.imageZoom);
+    vtkcamera->Zoom(view.imageZoom);
+    // here we have to use the old near/far planes
+    vtkcamera->SetClippingRange(old_near_plane, old_far_plane);
+    // here we dont want to move window center ?
+    //vtkcamera->SetWindowCenter(2.0*view.imagePan[0], 2.0*view.imagePan[1]);
+    //----------------------------------------------------------------------//
+    // compute matrix
+    //----------------------------------------------------------------------//
+    vtkMatrix4x4 *matMVPS =
+        vtkcamera->GetModelViewTransformMatrix();
+    vtkMatrix4x4 *matProj = 
+        vtkcamera->GetProjectionTransformMatrix(aspect, -1, 1);    
+    vtkMatrix4x4::Multiply4x4(matProj, matMVPS,
+                              model_to_screen_transform);
+    vtkMatrix4x4::Invert(model_to_screen_transform,
+                         screen_to_model_transform);
+    vtkMatrix4x4::Invert(matProj,
+                         screen_to_camera_transform);
+    //----------------------------------------------------------------------//
+    // compute canvas size (parallel scale)
+    //----------------------------------------------------------------------//
+    if (!view.orthographic)
+    {
+        canvas_size[0] = 2.0 * old_near_plane / matProj->GetElement(0, 0);
+        canvas_size[1] = 2.0 * old_near_plane / matProj->GetElement(1, 1);
+    }
+    else
+    {
+        canvas_size[0] = 2.0 / matProj->GetElement(0, 0);
+        canvas_size[1] = 2.0 / matProj->GetElement(1, 1);
+    }
+    //----------------------------------------------------------------------//
+    // cleanup
+    //----------------------------------------------------------------------//
+    vtkcamera->Delete();
+    //----------------------------------------------------------------------//
+    // get the renderable region
+    //----------------------------------------------------------------------//
+    double depths[2];
+    ospray::ProjectWorldToScreenCube(data_bound,
+                                     screen_size[0], screen_size[1], 
+                                     view.imagePan, view.imageZoom,
+                                     model_to_screen_transform,
+                                     rendering_extents, depths);
+    rendering_extents[0] = std::max(rendering_extents[0], 0);
+    rendering_extents[2] = std::max(rendering_extents[2], 0);
+    rendering_extents[1] = std::min(1+rendering_extents[1], screen_size[0]);
+    rendering_extents[3] = std::min(1+rendering_extents[3], screen_size[1]);
+}
+
+double
+ospray::ProjectWorldToScreen(const double worldCoord[3], 
+                             const int screenWidth, 
+                             const int screenHeight,
+                             const double panPercentage[2], 
+                             const double imageZoom,
+                             vtkMatrix4x4 *mvp, int screenCoord[2])
+{
+    // world space coordinate in homogeneous coordinate
+    double worldHCoord[4] = {worldCoord[0],worldCoord[1],worldCoord[2],1.0};
+    // world to clip space (-1 ~ 1)
+    double clipHCoord[4];
+    mvp->MultiplyPoint(worldHCoord, clipHCoord);
+    // check error
+    if (clipHCoord[3] == 0.0)
+    {
+        std::cerr << "world coordinates: (" 
+                  << worldHCoord[0] << ", " 
+                  << worldHCoord[1] << ", " 
+                  << worldHCoord[2] << ", " 
+                  << worldHCoord[3] << ")" << std::endl
+                  << "clip space coordinate: ("
+                  << clipHCoord[0] << ", " 
+                  << clipHCoord[1] << ", " 
+                  << clipHCoord[2] << ", "
+                  << clipHCoord[3] << std::endl
+                  << "Matrix: " << *mvp << std::endl;
+        ospray::Exception("Zero Division During Projection.");
+    }
+    // screen coordinates (int integer)
+    screenCoord[0] =
+        round((clipHCoord[0] / clipHCoord[3] + 1) * screenWidth  * 0.5) +
+        round(screenWidth  * panPercentage[0]);
+    screenCoord[1] =
+        round((clipHCoord[1] / clipHCoord[3] + 1) * screenHeight * 0.5) +
+        round(screenHeight * panPercentage[1]); 
+    // return point depth
+    return clipHCoord[2]/clipHCoord[3];
+}
+
+void
+ospray::ProjectScreenToWorld(const int screenCoord[2], const double z,
+                             const int screenWidth, const int screenHeight, 
+                             const double panPercentage[2], 
+                             const double imageZoom,
+                             vtkMatrix4x4 *imvp, double worldCoord[3])
+{
+    // remove panning
+    const int x = screenCoord[0] - round(screenWidth*panPercentage[0]);
+    const int y = screenCoord[1] - round(screenHeight*panPercentage[1]);   
+    // do projection
+    double worldHCoord[4] = {0,0,0,1};
+    double clipHCoord[4] = {
+        (x - screenWidth  / 2.0) / (screenWidth  / 2.0),
+        (y - screenHeight / 2.0) / (screenHeight / 2.0), z, 1.0};
+    imvp->MultiplyPoint(clipHCoord, worldHCoord);
+    // check error
+    if (worldHCoord[3] == 0) {
+        std::cerr << "world coordinates: (" 
+                  << worldHCoord[0] << ", " 
+                  << worldHCoord[1] << ", " 
+                  << worldHCoord[2] << ", " 
+                  << worldHCoord[3] << ")" << std::endl
+                  << "clip space coordinate: ("
+                  << clipHCoord[0] << ", " 
+                  << clipHCoord[1] << ", " 
+                  << clipHCoord[2] << ", "
+                  << clipHCoord[3] << std::endl
+                  << "Matrix: " << *imvp << std::endl;
+        ospray::Exception("Zero Division During Projection.");
+    }    
+    // normalize world space coordinate 
+    worldCoord[0] = worldHCoord[0]/worldHCoord[3];
+    worldCoord[1] = worldHCoord[1]/worldHCoord[3];
+    worldCoord[2] = worldHCoord[2]/worldHCoord[3];
+}
+
+void
+ospray::ProjectScreenToCamera(const int screenCoord[2], const double z,
+                              const int screenWidth, const int screenHeight, 
+                              vtkMatrix4x4 *imvp, double cameraCoord[3])
+{
+    // remove panning
+    const int x = screenCoord[0];
+    const int y = screenCoord[1];
+    // do projection
+    double cameraHCoord[4] = {0,0,0,1};
+    double clipHCoord[4] = {
+        (x - screenWidth /2.0)/(screenWidth /2.0),
+        (y - screenHeight/2.0)/(screenHeight/2.0), z, 1.0};
+    imvp->MultiplyPoint(clipHCoord, cameraHCoord);
+    // check error
+    if (cameraHCoord[3] == 0) {
+        std::cerr << "world coordinates: (" 
+                  << cameraHCoord[0] << ", " 
+                  << cameraHCoord[1] << ", " 
+                  << cameraHCoord[2] << ", " 
+                  << cameraHCoord[3] << ")" << std::endl
+                  << "clip space coordinate: ("
+                  << clipHCoord[0] << ", " 
+                  << clipHCoord[1] << ", " 
+                  << clipHCoord[2] << ", "
+                  << clipHCoord[3] << std::endl
+                  << "Matrix: " << *imvp << std::endl;
+        ospray::Exception("Zero Division During Projection.");
+    }
+    // normalize world space coordinate 
+    cameraCoord[0] = cameraHCoord[0]/cameraHCoord[3];
+    cameraCoord[1] = cameraHCoord[1]/cameraHCoord[3];
+    cameraCoord[2] = cameraHCoord[2]/cameraHCoord[3];
+}
+
+void
+ospray::ProjectWorldToScreenCube(const double cube[6],
+                                 const int screenWidth, 
+                                 const int screenHeight, 
+                                 const double panPercentage[2], 
+                                 const double imageZoom,
+                                 vtkMatrix4x4 *mvp, 
+                                 int screenExtents[4], 
+                                 double depthExtents[2])
+{
+    int xMin = std::numeric_limits<int>::max();
+    int xMax = std::numeric_limits<int>::min();
+    int yMin = std::numeric_limits<int>::max();
+    int yMax = std::numeric_limits<int>::min();
+    double zMin = std::numeric_limits<double>::max();
+    double zMax = std::numeric_limits<double>::min();
+
+    float coordinates[8][3];
+    coordinates[0][0] = cube[0];   
+    coordinates[0][1] = cube[2];   
+    coordinates[0][2] = cube[4];        
+
+    coordinates[1][0] = cube[1];   
+    coordinates[1][1] = cube[2];   
+    coordinates[1][2] = cube[4];        
+
+    coordinates[2][0] = cube[1];  
+    coordinates[2][1] = cube[3];
+    coordinates[2][2] = cube[4];        
+
+    coordinates[3][0] = cube[0]; 
+    coordinates[3][1] = cube[3]; 
+    coordinates[3][2] = cube[4];
+
+    coordinates[4][0] = cube[0];
+    coordinates[4][1] = cube[2];
+    coordinates[4][2] = cube[5];
+
+    coordinates[5][0] = cube[1]; 
+    coordinates[5][1] = cube[2]; 
+    coordinates[5][2] = cube[5];        
+
+    coordinates[6][0] = cube[1]; 
+    coordinates[6][1] = cube[3];
+    coordinates[6][2] = cube[5];
+
+    coordinates[7][0] = cube[0]; 
+    coordinates[7][1] = cube[3]; 
+    coordinates[7][2] = cube[5];
+
+    double worldCoord[3];
+    int screenCoord[2]; double depth;
+    for (int i=0; i<8; i++)
+    {
+        worldCoord[0] = coordinates[i][0];
+        worldCoord[1] = coordinates[i][1];
+        worldCoord[2] = coordinates[i][2];
+        depth = ProjectWorldToScreen(worldCoord, screenWidth, screenHeight, 
+                                     panPercentage, imageZoom, mvp,
+                                     screenCoord);
+        // clamp values
+        screenCoord[0] = CLAMP(screenCoord[0], 0, screenWidth);
+        screenCoord[1] = CLAMP(screenCoord[1], 0, screenHeight);
+        screenExtents[0] = xMin = std::min(xMin, screenCoord[0]);
+        screenExtents[1] = xMax = std::max(xMax, screenCoord[0]);
+        screenExtents[2] = yMin = std::min(yMin, screenCoord[1]);
+        screenExtents[3] = yMax = std::max(yMax, screenCoord[1]);
+        depthExtents[0] = zMin = std::min(zMin, depth);
+        depthExtents[1] = zMax = std::max(zMax, depth);
+    }
+}
+
+void
+ospray::CompositeBackground(int screen[2],
+                            int compositedImageExtents[4],
+                            int compositedImageWidth,
+                            int compositedImageHeight,
+                            float *compositedImageBuffer,
+                            unsigned char *opaqueImageColor,
+                            float         *opaqueImageDepth,
+                            unsigned char *&imgFinal)
+{
+    if (UseThreadedBlend_MetaData) {
+        visit::CompositeBackground(screen,
+                                   compositedImageExtents,
+                                   compositedImageWidth,
+                                   compositedImageHeight,
+                                   compositedImageBuffer,
+                                   opaqueImageColor,
+                                   opaqueImageDepth,
+                                   imgFinal);
+        return;
+    } 
+    for (int y = 0; y < screen[1]; y++)
+    {
+        for (int x = 0; x < screen[0]; x++)
+        {
+            int indexScreen     = y * screen[0] + x;
+            int indexComposited =
+                (y - compositedImageExtents[2]) * compositedImageWidth +
+                (x - compositedImageExtents[0]);
+
+            bool insideComposited = 
+                ((x >= compositedImageExtents[0] && 
+                  x < compositedImageExtents[1]) &&
+                 (y >= compositedImageExtents[2] && 
+                  y < compositedImageExtents[3]));
+
+            if (insideComposited)
+            {
+                if (compositedImageBuffer[indexComposited*4 + 3] == 0)
+                {
+                    // No data from rendering here! - Good
+                    imgFinal[indexScreen * 3 + 0] = 
+                        opaqueImageColor[indexScreen * 3 + 0];
+                    imgFinal[indexScreen * 3 + 1] = 
+                        opaqueImageColor[indexScreen * 3 + 1];
+                    imgFinal[indexScreen * 3 + 2] = 
+                        opaqueImageColor[indexScreen * 3 + 2];
+                }
+                else
+                {
+                    // Volume in front
+                    float alpha = 
+                        (1.0 - compositedImageBuffer[indexComposited * 4 + 3]);
+                    imgFinal[indexScreen * 3 + 0] = 
+                        CLAMP(opaqueImageColor[indexScreen * 3 + 0] * alpha +
+                              compositedImageBuffer[indexComposited * 4 + 0] *
+                              255.f,
+                              0.f, 255.f);
+                    imgFinal[indexScreen * 3 + 1] = 
+                        CLAMP(opaqueImageColor[indexScreen * 3 + 1] * alpha +
+                              compositedImageBuffer[indexComposited * 4 + 1] *
+                              255.f,
+                              0.f, 255.f);
+                    imgFinal[indexScreen * 3 + 2] =
+                        CLAMP(opaqueImageColor[indexScreen * 3 + 2] * alpha +
+                              compositedImageBuffer[indexComposited * 4 + 2] *
+                              255.f,
+                              0.f, 255.f);
+                }
+            }
+            else
+            {
+                // Outside bounding box: Use the background : Good
+                imgFinal[indexScreen * 3 + 0] = 
+                    opaqueImageColor[indexScreen * 3 + 0];
+                imgFinal[indexScreen * 3 + 1] =
+                    opaqueImageColor[indexScreen * 3 + 1];
+                imgFinal[indexScreen * 3 + 2] =
+                    opaqueImageColor[indexScreen * 3 + 2];
+            }
+        }
+    }
+}
+
+void
+ospray::WriteArrayToPPM(std::string filename, const float * image,
+                        int dimX, int dimY)
+{
+    std::ofstream outputFile((filename+ ".ppm").c_str(), 
+                             std::ios::out | std::ios::binary);
+    outputFile <<  "P6\n" << dimX << "\n" << dimY << "\n" << 255 << "\n"; 
+    for (int y=dimY-1; y>=0; --y)
+    {
+        for (int x=0; x<dimX; ++x)
+        {
+            int index = (y * dimX + x)*4;
+            char color[3];
+            float alpha = image[index + 3];
+            color[0] = CLAMP(image[index + 0]*alpha, 0.0f, 1.0f) * 255;
+            color[1] = CLAMP(image[index + 1]*alpha, 0.0f, 1.0f) * 255;
+            color[2] = CLAMP(image[index + 2]*alpha, 0.0f, 1.0f) * 255;
+            outputFile.write(color,3);
+        }
+    } 
+    outputFile.close();
+}
+
+void
+ospray::WriteArrayToPPM(std::string filename,  const unsigned char *image, 
+                        int dimX, int dimY)
+{
+    std::ofstream outputFile((filename+ ".ppm").c_str(), 
+                             std::ios::out | std::ios::binary);
+    outputFile <<  "P6\n" << dimX << "\n" << dimY << "\n" << 255 << "\n"; 
+    for (int y=dimY-1; y>=0; --y)
+    {
+        outputFile.write(reinterpret_cast<const char*>(&image[y * dimX * 3]), 
+                         dimX * 3);
+    } 
+    outputFile.close();
+}
+
+void
+ospray::WriteArrayGrayToPPM(std::string filename, const float* image, 
+                            int dimX, int dimY)
+{
+    std::ofstream outputFile((filename+ ".ppm").c_str(), 
+                             std::ios::out | std::ios::binary);
+    outputFile <<  "P6\n" << dimX << "\n" << dimY << "\n" << 255 << "\n"; 
+    for (int y=dimY-1; y>=0; --y)
+    {
+        for (int x=0; x<dimX; ++x)
+        {
+            int index = (y * dimX + x);
+            char var = CLAMP(image[index], 0.f, 1.f) * 255;
+            char color[3];
+            color[0] = var;
+            color[1] = var;
+            color[2] = var;
+            outputFile.write(color,3);
+        }
+    } 
+    outputFile.close();
+}
diff --git a/avt/Filters/avtOSPRayCommon.h b/avt/Filters/avtOSPRayCommon.h
new file mode 100644
index 0000000000..e1b087d042
--- /dev/null
+++ b/avt/Filters/avtOSPRayCommon.h
@@ -0,0 +1,724 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2017, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef VISIT_OSPRAY /* make sure VISIT_OSPRAY is defined */
+# error "VISIT_OSPRAY is not defined but ospray is used"
+#endif
+
+#ifndef AVT_OSPRAY_COMMON_H
+#define AVT_OSPRAY_COMMON_H
+
+#include <ospray/ospray.h>
+#include <string>
+#include <vector>
+#include <map>
+
+namespace ospray {
+namespace visit {
+  
+    /** 
+     * Helper Functions
+     */
+    template<typename T> void ospray_rm(T& obj) {
+        if (!obj) { ospRelease(obj); obj = NULL; }
+    }
+  
+    /**
+     * Abstraction of an object
+     */
+    template<typename T> struct Object {
+        bool init;
+        T    self;
+        Object() : init(false), self(NULL) {}
+        virtual ~Object() { ospray_rm(self); init = false; }
+        T operator*() { return self; }
+    };
+  
+    /**
+     * Transfer Function Wrapper
+     */
+    struct TransferFunctionCore : public Object<OSPTransferFunction> {
+    TransferFunctionCore() : Object<OSPTransferFunction>() {}
+    };
+
+    /**
+     * Camera Wrapper
+     */
+    struct CameraCore : public Object<OSPCamera> {
+        bool   orthographic;
+        int    windowExts[4];
+        int    screenSize[2];
+        double pan[2]; // pan ratio [0, 1]
+        double zoom;   // zoom factor
+        CameraCore() : Object<OSPCamera>() {
+            orthographic = false;
+            windowExts[0] = windowExts[1] = 0;
+            windowExts[2] = windowExts[3] = 0;
+            screenSize[0] = screenSize[1] = 0;
+            pan[0] = pan[1] = 0.0;
+            zoom = 1.0;
+        }
+    };
+
+    /**
+     * Light Wrapper
+     */
+    struct LightCore : public Object<OSPLight> {
+        bool isAmbient;
+        LightCore() : Object<OSPLight>() {
+            isAmbient = false;
+        }
+    };  
+
+    /**
+     * Renderer Wrapper
+     */
+    struct RendererCore : public Object<OSPRenderer> {
+        OSPData                lightData;
+        std::vector<LightCore> lightList;
+    RendererCore() : Object<OSPRenderer>() {
+            lightData = NULL;
+        }
+        ~RendererCore() { ospray_rm(lightData); }
+    };
+
+    /**
+     * Model Wrapper
+     */
+    struct ModelCore : public Object<OSPModel> {
+        ModelCore() : Object<OSPModel>() {}
+    };
+
+    /**
+     * Volume Wrapper
+     */
+    struct VolumeCore : public Object<OSPVolume> {
+        std::string volumeType;
+        OSPDataType dataType;
+        size_t      dataSize;
+        const void* dataPtr;
+        bool useGridAccelerator;
+        VolumeCore() : Object<OSPVolume>() {
+            volumeType = "";
+            dataType = OSP_UCHAR; /* just give it a value */
+            dataSize = 0;
+            dataPtr  = NULL;
+            useGridAccelerator = false;
+        }
+    };
+  
+    /**
+     * Framebuffer Wrapper
+     */
+    struct FrameBufferCore : public Object<OSPFrameBuffer> {
+        FrameBufferCore() : Object<OSPFrameBuffer>() {}
+    };
+
+    /**
+     * Now we define a PatchCore
+     */
+    struct Patch {
+        VolumeCore      volume;
+        ModelCore       model;
+        FrameBufferCore fb;
+    };
+
+    /**
+     * And a ContextCore
+     */
+    struct ContextCore {
+        // data
+        std::string varname;
+        std::map<int, Patch> patches;
+        CameraCore           camera;
+        RendererCore         renderer;
+        TransferFunctionCore tfn;
+        // flags
+        bool oneSidedLighting;       /* renderer */
+        bool shadowsEnabled;         /* renderer */
+        bool aoTransparencyEnabled;  /* renderer */
+        bool useGridAccelerator;     /*  volume  */
+        bool adaptiveSampling;       /*  volume  */
+        bool preIntegration;         /*  volume  */
+        bool singleShade;            /*  volume  */
+        bool gradientShadingEnabled; /*  volume  */
+        // other parameters
+        double Ks;
+        double Ns;
+        double samplingRate;
+        int aoSamples;
+        int spp;
+        double scale[3];
+        double gbbox[6];
+        // (shared, dont delete here)
+        const unsigned char *bgColorBuffer;  // backplatte color channel
+        const float         *bgDepthBuffer;  // backplatte depth channel 
+        int                  bgSize[2];      // channel buffer size
+        ContextCore() {
+            varname = "";
+            oneSidedLighting       = false;
+            shadowsEnabled         = false;
+            aoTransparencyEnabled  = false;
+            useGridAccelerator     = false;
+            adaptiveSampling       = false;
+            preIntegration         = false;
+            singleShade            = false;
+            gradientShadingEnabled = false;
+            Ks = 1.0; Ns = 20;
+            samplingRate = 3.0;
+            aoSamples = 0;
+            spp = 1;
+            scale[0] = scale[1] = scale[2] = 1.f;
+            gbbox[0] = gbbox[1] = gbbox[2] = 0.f;
+            gbbox[3] = gbbox[4] = gbbox[5] = 0.f;
+            bgSize[0] = bgSize[1] = 0;
+        }
+    };
+
+};
+};
+
+// ***************************************************************************
+//  Struct:  OSPVisItContext
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ***************************************************************************
+
+typedef ospray::visit::ContextCore OSPVisItContext;
+namespace ospray {
+    void InitOSP(int numThreads = 0);
+    void Finalize();
+    struct Context : public ospray::visit::ContextCore {
+    public:
+        void SetBackgroundBuffer(const unsigned char* color,
+                                 const float* depth, const int size[2]);
+        void SetSpecular(const double& k, const double& n) { Ks = k; Ns = n; }
+        void SetScaleAndDataBounds(const double v[3], const double d[6])
+        {
+            scale[0] = v[0]; scale[1] = v[1]; scale[2] = v[2];
+            gbbox[0] = d[0] * scale[0];
+            gbbox[3] = d[1] * scale[0];
+            gbbox[1] = d[2] * scale[1];
+            gbbox[4] = d[3] * scale[1];
+            gbbox[2] = d[4] * scale[2];
+            gbbox[5] = d[5] * scale[2];
+        }       
+        void SetSamplingRate(const double& v) { samplingRate = v; }
+        void SetAoSamples(const int v) { aoSamples = v; } 
+        void SetSpp(const int v) { spp = v; }
+        void SetOneSidedLighting(bool v) { oneSidedLighting = v; }
+        void SetShadowsEnabled(bool v) { shadowsEnabled = v; }
+        void SetAoTransparencyEnabled(bool v) { aoTransparencyEnabled = v; }
+        void SetUseGridAccelerator(bool v) { useGridAccelerator = v; }
+        void SetAdaptiveSampling(bool v) { adaptiveSampling = v; }
+        void SetPreIntegration(bool v) { preIntegration = v; }
+        void SetSingleShade(bool v) { singleShade = v; }
+        void SetGradientShadingEnabled(bool v) { gradientShadingEnabled = v; }
+        void SetVariableName(const std::string& str) { varname = str; }
+        const std::string& GetVariableName() const { return varname; }
+        void InitPatch(const int patchID);
+        void SetupPatch(const int patchID, const int vtk_type,
+                        const size_t data_size, const void* data_ptr,
+                        const double *X, const double *Y, const double *Z, 
+                        const int nX, const int nY, const int nZ,
+                        const double dbox[6], const double cbox[6]);
+        void RenderPatch(const int patchID,
+                         const float xMin, const float xMax, 
+                         const float yMin, const float yMax,
+                         const int tile_w, const int tile_h,
+                         float*& dest); 
+    };
+};
+
+#endif//AVT_OSPRAY_COMMON_H
+
+// ***************************************************************************
+//
+//
+//
+//  Extra Functions Defined here
+//
+//
+//
+// ***************************************************************************
+
+#ifndef VISIT_OSPRAY_CONTEXT_ONLY
+
+#ifndef AVT_OSPRAY_COMMON_EXTRA_H
+#define AVT_OSPRAY_COMMON_EXTRA_H
+
+#include <avtParallel.h>
+#include <avtViewInfo.h>
+#include <avtCallback.h>
+
+#include <DebugStream.h>
+#include <StackTimer.h>
+#include <TimingsManager.h>
+#include <ImproperUseException.h>
+
+#include <vtkType.h>
+#include <vtkMatrix4x4.h>
+
+#include <ospray/ospray.h>
+#include <ospray/visit/VisItModuleCommon.h>
+#include <ospray/visit/VisItExtraLibraries.h>
+#include <ospray/visit/VisItImageComposite.h>
+
+#include <cmath>
+#include <cstdlib>
+#include <iostream>
+#include <limits>
+#include <stdio.h>
+
+#ifndef CLAMP
+# define CLAMP(x, l, h) (x > l ? x < h ? x : h : l)
+#endif
+#ifndef M_MIN
+# define M_MIN(x, r) (x < r ? x : r)
+#endif
+#ifndef M_MAX
+# define M_MAX(x, r) (x > r ? x : r)
+#endif
+
+// ostreams customized for ospray
+#ifdef ospout
+#undef ospout
+#endif
+#define ospout                                                      \
+    if (!ospray::visit::CheckVerbose() && !DebugStream::Level5()) ; \
+    else (*ospray::osp_out)
+#ifdef osperr
+#undef osperr
+#endif
+#define osperr                                                      \
+    if (!ospray::visit::CheckVerbose() && !DebugStream::Level1()) ; \
+    else (*ospray::osp_err)
+namespace ospray {
+    extern std::ostream *osp_out;
+    extern std::ostream *osp_err;
+    //////////////////////////////////////////////////////
+    //                                                  //
+    // Those function has to be inline, otherwise we    //
+    // need to link this library to other components    //
+    // manually                                         //
+    //                                                  //
+    //////////////////////////////////////////////////////
+};
+
+// ***************************************************************************
+//  Namespace:  ospray
+//
+//  Purpose:
+//    
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ***************************************************************************
+
+namespace ospray {
+
+    namespace visit {
+
+        template<typename _CoreType, typename _OSPType> struct Manipulator {
+        protected:
+            typedef _CoreType CoreType;
+            typedef _OSPType  OSPType;
+            _CoreType *core;
+        public:
+            Manipulator(_CoreType& other) : core{&other} {}
+            _OSPType   operator* () { return *(*core); }
+            _CoreType* operator->() { return &(*core); }
+        };
+  
+        /**
+         * Transfer Function Wrapper
+         */
+        struct TransferFunction
+            : public Manipulator<TransferFunctionCore, OSPTransferFunction>
+        {
+        public:
+            TransferFunction(CoreType& other);
+            void Set(const void *table, const unsigned int size,
+                     const double datamin, const double datamax);      
+        };
+
+        /**
+         * Camera Wrapper
+         */
+        struct Camera
+            : public Manipulator<CameraCore, OSPCamera>
+        {
+        public:
+            Camera(CameraCore& other);
+            double GetWindowExts(const int i) const { 
+                return core->windowExts[i]; 
+            }
+            void Set(const bool ortho,
+                     const double camera_p[3], 
+                     const double camera_f[3], 
+                     const double camera_u[3], 
+                     const double fovy, 
+                     const double pan_ratio[2],
+                     const double zoom_ratio,
+                     const double near_clip,
+                     const double canvas_size[2],
+                     const int screen_size[2],
+                     const int tile_extents[4]);
+            void SetScreen(const double xMin, const double xMax,
+                           const double yMin, const double yMax);
+        };
+
+        /**
+         * Light Wrapper
+         */
+        struct Light
+            : public Manipulator<LightCore, OSPLight>
+        {
+        public:
+            Light(LightCore& other);
+            void Set(const bool ambient, const double i, 
+                     const double c, const double* d = NULL);
+            void Set(const bool ambient, const double i, 
+                     const double cr, const double cg, const double cb,
+                     const double* d = NULL);
+            void Set(const bool ambient, const double i, 
+                     const double c[3], const double* d = NULL);
+        };
+
+        /**
+         * Volume Wrapper
+         */
+        struct Volume 
+            : public Manipulator<VolumeCore, OSPVolume>
+        {
+        public:
+            Volume(VolumeCore& other);
+            bool Init(const std::string volume_type, 
+                      const OSPDataType data_type, 
+                      const std::string data_char,
+                      const size_t data_size, 
+                      const void* data_ptr,
+                      const bool use_grid_accelerator);
+            void Set(const bool adaptiveSampling,
+                     const bool preIntegration, 
+                     const bool singleShade, 
+                     const bool gradientShadingEnabled,
+                     const double samplingRate, 
+                     const double Ks, const double Ns,
+                     const double *X, const double *Y, const double *Z, 
+                     const int nX, const int nY, const int nZ,
+                     const double dbox[6], const double cbox[6], 
+                     const osp::vec3f& global_upper,
+                     const osp::vec3f& global_lower,
+                     const osp::vec3f& scale,
+                     OSPTransferFunction tfn);
+            void Set(const bool adaptiveSampling,
+                     const bool preIntegration, 
+                     const bool singleShade, 
+                     const bool gradientShadingEnabled, 
+                     const double samplingRate, 
+                     const double Ks, const double Ns,
+                     const double *X, const double *Y, const double *Z, 
+                     const int nX, const int nY, const int nZ,
+                     const double dbox[6], const double cbox[6], 
+                     const osp::vec3f& global_upper,
+                     const osp::vec3f& global_lower,
+                     const osp::vec3f& scale,
+                     TransferFunction tfn)
+            {
+                Set(adaptiveSampling,
+                    preIntegration, singleShade, 
+                    gradientShadingEnabled, samplingRate, 
+                    Ks, Ns, X, Y, Z, nX, nY, nZ,
+                    dbox, cbox, global_upper, global_lower, scale,
+                    *tfn);    
+            }
+
+            static void ComputeGhostBounds(bool bound[6], 
+                                           const unsigned char *ghosts, 
+                                           const int gnX, 
+                                           const int gnY, 
+                                           const int gnZ);
+        };
+
+        /**
+         * Model Wrapper
+         */
+        struct Model
+            : public Manipulator<ModelCore, OSPModel>
+        {
+        public:
+            Model(ModelCore& other);
+            void Reset();
+            void Init();
+            void Set(OSPVolume osp_volume);
+            void Set(Volume volume) { Set(*volume); }
+        };
+
+        /**
+         * Renderer Wrapper
+         */
+        struct Renderer
+            : public Manipulator<RendererCore, OSPRenderer>
+        {
+        public:
+            Renderer(RendererCore& other);
+            void  Init();
+            void  ResetLights();
+            Light AddLight();
+            void  FinalizeLights();
+            void  Set(const int aoSamples, const int spp, 
+                      const bool oneSidedLighting,
+                      const bool shadowsEnabled,
+                      const bool aoTransparencyEnabled);
+            void  Set(OSPCamera osp_camera);
+            void  Set(Camera        camera) { Set(*camera); }
+            void  Set(OSPModel   osp_world);
+            void  Set(Model          world) { Set(*world);  }
+        };
+
+
+        /**
+         * FrameBuffer Wrapper
+         */
+        struct FrameBuffer
+            : public Manipulator<FrameBufferCore, OSPFrameBuffer>
+        {
+        public:
+            FrameBuffer(FrameBufferCore& other);
+            void Render(const int tile_w, const int tile_h,
+                        const int tile_x, const int tile_y,
+                        const int global_stride, 
+                        const float* global_depth,
+                        OSPRenderer renderer,
+                        float*& dest);
+            void Render(const int tile_w, const int tile_h,
+                        const int tile_x, const int tile_y,
+                        const int global_stride, 
+                        const float* global_depth,
+                        Renderer renderer,
+                        float*& dest)
+            {
+                Render(tile_w, tile_h, tile_x, tile_y,
+                       global_stride, global_depth,
+                       *renderer, dest);
+            }
+
+        };
+    };
+
+    typedef ospray::visit::TransferFunction TransferFunction;
+    typedef ospray::visit::Camera Camera;
+    typedef ospray::visit::Renderer Renderer;
+    typedef ospray::visit::Volume Volume;
+    typedef ospray::visit::Model Model;
+    typedef ospray::visit::FrameBuffer FrameBuffer;
+    typedef ospray::visit::Patch Patch;
+        
+    // ***********************************************************************
+    //  Struct:  ImgMetaData
+    //
+    //  Purpose:
+    //    Holds information about patches but not the image 
+    //
+    //  Programmer:  
+    //  Creation:   
+    //
+    // ***********************************************************************
+
+    struct ImgMetaData
+    {
+        int procId;       // processor that produced the patch
+        int patchNumber;  // id of the patch on that processor
+        int destProcId;   // destination proc where this patch gets composited
+        int inUse;        // whether the patch is composed locally or not
+        int dims[2];      // height, width
+        int screen_ll[2]; // (lower left)  position in the final image
+        int screen_ur[2]; // (upper right)
+        float avg_z;      // camera space depth of the patch (average)
+        float eye_z;      // camera space z
+        float clip_z;     // clip space z
+    };
+
+    // ***********************************************************************
+    //  Struct:  ImgData
+    //
+    //  Purpose:
+    //    Holds the image data generated
+    //
+    //  Programmer:  
+    //  Creation:    
+    //
+    // ***********************************************************************
+    
+    struct ImgData
+    {
+        // acts as a key
+        int procId;        // processor that produced the patch
+        int patchNumber;   // id of the patch on that processor
+        float *imagePatch; // the image data - RGBA
+        ImgData() { imagePatch = NULL; }
+        bool operator==(const ImgData &a) {
+            return (patchNumber == a.patchNumber);
+        }
+    };
+
+    // ***********************************************************************
+    //
+    //  Helper Functions
+    //
+    // ***********************************************************************
+        
+    void CheckMemoryHere(const std::string& message, 
+                         std::string debugN = "debug5");
+    void CheckMemoryHere(const std::string& message, 
+                         std::ostream& out);
+
+    typedef int timestamp;
+    inline void CheckSectionStart(const std::string& c,
+                                  const std::string& f,
+                                  timestamp& timingDetail,
+                                  const std::string& str) 
+    {
+        debug5 << c << "::" << f << " " << str << " Start" << std::endl;
+        timingDetail = visitTimer->StartTimer();            
+    }
+    
+    inline void CheckSectionStop(const std::string& c,
+                                 const std::string& f, 
+                                 timestamp& timingDetail,
+                                 const std::string& str) 
+    {
+        visitTimer->StopTimer(timingDetail, 
+                              (c + "::" + f + " " + str).c_str());
+        ospray::CheckMemoryHere(("[" + c + "]" + " " + f + " " + str).c_str(),
+                                "debug5");
+        debug5 << c << "::" << f << " " << str << " Done" << std::endl;
+    }
+
+    inline void Exception(const std::string str)
+    {
+        std::cerr << str << std::endl;
+        debug1    << str << std::endl;
+        EXCEPTION1(ImproperUseException, str.c_str());
+        avtCallback::SetRenderingException(str);
+    }
+
+    inline void Warning(const std::string str)
+    {
+        avtCallback::IssueWarning(str.c_str());
+    }
+    void CheckVolumeFormat(const int dt,
+                           std::string& str_type,
+                           OSPDataType& osp_type);
+
+    void ComputeProjections(const avtViewInfo &view, 
+                            const double      &aspect,
+                            const double      &old_near_plane,
+                            const double      &old_far_plane,
+                            const double       data_scale[3],
+                            const double       data_bound[6],
+                            const int          screen_size[2],
+                            vtkMatrix4x4 *model_to_screen_transform, 
+                            vtkMatrix4x4 *screen_to_model_transform, 
+                            vtkMatrix4x4 *screen_to_camera_transform,
+                            double        canvas_size[2],
+                            int           rendering_extents[4]);
+
+    double ProjectWorldToScreen
+        (const double worldCoord[3], 
+         const int screenWidth, const int screenHeight,  
+         const double panPercentage[2], const double imageZoom,
+         vtkMatrix4x4 *mvp, int screenCoord[2]);
+    
+    void ProjectScreenToWorld
+        (const int screenCoord[2], const double z,
+         const int screenWidth, const int screenHeight, 
+         const double panPercentage[2], const double imageZoom,
+         vtkMatrix4x4 *imvp, double worldCoord[3]);
+
+    void ProjectScreenToCamera
+        (const int screenCoord[2], const double z,
+         const int screenWidth, const int screenHeight,
+         vtkMatrix4x4 *imvp, double cameraCoord[3]);
+
+    inline void ProjectScreenToWorld
+        (const int x, const int y, const double z,
+         const int screenWidth, const int screenHeight, 
+         const double panPercentage[2], const double imageZoom,
+         vtkMatrix4x4 *imvp, double worldCoord[3]) 
+    {
+        int screen_coord[2] = {x, y};
+        ProjectScreenToWorld(screen_coord, z, screenWidth, screenHeight, 
+                             panPercentage, imageZoom, imvp, worldCoord);
+    }
+
+    void ProjectWorldToScreenCube
+        (const double cube[6], const int screenWidth, const int screenHeight, 
+         const double panPercentage[2], const double imageZoom, 
+         vtkMatrix4x4 *mvp,int screenExtents[4], double depthExtents[2]);
+
+    void CompositeBackground(int screen[2],
+                             int compositedImageExtents[4],
+                             int compositedImageWidth,
+                             int compositedImageHeight,
+                             float *compositedImageBuffer,
+                             unsigned char *opaqueImageColor,
+                             float         *opaqueImageDepth,
+                             unsigned char *&imgFinal);
+    
+    void WriteArrayToPPM
+        (std::string, const float *image, int dimX, int dimY);
+
+    void WriteArrayToPPM
+        (std::string, const unsigned char *image, int dimX, int dimY);
+
+    void WriteArrayGrayToPPM
+        (std::string, const float * image, int dimX, int dimY);
+};
+
+#endif//AVT_OSPRAY_COMMON_EXTRA_H
+
+#endif//VISIT_OSPRAY_CONTEXT_ONLY
+
diff --git a/avt/Filters/avtOSPRayImageCompositor.C b/avt/Filters/avtOSPRayImageCompositor.C
new file mode 100644
index 0000000000..08aaf7c9c5
--- /dev/null
+++ b/avt/Filters/avtOSPRayImageCompositor.C
@@ -0,0 +1,2394 @@
+/*****************************************************************************
+ *
+ * Copyright (c) 2000 - 2017, Lawrence Livermore National Security, LLC
+ * Produced at the Lawrence Livermore National Laboratory
+ * LLNL-CODE-442911
+ * All rights reserved.
+ *
+ * This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+ * full copyright notice is contained in the file COPYRIGHT located at the root
+ * of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+ *
+ * Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  - Redistributions of  source code must  retain the above  copyright notice,
+ *    this list of conditions and the disclaimer below.
+ *  - Redistributions in binary form must reproduce the above copyright notice,
+ *    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+ *    documentation and/or other materials provided with the distribution.
+ *  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+ * ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+ * LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+ * DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+ * LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+ * OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ *****************************************************************************/
+
+// ************************************************************************ //
+//                        avtOSPRayImageCompositor.C                         //
+// ************************************************************************ //
+
+#include <avtOSPRayImageCompositor.h>
+
+#ifdef PARALLEL
+#  ifdef VISIT_OSPRAY_ICET
+#    include <IceT.h>
+#    include <IceTMPI.h>
+#  endif
+#endif
+
+#include <cmath>
+#include <ctime>
+#include <cstdio>
+#include <cstring>
+#include <cstdlib>
+#include <limits>
+#include <fstream>
+#include <algorithm>
+#include <set>
+
+#if defined (_MSC_VER) && (_MSC_VER < 1800) && !defined(round)
+inline double round(double x) {return (x-floor(x))>0.5?ceil(x):floor(x);}
+#endif
+
+enum blendDirection {FRONT_TO_BACK = 0, BACK_TO_FRONT = 1};
+
+// ***************************************************************************
+// Threaded Blending
+// ***************************************************************************
+
+bool CheckThreadedBlend_Communicator()
+{
+    bool use = true;
+    const char* env_use = std::getenv("OSPRAY_SERIAL_BLEND");
+    if (env_use) { 
+        use = atoi(env_use) <= 0; 
+    }
+    return use;
+}
+static bool UseThreadedBlend_Communicator = CheckThreadedBlend_Communicator();
+
+// ***************************************************************************
+//  Class: avtOSPRayIC_IceT
+// ***************************************************************************
+
+class avtOSPRayIC_IceT : public avtOSPRayIC_Implementation
+{
+public:
+    avtOSPRayIC_IceT(int mpiSize, int mpiRank);
+    ~avtOSPRayIC_IceT();
+    void Init(int, int);
+    void SetTile(const float*, const int*, const float&);
+    void Composite(float*&);
+    static bool Valid();
+private:
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    //---------------------------------------
+    IceTInt          screen[2];
+    IceTContext      context, prevContext;
+    IceTCommunicator comm;
+    IceTInt          MPISize;
+    IceTInt          MPIRank;
+    IceTImage        result;    
+    //---------------------------------------
+    static const bool       usage;
+    static const IceTDouble identity[16];
+    static const IceTFloat  bgColor[4];
+    static const IceTEnum   strategy;
+    //---------------------------------------
+    static const float* imgData;
+    static int          imgMeta[4];
+    //---------------------------------------
+    static bool     CheckUsage();
+    static IceTEnum CheckStrategy();
+    static void DrawCallback(const IceTDouble*, const IceTDouble*,  
+                             const IceTFloat*, const IceTInt*, 
+                             IceTImage img);
+#endif
+};
+
+/*! static functions */
+bool avtOSPRayIC_IceT::Valid() { 
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    return usage;
+#else
+    return false;
+#endif
+}
+
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+const bool avtOSPRayIC_IceT::usage =
+    avtOSPRayIC_IceT::CheckUsage(); 
+bool avtOSPRayIC_IceT::CheckUsage()
+{
+    bool use_icet = false;
+    const char* env_use_icet = std::getenv("OSPRAY_USE_ICET");
+    if (env_use_icet) { 
+        use_icet = atoi(env_use_icet) > 0; 
+    }
+    return use_icet;
+}
+const IceTDouble avtOSPRayIC_IceT::identity[16] = 
+    {
+        IceTDouble(1.0), IceTDouble(0.0), IceTDouble(0.0), IceTDouble(0.0),
+        IceTDouble(0.0), IceTDouble(1.0), IceTDouble(0.0), IceTDouble(0.0),
+        IceTDouble(0.0), IceTDouble(0.0), IceTDouble(1.0), IceTDouble(0.0),
+        IceTDouble(0.0), IceTDouble(0.0), IceTDouble(0.0), IceTDouble(1.0)
+    };
+const IceTFloat avtOSPRayIC_IceT::bgColor[4] = 
+    {
+        IceTFloat(0.0f), IceTFloat(0.0f), IceTFloat(0.0f), IceTFloat(0.0f)
+    };
+const float*   avtOSPRayIC_IceT::imgData = NULL;
+int            avtOSPRayIC_IceT::imgMeta[4] = {0,0,0,0};
+const IceTEnum avtOSPRayIC_IceT::strategy =
+    avtOSPRayIC_IceT::CheckStrategy();
+IceTEnum       avtOSPRayIC_IceT::CheckStrategy() 
+{
+    if (avtOSPRayIC_IceT::Valid()) {
+        IceTEnum ret;
+        int strategy = 3;
+        const char* env_icet_strategy = std::getenv("OSPRAY_ICET_STRATEGY");
+        if (env_icet_strategy) { strategy = atoi(env_icet_strategy); }
+        switch (strategy) {
+        case 0:
+            ret = ICET_STRATEGY_REDUCE;
+            break;
+        case 1:
+            ret = ICET_SINGLE_IMAGE_STRATEGY_TREE;
+            break;
+        case 2:
+            ret = ICET_SINGLE_IMAGE_STRATEGY_RADIXK;
+            break;
+        default:
+            ret = ICET_SINGLE_IMAGE_STRATEGY_BSWAP;
+            break;
+        }
+        return ret;
+    }
+    else {
+        return false;
+    }
+}
+#endif
+
+/*! regular member functions */
+avtOSPRayIC_IceT::avtOSPRayIC_IceT(int mpiSize, int mpiRank)
+    : avtOSPRayIC_Implementation(mpiSize, mpiRank)
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    MPISize = IceTInt(mpiSize);
+    MPIRank = IceTInt(mpiRank);
+    prevContext = icetGetContext();
+    comm = icetCreateMPICommunicator(VISIT_MPI_COMM);
+    context = icetCreateContext(comm);
+    icetDestroyMPICommunicator(comm);
+    // debug
+    if (avtOSPRayIC_IceT::Valid() && mpiRank == 0) {
+        switch (avtOSPRayIC_IceT::strategy) {
+        case 0:
+            ospout << "[avtOSPRayIC_IceT] Strategy Reduce" << std::endl;
+            break;
+        case 1:
+            ospout << "[avtOSPRayIC_IceT] Strategy Tree" << std::endl;
+            break;
+        case 2:
+            ospout << "[avtOSPRayIC_IceT] Strategy Radix-k" << std::endl;
+            break;
+        default:
+            ospout << "[avtOSPRayIC_IceT] Strategy BSwap" << std::endl;
+            break;
+        }
+    }
+#endif
+}
+
+avtOSPRayIC_IceT::~avtOSPRayIC_IceT()
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    icetDestroyContext(context);
+    icetSetContext(prevContext);
+#endif
+}
+
+void avtOSPRayIC_IceT::Init(int W, int H)
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    
+    if (MPIRank == 0) {
+        ospout << "avtOSPRayIC_IceT::Init Start";
+    }
+    //
+    // Initialization
+    //
+    screen[0] = W;
+    screen[1] = H;
+    //
+    // Setup IceT parameters
+    //
+    if (/*ospray::CheckVerbose()*/ false /*|| DebugStream::Level5()*/) {
+        icetDiagnostics(ICET_DIAG_FULL);
+    }
+    icetCompositeMode(ICET_COMPOSITE_MODE_BLEND);
+    icetSetColorFormat(ICET_IMAGE_COLOR_RGBA_FLOAT);
+    icetSetDepthFormat(ICET_IMAGE_DEPTH_NONE);
+    icetEnable(ICET_ORDERED_COMPOSITE);
+    icetDisable(ICET_INTERLACE_IMAGES);
+    //
+    // Safety
+    //
+    MPI_Barrier(MPI_COMM_WORLD);
+    if (MPIRank == 0) {
+        ospout << " ... Done" << std::endl;
+    }
+#endif
+}
+
+void avtOSPRayIC_IceT::SetTile(const float* d, 
+                                   const int*   e, /* xmin, xmax, ymin, ymax */
+                                   const float& z)
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    //
+    // Gather depths
+    //
+    if (MPIRank == 0) {
+        ospout << "avtOSPRayIC_IceT::SetTile Gather Depth";
+    }
+    std::vector<float>   all_depths(MPISize);
+    std::vector<IceTInt> all_orders(MPISize);
+    MPI_Allgather(&z, 1, MPI_FLOAT, all_depths.data(), 1, 
+                  MPI_FLOAT, MPI_COMM_WORLD);
+    if (MPIRank == 0) { ospout << " ... Done" << std::endl; }
+    //
+    // Sort depths in compositing order
+    //
+    if (MPIRank == 0) {
+        ospout << "avtOSPRayIC_IceT::SetTile Sort Depths";
+    }
+    std::multimap<float,int> ordered_depths;
+    for (int i = 0; i < MPISize; i++) {
+        ordered_depths.insert(std::pair<float, int>(all_depths[i], i));      
+    }
+    int i = 0;
+    for (std::multimap<float,int>::iterator it = ordered_depths.begin(); 
+         it != ordered_depths.end(); ++it) {
+        all_orders[i] = (*it).second;
+        i++;
+    }
+    icetCompositeOrder(all_orders.data());
+    if (MPIRank == 0) { ospout << " ... Done" << std::endl; }
+    //
+    // Set IceT Tile Information
+    //
+    icetResetTiles();
+    icetAddTile(0, 0, screen[0], screen[1], 0);
+    icetPhysicalRenderSize(screen[0], screen[1]);
+    //
+    // Composite Stratagy
+    //
+    if (strategy == ICET_STRATEGY_REDUCE) {
+        icetStrategy(ICET_STRATEGY_REDUCE);
+    } else {    
+        icetStrategy(ICET_STRATEGY_SEQUENTIAL);
+        icetSingleImageStrategy(strategy);
+    }
+    //
+    // Bounding Box
+    //
+    icetBoundingBoxf(((float) e[0]   /(screen[0]-1) - 0.5f) * 2.f,
+                     ((float)(e[1]-1)/(screen[0]-1) - 0.5f) * 2.f,
+                     ((float) e[2]   /(screen[1]-1) - 0.5f) * 2.f,
+                     ((float)(e[3]-1)/(screen[1]-1) - 0.5f) * 2.f,
+                     0.0, 0.0);
+    //
+    // Compose
+    //
+    avtOSPRayIC_IceT::imgData = d;
+    avtOSPRayIC_IceT::imgMeta[0] = e[0];
+    avtOSPRayIC_IceT::imgMeta[1] = e[2];
+    avtOSPRayIC_IceT::imgMeta[2] = e[1] - e[0];
+    avtOSPRayIC_IceT::imgMeta[3] = e[3] - e[2];
+    icetDrawCallback(DrawCallback);
+#endif
+}
+
+void avtOSPRayIC_IceT::Composite(float*& output)
+{
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+    if (MPIRank == 0) { ospout << "avtOSPRayIC_IceT::Composite"; }
+    result = icetDrawFrame(identity, identity, bgColor);
+    if (MPIRank == 0) { ospout << " ... Done" << std::endl; }
+    if (MPIRank == 0) {
+        icetImageCopyColorf(result, output, ICET_IMAGE_COLOR_RGBA_FLOAT);
+    }
+#endif
+}
+
+#if defined(PARALLEL) && defined(VISIT_OSPRAY_ICET)
+void avtOSPRayIC_IceT::DrawCallback(const IceTDouble*,
+                                        const IceTDouble*, 
+                                        const IceTFloat*, 
+                                        const IceTInt*,
+                                        IceTImage img) 
+{
+    float *o = icetImageGetColorf(img);
+    const int outputStride = icetImageGetWidth(img);
+    for (int j = 0; j < imgMeta[3]; ++j) {      
+        for (int i = 0; i < imgMeta[2]; ++i) {
+            const int gIdx = 
+                i + imgMeta[0] + (j + imgMeta[1]) * outputStride;
+            const int lIdx = i + j * imgMeta[2];
+            o[4 * gIdx + 0] = imgData[4 * lIdx + 0];
+            o[4 * gIdx + 1] = imgData[4 * lIdx + 1];
+            o[4 * gIdx + 2] = imgData[4 * lIdx + 2];
+            o[4 * gIdx + 3] = imgData[4 * lIdx + 3];
+        }
+    }
+}
+#endif
+
+// ***************************************************************************
+//  End Class: avtOSPRayIC_IceT
+// ***************************************************************************
+
+
+// ***************************************************************************
+//  Begin Class: avtOSPRayIC_OneNode
+// ***************************************************************************
+
+struct MetaData_OneNode {
+    int id;         // id of the patch on that processor
+    int dims[2];    // height, width
+    int extents[4]; // (lower left) (upper right)
+    float z;        // camera space depth of the patch (average)
+};
+
+class avtOSPRayIC_OneNode : public avtOSPRayIC_Implementation
+{
+private:
+    std::vector<MetaData_OneNode> allPatchMeta;
+    std::vector<const float*>     allPatchData;
+    int fullExtents[4];
+
+    static bool Predicate(MetaData_OneNode const& before,
+                          MetaData_OneNode const& after);
+public:
+    avtOSPRayIC_OneNode(int mpiSize, int mpiRank);
+    ~avtOSPRayIC_OneNode();
+    void Init(int, int);
+    void SetTile(const float*, const int*, const float&);
+    void Composite(float*&);
+    static bool Valid();
+};
+
+bool avtOSPRayIC_OneNode::Valid() { return true; };
+bool avtOSPRayIC_OneNode::Predicate(MetaData_OneNode const& before,
+                                        MetaData_OneNode const& after)
+{ return before.z > after.z; }
+
+avtOSPRayIC_OneNode::avtOSPRayIC_OneNode(int mpiSize, int mpiRank)
+    : avtOSPRayIC_Implementation(mpiSize, mpiRank)
+{
+}
+
+avtOSPRayIC_OneNode::~avtOSPRayIC_OneNode()
+{
+    allPatchMeta.clear();
+    allPatchData.clear();
+};
+
+void avtOSPRayIC_OneNode::Init(int W, int H)
+{
+    fullExtents[0] = 0;
+    fullExtents[1] = W;
+    fullExtents[2] = 0;
+    fullExtents[3] = H;
+};
+
+void avtOSPRayIC_OneNode::SetTile(const float* d,
+                                      /* xmin, xmax, ymin, ymax */ 
+                                      const int*   e,
+                                      const float& z)
+{
+    MetaData_OneNode m;
+    m.id = allPatchMeta.size();
+    m.dims[0] = e[1] - e[0];
+    m.dims[1] = e[3] - e[2];
+    m.extents[0] = e[0];
+    m.extents[1] = e[1];
+    m.extents[2] = e[2];
+    m.extents[3] = e[3];
+    m.z = z;
+    allPatchMeta.push_back(m);
+    allPatchData.push_back(d);
+}
+
+void avtOSPRayIC_OneNode::Composite(float*& output)
+{
+    // Sort with the largest z first
+    std::sort(allPatchMeta.begin(), allPatchMeta.end(),
+              &(avtOSPRayIC_OneNode::Predicate));
+    for (int i=0; i<allPatchMeta.size(); i++) {
+      MetaData_OneNode m = allPatchMeta[i];
+      avtOSPRayImageCompositor::BlendBackToFront(allPatchData[m.id],
+                                                m.extents,
+                                                output, 
+                                                fullExtents);
+    }
+}
+
+// ***************************************************************************
+//  End Class: avtOSPRayIC_OneNode
+// ***************************************************************************
+
+
+// ***************************************************************************
+//  Begin Class: avtOSPRayIC_Serial
+// ***************************************************************************
+
+// class avtOSPRayIC_Serial : public avtOSPRayIC_Implementation
+// {
+// public:
+//     avtOSPRayIC_Serial(int mpiSize, int mpiRank);
+//     ~avtOSPRayIC_Serial();
+//     void Init(int, int);
+//     void SetTile(const float*, const int*, const float&);
+//     void Composite(float*&);
+//     static bool Valid();
+// };
+
+// bool avtOSPRayIC_Serial::Valid() { return true; };
+
+// ***************************************************************************
+//  End Class: avtOSPRayIC_Serial
+// ***************************************************************************
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::avtOSPRayImageCompositor
+//
+//  Purpose: Constructor
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+avtOSPRayImageCompositor::avtOSPRayImageCompositor()
+{
+#ifdef PARALLEL
+    MPI_Comm_size(VISIT_MPI_COMM, &mpiSize);
+    MPI_Comm_rank(VISIT_MPI_COMM, &mpiRank);
+#else
+    mpiSize = 1;
+    mpiRank = 0;
+#endif
+    finalImage = NULL;
+    compositor = NULL;
+    // debug
+    if (mpiRank == 0) {
+        if (!UseThreadedBlend_Communicator) {
+            ospout << "[avtOSPRayImageCompositor] "
+                   << "Not Using Multi-Threading for Blending"
+                   << std::endl;
+        } else {
+            ospout << "[avtOSPRayImageCompositor] "
+                   << "Using Multi-Threading for Blending"
+                   << std::endl;
+        }
+        if (!avtOSPRayIC_IceT::Valid()) {
+            ospout << "[avtOSPRayImageCompositor] "
+                   << "Not Using IceT for Image Compositing"
+                   << std::endl;
+        } else {
+            ospout << "[avtOSPRayImageCompositor] "
+                   << "Using IceT for Image Compositing"
+                   << std::endl;
+        }
+    }
+    //////////////////////////////////////////////////////////////////////////
+    intermediateImageExtents[0] = intermediateImageExtents[1] = 0.0;
+    intermediateImageExtents[2] = intermediateImageExtents[3] = 0.0;
+    intermediateImageBBox[0] = intermediateImageBBox[1] = 0.0;
+    intermediateImageBBox[2] = intermediateImageBBox[3] = 0.0;
+    totalPatches = 0;
+    intermediateImage = NULL;
+    //////////////////////////////////////////////////////////////////////////
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::~avtOSPRayImageCompositor
+//
+//  Purpose:
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+avtOSPRayImageCompositor::~avtOSPRayImageCompositor()
+{
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendFrontToBack
+//
+//  Purpose:
+//      Blends tow patches in a front to back manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendFrontToBack(const float *srcImage,
+                                               const int srcExtents[4],
+                                               const int blendExtents[4], 
+                                               float *&dstImage,
+                                               const int dstExtents[4])
+{
+    if (UseThreadedBlend_Communicator) {
+      ospray::visit::BlendFrontToBack(blendExtents,
+                                srcExtents,
+                                srcImage,
+                                dstExtents,
+                                dstImage);
+    } else {
+        // image sizes
+        const int srcX = srcExtents[1] - srcExtents[0];
+        const int srcY = srcExtents[3] - srcExtents[2];
+        const int dstX = dstExtents[1] - dstExtents[0];
+        const int dstY = dstExtents[3] - dstExtents[2];
+        // determin the region to blend
+        const int startX = 
+            std::max(std::max(blendExtents[0], srcExtents[0]), dstExtents[0]);
+        const int startY = 
+            std::max(std::max(blendExtents[2], srcExtents[2]), dstExtents[2]);
+        const int endX = 
+            std::min(std::min(blendExtents[1], srcExtents[1]), dstExtents[1]);
+        const int endY = 
+            std::min(std::min(blendExtents[3], srcExtents[3]), dstExtents[3]);
+    
+        for (int y = startY; y < endY; ++y) {
+            for (int x = startX; x < endX; ++x) {
+                // get indices
+                int srcIndex = (srcX*(y-srcExtents[2]) + x-srcExtents[0])*4;
+                int dstIndex = (dstX*(y-dstExtents[2]) + x-dstExtents[0])*4;
+
+                // front to back compositing
+                if (dstImage[dstIndex + 3] < 1.0f) {
+                    float trans = 1.0f - dstImage[dstIndex + 3];
+                    dstImage[dstIndex+0] = 
+                        CLAMP(srcImage[srcIndex+0] * trans + 
+                              dstImage[dstIndex+0],
+                              0.0f, 1.0f);
+                    dstImage[dstIndex+1] = 
+                        CLAMP(srcImage[srcIndex+1] * trans + 
+                              dstImage[dstIndex+1],
+                              0.0f, 1.0f);
+                    dstImage[dstIndex+2] = 
+                        CLAMP(srcImage[srcIndex+2] * trans + 
+                              dstImage[dstIndex+2],
+                              0.0f, 1.0f);
+                    dstImage[dstIndex+3] = 
+                        CLAMP(srcImage[srcIndex+3] * trans + 
+                              dstImage[dstIndex+3],
+                              0.0f, 1.0f);
+                }
+            }
+        }
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendBackToFront
+//
+//  Purpose:
+//      Blends tow patches in a back to front manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendBackToFront(const float *srcImage,
+                                               const int srcExtents[4],
+                                               const int blendExtents[4], 
+                                               float *&dstImage,
+                                               const int dstExtents[4])
+{
+    if (UseThreadedBlend_Communicator) {
+      ospray::visit::BlendBackToFront(blendExtents,
+                                srcExtents,
+                                srcImage,
+                                dstExtents,
+                                dstImage);
+    } else {
+        // image sizes
+        const int srcX = srcExtents[1] - srcExtents[0];
+        const int srcY = srcExtents[3] - srcExtents[2];
+        const int dstX = dstExtents[1] - dstExtents[0];
+        const int dstY = dstExtents[3] - dstExtents[2];
+        // determin the region to blend
+        const int startX = 
+            std::max(std::max(blendExtents[0], srcExtents[0]), dstExtents[0]);
+        const int startY = 
+            std::max(std::max(blendExtents[2], srcExtents[2]), dstExtents[2]);
+        const int endX = 
+            std::min(std::min(blendExtents[1], srcExtents[1]), dstExtents[1]);
+        const int endY = 
+            std::min(std::min(blendExtents[3], srcExtents[3]), dstExtents[3]);
+    
+        for (int y = startY; y < endY; ++y) {
+            for (int x = startX; x < endX; ++x) {
+                // get indices
+                int srcIndex = (srcX*(y-srcExtents[2]) + x-srcExtents[0])*4;
+                int dstIndex = (dstX*(y-dstExtents[2]) + x-dstExtents[0])*4;
+                // back to front compositing        
+                float trans = 1.0f - srcImage[srcIndex + 3];
+                dstImage[dstIndex+0] = 
+                    CLAMP(dstImage[dstIndex+0] * trans + srcImage[srcIndex+0],
+                          0.0f, 1.0f);
+                dstImage[dstIndex+1] = 
+                    CLAMP(dstImage[dstIndex+1] * trans + srcImage[srcIndex+1],
+                          0.0f, 1.0f);
+                dstImage[dstIndex+2] = 
+                    CLAMP(dstImage[dstIndex+2] * trans + srcImage[srcIndex+2],
+                          0.0f, 1.0f);
+                dstImage[dstIndex+3] = 
+                    CLAMP(dstImage[dstIndex+3] * trans + srcImage[srcIndex+3],
+                          0.0f, 1.0f);
+            }
+        }
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendFrontToBack
+//
+//  Purpose:
+//      Blends tow patches in a front to back manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendFrontToBack(const float * srcImage,
+                                               const int srcExtents[4], 
+                                               float *& dstImage,
+                                               const int dstExtents[4])
+{
+    BlendFrontToBack(srcImage, srcExtents, srcExtents, dstImage, dstExtents);
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendBackToFront
+//
+//  Purpose:
+//      Blends tow patches in a back to front manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendBackToFront(const float * srcImage,
+                                               const int srcExtents[4], 
+                                               float *& dstImage, 
+                                               const int dstExtents[4])
+{
+    BlendBackToFront(srcImage, srcExtents, srcExtents, dstImage, dstExtents);
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::Barrier
+//
+//  Purpose:
+//    Barrier, useful for debugging
+//
+//  Programmer: Pascal Grosset
+//  Creation: July 2013
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtOSPRayImageCompositor::Barrier() {
+#ifdef PARALLEL
+    MPI_Barrier(MPI_COMM_WORLD);
+#endif
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::ColorImage
+//
+//  Purpose:
+//       Fills a 4 channel image with a specific color
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtOSPRayImageCompositor::ColorImage(float *&srcImage,
+                                         const int widthSrc,
+                                         const int heightSrc,
+                                         const float color[4])
+{
+    for (int i = 0; i < heightSrc * widthSrc; ++i) {
+        const int srcIndex = 4 * i;
+        srcImage[srcIndex+0] = color[0];
+        srcImage[srcIndex+1] = color[1];
+        srcImage[srcIndex+2] = color[2];
+        srcImage[srcIndex+3] = color[3];
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::PlaceImage
+//
+//  Purpose:
+//      Puts srcImage into dstImage
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtOSPRayImageCompositor::PlaceImage(const float *srcImage,
+                                         const int srcExtents[4], 
+                                         float *&dstImage,
+                                         const int dstExtents[4])
+{
+    const int srcX = srcExtents[1] - srcExtents[0];
+    const int srcY = srcExtents[3] - srcExtents[2];
+    const int dstX = dstExtents[1] - dstExtents[0];
+    const int dstY = dstExtents[3] - dstExtents[2];
+    const int startingX = std::max(srcExtents[0], dstExtents[0]);
+    const int startingY = std::max(srcExtents[2], dstExtents[2]);
+    const int endingX = std::min(srcExtents[1], dstExtents[1]);
+    const int endingY = std::min(srcExtents[3], dstExtents[3]);
+    
+    for (int y = startingY; y < endingY; ++y) {
+        for (int x = startingX; x < endingX; ++x) {
+            // index in the sub-image
+            const int srcIndex = 
+                (srcX * (y-srcExtents[2]) + x-srcExtents[0]) * 4; 
+            // index in the larger buffer
+            const int dstIndex = 
+                (dstX * (y-dstExtents[2]) + x-dstExtents[0]) * 4;
+            dstImage[dstIndex+0] = srcImage[srcIndex+0];
+            dstImage[dstIndex+1] = srcImage[srcIndex+1];
+            dstImage[dstIndex+2] = srcImage[srcIndex+2];
+            dstImage[dstIndex+3] = srcImage[srcIndex+3];
+        }
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::BlendWithBackground
+//
+//  Purpose:
+//      Blends _image with the backgroundColor
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void avtOSPRayImageCompositor::BlendWithBackground(float *&image,
+                                                  const int extents[4],
+                                                  const float bgColor[4])
+{
+    const int pixelSize = (extents[3]-extents[2]) * (extents[1]-extents[0]);
+    // estimated potential speedup: 2.240
+    for (int i = 0; i < pixelSize; ++i)
+        {
+            const int   idx = i * 4;
+            const float alpha = (1.0 - image[idx+3]);
+            image[idx+0] = bgColor[0] * alpha + image[idx+0];
+            image[idx+1] = bgColor[1] * alpha + image[idx+1];
+            image[idx+2] = bgColor[2] * alpha + image[idx+2];
+            image[idx+3] = bgColor[3] * alpha + image[idx+3];
+        }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::IceT
+//
+//  Purpose:
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+//  Modifications:
+//
+// **************************************************************************
+
+bool avtOSPRayImageCompositor::IceTValid() 
+{
+    return avtOSPRayIC_IceT::Valid(); 
+}
+
+void avtOSPRayImageCompositor::IceTInit(int W, int H)
+{
+    if (!avtOSPRayIC_IceT::Valid()) {
+        std::cerr << "ERROR: IceT compositor is not valid. "
+                  << "Probably IceT is not compiled with VisIt"
+                  << std::endl;
+        ospray::Exception("ERROR: IceT compositor is not valid. "
+                          "Probably IceT is not compiled with VisIt");
+        return;
+    }
+    if (compositor) delete compositor;
+    compositor = new avtOSPRayIC_IceT(mpiSize, mpiRank);
+    compositor->Init(W, H);
+}
+
+void avtOSPRayImageCompositor::IceTSetTile(const float* d, 
+                                          const int*   e,
+                                          const float& z)
+{
+    ospray::timestamp timingDetail;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                             "IceTSetTile", timingDetail,
+                             "IceT Setup Image Tile");
+    //---------------------------------------------------------------------//
+    compositor->SetTile(d, e, z);
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                            "IceTSetTile", timingDetail,
+                            "IceT Setup Image Tile");
+    //---------------------------------------------------------------------//
+}
+
+void avtOSPRayImageCompositor::IceTComposite(float*& output)
+{
+    ospray::timestamp timingDetail;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                             "IceTComposite", timingDetail,
+                             "IceT Image Composition");
+    //---------------------------------------------------------------------//
+    compositor->Composite(output);
+    if (compositor != NULL) { delete compositor; }
+    compositor = NULL;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                            "IceTComposite", timingDetail,
+                            "IceT Image Composition");
+    //---------------------------------------------------------------------//
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::OneNode
+//
+//  Purpose:
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+//  Modifications:
+//
+// **************************************************************************
+
+bool avtOSPRayImageCompositor::OneNodeValid()
+{
+    return avtOSPRayIC_OneNode::Valid();    
+}
+void avtOSPRayImageCompositor::OneNodeInit(int W, int H)
+{
+    if (compositor) delete compositor;
+    compositor = new avtOSPRayIC_OneNode(mpiSize, mpiRank);
+    compositor->Init(W, H);    
+}
+void avtOSPRayImageCompositor::OneNodeSetTile(const float* d,
+                                             const int*   e, 
+                                             const float& z)
+{
+    compositor->SetTile(d, e, z);
+}
+void avtOSPRayImageCompositor::OneNodeComposite(float*& output)
+{
+    compositor->Composite(output);
+    if (compositor != NULL) { delete compositor; }
+    compositor = NULL;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::UpdateBoundingBox
+//
+//  Purpose:
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void
+avtOSPRayImageCompositor::UpdateBoundingBox(int currentBoundingBox[4],
+                                           const int imageExtents[4])
+{
+    if ((currentBoundingBox[0] == 0 && currentBoundingBox[1] == 0) && 
+        (currentBoundingBox[2] == 0 && currentBoundingBox[3] == 0)) {
+        currentBoundingBox[0]=imageExtents[0];
+        currentBoundingBox[1]=imageExtents[1];
+        currentBoundingBox[2]=imageExtents[2];
+        currentBoundingBox[3]=imageExtents[3];
+        return;
+    }
+
+    if (imageExtents[0] < currentBoundingBox[0])
+        { currentBoundingBox[0] = imageExtents[0]; }
+
+    if (imageExtents[2] < currentBoundingBox[2])
+        { currentBoundingBox[2] = imageExtents[2]; }
+
+    if (imageExtents[1] > currentBoundingBox[1])
+        { currentBoundingBox[1] = imageExtents[1]; }
+
+    if (imageExtents[3] > currentBoundingBox[3])
+        { currentBoundingBox[3] = imageExtents[3]; }
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::GatherDepthAtRoot
+//
+//  Purpose:
+//      Used by Serial Direct Send
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void
+avtOSPRayImageCompositor::GatherDepthAtRoot(const int numlocalPatches,
+                                           const float *localPatchesDepth,
+                                           int &totalPatches,
+                                           int *&patchCountPerRank,
+                                           float *&allPatchesDepth)
+{
+#ifdef PARALLEL
+    // Get how many patches are coming from each MPI rank
+    totalPatches = 0;
+    int *patchesOffset = NULL;
+
+    if (mpiRank == 0) // root!
+        { patchCountPerRank = new int[mpiSize](); }
+
+    // reference
+    // https://www.mpich.org/static/docs/v3.1/www3/MPI_Gather.html
+    MPI_Gather(&numlocalPatches, /* send buffer */
+               1, /* send count */
+               MPI_INT, 
+               patchCountPerRank, /* address of receive buffer (root) */
+               1, /* number of elements for any single receive (root) */
+               MPI_INT, 
+               0, /* rank of receiving process (integer) */
+               MPI_COMM_WORLD); /* communicator (handle) */
+
+    // gather number of patch group
+    if (mpiRank == 0)
+        {
+            patchesOffset = new int[mpiSize]();
+            patchesOffset[0] = 0; // a bit redundant
+
+            for (int i=0; i<mpiSize; i++)
+                {
+                    totalPatches += patchCountPerRank[i];
+                    if (i == 0)
+                        { patchesOffset[i] = 0; }
+                    else
+                        {
+                            patchesOffset[i] = 
+                                patchesOffset[i-1] + patchCountPerRank[i-1]; 
+                        }
+                }
+        
+            // allocate only at root
+            allPatchesDepth = new float[totalPatches];
+        }
+
+    // Gathers into specified locations from all processes in a group
+    MPI_Gatherv(localPatchesDepth, numlocalPatches, MPI_FLOAT, 
+                allPatchesDepth, /* receive all depth */
+                patchCountPerRank, patchesOffset, MPI_FLOAT, 
+                0, MPI_COMM_WORLD);
+
+    // Cleanup
+    if (mpiRank == 0 && patchesOffset != NULL)
+        { delete [] patchesOffset; }
+    patchesOffset = NULL;
+#endif
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::SerialDirectSend
+//
+//  Purpose:
+//      A very simple compositing that we can fall back to if parallel direct
+//      send is buggy.
+//      Works with convex patches though
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void
+avtOSPRayImageCompositor::SerialDirectSend(int localNumPatches,
+                                          float *localPatchesDepth, 
+                                          int *extents,
+                                          float *imgData,
+                                          float bgColor[4],
+                                          int width, int height)
+{
+#ifdef PARALLEL
+    //
+    // Message
+    //
+    //debug5 << "-- Serial Direct Send --" << std::endl;
+
+    float *recvImage = NULL;
+    int tags[2] = {5781, 5782};
+    //
+    // Retrieve depth info through MPI
+    //
+    int    totalPatches; // total number of patches
+    int   *totalPatchCountsPerRank = NULL;
+    float *totalPatchDepths = NULL;
+    GatherDepthAtRoot(localNumPatches,
+                      localPatchesDepth,
+                      totalPatches, 
+                      totalPatchCountsPerRank,
+                      totalPatchDepths);
+    //
+    //
+    //
+    if (mpiRank == 0)
+        {
+            // Root
+            int srcSize[2] = {width, height};
+            int srcPos[2]  = {0, 0};
+            int dstSize[2], dstPos[2];
+
+            // Sort patches we will receive
+            std::multimap<float,int> sortedPatches;
+
+            int patchId = 0;
+            for (int i=0; i<mpiSize; i++) {
+                for (int j=0; j<totalPatchCountsPerRank[i]; j++) {
+                    sortedPatches.insert
+                        (std::make_pair(totalPatchDepths[patchId++],i));
+                }
+            }
+
+            // Create space for buffers
+            int recvParams[4]; // minX, maxX, minY, maxY
+            int imgExtents[4] = {0,width,0,height};
+
+            recvImage = new float[width*height*4]();
+            finalImage = new float[width*height*4]();
+        
+            int localIndex = 0;
+
+            // Compositing
+            for (std::multimap<float,int>::iterator it = sortedPatches.begin(); 
+                 it != sortedPatches.end(); ++it)
+                {
+                    int rank = (*it).second;
+                    if (rank != mpiRank)
+                        {
+                            // recv image info
+                            MPI_Recv(recvParams, 4, MPI_INT, rank, 
+                                     tags[0], MPI_COMM_WORLD, MPI_STATUS_IGNORE); 
+                            // recv image
+                            MPI_Recv(recvImage, width*height*4, MPI_FLOAT, rank,
+                                     tags[1],  MPI_COMM_WORLD, MPI_STATUS_IGNORE);
+                            dstPos[0]  = dstPos[0];                     
+                            dstPos[1]  = dstPos[1];
+                            dstSize[0] = recvParams[2]-recvParams[0];   
+                            dstSize[1] = recvParams[3]-recvParams[1];
+                        }
+                    else
+                        {
+                            // It's local
+                            recvParams[0] = extents[ localIndex*4 + 0];
+                            recvParams[1] = extents[ localIndex*4 + 1];
+                            recvParams[2] = extents[ localIndex*4 + 2];
+                            recvParams[3] = extents[ localIndex*4 + 3];
+                            recvImage = &imgData[ localIndex*(width*height*4) ];
+                            localIndex++;
+                        }
+                    BlendFrontToBack(recvImage, recvParams, finalImage, imgExtents);
+                }
+            BlendWithBackground(finalImage, imgExtents, bgColor);
+        }
+    else
+        {
+            // Sender
+            for (int i=0; i<localNumPatches; i++)
+                {
+                    int imgSize = 
+                        (extents[i*4 + 1] - extents[i*4 + 0]) *
+                        (extents[i*4 + 3] - extents[i*4 + 2]) * 4;          
+                    if (imgSize > 0)
+                        {
+                            MPI_Send(&extents[i*4],
+                                     4, MPI_INT, 0, tags[0], MPI_COMM_WORLD);
+                            MPI_Send(&imgData[i*(width*height*4)], 
+                                     imgSize, MPI_FLOAT, 0, tags[1], MPI_COMM_WORLD);
+                        }
+                }
+        }
+
+    // Cleanup
+    if (totalPatchDepths != NULL)
+        delete []totalPatchDepths;
+
+    if (totalPatchCountsPerRank != NULL)
+        delete []totalPatchCountsPerRank;
+
+    if (recvImage != NULL)
+        delete []recvImage;
+
+    recvImage = NULL;
+    totalPatchCountsPerRank = NULL;
+    totalPatchDepths = NULL;
+#endif
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::regionAllocation
+//
+//  Purpose:
+//      Arbitrarily allocates regions to MPI ranks
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void
+avtOSPRayImageCompositor::RegionAllocation(int *& regions)
+{
+    regions = new int[mpiSize];
+    // Initial allocation: partition for section rank
+    for (int i=0; i<mpiSize; i++) { regions[i] = i; }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::parallelDirectSend
+//
+//  Purpose:
+//      Parallel Direct Send rendering that can blend convex patches from each
+//      MPI rank. However, since we are not guaranteed to have convex patches.
+//      It's not used.
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtOSPRayImageCompositor::parallelDirectSend(float *imgData,
+                                            int imgExtents[4],
+                                            int region[],
+                                            int numRegions,
+                                            int tags[2],
+                                            int fullImageExtents[4])
+{
+#ifdef PARALLEL
+    //
+    // Determine position in region (myPositionInRegion)
+    int width  = fullImageExtents[1]-fullImageExtents[0];
+    int height = fullImageExtents[3]-fullImageExtents[2];
+
+    //debug5 << "fullImageExtents: " << fullImageExtents[0] << ", " << fullImageExtents[1] << "   " << fullImageExtents[2] << ", " << fullImageExtents[3] << endl;
+
+    compositingDone = false;
+    int myPositionInRegion = -1;
+    bool inRegion = true;
+    std::vector<int> regionVector(region, region+numRegions);
+    std::vector<int>::iterator it = std::find(regionVector.begin(),
+                                              regionVector.end(),
+                                              mpiRank);
+
+    if (it == regionVector.end())
+        {
+            inRegion = false;
+            //debug5 << mpiRank << " ~ SHOULD NOT HAPPEN: Not found " << mpiRank <<  " !!!" << std::endl;
+        }
+    else
+        myPositionInRegion = it - regionVector.begin();
+
+    //
+    // Region boundaries
+    int regionHeight = height/numRegions;
+    int lastRegionHeight = height - regionHeight*(numRegions-1);
+
+    // Extents of my region
+    int myStartingHeight =
+        fullImageExtents[2] +
+        myPositionInRegion *
+        regionHeight;
+    int myEndingHeight = myStartingHeight + regionHeight;
+    if (myPositionInRegion == numRegions-1)
+        myEndingHeight = fullImageExtents[3];
+
+    int myRegionHeight = myEndingHeight-myStartingHeight;
+
+    // Size of one buffer
+    int sizeOneBuffer = std::max(regionHeight,lastRegionHeight) * width * 4;
+
+    //debug5 << "myPositionInRegion: " << myPositionInRegion << std::endl;
+    //debug5 << "My extents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
+    //debug5 << "myRegionHeight: " << myRegionHeight << "  lastRegionHeight: " << lastRegionHeight << " regionHeight: " << regionHeight << "  myStartingHeight: " << myStartingHeight << "  myEndingHeight: " << myEndingHeight << std::endl;
+
+
+    //
+    // MPI Async
+
+    // Recv
+    MPI_Request *recvMetaRq = new MPI_Request[ numRegions-1 ];
+    MPI_Request *recvImageRq = new MPI_Request[ numRegions-1 ];
+
+    MPI_Status *recvMetaSt = new MPI_Status[ numRegions-1 ];
+    MPI_Status *recvImageSt = new MPI_Status[ numRegions-1 ];
+
+    // Send
+    MPI_Request *sendMetaRq = new MPI_Request[ numRegions-1 ];
+    MPI_Request *sendImageRq = new MPI_Request[ numRegions-1 ];
+
+    MPI_Status *sendMetaSt = new MPI_Status[ numRegions-1 ];
+    MPI_Status *sendImageSt = new MPI_Status[ numRegions-1 ];
+
+
+    //
+    // Create Buffers
+
+    // Create buffer for receiving images
+    float *recvDataBuffer;
+    recvDataBuffer = new float[ sizeOneBuffer * numRegions];
+
+    // Create buffer for receiving messages
+    std::vector<int> msgBuffer;
+    msgBuffer.clear();
+    msgBuffer.resize(5 * numRegions);
+
+    // Create buffer for sending messages
+    int *sendExtents = new int[numRegions*5];
+
+    //
+    // Async Recv
+    if (inRegion)
+        {
+            int recvCount=0;
+            for (int i=0; i<numRegions; i++)
+                {
+                    if ( regionVector[i] == mpiRank )
+                        continue;
+
+                    int src = regionVector[i];
+                    MPI_Irecv(&msgBuffer[i*5],                              5, MPI_INT,   src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvCount] );
+                    MPI_Irecv(&recvDataBuffer[i*sizeOneBuffer], sizeOneBuffer, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+                    recvCount++;
+                }
+        }
+
+    //debug5 << "Async Recv setup done " << std::endl;
+
+    //
+    // Async Send
+    int sendCount = 0;
+    int sendingOffset;
+    for (int i=0; i<numRegions; i++)
+        {
+            int regionStart, regionEnd, imgSize, dest;
+            dest = regionVector[i];
+
+            if ( dest == mpiRank )
+                continue;
+
+            regionStart = i*regionHeight;
+            regionEnd = regionStart + regionHeight;
+            if (i == numRegions-1) // the last one in region
+                regionEnd = height;
+
+            int startingYExtents = fullImageExtents[2] + regionStart;
+            int endingYExtents = fullImageExtents[2] + regionEnd;
+
+            //debug5 << "startingYExtents: " << startingYExtents <<"   endingYExtents: " << endingYExtents <<  std::endl;
+
+            if (startingYExtents < imgExtents[2])
+                startingYExtents = imgExtents[2];
+
+            if (endingYExtents > imgExtents[3])
+                endingYExtents = imgExtents[3];
+
+            bool hasData = true;
+            if (endingYExtents - startingYExtents <= 0 || imgExtents[1]-imgExtents[0] <= 0)
+                {
+                    hasData = false;
+
+                    sendingOffset = 0;
+                    imgSize = sendExtents[i*5 + 0] = sendExtents[i*5 + 1] = sendExtents[i*5 + 2] = sendExtents[i*5 + 3] =  sendExtents[i*5 + 4] = 0;
+                }
+            else
+                {
+                    imgSize = (endingYExtents-startingYExtents) * (imgExtents[1]-imgExtents[0]) * 4;
+                    sendingOffset = (startingYExtents-imgExtents[2]) * (imgExtents[1]-imgExtents[0]) * 4;
+
+                    sendExtents[i*5 + 0] = imgExtents[0];
+                    sendExtents[i*5 + 1] = imgExtents[1];
+                    sendExtents[i*5 + 2] = startingYExtents;
+                    sendExtents[i*5 + 3] = endingYExtents;
+                    sendExtents[i*5 + 4] = 0;
+                }
+
+            //std::cout << mpiRank << " ~ i: " << i << "   regionVector[index]: " << regionVector[index] << "  extents: " <<  sendExtents[index*5 + 0] << ", " << sendExtents[index*5 + 1]  << ", " << sendExtents[index*5 + 2] << ", " << sendExtents[index*5 + 3] << "  sending ... " << std::endl;
+            MPI_Isend(&sendExtents[i*5],             5,   MPI_INT, dest, tags[0], MPI_COMM_WORLD, &sendMetaRq[sendCount]);
+            MPI_Isend(&imgData[sendingOffset], imgSize, MPI_FLOAT, dest, tags[1], MPI_COMM_WORLD, &sendImageRq[sendCount]);
+
+            //debug5 << "dest: " << dest <<"   sendExtents: " << sendExtents[i*5 +0] << ", " << sendExtents[i*5 +1] << "    " << sendExtents[i*5 +2] << ", " << sendExtents[i*5 +3] << std::endl << std::endl;
+
+            sendCount++;
+        }
+
+    //debug5 << "Async Recv" << std::endl;
+
+    //
+    // Create buffer for region
+    intermediateImageExtents[0] = fullImageExtents[0];  intermediateImageExtents[1] = fullImageExtents[1];
+    intermediateImageExtents[2] = myStartingHeight;     intermediateImageExtents[3] = myEndingHeight;
+
+    intermediateImage = new float[width * (myEndingHeight-myStartingHeight) * 4]();
+
+    int recvImageExtents[4];
+    float *recvImageData;
+
+    //
+    // Blend
+    int numBlends = 0;
+    int countBlend = 0;
+
+    intermediateImageBBox[0] = intermediateImageBBox[2] = 0;
+    intermediateImageBBox[1] = intermediateImageBBox[3] = 0;
+
+    if (inRegion)
+        {
+            for (int i=0; i<numRegions; i++)
+                {
+                    int index = i;
+
+                    //debug5 << "regionVector[" << i << "] " << regionVector[index] << std::endl;
+
+                    if (regionVector[index] == mpiRank)
+                        {
+                            int startingYExtents = myStartingHeight;
+                            int endingYExtents = myEndingHeight;
+
+                            if (startingYExtents < imgExtents[2])
+                                startingYExtents = imgExtents[2];
+
+                            if (endingYExtents > imgExtents[3])
+                                endingYExtents = imgExtents[3];
+
+
+                            bool hasData = true;
+                            if (endingYExtents - startingYExtents <= 0)
+                                {
+                                    hasData = false;
+                                    endingYExtents = startingYExtents = 0;
+                                }
+
+                            if (hasData == true)
+                                {
+                                    int extentsSectionRecv[4];
+                                    extentsSectionRecv[0] = imgExtents[0];
+                                    extentsSectionRecv[1] = imgExtents[1];
+                                    extentsSectionRecv[2] = startingYExtents;
+                                    extentsSectionRecv[3] = endingYExtents;
+
+                                    BlendFrontToBack(imgData, imgExtents, extentsSectionRecv, intermediateImage, intermediateImageExtents);
+
+                                    UpdateBoundingBox(intermediateImageBBox, extentsSectionRecv);
+                                    numBlends++;
+                                }
+                        }
+                    else
+                        {
+                            MPI_Wait(&recvMetaRq[countBlend], &recvMetaSt[countBlend]);
+
+                            for (int j=0; j<4; j++)
+                                recvImageExtents[j] = msgBuffer[index*5 + j];
+
+                            bool hasData =  false;
+                            if (recvImageExtents[1]-recvImageExtents[0] > 0 && recvImageExtents[3]-recvImageExtents[2] > 0)
+                                {
+                                    hasData = true;
+                                    MPI_Wait(&recvImageRq[countBlend], &recvImageSt[countBlend]);
+                                    recvImageData = &recvDataBuffer[index*sizeOneBuffer];
+                                }
+
+                            if (hasData)
+                                {
+
+                                    BlendFrontToBack(recvImageData, recvImageExtents, intermediateImage, intermediateImageExtents);
+
+                                    UpdateBoundingBox(intermediateImageBBox, recvImageExtents);
+                                    numBlends++;
+                                }
+
+                            countBlend++;
+                        }
+                }
+        }
+    else
+        compositingDone = true;
+
+    //debug5 << "PDS blending done" << std::endl;
+
+    msgBuffer.clear();
+
+
+    if (recvDataBuffer != NULL)
+        delete []recvDataBuffer;
+    recvDataBuffer = NULL;
+
+
+    if (numBlends == 0)
+        intermediateImageBBox[0]=intermediateImageBBox[1]=intermediateImageBBox[2]=intermediateImageBBox[3] = 0;
+
+    delete []recvMetaRq;
+    delete []recvImageRq;
+    delete []recvMetaSt;
+    delete []recvImageSt;
+
+    delete []sendMetaRq;
+    delete []sendImageRq;
+    delete []sendMetaSt;
+    delete []sendImageSt;
+
+    recvMetaRq = NULL;
+    recvImageRq = NULL;
+    recvMetaSt = NULL;
+    recvImageSt = NULL;
+
+    sendMetaRq = NULL;
+    sendImageRq = NULL;
+    sendMetaSt = NULL;
+    sendImageSt = NULL;
+#endif
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::findRegionsForPatch
+//
+//  Purpose:
+//      Needed by Parallel Direct Send to determine the regions a patch will overlap
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+int
+avtOSPRayImageCompositor::findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to)
+{
+    from = to = 0;
+    if (patchExtents[1]-patchExtents[0] <=0 || patchExtents[3]-patchExtents[2] <=0)
+        return 0;
+
+    if ( patchExtents[0] > screenProjectedExtents[1])
+        return 0;
+
+    if ( patchExtents[1] < screenProjectedExtents[0])
+        return 0;
+
+    if ( patchExtents[2] > screenProjectedExtents[3])
+        return 0;
+
+    if ( patchExtents[3] < screenProjectedExtents[2])
+        return 0;
+
+
+    // find from
+    for (int i=numRegions-1; i>=0; i--)
+        if ( patchExtents[2] >= getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
+            {
+                from = i;
+                break;
+            }
+    
+
+    // find to
+    for (int i=numRegions-1; i>=0; i--)
+        if ( patchExtents[3] > getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
+            {
+                to = i;
+                break;
+            }
+
+    return ( std::max( (to - from) + 1, 0) );
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::computeRegionExtents
+//
+//  Purpose:
+//      Compute extents for each region
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtOSPRayImageCompositor::computeRegionExtents(int numRanks, int height)
+{
+    //debug5 << "computeRegionExtents height " << height << std::endl;
+
+    int regionHeight = round((float)height/numRanks);
+    regularRegionSize = regionHeight;
+    maxRegionHeight = 0;
+    regionRankExtents.resize(numRanks*3);
+    for (int i=0; i<numRanks; i++)
+        {
+            int startRegionExtents, endRegionExtents, _currentRegionHeight;
+
+            startRegionExtents = CLAMP(regionHeight * i, 0, height);
+            endRegionExtents = CLAMP(regionHeight * i + regionHeight, 0, height);
+
+            if ( i == numRanks -1 )
+                if ( endRegionExtents < height )
+                    endRegionExtents = height;
+
+            _currentRegionHeight = CLAMP(endRegionExtents-startRegionExtents, 0, height);
+            maxRegionHeight = std::max(maxRegionHeight, _currentRegionHeight);
+
+            regionRankExtents[i*3+0] = startRegionExtents;
+            regionRankExtents[i*3+1] = endRegionExtents;
+            regionRankExtents[i*3+2] = _currentRegionHeight;
+
+            //debug5 << i << " : (start, end, region): " << startRegionExtents << ", " << endRegionExtents << ", " << _currentRegionHeight << std::endl;
+        }
+}
+
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::ParallelDirectSendManyPatches
+//
+//  Purpose:
+//      Parallel Direct Send rendering that can blend individual patches
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+int
+avtOSPRayImageCompositor::ParallelDirectSendManyPatches
+(const std::multimap<int, ospray::ImgData> &imgDataHashMap, 
+ const std::vector<ospray::ImgMetaData>    &imageMetaPatchVector, 
+ int numPatches,
+ int *region,
+ int numRegions, 
+ int tags[2],
+ int fullImageExtents[4])
+{
+    int myRegionHeight = 0;
+#ifdef PARALLEL
+
+    //
+    // Some Initializations
+    //
+    //debug5 << "Parallel Direct Send" << endl;
+    ospray::timestamp timingDetail;
+    for (int i=0; i<4; i++)
+        {
+            intermediateImageExtents[i] = 0;
+            intermediateImageBBox[i] = 0;
+        }
+
+
+    //
+    // Find My Position in Regions
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Find My position in Regions");
+    //---------------------------------------------------------------------//
+    compositingDone = false;
+    int myPositionInRegion = -1;
+    bool inRegion = true;
+    std::vector<int> regionVector(region, region+numRegions);
+    const std::vector<int>::const_iterator it = 
+        std::find(regionVector.begin(),
+                  regionVector.end(), 
+                  mpiRank);
+    if (it == regionVector.end())
+        {
+            inRegion = false;
+            //ospout << mpiRank << " ~ SHOULD NOT HAPPEN!!!!: Not found " 
+            //       << mpiRank <<  " !!!" << std::endl;
+        }
+    else 
+        {
+            myPositionInRegion = it - regionVector.begin();
+        }
+    int width =  fullImageExtents[1]-fullImageExtents[0];
+    int height = fullImageExtents[3]-fullImageExtents[2];
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Find My position in Regions");
+    //ospout << mpiRank << " ~ myPositionInRegion: " 
+    //       << myPositionInRegion << ", numRanks: " << mpiSize << std::endl;
+    //ospout << "width: " << width << ", height : " << height 
+    //       << " | fullImageExtents: "
+    //       << fullImageExtents[0] << ", " 
+    //       << fullImageExtents[1] << ", " 
+    //       << fullImageExtents[2] << ", "
+    //       << fullImageExtents[3] << std::endl;
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Compute Region Boundaries
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Compute Region Boundaries");
+    //---------------------------------------------------------------------//
+    computeRegionExtents(mpiSize, height); // ?
+    int myStartingHeight = getScreenRegionStart
+        (myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
+    int myEndingHeight   = getScreenRegionEnd
+        (myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
+    myRegionHeight = CLAMP((myEndingHeight-myStartingHeight), 0, height);
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Compute Region Boundaries");
+    // ospout << "myStartingHeight: " << myStartingHeight << ", "
+    //        << "myEndingHeight: "   << myEndingHeight   << ", "
+    //        << "myRegionHeight: "   << myRegionHeight   << std::endl;
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Size of one buffer
+    //
+    int sizeOneBuffer = getMaxRegionHeight() * width * 4;
+
+
+    //
+    // Determine How Many Patches and Pixel to Send to Each Region
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Determine How Many Patches and Pixel to Send "
+                              "to Each Region");
+    //---------------------------------------------------------------------//
+    std::vector<int> numPatchesPerRegion;
+    std::vector<int> areaPerRegion;
+    std::set<int> numOfRegions;
+    numPatchesPerRegion.resize(numRegions);
+    areaPerRegion.resize(numRegions);
+
+    // 2D array: extents for each partition
+    std::vector < std::vector<float> > extentsPerPartiton;
+    for (int i=0; i<numRegions; i++) { 
+        extentsPerPartiton.push_back(std::vector<float>()); 
+    }
+    // ospout << "Parallel Direct Send ~ numPatches " << numPatches << endl;
+    int totalSendBufferSize = 0;
+    for (int i=0; i<numPatches; i++)
+        {
+            int _patchExtents[4];
+            ospray::ImgMetaData temp;
+            temp = imageMetaPatchVector.at(i);
+            _patchExtents[0]=temp.screen_ll[0];   // minX
+            _patchExtents[1]=temp.screen_ur[0];   // maxX
+            _patchExtents[2]=temp.screen_ll[1];   // minY
+            _patchExtents[3]=temp.screen_ur[1];   // maxY
+            const std::multimap<int, ospray::ImgData>::const_iterator it = 
+                imgDataHashMap.find( i );
+            int from, to;
+            int numRegionIntescection = findRegionsForPatch(_patchExtents, 
+                                                            fullImageExtents,
+                                                            numRegions, 
+                                                            from, to);
+            if (numRegionIntescection <= 0) continue;
+            // ospout << "\nParallel Direct Send ~ patch " << i 
+            //        << "  from:" << from << "  to:" << to 
+            //        << "  numPatches: " << numPatches 
+            //        << "   _patchExtents: " 
+            //        << _patchExtents[0] << ", " 
+            //        << _patchExtents[1] << ", " 
+            //        << _patchExtents[2] << ", " 
+            //        << _patchExtents[3] 
+            //        << ", fullImageExtents[2]: " << fullImageExtents[2] 
+            //        << ", numRegions: " <<  numRegions 
+            //        << ", totalSendBufferSize: " << totalSendBufferSize << endl;
+            for (int j=from; j<=to; j++) numPatchesPerRegion[j]++;
+            for (int partition=from; partition<=to; partition++)
+                {
+                    int _extentsYStart = std::max( _patchExtents[2], getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) );
+                    int _extentsYEnd   = std::min( _patchExtents[3], getScreenRegionEnd(  partition, fullImageExtents[2], fullImageExtents[3]) );
+                    int _area = (_extentsYEnd-_extentsYStart)*(_patchExtents[1]-_patchExtents[0]);
+                    areaPerRegion[partition] += _area;
+                    totalSendBufferSize += _area;
+                    //debug5 << "_patchExtents[2]: " << _patchExtents[2] << ", region start: " << getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) <<  ", _extentsYStart: " << _extentsYStart<< endl;
+                    //debug5 << "_patchExtents[3]: " << _patchExtents[3] << ", region end: " << getScreenRegionEnd(partition, fullImageExtents[2], fullImageExtents[3]) << ", _extentsYEnd: " << _extentsYEnd << endl;
+                    //debug5 << "_area " << _area << endl;
+                    extentsPerPartiton[partition].push_back(i);
+                    extentsPerPartiton[partition].push_back(_patchExtents[0]);
+                    extentsPerPartiton[partition].push_back(_patchExtents[1]);
+                    extentsPerPartiton[partition].push_back(_extentsYStart);
+                    extentsPerPartiton[partition].push_back(_extentsYEnd);
+                    extentsPerPartiton[partition].push_back(temp.eye_z);
+                    numOfRegions.insert(partition);
+                }
+        }
+    totalSendBufferSize *= 4;                           // to account for RGBA
+    int numRegionsWithData = numOfRegions.size();
+    //debug5 << "\nParallel Direct Send ~ creating buffers" << endl;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Determine How Many Patches and Pixel to Send "
+                             "to Each Region");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Copy the Data for Each Region for Each Patch
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Copy the Data for Each Region for Each Patch");
+    //---------------------------------------------------------------------//
+    // Create buffer
+    float *sendDataBuffer = new float[totalSendBufferSize];     // contains all the data arranged by region
+    int   *sendDataBufferSize = new int[numRegionsWithData]();
+    int   *sendDataBufferOffsets = new int[numRegionsWithData]();
+    int   *sendBuffer = new int[numRegions*2]();
+    int regionWithDataCount = 0;
+    int numRegionsToSend = 0;
+    // Populate the buffer with data
+    int dataSendBufferOffset = 0;
+    for (int i=0; i<numRegions; i++)
+        {
+            int _dataSize = 0;
+            //ospout << "Region: " << i << "  size: " << extentsPerPartiton[i].size() << std::endl;
+            for (int j=0; j<extentsPerPartiton[i].size(); j+=6)
+                {
+                    int _patchID = extentsPerPartiton[i][j + 0];
+                    const std::multimap<int, ospray::ImgData>::const_iterator it = imgDataHashMap.find( _patchID );
+
+                    int _width = (extentsPerPartiton[i][j+2] - extentsPerPartiton[i][j+1]);
+                    int _bufferSize = _width * (extentsPerPartiton[i][j+4] - extentsPerPartiton[i][j+3]) * 4;
+                    int _dataOffset = extentsPerPartiton[i][j+3] - imageMetaPatchVector[_patchID].screen_ll[1];
+
+                    memcpy(&sendDataBuffer[dataSendBufferOffset], &(((*it).second).imagePatch[_width * _dataOffset * 4]), _bufferSize*sizeof(float) );
+
+                    dataSendBufferOffset += _bufferSize;
+                    _dataSize += _bufferSize;
+                }
+
+            if (_dataSize != 0){
+                sendDataBufferSize[regionWithDataCount] = _dataSize;
+
+                regionWithDataCount ++;
+                if (regionWithDataCount != numRegionsWithData)
+                    sendDataBufferOffsets[regionWithDataCount] = sendDataBufferOffsets[regionWithDataCount-1] + sendDataBufferSize[regionWithDataCount-1];
+
+                if (regionVector[i] != mpiRank)
+                    numRegionsToSend++;
+            }
+
+            sendBuffer[i*2+0] = numPatchesPerRegion[i];
+            sendBuffer[i*2+1] = areaPerRegion[i];
+
+            //ospout << "Region: " << i << "  numPatchesPerRegion: " << sendBuffer[i*2+0] << ", sendBuffer[i*2+1]: " << sendBuffer[i*2+1] << std::endl;
+        }
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                            "ParallelDirectSendManyPatches", timingDetail,
+                            "Copy the Data for Each Region for Each Patch");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Exchange Information about Size to Recv
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Exchange Information about Size to Recv");
+    //---------------------------------------------------------------------//
+    int *recvInfoATABuffer = new int[numRegions*2]();
+    MPI_Alltoall(sendBuffer, 2, MPI_INT,  recvInfoATABuffer, 2, MPI_INT, MPI_COMM_WORLD);
+    delete []sendBuffer;
+    sendBuffer = NULL;
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                            "ParallelDirectSendManyPatches", timingDetail,
+                            "Exchange Information about Size to Recv");
+    //ospout << "Parallel Direct Send ~ Exchange information about size to recv" << endl;
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Calculate Buffer Size Needed
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Calculate Buffer Size Needed");
+    //---------------------------------------------------------------------//
+    int infoBufferSize = 0;
+    int dataBufferSize = 0;
+    int numRegionsToRecvFrom = 0;
+    for (int i=0; i<numRegions; i++)
+        {
+            infoBufferSize += recvInfoATABuffer[i*2 + 0];   // number of patches per region
+            dataBufferSize += recvInfoATABuffer[i*2 + 1];   // area per region
+            //ospout << "From: " << i << ", #patches: " << recvInfoATABuffer[i*2 + 0] << ", " << recvInfoATABuffer[i*2 + 1] << std::endl;
+            if (i == mpiRank) continue;
+            if (recvInfoATABuffer[i*2 + 0] != 0)
+                numRegionsToRecvFrom++;
+        }
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                            "ParallelDirectSendManyPatches", timingDetail,
+                            "Calculate Buffer Size Needed");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Create Structure for MPI Async send/recv
+    //
+    // Send
+    MPI_Request *sendMetaRq = new MPI_Request[ numRegionsToSend ];
+    MPI_Status *sendMetaSt = new MPI_Status[ numRegionsToSend ];
+    MPI_Request *sendImageRq = new MPI_Request[ numRegionsToSend ];
+    MPI_Status *sendImageSt = new MPI_Status[ numRegionsToSend ];
+    // Recv
+    MPI_Request *recvMetaRq = NULL;
+    MPI_Status *recvMetaSt = NULL;
+    MPI_Request *recvImageRq = NULL;
+    MPI_Status *recvImageSt = NULL;
+    // counters
+    int recvInfoCount = 0;
+    int offsetMeta = 0;
+    int offsetData = 0;
+
+
+    //
+    // Create Recv Buffers
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Create Recv Buffers");
+    //---------------------------------------------------------------------//
+    float *recvInfoBuffer = new float[infoBufferSize*6];  // 6 - passing 6 parameters for each patch
+    float *recvDataBuffer =  new float[dataBufferSize*4]; // 4 - to account for RGBA
+
+    //debug5 << "infoBufferSize: " << infoBufferSize << ", dataBufferSize: " << dataBufferSize << std::endl;
+    if (myRegionHeight != 0)
+        {
+            // Recv
+            recvMetaRq = new MPI_Request[ numRegionsToRecvFrom ];
+            recvMetaSt = new MPI_Status[ numRegionsToRecvFrom ];
+
+            recvImageRq = new MPI_Request[ numRegionsToRecvFrom ];
+            recvImageSt = new MPI_Status[ numRegionsToRecvFrom ];
+
+            // Async Recv for info
+            for (int i=0; i<numRegions; i++)
+                {
+                    if (recvInfoATABuffer[i*2 + 0] == 0)
+                        continue;
+
+                    if ( regionVector[i] == mpiRank )
+                        continue;
+
+                    int src = regionVector[i];
+                    MPI_Irecv(&recvInfoBuffer[offsetMeta], recvInfoATABuffer[i*2 + 0]*6, MPI_FLOAT, src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvInfoCount] );
+                    MPI_Irecv(&recvDataBuffer[offsetData], recvInfoATABuffer[i*2 + 1]*4, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvInfoCount] );
+
+                    offsetMeta += recvInfoATABuffer[i*2 + 0]*6;
+                    offsetData += recvInfoATABuffer[i*2 + 1]*4;
+                    recvInfoCount++;
+                }
+            //ospout << "Async recv setup - numRegionsToRecvFrom: " << numRegionsToRecvFrom << "   recvInfoCount: " << recvInfoCount << endl;
+        }
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                            "ParallelDirectSendManyPatches", timingDetail,
+                            "Create Recv Buffers");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Async Send
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Async Send");
+    //---------------------------------------------------------------------//
+    int offset = 0;
+    int sendCount = 0;
+    int mpiSendCount = 0;
+    for (int i=0; i<numRegions; i++) {
+            if ( extentsPerPartiton[i].size() != 0 ) {
+                    if ( regionVector[i] == mpiRank )
+                        {
+                            memcpy( &recvInfoBuffer[offsetMeta], &extentsPerPartiton[i][0], extentsPerPartiton[i].size()*sizeof(float) );
+                            memcpy( &recvDataBuffer[offsetData], &sendDataBuffer[offset],   sendDataBufferSize[ sendCount ]*sizeof(float) );
+
+                            offset += sendDataBufferSize[sendCount];
+                            sendCount++;
+                        }
+                    else
+                        {
+                            MPI_Isend(&extentsPerPartiton[i][0],  extentsPerPartiton[i].size(),  MPI_FLOAT, region[i], tags[0], MPI_COMM_WORLD, &sendMetaRq[mpiSendCount]);
+                            MPI_Isend(&sendDataBuffer[offset], sendDataBufferSize[ sendCount ], MPI_FLOAT, region[i], tags[1], MPI_COMM_WORLD, &sendImageRq[mpiSendCount]);
+
+                            offset += sendDataBufferSize[sendCount];
+                            sendCount++;
+                            mpiSendCount++;
+                        }
+                }
+        }
+
+    //ospout << "Asyn send setup done ~ numRegionsToSend: " << numRegionsToSend << "  mpiSendCount: " << mpiSendCount << endl;
+
+    if (myRegionHeight != 0)
+        {
+            //debug5 << "MPI_Waitall ..." << std::endl;
+            MPI_Waitall(recvInfoCount, recvImageRq, recvImageSt);   // Means that we have reveived everything!
+
+            //debug5 << "MAPI_WAITALL done!" << std::endl;
+
+            if (recvInfoATABuffer != NULL)
+                delete []recvInfoATABuffer;
+            recvInfoATABuffer = NULL;
+
+            //debug5 << "Sorting..." << std::endl;
+
+            //
+            // Sort the data
+            std::multimap<float,int> patchData;
+            std::vector<int> patchOffset;
+            patchOffset.push_back(0);
+            for (int i=0; i<infoBufferSize; i++)
+                {
+                    patchData.insert( std::pair<float,int> (recvInfoBuffer[i*6 + 5],i));
+                    int _patchSize = (recvInfoBuffer[i*6 + 4]-recvInfoBuffer[i*6 + 3]) * (recvInfoBuffer[i*6 + 2]-recvInfoBuffer[i*6 + 1]) * 4;
+                    int _offset = patchOffset[i] + _patchSize;
+
+                    if (i != infoBufferSize-1)
+                        patchOffset.push_back(_offset);
+                }
+
+            //
+            // Create buffer for current region
+            intermediateImageBBox[0] = intermediateImageExtents[0] = fullImageExtents[0];
+            intermediateImageBBox[1] = intermediateImageExtents[1] = fullImageExtents[1];
+            intermediateImageBBox[2] = intermediateImageExtents[2] = myStartingHeight;
+            intermediateImageBBox[3] = intermediateImageExtents[3] = myEndingHeight;
+            intermediateImage = new float[width * (myEndingHeight - myStartingHeight) * 4]();
+            //debug5 << "intermediate image size " << width << ", " << (myEndingHeight - myStartingHeight) << std::endl;
+
+            //
+            // Blend
+            int numBlends = 0;
+            for (std::multimap<float,int>::iterator it=patchData.begin(); it!=patchData.end(); ++it)
+                {
+                    int _id = (*it).second;
+                    int _extents[4];
+                    _extents[0] = recvInfoBuffer[_id*6 + 1];
+                    _extents[1] = recvInfoBuffer[_id*6 + 2];
+                    _extents[2] = recvInfoBuffer[_id*6 + 3];
+                    _extents[3] = recvInfoBuffer[_id*6 + 4];
+                    BlendFrontToBack(&recvDataBuffer[patchOffset[_id]], _extents, _extents, intermediateImage, intermediateImageExtents);
+                    numBlends++;
+                }
+
+            if (numBlends == 0) {
+                intermediateImageBBox[0]=intermediateImageBBox[1]=intermediateImageBBox[2]=intermediateImageBBox[3] = 0;
+            }
+        }
+
+    MPI_Waitall(numRegionsToSend, sendImageRq, sendImageSt);   // Means that we have sent everything!
+
+    if (myRegionHeight == 0) compositingDone = true;
+
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Async Send");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Cleanup
+    //
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStart("avtOSPRayImageCompositor", 
+                              "ParallelDirectSendManyPatches", timingDetail,
+                              "Cleanup");
+    //---------------------------------------------------------------------//
+    if (sendDataBuffer != NULL)
+        delete []sendDataBuffer;
+    sendDataBuffer = NULL;
+
+    if (sendDataBufferSize != NULL)
+        delete []sendDataBufferSize;
+    sendDataBufferSize = NULL;
+
+    if (sendDataBufferOffsets != NULL)
+        delete []sendDataBufferOffsets;
+    sendDataBufferOffsets = NULL;
+
+
+    if (sendMetaRq != NULL)
+        delete []sendMetaRq;
+
+    if (sendImageRq != NULL)
+        delete []sendImageRq;
+
+    if (sendMetaSt != NULL)
+        delete []sendMetaSt;
+
+    if (sendImageSt != NULL)
+        delete []sendImageSt;
+
+    sendMetaRq = NULL;
+    sendImageRq = NULL;
+    sendMetaSt = NULL;
+    sendImageSt = NULL;
+
+    if (myRegionHeight != 0)
+        {
+            if (recvInfoBuffer != NULL)
+                delete []recvInfoBuffer;
+            recvInfoBuffer = NULL;
+
+            if (recvDataBuffer != NULL)
+                delete []recvDataBuffer;
+            recvDataBuffer = NULL;
+
+            if (recvMetaRq != NULL)
+                delete []recvMetaRq;
+
+            if (recvMetaSt != NULL)
+                delete []recvMetaSt;
+
+            if (recvImageRq != NULL)
+                delete []recvImageRq;
+
+            if (recvImageSt != NULL)
+                delete []recvImageSt;
+
+            recvMetaRq = NULL;
+            recvImageRq = NULL;
+            recvMetaSt = NULL;
+            recvImageSt = NULL;
+        }
+    //---------------------------------------------------------------------//
+    ospray::CheckSectionStop("avtOSPRayImageCompositor", 
+                             "ParallelDirectSendManyPatches", timingDetail,
+                             "Cleanup");
+    //ospout << "All Parallel Direct Send is Done" << std::endl;
+    //---------------------------------------------------------------------//
+#endif
+    return myRegionHeight;
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::gatherImages
+//
+//  Purpose:
+//      Gather images from Parallel Direct Send
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtOSPRayImageCompositor::gatherImages(int regionGather[], int totalNumRanks, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight)
+{
+#ifdef PARALLEL
+    //debug5 << "gatherImages starting... totalNumRanks: " << totalNumRanks << ", compositingDone: " << compositingDone
+    //     << ", imgExtents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
+
+    for (int i=0; i<4; i++)
+        finalImageExtents[i] = finalBB[i] = 0;
+
+    if (mpiRank == 0)
+        {
+            int width =  fullImageExtents[1]-fullImageExtents[0];
+            int height = fullImageExtents[3]-fullImageExtents[2];
+
+            //debug5 << "Gather Images at 0, final size: " << fullImageExtents[1]-fullImageExtents[0] << " x " << fullImageExtents[3]-fullImageExtents[2] << std::endl;
+
+            //
+            // Receive at root/display node!
+            finalImage = new float[width*height*4];
+            finalImageExtents[0] = fullImageExtents[0];
+            finalImageExtents[1] = fullImageExtents[1];
+            finalImageExtents[2] = fullImageExtents[2];
+            finalImageExtents[3] = fullImageExtents[3];
+
+            int numRegionsWithData = 0;
+            int numToRecv = 0;
+            for (int i=0; i<totalNumRanks; i++)
+                {
+                    if (getRegionSize(i) != 0)
+                        numRegionsWithData++;
+                }
+            numToRecv = numRegionsWithData;
+
+            // remove itself from the recv
+            if (getRegionSize(mpiRank) != 0) 
+                numToRecv--;
+
+
+            //
+            // Create buffers for async reciving
+            MPI_Request *recvImageRq = new MPI_Request[ numToRecv ];
+            MPI_Status  *recvImageSt = new MPI_Status[ numToRecv ];
+
+            int lastBufferSize    = getRegionSize(totalNumRanks-1) * width * 4;
+            int regularBufferSize = regularRegionSize * width * 4;
+
+            //debug5 << "numToRecv: " << numToRecv << ", numRegionsWithData: " << numRegionsWithData << std::endl;
+            //debug5 << "regularBufferSize: " << regularBufferSize << ", lastBufferSize: " << lastBufferSize << std::endl;
+
+            // Async Recv
+            int recvCount=0;
+            for (int i=0; i<numRegionsWithData; i++)
+                {
+                    int src = regionGather[i];
+
+                    if (src == mpiRank)
+                        continue;
+
+                    if (i == totalNumRanks-1)
+                        {
+                            if (lastBufferSize != 0)
+                                {
+                                    MPI_Irecv(&finalImage[i*regularBufferSize], lastBufferSize,     MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+                                }
+                        }
+                    else
+                        MPI_Irecv(&finalImage[i*regularBufferSize], regularBufferSize,  MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+                        
+
+                    //debug5 << i << " ~ recvCount: " << recvCount << std::endl;
+                    recvCount++;
+                }
+
+            if (compositingDone == false)   // If root has data for the final image
+                PlaceImage(inputImg, imgExtents, finalImage, finalImageExtents);
+
+            MPI_Waitall(numToRecv, recvImageRq, recvImageSt);
+            compositingDone = true;
+
+            delete []recvImageRq;
+            recvImageRq = NULL;
+            delete []recvImageSt;
+            recvImageSt = NULL;
+        }
+    else
+        {
+            if (compositingDone == false)   
+                {
+                    int imgSize = (imgExtents[1]-imgExtents[0]) * (imgExtents[3]-imgExtents[2]) * 4;
+                    //debug5 << "imgSize: " << imgSize << std::endl;
+
+                    MPI_Send(inputImg, imgSize, MPI_FLOAT, 0, tag, MPI_COMM_WORLD);
+                    compositingDone = true;
+                }
+        }
+
+#endif
+}
+
+// ***************************************************************************
+//  Method: avtOSPRayImageCompositor::getcompositedImage
+//
+//  Purpose:
+//      Returns the whole image if needed
+//
+//  Programmer: Pascal Grosset
+//  Creation: July 2013
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtOSPRayImageCompositor::getcompositedImage
+(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage)
+{
+    for (int i=0; i< imgBufferHeight; i++) {
+        for (int j=0; j<imgBufferWidth; j++) {
+            int bufferIndex = (imgBufferWidth*4*i) + (j*4);
+            int wholeImgIndex = (imgBufferWidth*3*i) + (j*3);
+            wholeImage[wholeImgIndex+0] = (finalImage[bufferIndex+0] ) * 255;
+            wholeImage[wholeImgIndex+1] = (finalImage[bufferIndex+1] ) * 255;
+            wholeImage[wholeImgIndex+2] = (finalImage[bufferIndex+2] ) * 255;
+        }
+    }
+    if (finalImage != NULL)
+        { delete []finalImage; }
+    finalImage = NULL;
+}
diff --git a/avt/Filters/avtOSPRayImageCompositor.h b/avt/Filters/avtOSPRayImageCompositor.h
new file mode 100644
index 0000000000..c1ca917e25
--- /dev/null
+++ b/avt/Filters/avtOSPRayImageCompositor.h
@@ -0,0 +1,267 @@
+/*****************************************************************************
+ *
+ * Copyright (c) 2000 - 2017, Lawrence Livermore National Security, LLC
+ * Produced at the Lawrence Livermore National Laboratory
+ * LLNL-CODE-442911
+ * All rights reserved.
+ *
+ * This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+ * full copyright notice is contained in the file COPYRIGHT located at the root
+ * of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+ *
+ * Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  - Redistributions of  source code must  retain the above  copyright notice,
+ *    this list of conditions and the disclaimer below.
+ *  - Redistributions in binary form must reproduce the above copyright notice,
+ *    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+ *    documentation and/or other materials provided with the distribution.
+ *  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+ * ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+ * LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+ * DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+ * LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+ * OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ *****************************************************************************/
+
+// *************************************************************************//
+//                          avtOSPRayImageCompositor.h                       //
+// *************************************************************************//
+
+#ifndef AVT_OSPRAY_IMG_COMMUNICATOR_H
+#define AVT_OSPRAY_IMG_COMMUNICATOR_H
+
+#include <avtOSPRayCommon.h>
+
+#include <string>
+#include <vector>
+#include <map>
+#include <algorithm>
+#include <utility>
+
+#ifdef PARALLEL
+# include <mpi.h>
+#endif
+
+// ***************************************************************************
+//  Class: avtOSPRayImageCompositor
+//
+//  Purpose:
+//      Does the composition for Ray casting: OSPRay
+//
+//  Programmer: Pascal Grosset
+//  Creation:   Spetember 20, 2013
+//
+// ***************************************************************************
+
+class avtOSPRayIC_Implementation
+{
+ public:
+    avtOSPRayIC_Implementation(int mpiSize, int mpiRank) {};
+    virtual ~avtOSPRayIC_Implementation() {};
+    virtual void Init (int W, int H) = 0;
+    virtual void SetTile (const float* data, 
+                          const int* extents, 
+                          const float& depth) = 0;
+    virtual void Composite (float*& output) = 0;
+};
+
+// ***************************************************************************
+//  Class: avtOSPRayImageCompositor
+//
+//  Purpose:
+//      Does the composition for Ray casting: SLIVR
+//
+//  Programmer: Pascal Grosset
+//  Creation:   Spetember 20, 2013
+//
+// ***************************************************************************
+
+class avtOSPRayImageCompositor
+{ 
+ public:    
+    avtOSPRayImageCompositor();
+    ~avtOSPRayImageCompositor();
+
+    virtual const char *GetType(void)
+    { return "avtOSPRayImageCompositor"; }
+    virtual const char *GetDescription(void) 
+    { return "Doing compositing for ray casting OSPRay"; }
+
+    float* GetFinalImageBuffer () { return finalImage; }
+    int GetParSize ()             { return mpiSize;   }
+    int GetParRank ()             { return mpiRank;   }
+
+    // Those functions can be static
+    static void BlendFrontToBack(const float *, const int srcExtents[4],
+                                 const int blendExtents[4], 
+                                 float *&, const int dstExtents[4]);
+    static void BlendBackToFront(const float *, const int srcExtents[4], 
+                                 const int blendExtents[4], 
+                                 float *&, const int dstExtents[4]);
+    static void BlendFrontToBack(const float *, const int srcExtents[4], 
+                                 float *&, const int dstExtents[4]);
+    static void BlendBackToFront(const float *, const int srcExtents[4], 
+                                 float *&, const int dstExtents[4]);
+    void Barrier();
+
+ private:
+    //----------------------------------------------------------------------//
+    static void ColorImage(float *&, const int, const int, 
+                           const float color[4]);
+    static void PlaceImage(const float *, const int srcExtents[4], 
+                           float *&, const int dstExtents[4]);
+    static void BlendWithBackground(float *&, const int extents[4],
+                                    const float bgColor[4]);
+ public:
+    //----------------------------------------------------------------------//
+    // Different Algorithms
+    //----------------------------------------------------------------------//
+
+    //----------------------------------------------------------------------//
+    // IceT: (export OSPRAY_USE_ICET=1)
+    //   Use IceT for compositing. This method only supports the case where 
+    //   each rank produces only one tile.
+    // Algorithms:
+    //   Reduce
+    //   Binary Swap
+    //    
+    //----------------------------------------------------------------------//
+    bool IceTValid();
+    void IceTInit(int W, int H);
+    void IceTSetTile(const float*, const int*, const float&);
+    void IceTComposite(float*&);
+
+    //----------------------------------------------------------------------//
+    // OneNode
+    //   There is only one VisIt process
+    //----------------------------------------------------------------------//
+    bool OneNodeValid();
+    void OneNodeInit(int W, int H);
+    void OneNodeSetTile(const float*, const int*, const float&);
+    void OneNodeComposite(float*&);
+
+    //----------------------------------------------------------------------//
+    // Serial
+    //----------------------------------------------------------------------//
+    //bool SerialValid();
+    //void SerialInit(int W, int H);
+    //void SerialSetTile(const float*, const int*, const float&);
+    //void SerialComposite(float*&);
+
+ private:
+    // Basic MPI information
+    int mpiSize; // total number of processes (# of ranks)
+    int mpiRank; // my rank id
+    // TODO this communicator shouldnt be in charge of this variable
+    // Final image is here
+    float *finalImage;
+    // Image Compisition Implementation
+    avtOSPRayIC_Implementation* compositor;
+
+
+
+
+
+
+
+
+
+
+
+
+
+    // CLEAN UP BELOW
+ private:
+    //----------------------------------------------------------------------//
+    void UpdateBoundingBox(int currentBoundingBox[4], 
+                           const int imageExtents[4]);
+    //----------------------------------------------------------------------//
+
+    //----------------------------------------------------------------------//
+    // Both currently unused but good for simple testing
+    //----------------------------------------------------------------------//
+ private:
+    void GatherDepthAtRoot(const int, const float *, int &, int *&, float *&);
+ public:
+    void SerialDirectSend
+        (int, float*, int*, float*, float bgColor[4], int, int);
+
+    //----------------------------------------------------------------------//
+    // Parallel Direct Send
+    //----------------------------------------------------------------------//
+ public:
+    void RegionAllocation(int *&);
+    int  ParallelDirectSendManyPatches
+        (const std::multimap<int, ospray::ImgData>&,
+         const std::vector<ospray::ImgMetaData>&,
+         int, int*, int, int tags[2], int fullImageExtents[4]);
+
+ private:
+    ///--------------------------------------
+    // flags for patch
+    int totalPatches;
+    bool compositingDone;
+
+    // image sizing for compositing
+    int maxRegionHeight;
+    int regularRegionSize;
+    std::vector<int> regionRankExtents;
+
+    //----------------------------------------------------------------------//
+      
+    void computeRegionExtents(int numRanks, int height);
+        
+    int getRegularRegionSize(){ return regularRegionSize; } 
+    int getRegionStart(int region){ return regionRankExtents[region*3+0]; }
+    int getRegionEnd(int region){ return regionRankExtents[region*3+1]; }
+    int getRegionSize(int region){ return regionRankExtents[region*3+2]; }
+    int getMaxRegionHeight(){ return maxRegionHeight; }
+        
+    int getScreenRegionStart(int region, int screenImgMinY, int screenImgMaxY)
+    {
+        return CLAMP(getRegionStart(region)+screenImgMinY, 
+                     screenImgMinY, screenImgMaxY); 
+    }
+    int getScreenRegionEnd(int region, int screenImgMinY, int screenImgMaxY)
+    {
+        return CLAMP(getRegionEnd(region)+screenImgMinY, 
+                     screenImgMinY, screenImgMaxY); 
+    }
+
+ public:
+    //----------------------------------------------------------------------//
+
+    void getcompositedImage(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage);  // get the final composited image
+
+
+    int findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to);
+
+
+    void parallelDirectSend(float *imgData, int imgExtents[4], int region[], int numRegions, int tags[2], int fullImageExtents[4]);     
+    void gatherImages(int regionGather[], int numToRecv, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight);
+
+ public:
+    // TODO: Remove all public fields
+    int finalImageExtents[4];
+    int finalBB[4];
+    float *intermediateImage; // Intermediate image, e.g. in parallel direct send
+    int intermediateImageExtents[4];
+    int intermediateImageBBox[4];
+
+
+};
+
+#endif//AVT_OSPRAY_IMG_COMMUNICATOR_H
diff --git a/avt/Filters/avtOSPRayRayTracer.C b/avt/Filters/avtOSPRayRayTracer.C
new file mode 100644
index 0000000000..d82ed06725
--- /dev/null
+++ b/avt/Filters/avtOSPRayRayTracer.C
@@ -0,0 +1,781 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                       avtOSPRayRayTracer.C                                //
+// ************************************************************************* //
+
+#include <avtOSPRayRayTracer.h>
+
+#include <visit-config.h>
+
+#include <avtDataset.h>
+#include <avtImage.h>
+#include <avtParallel.h>
+#include <avtRayCompositer.h>
+#include <avtOSPRaySamplePointExtractor.h>
+#include <avtWorldSpaceToImageSpaceTransform.h>
+
+#include <DebugStream.h>
+#include <ImproperUseException.h>
+#include <TimingsManager.h>
+#include <StackTimer.h>
+
+#include <vtkImageData.h>
+#include <vtkMatrix4x4.h>
+
+#include <vector>
+
+using     std::vector;
+
+bool OSPRaySortImgMetaDataByDepth(ospray::ImgMetaData const& before, 
+                                  ospray::ImgMetaData const& after)
+{ return before.avg_z > after.avg_z; }
+bool OSPRaySortImgMetaDataByEyeSpaceDepth(ospray::ImgMetaData const& before,
+                                          ospray::ImgMetaData const& after)
+{ return before.eye_z > after.eye_z; }
+
+// ****************************************************************************
+//  Method: avtOSPRayRayTracer constructor
+//
+//  Programmer: Hank Childs
+//  Creation:   November 27, 2000
+//
+//  Modifications:
+//    Brad Whitlock, Wed Dec 5 11:19:29 PDT 2001
+//    Added gradient backgrounds.
+//
+//    Hank Childs, Mon Jan 16 11:11:47 PST 2006
+//    Added kernel based sampling.
+//
+//    Pascal Grosset, Fri Sep 20 2013
+//    Added ray casting slivr & trilinear interpolation
+//
+//    Qi WU, Wed Jun 20 2018
+//    Added support for raycasting ospray
+//
+// ****************************************************************************
+
+avtOSPRayRayTracer::avtOSPRayRayTracer() : avtRayTracerBase()
+{
+    gradientShadingEnabled = false;
+    shadowsEnabled = false;
+    useGridAccelerator = false;
+    preIntegration = false;
+    singleShade = false;
+    oneSidedLighting = false;
+    aoTransparencyEnabled = false;
+    spp = 1;
+    aoSamples = 0;
+    aoDistance = 1e6;
+    samplingRate = 3.0;
+    minContribution = 0.001;
+    
+    materialProperties[0] = 0.4;
+    materialProperties[1] = 0.75;
+    materialProperties[2] = 0.0;
+    materialProperties[3] = 15.0;
+
+    ospray_core = NULL;
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRayRayTracer destructor
+//
+//  Purpose:
+//      Defines the destructor.  Note: this should not be inlined in the header
+//      because it causes problems for certain compilers.
+//
+//  Programmer: Hank Childs
+//  Creation:   February 5, 2004
+//
+// ****************************************************************************
+
+avtOSPRayRayTracer::~avtOSPRayRayTracer()
+{
+    ;
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRayRayTracer::Execute
+//
+//  Purpose:
+//      Executes the ray tracer.  
+//      This means:
+//      - Put the input mesh through a transform so it is in camera space.
+//      - Get the sample points.
+//      - Communicate the sample points (parallel only).
+//      - Composite the sample points along rays.
+//      - Communicate the pixels from each ray (parallel only).
+//      - Output the image.
+//
+//  Programmer: Hank Childs
+//  Creation:   November 27, 2000
+//
+//  Modifications:
+//
+//    Hank Childs, Fri Jan 26 17:00:07 PST 2001
+//    Added support for parallel ray tracing.
+//
+//    Hank Childs, Sat Jan 27 15:09:34 PST 2001
+//    Added support for sending cells when doing parallel ray tracing.
+//
+//    Hank Childs, Sun Mar  4 21:50:36 PST 2001
+//    Added image partition to aid parallel modules in minimizing
+//    communication by dynamically assigning the partitions.
+//
+//    Eric Brugger, Mon Nov  5 13:47:19 PST 2001
+//    Modified to always compile the timing code.
+//
+//    Brad Whitlock, Wed Dec 5 10:57:56 PDT 2001
+//    Added code to set the gradient background colors, background mode in
+//    the ray compositer.
+//
+//    Kathleen Bonnell, Tue Apr 30 12:34:54 PDT 2002  
+//    Use new version of CopyTo. 
+//
+//    Hank Childs, Fri Sep 13 12:04:04 PDT 2002
+//    Reverse arguments for CopyTo (we weren't sending in the input correctly).
+//
+//    Hank Childs, Fri Nov 19 13:47:20 PST 2004
+//    Added option to have sampling of rectilinear grids done efficiently
+//    by sample point extractor by not converting grid into image space.
+//
+//    Hank Childs, Thu Dec  2 09:26:28 PST 2004
+//    No longer tighten clipping planes ['5699].
+//
+//    Hank Childs, Thu Dec  9 17:15:44 PST 2004
+//    Cast rays in tiles for big images ['1948].
+//
+//    Hank Childs, Sun Mar 13 11:16:20 PST 2005
+//    Fix memory leak.
+//
+//    Hank Childs, Tue Mar 29 16:19:19 PST 2005
+//    If the image is large, force divisions of 512x512, even if we should
+//    theoretically have enough memory to cover it.
+//
+//    Hank Childs, Mon Jan 16 11:11:47 PST 2006
+//    Add support for kernel based sampling.
+//
+//    Hank Childs, Thu May 31 22:36:32 PDT 2007
+//    Remove code for setting number of variables for processors that don't
+//    have data, since that is now handled by the avtSamplePointExtractor's
+//    base class.
+//
+//    Hank Childs, Wed Dec 24 09:46:56 PST 2008
+//    Add code to convert the z-buffer of the background to the w-buffer.
+//    This is being done so the samples lie more evenly.
+//
+//    Hank Childs, Wed Dec 24 14:16:04 PST 2008
+//    Automatically tighten the clipping planes so we utilize our samples
+//    more effectively.
+//
+//    Hank Childs, Fri Jan  9 14:17:10 PST 2009
+//    Have each ray be randomly jittered forward or backwards along its
+//    direction.
+//
+//    Hank Childs, Tue Jan 13 14:26:44 PST 2009
+//    Fix oversight where parallel volume rendering was not being jittered.
+//
+//    Hank Childs, Sun Jan 24 15:35:50 PST 2010
+//    Automatically use the kernel based resampling for point data.
+//
+//    Pascal Grosset & Manasa Prasad, Fri Aug 20 2016
+//    Add the ray casting OSPRay code
+//
+//    Qi WU, Tue Aug 8 2017
+//    Fix camera matrices multiplication order for ray casting OSPRay
+//    Also fixed panning for ray casting OSPRay
+//
+//    Qi WU, Wed Jun 20 2018
+//    Added support for raycasting ospray
+//
+// ****************************************************************************
+
+void
+avtOSPRayRayTracer::Execute()
+{
+    //======================================================================//
+    // Initialization and Debug
+    //======================================================================//
+    // check memory in the beginning
+    ospout << "[avrRayTracer] entering execute" << std::endl;
+    ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute", "ospout");    
+
+    // initialize current time
+    StackTimer t0("Ray Tracing");
+
+    //======================================================================//
+    // Start of original pipeline
+    //======================================================================//
+    bool parallelOn = (imgComm.GetParSize() == 1) ? false : true;
+    /* dont need rayfoo for ospray */
+    /*
+    if (rayfoo == NULL)
+    {
+        debug1 << "Never set ray function for ray tracer." << endl;
+        EXCEPTION0(ImproperUseException);
+    }
+    */
+
+    //
+    // First we need to transform all of domains into camera space.
+    //
+    double aspect = 1.;
+    if (screen[1] > 0)
+    {
+        aspect = (double)screen[0] / (double)screen[1];
+    }
+
+    double scale[3] = {1,1,1};
+    vtkMatrix4x4 *transform = vtkMatrix4x4::New();
+    avtWorldSpaceToImageSpaceTransform::CalculateTransform(view, transform,
+                                                           scale, aspect);
+    double newNearPlane, newFarPlane, oldNearPlane, oldFarPlane;
+    TightenClippingPlanes(view, transform, newNearPlane, newFarPlane);
+    oldNearPlane = view.nearPlane;  oldFarPlane  = view.farPlane;
+    view.nearPlane = newNearPlane;  view.farPlane  = newFarPlane;
+    transform->Delete();
+
+    avtWorldSpaceToImageSpaceTransform trans(view, aspect);
+    trans.SetInput(GetInput());
+    trans.SetPassThruRectilinearGrids(true);
+
+    //======================================================================//
+    // Compute Projection
+    //======================================================================//
+    vtkImageData  *opaqueImageVTK =
+        opaqueImage->GetImage().GetImageVTK();
+    unsigned char *opaqueImageData =
+        (unsigned char *)opaqueImageVTK->GetScalarPointer(0, 0, 0);;
+    float         *opaqueImageZB =
+        opaqueImage->GetImage().GetZBuffer();
+    std::vector<float> opaqueImageDepth(screen[0] * screen[1], oldFarPlane);
+    vtkMatrix4x4  *model_to_screen_transform = vtkMatrix4x4::New();
+    vtkMatrix4x4  *screen_to_model_transform = vtkMatrix4x4::New();
+    vtkMatrix4x4  *screen_to_camera_transform = vtkMatrix4x4::New();
+    int            renderingExtents[4];
+    double         sceneSize[2];
+    double         dbounds[6];  // Extents of the volume in world coordinates
+    {
+        GetSpatialExtents(dbounds);
+        ospray::ComputeProjections(view, aspect, oldNearPlane, oldFarPlane,
+                                   scale, dbounds, screen,
+                                   model_to_screen_transform, 
+                                   screen_to_model_transform, 
+                                   screen_to_camera_transform,
+                                   sceneSize, renderingExtents);
+        for (int y = 0; y < screen[1]; ++y) {
+            for (int x = 0; x < screen[0]; ++x) {
+                int index = x + y * screen[0];
+                int    screenCoord[2] = {x, y};
+                double screenDepth = opaqueImageZB[index] * 2 - 1;
+                double worldCoord[3];
+                ospray::ProjectScreenToCamera
+                    (screenCoord, screenDepth, 
+                     screen[0], screen[1],
+                     screen_to_camera_transform, 
+                     worldCoord);
+                opaqueImageDepth[index] = -worldCoord[2];
+            }
+        }
+        // Debug
+        ospout << "[avtOSPRayRayTracer] avtViewInfo settings: " << endl
+               << "\tcamera: "
+               << view.camera[0] << ", " 
+               << view.camera[1] << ", " 
+               << view.camera[2] << std::endl
+               << "\tfocus: "
+               << view.focus[0] << ", " 
+               << view.focus[1] << ", " 
+               << view.focus[2] << std::endl
+               << "\tviewUp: "    
+               << view.viewUp[0] << ", " 
+               << view.viewUp[1] << ", " 
+               << view.viewUp[2] << std::endl
+               << "\tviewAngle: " << view.viewAngle << std::endl
+               << "\teyeAngle:  " << view.eyeAngle  << std::endl
+               << "\tparallelScale: " << view.parallelScale  << std::endl
+               << "\tsetScale: " << view.setScale << std::endl
+               << "\tnearPlane: " << view.nearPlane << std::endl
+               << "\tfarPlane:  " << view.farPlane  << std::endl
+               << "\timagePan[0]: " << view.imagePan[0] << std::endl 
+               << "\timagePan[1]: " << view.imagePan[1] << std::endl
+               << "\timageZoom:   " << view.imageZoom   << std::endl
+               << "\torthographic: " << view.orthographic << std::endl
+               << "\tshear[0]: " << view.shear[0] << std::endl
+               << "\tshear[1]: " << view.shear[1] << std::endl
+               << "\tshear[2]: " << view.shear[2] << std::endl;
+        ospout << "[avtOSPRayRayTracer] other settings " << std::endl
+               << "\toldNearPlane: " << oldNearPlane
+               << std::endl
+               << "\toldFarPlane:  " << oldFarPlane
+               << std::endl
+               << "\taspect: " << aspect << std::endl
+               << "\tscale:    " 
+               << scale[0] << " " 
+               << scale[1] << " " 
+               << scale[2] << " " << std::endl;
+        ospout << "[avtOSPRayRayTracer] sceneSize: " 
+               << sceneSize[0] << " " 
+               << sceneSize[1] << std::endl;
+        ospout << "[avtOSPRayRayTracer] screen: " 
+               << screen[0] << " " << screen[1] << std::endl;
+        ospout << "[avtOSPRayRayTracer] data bounds: "
+               << dbounds[0] << " " << dbounds[1] << std::endl
+               << "               data bounds  "
+               << dbounds[2] << " " << dbounds[3] << std::endl
+               << "               data bounds  "
+               << dbounds[4] << " " << dbounds[5] << std::endl;
+        ospout << "[avtOSPRayRayTracer] rendering extents: " 
+               << renderingExtents[0] << " " << renderingExtents[1]
+               << std::endl
+               << "               rendering extents: "
+               << renderingExtents[2] << " " << renderingExtents[3]
+               << std::endl;
+        ospout << "[avtOSPRayRayTracer] full image size: " 
+               << renderingExtents[1] - renderingExtents[0] << " "
+               << renderingExtents[3] - renderingExtents[2] << std::endl;
+        ospout << "[avtOSPRayRayTracer] model_to_screen_transform: " 
+               << *model_to_screen_transform << std::endl;
+        ospout << "[avtOSPRayRayTracer] screen_to_model_transform: " 
+               << *screen_to_model_transform << std::endl;
+        ospout << "[avtOSPRayRayTracer] screen_to_camera_transform: " 
+               << *screen_to_camera_transform << std::endl;
+
+    }
+    
+    //===================================================================//
+    // ospray stuffs
+    //===================================================================//
+    ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute before ospray", 
+                            "ospout");    
+
+    ospray::InitOSP(); // initialize ospray
+    ospray::Context* ospray = (ospray::Context*)ospray_core;
+
+    ospray->SetVariableName(activeVariable);    
+    ospray->SetBackgroundBuffer(opaqueImageData, opaqueImageDepth.data(),
+                                screen);
+
+    ospray->SetAdaptiveSampling(false);
+    ospray->SetAoSamples(aoSamples); 
+    ospray->SetSpp(spp);
+    ospray->SetOneSidedLighting(oneSidedLighting);
+    ospray->SetShadowsEnabled(shadowsEnabled);
+    ospray->SetAoTransparencyEnabled(aoTransparencyEnabled);
+    ospray->SetUseGridAccelerator(useGridAccelerator);
+    ospray->SetPreIntegration(preIntegration);
+    ospray->SetSingleShade(singleShade);
+    ospray->SetGradientShadingEnabled(gradientShadingEnabled);
+    ospray->SetSamplingRate(samplingRate);
+    ospray->SetScaleAndDataBounds(scale, dbounds);
+    ospray->SetSpecular(materialProperties[2], materialProperties[3]);    
+    
+    ospout << "[avrRayTracer] make ospray camera" << std::endl;
+    ospray::Camera cam(ospray->camera);
+    cam.Set(view.orthographic, view.camera, view.focus, view.viewUp,
+            view.viewAngle, view.imagePan, view.imageZoom, oldNearPlane,
+            sceneSize, screen, renderingExtents);
+
+    ospout << "[avrRayTracer] make ospray transfer function" << std::endl;
+    ospray::TransferFunction tfn(ospray->tfn);
+    tfn.Set(transferFn1D->GetTableFloat(),
+            transferFn1D->GetNumberOfTableEntries(),
+            transferFn1D->GetMin(),
+            transferFn1D->GetMax());
+    
+    ospout << "[avrRayTracer] make ospray renderer" << std::endl;
+    ospray::Renderer ren(ospray->renderer);
+    ren.Init();
+    ren.ResetLights();
+    double light_scale = gradientShadingEnabled ? 0.9 : 1.0;
+    ren.AddLight().Set(true,  materialProperties[0], light_scale); // ambient 
+    ren.AddLight().Set(false, materialProperties[1], light_scale,
+                       viewDirection);
+    ren.AddLight().Set(false, 1.5, light_scale,
+                       viewDirection); 
+    for (int i = 0; i < 8; ++i) { // in VisIt there are only 8 lights
+        const LightAttributes& la = lightList.GetLight(i);
+        if (la.GetEnabledFlag()) {
+            if (la.GetType() == LightAttributes::Ambient) {
+                ren.AddLight().Set(true, la.GetBrightness(),
+                                   (double)la.GetColor().Red() / 255.0,
+                                   (double)la.GetColor().Green() / 255.0,
+                                   (double)la.GetColor().Blue() / 255.0);
+            } else {
+                ren.AddLight().Set(false, la.GetBrightness(),
+                                   (double)la.GetColor().Red() / 255.0,
+                                   (double)la.GetColor().Green() / 255.0,
+                                   (double)la.GetColor().Blue() / 255.0,
+                                   la.GetDirection());        
+
+            }          
+        }
+    }    
+    ren.FinalizeLights();
+    ren.Set(0, 1, false, false, false);
+    ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute after ospray",
+                            "ospout");    
+
+    //===================================================================//
+    // continuation of previous pipeline
+    //===================================================================//
+    //
+    // Extract all of the samples from the dataset.
+    //
+    avtOSPRaySamplePointExtractor extractor(screen[0], screen[1],
+                                            samplesPerRay);
+
+    extractor.SetJittering(true);
+    extractor.SetTransferFn(transferFn1D);
+    extractor.SetInput(trans.GetOutput());
+    extractor.SetOSPRay(ospray_core);
+    extractor.SetViewInfo(view);
+    extractor.SetSamplingRate(samplingRate); 
+    extractor.SetRenderingExtents(renderingExtents); // rendered region
+    extractor.SetMVPMatrix(model_to_screen_transform);
+    
+    //
+    // For curvilinear and unstructured meshes, it makes sense to convert the
+    // cells to image space.  But for rectilinear meshes, it is not the
+    // most efficient strategy.  So set some flags here that allow the
+    // extractor to do the extraction in world space.
+    //
+    {
+        trans.SetPassThruRectilinearGrids(true);
+        extractor.SetRectilinearGridsAreInWorldSpace(true, view, aspect);
+    }
+
+    //===================================================================//
+    // Qi debug
+    //===================================================================//
+    ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute "
+                            "raytracing setup done",
+                            "ospout");
+
+    
+    //===================================================================//
+    // Execute rendering
+    //===================================================================//
+    {
+        StackTimer t1("AllPatchRendering");
+        extractor.Update(GetGeneralContract());
+    }
+    
+    /*
+    avtDataObject_p samples = extractor.GetOutput();
+    // Only required to force an update 
+    // Need to find a way to get rid of that!!!!
+    avtRayCompositer rc(rayfoo);
+    rc.SetInput(samples);
+    avtImage_p image  = rc.GetTypedOutput();
+    image->Update(GetGeneralContract());     
+    */
+
+    //===================================================================//
+    // Image Compositing
+    //===================================================================//
+    // Initialization
+    int timingIdx;
+    float *compositedData = NULL;
+    int compositedW, compositedH;
+    int compositedExtents[4];
+    // Debug
+    int numPatches = extractor.GetImgPatchSize();
+    ospout << "[avtOSPRayRayTracer] Total num of patches " 
+           << numPatches << std::endl;
+    for (int i=0; i<numPatches; i++) {
+        ospray::ImgMetaData currImgMeta = extractor.GetImgMetaPatch(i);
+        ospout << "[avtOSPRayRayTracer] Rank " << PAR_Rank() << " "
+               << "Idx " << i << " (" << currImgMeta.patchNumber << ") " 
+               << " depth " << currImgMeta.eye_z << std::endl
+               << "current patch size = " 
+               << currImgMeta.dims[0] << ", " 
+               << currImgMeta.dims[1] << std::endl
+               << "current patch starting" 
+               << " X = " << currImgMeta.screen_ll[0] 
+               << " Y = " << currImgMeta.screen_ll[1] << std::endl
+               << "current patch ending" 
+               << " X = " << currImgMeta.screen_ur[0] 
+               << " Y = " << currImgMeta.screen_ur[1] << std::endl;
+    }
+    //-------------------------------------------------------------------//
+    // IceT: If each rank has only one patch, we use IceT to composite
+    //-------------------------------------------------------------------//
+    if (imgComm.IceTValid() && extractor.GetImgPatchSize() == 1) {
+        //---------------------------------------------------------------//
+        // Setup Local Tile
+        ospray::ImgMetaData currMeta = extractor.GetImgMetaPatch(0);
+        ospray::ImgData     currData;
+        currData.imagePatch = NULL;
+        extractor.GetAndDelImgData /* do shallow copy inside */
+            (currMeta.patchNumber, currData);
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // First Composition
+        if (PAR_Size() > 1) { 
+            compositedW = renderingExtents[1] - renderingExtents[0];
+            compositedH = renderingExtents[3] - renderingExtents[2];
+            compositedExtents[0] = renderingExtents[0];
+            compositedExtents[1] = renderingExtents[1];
+            compositedExtents[2] = renderingExtents[2];
+            compositedExtents[3] = renderingExtents[3];
+            if (PAR_Rank() == 0) {
+                compositedData = 
+                    new float[4 * compositedW * compositedH]();
+            }
+            int currExtents[4] = 
+                {std::max(currMeta.screen_ll[0]-renderingExtents[0], 0), 
+                 std::min(currMeta.screen_ur[0]-renderingExtents[0], 
+                          compositedW), 
+                 std::max(currMeta.screen_ll[1]-renderingExtents[2], 0),
+                 std::min(currMeta.screen_ur[1]-renderingExtents[2],
+                          compositedH)};
+            imgComm.IceTInit(compositedW, compositedH);
+            imgComm.IceTSetTile(currData.imagePatch, 
+                                currExtents,
+                                currMeta.eye_z);
+            imgComm.IceTComposite(compositedData);
+            if (currData.imagePatch != NULL) {
+                delete[] currData.imagePatch;
+                currData.imagePatch = NULL;
+            }
+        } else {
+            compositedW = currMeta.dims[0];
+            compositedH = currMeta.dims[1];
+            compositedExtents[0] = renderingExtents[0];
+            compositedExtents[1] = renderingExtents[0] + compositedW;
+            compositedExtents[2] = renderingExtents[2];
+            compositedExtents[3] = renderingExtents[2] + compositedH;
+            compositedData = currData.imagePatch;
+            currData.imagePatch = NULL;
+        }
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Memory
+        ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute "
+                                "IceT Compositing Done", 
+                                "ospout");
+        //---------------------------------------------------------------//
+    }
+    //-------------------------------------------------------------------//
+    // SERIAL: Image Composition
+    //-------------------------------------------------------------------//
+    else if (parallelOn == false) {
+        //---------------------------------------------------------------//
+        // Get the Metadata for All Patches
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Serial-Composite: Get the Metadata for "
+                                  "All Patches");
+        // contains the metadata to composite the image
+        std::vector<ospray::ImgMetaData> allPatchMeta;
+        std::vector<ospray::ImgData>     allPatchData;
+        // get the number of patches
+        int numPatches = extractor.GetImgPatchSize();
+        for (int i=0; i<numPatches; i++)
+        {
+            allPatchMeta.push_back(extractor.GetImgMetaPatch(i));
+        }
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Serial-Composite: Get the Metadata for "
+                                 "All Patches");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Sort with the Largest z First
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Serial-Composite: Sort with the Largest "
+                                  "z First");
+        std::sort(allPatchMeta.begin(), allPatchMeta.end(), 
+                  &OSPRaySortImgMetaDataByEyeSpaceDepth);
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Serial-Composite: Sort with the Largest "
+                                 "z First");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Blend Images
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Serial-Composite: Blend Images");
+        compositedW = renderingExtents[1] - renderingExtents[0];
+        compositedH = renderingExtents[3] - renderingExtents[2];
+        compositedExtents[0] = renderingExtents[0];
+        compositedExtents[1] = renderingExtents[0] + compositedW;
+        compositedExtents[2] = renderingExtents[2];
+        compositedExtents[3] = renderingExtents[2] + compositedH;           
+        if (PAR_Rank() == 0) {
+            compositedData = new float[compositedW * compositedH * 4]();
+        }
+        for (int i=0; i<numPatches; i++)
+        {
+            ospray::ImgMetaData currImgMeta = allPatchMeta[i];
+            ospray::ImgData     currImgData;
+            currImgData.imagePatch = NULL;
+            extractor.GetAndDelImgData /* do shallow copy inside */
+                (currImgMeta.patchNumber, currImgData);
+            const float* currData = currImgData.imagePatch;
+            const int currExtents[4] = 
+                {currImgMeta.screen_ll[0], currImgMeta.screen_ur[0], 
+                 currImgMeta.screen_ll[1], currImgMeta.screen_ur[1]};
+            avtOSPRayImageCompositor::BlendBackToFront(currData,
+                                                       currExtents,
+                                                       compositedData, 
+                                                       compositedExtents);
+            if (currImgData.imagePatch != NULL) {
+                delete[] currImgData.imagePatch;
+            }
+            currImgData.imagePatch = NULL;
+        }
+        allPatchMeta.clear();
+        allPatchData.clear();
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Serial-Composite: Blend Images");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Memory
+        ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute "
+                                "Sequential Compositing Done", 
+                                "ospout");
+        //---------------------------------------------------------------//
+    } 
+    //-------------------------------------------------------------------//
+    // PARALLEL: Customized Parallel Direct Send Method
+    //-------------------------------------------------------------------//
+    else { 
+        //---------------------------------------------------------------//
+        // Parallel Direct Send
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Parallel-Composite: "
+                                  "Parallel Direct Send");
+        int tags[2] = {1081, 1681};
+        int tagGather = 2681;
+        int *regions = NULL;
+        imgComm.RegionAllocation(regions);
+        int myRegionHeight =
+            imgComm.ParallelDirectSendManyPatches
+            (extractor.imgDataHashMap, extractor.imageMetaPatchVector,
+             numPatches, regions, imgComm.GetParSize(), tags, 
+             renderingExtents);
+        imgComm.gatherImages(regions, imgComm.GetParSize(), 
+                             imgComm.intermediateImage, 
+                             imgComm.intermediateImageExtents, 
+                             imgComm.intermediateImageExtents, 
+                             tagGather, renderingExtents, myRegionHeight);
+
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Parallel-Composite: "
+                                 "Parallel Direct Send");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Some Cleanup
+        ospray::CheckSectionStart("avtOSPRayRayTracer", "Execute", timingIdx,
+                                  "Parallel-Composite: Some Cleanup");
+        if (regions != NULL)
+            delete [] regions;
+        regions = NULL;
+        if (imgComm.intermediateImage != NULL)
+            delete [] imgComm.intermediateImage;
+        imgComm.intermediateImage = NULL;               
+        imgComm.Barrier();
+        ospray::CheckSectionStop("avtOSPRayRayTracer", "Execute", timingIdx,
+                                 "Parallel-Composite: Some Cleanup");
+        //---------------------------------------------------------------//
+        //---------------------------------------------------------------//
+        // Setup for Final Composition
+        compositedW = 
+            imgComm.finalImageExtents[1] -
+            imgComm.finalImageExtents[0];
+        compositedH = 
+            imgComm.finalImageExtents[3] -
+            imgComm.finalImageExtents[2];
+        compositedExtents[0] = imgComm.finalImageExtents[0];
+        compositedExtents[1] = imgComm.finalImageExtents[1];
+        compositedExtents[2] = imgComm.finalImageExtents[2];
+        compositedExtents[3] = imgComm.finalImageExtents[3];
+        if (PAR_Rank() == 0) {
+            compositedData = imgComm.GetFinalImageBuffer();
+        }
+        //--------------------------------------------------------------//
+        //--------------------------------------------------------------//
+        // Memory
+        ospray::CheckMemoryHere("[avtOSPRayRayTracer] Execute "
+                                "Parallel Compositing Done", 
+                                "ospout");
+        //--------------------------------------------------------------//
+    }   
+
+    ///////////////////////////////////////////////////////////////////
+    //
+    // Final Composition for Displaying
+    //
+    ///////////////////////////////////////////////////////////////////
+    if (PAR_Rank() == 0) {
+        avtImage_p finalImage = new avtImage(this);
+        vtkImageData *finalVTKImage = 
+            avtImageRepresentation::NewImage(screen[0], screen[1]);
+        finalImage->GetImage() = finalVTKImage;
+        unsigned char *finalImageBuffer = 
+            finalImage->GetImage().GetRGBBuffer();
+        ospray::CompositeBackground(screen,
+                                    compositedExtents,
+                                    compositedW,
+                                    compositedH,
+                                    compositedData,
+                                    opaqueImageData,
+                                    opaqueImageZB,
+                                    finalImageBuffer);
+        finalVTKImage->Delete();
+        SetOutput(finalImage);
+    }
+    if (compositedData != NULL) { 
+        delete [] compositedData;
+    }
+    compositedData = NULL; 
+    ospout << "[avtOSPRayRayTracer] Raycasting OSPRay is Done !" << std::endl;
+
+    ///////////////////////////////////////////////////////////////////
+    //
+    // Clean up
+    //
+    ///////////////////////////////////////////////////////////////////
+    screen_to_model_transform->Delete();
+    model_to_screen_transform->Delete();
+    screen_to_camera_transform->Delete();
+    ospray::Finalize();
+}
diff --git a/avt/Filters/avtOSPRayRayTracer.h b/avt/Filters/avtOSPRayRayTracer.h
new file mode 100644
index 0000000000..63ca7ae0e5
--- /dev/null
+++ b/avt/Filters/avtOSPRayRayTracer.h
@@ -0,0 +1,162 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                           avtOSPRayRayTracer.h                            //
+// ************************************************************************* //
+
+#ifndef AVT_OSPRAY_RAY_TRACER_H
+#define AVT_OSPRAY_RAY_TRACER_H
+
+#include <filters_exports.h>
+
+#include <avtRayTracerBase.h>
+#include <avtOSPRayCommon.h>
+#include <avtOSPRayImageCompositor.h>
+#include <LightList.h>
+
+class   vtkMatrix4x4;
+
+// ****************************************************************************
+//  Class: avtOSPRayRayTracer
+//
+//  Purpose:
+//      Performs ray tracing, taking in a dataset as a source and has an
+//      image as an output.
+//
+//  Programmer: Hank Childs
+//  Creation:   November 27, 2000
+//
+//  Modifications:
+//
+//    Hank Childs, Mon Jan  8 16:52:26 PST 2001
+//    Added "Get" functions.
+//
+//    Hank Childs, Sat Feb  3 20:37:01 PST 2001
+//    Removed pixelizer and added mechanism to change background color.
+//
+//    Hank Childs, Tue Feb 13 15:15:50 PST 2001
+//    Added ability to insert an opaque image into the rendering.
+//
+//    Brad Whitlock, Wed Dec 5 11:13:18 PDT 2001
+//    Added gradient backgrounds.
+//
+//    Hank Childs, Thu Feb  5 17:11:06 PST 2004
+//    Moved inlined destructor definition to .C file because certain compilers
+//    have problems with them.
+//
+//    Hank Childs, Sun Dec  4 18:00:55 PST 2005
+//    Add method that estimates number of stages.
+//
+//    Hank Childs, Mon Jan 16 11:11:47 PST 2006
+//    Add support for kernel based sampling.
+//
+//    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
+//    Added support for rectilinear grids with an inherent transform.
+//
+//    Hank Childs, Wed Dec 24 14:17:03 PST 2008
+//    Add method TightenClippingPlanes.
+//
+//    Pascal Grosset, Fri Sep 20 2013
+//    Added ray casting slivr & trilinear interpolation
+//
+//    Qi Wu, Sun Jul 1 2018
+//    Added support for ospray volume rendering.
+//
+// ****************************************************************************
+
+class AVTFILTERS_API avtOSPRayRayTracer : public avtRayTracerBase
+{
+public:
+    avtOSPRayRayTracer();
+    virtual              ~avtOSPRayRayTracer();
+
+    virtual const char   *GetType(void)      { return "avtOSPRayRayTracer"; };
+    virtual const char   *GetDescription(void) 
+                                             { return "OSPRay Ray tracing"; };
+
+    void SetActiveVariable(const char* s)             { activeVariable = s; };
+    void SetLightInfo(const LightList& l)                  { lightList = l; };
+    void SetOSPRay(OSPVisItContext *ptr)               { ospray_core = ptr; };
+
+    void SetLighting(bool l)                  { gradientShadingEnabled = l; };
+    void SetShadowsEnabled(bool l)                    { shadowsEnabled = l; };
+    void SetUseGridAccelerator(bool l)            { useGridAccelerator = l; };
+    void SetPreIntegration(bool l)                    { preIntegration = l; };
+    void SetSingleShade(bool l)                          { singleShade = l; };
+    void SetOneSidedLighting(bool l)                { oneSidedLighting = l; };
+    void SetAoTransparencyEnabled(bool l)      { aoTransparencyEnabled = l; };
+
+    void SetAoSamples(int v)                               { aoSamples = v; };
+    void SetSpp(int v)                                           { spp = v; };
+    
+    void SetAoDistance(double v)                          { aoDistance = v; };
+    void SetSamplingRate(double v)                      { samplingRate = v; };
+    void SetMinContribution(double v)                { minContribution = v; };
+    
+    void SetMatProperties(double v[4]) 
+                    { for (int i=0; i<4; i++) materialProperties[i] = v[i]; };
+    void SetViewDirection(double v[3])
+                         { for (int i=0; i<3; i++) viewDirection[i] = v[i]; };
+protected:
+    virtual void             Execute(void);
+
+    const char*              activeVariable;
+    LightList                lightList;
+    OSPVisItContext         *ospray_core;
+
+    bool                     gradientShadingEnabled;
+    bool                     shadowsEnabled;
+    bool                     useGridAccelerator;
+    bool                     preIntegration;
+    bool                     singleShade;
+    bool                     oneSidedLighting;
+    bool                     aoTransparencyEnabled;
+    int                      spp;
+    int                      aoSamples;
+    double                   aoDistance;
+    double                   samplingRate;
+    double                   minContribution;
+    
+    double                   materialProperties[4];
+    double                   viewDirection[3];
+
+    avtOSPRayImageCompositor imgComm;
+};
+
+#endif
diff --git a/avt/Filters/avtOSPRaySamplePointExtractor.C b/avt/Filters/avtOSPRaySamplePointExtractor.C
new file mode 100644
index 0000000000..cfbaff7ebb
--- /dev/null
+++ b/avt/Filters/avtOSPRaySamplePointExtractor.C
@@ -0,0 +1,574 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                    avtOSPRaySamplePointExtractor.C                        //
+// ************************************************************************* //
+
+#include <avtOSPRaySamplePointExtractor.h>
+
+#include <float.h>
+
+#include <vtkCellData.h>
+#include <vtkDataSet.h>
+#include <vtkPointData.h>
+#include <vtkPoints.h>
+#include <vtkUnsignedCharArray.h>
+#include <vtkIdList.h>
+#include <vtkRectilinearGrid.h>
+
+#include <avtCellList.h>
+#include <avtOSPRayVoxelExtractor.h>
+#include <avtParallel.h>
+#include <avtSamplePoints.h>
+#include <avtVolume.h>
+
+#include <DebugStream.h>
+#include <TimingsManager.h>
+#include <StackTimer.h>
+
+#include <Utility.h>
+#include <DebugStream.h>
+
+#include <limits>
+#include <algorithm>
+#include <stack>
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor constructor
+//
+//  Arguments:
+//      w       The width.
+//      h       The height.
+//      d       The depth.
+//
+//  Programmer: Hank Childs
+//  Creation:   December 5, 2000
+//     
+//  Modifications:
+//
+//    Hank Childs, Thu Nov 15 15:39:48 PST 2001
+//    Moved construction of cell list to Execute to account new limitations of
+//    sample points involving multiple variables.
+//
+//    Hank Childs, Tue Jan  1 10:01:20 PST 2002
+//    Initialized sendCells.
+//
+//    Hank Childs, Sun Dec 14 11:07:56 PST 2003
+//    Initialized massVoxelExtractor.
+//
+//    Hank Childs, Fri Nov 19 13:57:02 PST 2004
+//    Initialized rectilinearGridsAreInWorldSpace.
+//
+//    Hank Childs, Fri Dec 10 09:59:57 PST 2004
+//    Initialized shouldDoTiling.
+//
+//    Hank Childs, Wed Feb  2 08:56:00 PST 2005
+//    Initialize modeIs3D.
+//
+//    Hank Childs, Sun Dec  4 19:12:42 PST 2005
+//    Initialize kernelBasedSampling.
+//
+//    Hank Childs, Tue Jan 24 16:42:40 PST 2006
+//    Added point extractor.
+//
+//    Timo Bremer, Thu Sep 13 14:02:40 PDT 2007
+//    Added hex20 extractor.
+//
+//    Hank Childs, Tue Jan 15 14:26:06 PST 2008
+//    Initialize members for sample point arbitration.
+//
+//    Hank Childs, Fri Jan  9 14:10:25 PST 2009
+//    Initialize jitter.
+//
+//    Mark C. Miller, Thu Oct  2 09:41:37 PDT 2014
+//    Initialize lightDirection.
+// ****************************************************************************
+
+avtOSPRaySamplePointExtractor::avtOSPRaySamplePointExtractor(int w,
+                                                             int h,
+                                                             int d)
+    : avtSamplePointExtractorBase(w, h, d)
+{
+    ospray_core = NULL;
+    osprayVoxelExtractor = NULL;
+    modelViewProj = vtkMatrix4x4::New();
+    patchCount = 0;
+    imageMetaPatchVector.clear();
+    imgDataHashMap.clear();
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor destructor
+//
+//  Programmer: Hank Childs
+//  Creation:   December 8, 2000
+//      
+//  Modifications:
+//
+//    Hank Childs, Sun Dec 14 11:07:56 PST 2003
+//    Deleted massVoxelExtractor.
+//
+//    Hank Childs, Tue Jan 24 16:42:40 PST 2006
+//    Deleted pointExtractor.
+//
+//    Timo Bremer, Thu Sep 13 14:02:40 PDT 2007
+//    Deleted hex20Extractor.
+//
+//    Hank Childs, Tue Jan 15 21:25:01 PST 2008
+//    Delete arbitrator.
+//
+// ****************************************************************************
+
+avtOSPRaySamplePointExtractor::~avtOSPRaySamplePointExtractor()
+{
+    if (osprayVoxelExtractor != NULL)
+    {
+        delete osprayVoxelExtractor;
+        osprayVoxelExtractor = NULL;
+    }
+
+    DelImgPatches();
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::SetUpExtractors
+//
+//  Purpose:
+//      Sets up the extractors and tell them which volume to extract into.
+//
+//  Programmer: Hank Childs
+//  Creation:   November 15, 2001
+//
+//  Modifications:
+//
+//    Hank Childs, Tue Jan  1 10:01:20 PST 2002
+//    Tell the extractors whether they should extract from large cells.
+//
+//    Hank Childs, Sun Dec 14 11:07:56 PST 2003
+//    Set up massVoxelExtractor.
+//
+//    Hank Childs, Fri Dec 10 09:59:57 PST 2004
+//    Do the sampling in tiles if necessary.
+//
+//    Hank Childs, Sun Dec  4 19:12:42 PST 2005
+//    Add support for kernel based sampling.
+//
+//    Timo Bremer, Thu Sep 13 14:02:40 PDT 2007
+//    Added hex20 extractor.
+//
+//    Hank Childs, Fri Jan  9 14:11:24 PST 2009
+//    Tell extractors whether or not to jitter.  Also remove call to 
+//    massVoxelExtractor regarding "sendCellsMode", as it does not participate
+//    in that mode ... so the call was worthless.
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::SetUpExtractors(void)
+{
+    StackTimer t0("avtOSPRaySamplePointExtractor::SetUpExtractors");
+    avtSamplePoints_p output = GetTypedOutput();
+
+    //
+    // This will always be NULL the first time through.  For subsequent tiles
+    // (provided we are doing tiling) will not have this issue.
+    //
+    if (output->GetVolume() == NULL)
+        output->SetVolume(width, height, depth);
+    else
+        output->GetVolume()->ResetSamples();
+    output->ResetCellList();
+    avtVolume *volume = output->GetVolume();
+    if (shouldDoTiling)
+        volume->Restrict(width_min, width_max-1, height_min, height_max-1);
+
+    //
+    // Set up the extractors and tell them which cell list to use.
+    //
+    avtCellList *cl = output->GetCellList();
+
+    if (osprayVoxelExtractor != NULL)
+    {
+        delete osprayVoxelExtractor;
+    }
+    osprayVoxelExtractor = new avtOSPRayVoxelExtractor(width, height, depth,
+                                                       volume, cl);
+    // osprayVoxelExtractor->SetJittering(jitter);
+    if (shouldDoTiling)
+    {
+        osprayVoxelExtractor->Restrict(width_min, width_max-1,
+                                      height_min, height_max-1);
+    }
+}
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::InitSampling
+//
+//  Purpose:
+//      Initialize sampling, called by base class ExecuteTree method before.
+//      the actual iteration starts. This function might be useful for
+//      children classes
+//
+//  Arguments:
+//      dt      The dataset tree that should be processed.
+//
+//  Programmer: Qi WU 
+//  Creation:   June 18, 2018
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::InitSampling(avtDataTree_p dt)
+{
+    ospray::Context* ospray = (ospray::Context*)ospray_core;    
+    for (int i = 0; i < dt->GetNChildren(); ++i)
+    { ospray->InitPatch(i); }    
+    patchCount = 0;
+    imageMetaPatchVector.clear();
+    imgDataHashMap.clear();
+}
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::DoSampling
+//
+//  Purpose:
+//      Performs sampling, called by base class ExecuteTree method.
+//
+//  Arguments:
+//      ds      The data set that should be processed.
+//      idx     The index of the dataset.
+//
+//  Programmer: Kathleen Biagas 
+//  Creation:   April 18, 2018
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::DoSampling(vtkDataSet *ds, int idx)
+{
+    // initialize ospray
+    StackTimer t0("avtOSPRaySamplePointExtractor::DoSampling "
+                  "OSPVisItContext::InitPatch");    
+    // volume scalar range
+    double scalarRange[2]; 
+    {
+        StackTimer t1("avtOSPRaySamplePointExtractor::DoSampling "
+                      "Retrieve Volume Scalar Range");
+        ds->GetScalarRange(scalarRange);
+    }
+
+    // transfer function visible range
+    double tfnVisibleRange[2];
+    {
+        StackTimer t2("avtOSPRaySamplePointExtractor::DoSampling "
+                      "Retrieve TFN Visible Range");
+        tfnVisibleRange[0] = transferFn1D->GetMinVisibleScalar();
+        tfnVisibleRange[1] = transferFn1D->GetMaxVisibleScalar();
+    }
+
+    osprayVoxelExtractor->SetScalarRange(scalarRange);
+    osprayVoxelExtractor->SetTFVisibleRange(tfnVisibleRange);
+    RasterBasedSample(ds, idx);
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::RasterBasedSample
+//
+//  Purpose:
+//      Does raster based sampling.
+//
+//  Programmer: Hank Childs
+//  Creation:   January 1, 2006
+//
+//  Modifications:
+//    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
+//    Added support for rectilinear grids with an inherent transform.
+//
+//    Hank Childs, Fri Jun  1 12:50:45 PDT 2007
+//    Added support for non-scalars.
+//
+//    Timo Bremer, Thu Sep 13 14:02:40 PDT 2007
+//    Added support for hex-20s.
+//
+//    Hank Childs, Mon Oct 29 20:29:55 PST 2007
+//    Ignore surface primitives in 3D.
+//
+//    Kevin Griffin, Fri Apr 22 16:31:57 PDT 2016
+//    Added support for polygons.
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
+{
+    StackTimer t0("avtOSPRaySamplePointExtractor::RasterBasedSample");
+
+    if (ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
+    {
+        avtDataAttributes &atts = GetInput()->GetInfo().GetAttributes();
+        const double *xform = NULL;
+        if (atts.GetRectilinearGridHasTransform())
+            xform = atts.GetRectilinearGridTransform();
+        avtSamplePoints_p samples = GetTypedOutput();
+        int numVars = samples->GetNumberOfRealVariables();
+        std::vector<std::string> varnames;
+        std::vector<int>         varsizes;
+        for (int i = 0 ; i < numVars ; i++)
+        {
+            varnames.push_back(samples->GetVariableName(i));
+            varsizes.push_back(samples->GetVariableSize(i));
+        }
+
+        //-----------------------------
+        // Extractor Setup
+        //----------------------------- 
+        osprayVoxelExtractor->SetProcIdPatchID(PAR_Rank(), num);
+        osprayVoxelExtractor->SetOSPRay(ospray_core);
+        osprayVoxelExtractor->SetViewInfo(viewInfo);
+        osprayVoxelExtractor->SetSamplingRate(samplingRate);       
+        osprayVoxelExtractor->SetRenderingExtents(renderingExtents);    
+        osprayVoxelExtractor->SetMVPMatrix(modelViewProj);
+
+        // Note (Qi): probably not necessary
+        osprayVoxelExtractor->SetGridsAreInWorldSpace
+            (rectilinearGridsAreInWorldSpace, view, aspect, xform);
+        
+        //-----------------------------
+        // Extract
+        //-----------------------------
+        osprayVoxelExtractor->Extract((vtkRectilinearGrid *) ds, varnames,
+                                      varsizes);
+
+        //-----------------------------
+        // Get rendering results
+        // put them into a proper vector, sort them based on z value
+        //-----------------------------
+        ospray::ImgMetaData tmpImageMetaPatch;
+        tmpImageMetaPatch = InitMetaPatch(patchCount);
+
+        osprayVoxelExtractor->GetImageDimensions
+            (tmpImageMetaPatch.inUse,     tmpImageMetaPatch.dims, 
+             tmpImageMetaPatch.screen_ll, tmpImageMetaPatch.screen_ur, 
+             tmpImageMetaPatch.eye_z,     tmpImageMetaPatch.clip_z);
+        if (tmpImageMetaPatch.inUse == 1)
+        {
+            tmpImageMetaPatch.avg_z = tmpImageMetaPatch.eye_z;
+            tmpImageMetaPatch.destProcId = tmpImageMetaPatch.procId;
+            imageMetaPatchVector.push_back(tmpImageMetaPatch);
+
+            ospray::ImgData tmpImageDataHash;
+            tmpImageDataHash.procId = tmpImageMetaPatch.procId;
+            tmpImageDataHash.patchNumber = tmpImageMetaPatch.patchNumber;
+            tmpImageDataHash.imagePatch = 
+                new float[tmpImageMetaPatch.dims[0] * 
+                          tmpImageMetaPatch.dims[1] * 4];
+
+            osprayVoxelExtractor->GetComputedImage
+                                                (tmpImageDataHash.imagePatch);
+            imgDataHashMap.insert
+                (std::pair<int, ospray::ImgData> (tmpImageDataHash.patchNumber,
+                                                  tmpImageDataHash));
+
+            patchCount++;
+        }
+    } else {
+        //---------------------------------------------------------
+        // Other Grid
+        //---------------------------------------------------------
+        if (num == 0) {
+            const std::string msg = 
+                "Dataset type " + std::to_string((int)(ds->GetDataObjectType())) + " "
+                "is not a VTK_RECTILINEAR_GRID. "
+                "Currently the RayCasting:OSPRay renderer "
+                "only supports rectilinear grid, " 
+                "thus the volume cannot be rendered\n";
+            //ospray::Warning(msg);
+            ospray::Exception(msg);
+        }
+    }
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::SendJittering
+//
+//  Purpose:
+//      Tell the individual cell extractors whether or not to jitter.
+//
+//  Arguments:
+//      j     true if the cell extractors should jitter
+//
+//  Programmer: Hank Childs
+//  Creation:   January 9, 2009
+//
+// ****************************************************************************
+
+void
+avtOSPRaySamplePointExtractor::SendJittering()
+{
+    if (osprayVoxelExtractor != NULL)
+    {
+        osprayVoxelExtractor->SetJittering(jitter);
+    }
+}
+
+
+// ****************************************************************************
+//  Method:  avtOSPRaySamplePointExtractor::FilterUnderstandsTransformedRectMesh
+//
+//  Purpose:
+//    If this filter returns true, this means that it correctly deals
+//    with rectilinear grids having an implied transform set in the
+//    data attributes.  It can do this conditionally if desired.
+//
+//  Arguments:
+//    none
+//
+//  Programmer:  Jeremy Meredith
+//  Creation:    February 15, 2007
+//
+// ****************************************************************************
+
+bool
+avtOSPRaySamplePointExtractor::FilterUnderstandsTransformedRectMesh()
+{
+    return true;
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::DelImgPatches
+//
+//  Purpose:
+//      allocates space to the pointer address and copy the image generated
+//      to it
+//
+//  Programmer: TODO
+//  Creation:   
+//
+//  Modifications:
+//
+//      Qi WU: TODO
+//      Rename based on VisIt naming convension
+//
+// ****************************************************************************
+void
+avtOSPRaySamplePointExtractor::DelImgPatches() {
+    imageMetaPatchVector.clear();
+    for (iter_t it=imgDataHashMap.begin(); it!=imgDataHashMap.end(); it++)
+    {
+        if ((*it).second.imagePatch != NULL) { 
+            delete [](*it).second.imagePatch;
+        }
+        (*it).second.imagePatch = NULL;
+    }
+    imgDataHashMap.clear();
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::GetImgData
+//
+//  Purpose:
+//      Copies a patchover
+//
+//  Programmer: TODO
+//  Creation:   
+//
+//  Modifications:
+//
+//      Qi WU: TODO
+//      Rename based on VisIt naming convension
+//      Does shallow copy instead deep copy for efficiency
+//
+// ****************************************************************************
+void 
+avtOSPRaySamplePointExtractor::GetAndDelImgData(int patchId, 
+                                          ospray::ImgData &tempImgData) 
+{
+    size_t imagePatchSize = 
+        imageMetaPatchVector[patchId].dims[0] * 
+        imageMetaPatchVector[patchId].dims[1] * sizeof(float) * 4;
+    iter_t it = imgDataHashMap.find(patchId);
+    tempImgData.procId = it->second.procId;
+    tempImgData.patchNumber = it->second.patchNumber;
+    // do shallow copy instead of deep copy
+    tempImgData.imagePatch = it->second.imagePatch;
+    // memcpy(tempImgData.imagePatch,
+    //        it->second.imagePatch,
+    //        imagePatchSize);
+    // delete [](*it).second.imagePatch;
+    it->second.imagePatch = NULL;
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRaySamplePointExtractor::InitMetaPatch
+//
+//  Purpose:
+//
+//  Programmer: 
+//  Creation:   
+//
+//  Modifications:
+//
+// ****************************************************************************
+ospray::ImgMetaData
+avtOSPRaySamplePointExtractor::InitMetaPatch(int id)
+{
+    ospray::ImgMetaData temp;
+    temp.inUse = 0;
+    temp.procId = PAR_Rank();
+    temp.destProcId = PAR_Rank();
+    temp.patchNumber = id;
+    temp.dims[0] = temp.dims[1] = -1;
+    temp.screen_ll[0] = temp.screen_ll[1] = -1;
+    temp.screen_ur[0] = temp.screen_ur[1] = -1;
+    temp.avg_z = -1.0;
+    temp.eye_z = -1.0;
+    temp.clip_z = -1.0;
+    return temp;
+}
diff --git a/avt/Filters/avtOSPRaySamplePointExtractor.h b/avt/Filters/avtOSPRaySamplePointExtractor.h
new file mode 100644
index 0000000000..6e3e2c0faa
--- /dev/null
+++ b/avt/Filters/avtOSPRaySamplePointExtractor.h
@@ -0,0 +1,180 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                      avtOSPRaySamplePointExtractor.h                      //
+// ************************************************************************* //
+
+#ifndef AVT_OSPRAY_SAMPLE_POINT_EXTRACTOR_H
+#define AVT_OSPRAY_SAMPLE_POINT_EXTRACTOR_H
+
+#include <filters_exports.h>
+
+#include <avtSamplePointExtractorBase.h>
+#include <avtOSPRayCommon.h> // this ensures VISIT_OSPRAY is defined
+
+class     avtOSPRayVoxelExtractor;
+
+#include <vtkMatrix4x4.h>
+
+#include <vector>
+#include <map>
+
+// ****************************************************************************
+//  Class: avtOSPRaySamplePointExtractor
+//
+//  Purpose:
+//      This is a component that will take an avtDataset as an input and find
+//      all of the sample points from that dataset.
+//
+//  Programmer: Hank Childs
+//  Creation:   December 5, 2000
+//
+//  Modifications:
+//
+//    Hank Childs, Sat Jan 27 15:09:34 PST 2001
+//    Added support for sending cells when doing parallel volume rendering.
+//
+//    Kathleen Bonnell, Sat Apr 21, 13:09:27 PDT 2001 
+//    Added recursive Execute method to walk down input data tree. 
+//
+//    Hank Childs, Tue Nov 13 15:51:15 PST 2001
+//    Remove boolean argument to Extract<Cell> calls since it is no longer
+//    necessary when all of the variables are being extracted.
+//
+//    Hank Childs, Sun Dec 14 11:07:56 PST 2003
+//    Added mass voxel extractor.
+//
+//    Hank Childs, Fri Nov 19 13:41:56 PST 2004
+//    Added view conversion option.
+//
+//    Hank Childs, Sat Jan 29 13:32:54 PST 2005
+//    Added 2D extractors.
+//
+//    Hank Childs, Sun Dec  4 19:12:42 PST 2005
+//    Added support for kernel-based sampling.
+//
+//    Hank Childs, Sun Jan  1 10:56:19 PST 2006
+//    Added RasterBasedSample and KernelBasedSample.
+//
+//    Hank Childs, Tue Feb 28 08:25:33 PST 2006
+//    Added PreExecute.
+//
+//    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
+//    Added support for rectilinear grids with an inherent transform.
+//
+//    Hank Childs, Fri Jun  1 11:47:56 PDT 2007
+//    Add method GetLoadingInfoForArrays.
+//
+//    Hank Childs, Thu Sep 13 14:02:40 PDT 2007
+//    Added support for hex-20s.
+//
+//    Hank Childs, Tue Jan 15 14:17:15 PST 2008
+//    Have this class set up custom sample point arbitrators, since it has
+//    the most knowledge.
+//
+//    Hank Childs, Fri Jan  9 14:09:57 PST 2009
+//    Add support for jittering.
+//
+//    Kevin Griffin, Fri Apr 22 16:31:57 PDT 2016
+//    Added support for polygons.
+//
+//    Qi Wu, Sun Jul 1 2018
+//    Added support for ospray volume rendering.
+//
+// ****************************************************************************
+
+class AVTFILTERS_API avtOSPRaySamplePointExtractor 
+    : public avtSamplePointExtractorBase
+{
+  public:
+                          avtOSPRaySamplePointExtractor(int, int, int);
+    virtual              ~avtOSPRaySamplePointExtractor();
+
+    virtual const char   *GetType(void)
+                                   { return "avtOSPRaySamplePointExtractor"; };
+    virtual const char   *GetDescription(void)
+                                         { return "Extracting sample points";};
+
+    void                  SetOSPRay(OSPVisItContext* o)   { ospray_core = o; };
+    void                  SetViewInfo(const avtViewInfo & v) { viewInfo = v; };
+    void                  SetSamplingRate(double r)      { samplingRate = r; };
+    void                  SetRenderingExtents(int extents[4]) 
+    {
+        renderingExtents[0] = extents[0];
+        renderingExtents[1] = extents[1];
+        renderingExtents[2] = extents[2];
+        renderingExtents[3] = extents[3];
+    }
+    void                  SetMVPMatrix(vtkMatrix4x4 *mvp)
+    {
+        modelViewProj->DeepCopy(mvp);
+    };
+
+    int                   GetImgPatchSize() { return patchCount; };
+    void                  GetAndDelImgData(int patchId,
+                                           ospray::ImgData &tempImgData);
+    ospray::ImgMetaData   GetImgMetaPatch(int patchId)
+                                  { return imageMetaPatchVector.at(patchId); };
+    void                  DelImgPatches();
+    
+    std::vector<ospray::ImgMetaData>    imageMetaPatchVector;
+    std::multimap<int, ospray::ImgData> imgDataHashMap;
+    typedef std::multimap<int, ospray::ImgData>::iterator iter_t;
+
+  protected:
+    
+    virtual void              InitSampling(avtDataTree_p dt);
+    virtual void              DoSampling(vtkDataSet *, int);
+    virtual void              SetUpExtractors(void);
+    virtual void              SendJittering(void);
+    virtual bool              FilterUnderstandsTransformedRectMesh(void);
+    void                      RasterBasedSample(vtkDataSet *, int num = 0);
+    ospray::ImgMetaData       InitMetaPatch(int id);
+
+    OSPVisItContext          *ospray_core;
+    avtOSPRayVoxelExtractor  *osprayVoxelExtractor;
+    avtViewInfo               viewInfo;
+    vtkMatrix4x4             *modelViewProj;
+    double                    samplingRate;
+    int                       renderingExtents[4];
+    int                       patchCount;
+};
+
+
+#endif
diff --git a/avt/Filters/avtOSPRayVoxelExtractor.C b/avt/Filters/avtOSPRayVoxelExtractor.C
new file mode 100644
index 0000000000..2e98c0a7d8
--- /dev/null
+++ b/avt/Filters/avtOSPRayVoxelExtractor.C
@@ -0,0 +1,639 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                            avtOSPRayVoxelExtractor.C                      //
+// ************************************************************************* //
+
+#include <avtOSPRayVoxelExtractor.h>
+
+#include <float.h>
+
+#include <avtAccessor.h>
+#include <avtCellList.h>
+#include <avtVolume.h>
+
+#include <vtkDataArray.h>
+#include <vtkCamera.h>
+#include <vtkCellData.h>
+#include <vtkMatrix4x4.h>
+#include <vtkPointData.h>
+#include <vtkRectilinearGrid.h>
+#include <vtkTemplateAliasMacro.h>
+#include <vtkUnsignedCharArray.h>
+
+#include <DebugStream.h>
+#include <StackTimer.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+
+#include <iostream>
+#include <fstream>
+#include <string>
+#include <sstream>
+#include <algorithm>
+#include <limits>
+#include <math.h>
+
+#if defined (_MSC_VER) && (_MSC_VER < 1800) && !defined(round)
+inline double round(double x) {return (x-floor(x)) > 0.5 ? ceil(x) : floor(x);}
+#endif
+
+// ****************************************************************************
+//  Method: avtOSPRayVoxelExtractor constructor
+//
+//  Arguments:
+//     w     The number of sample points in the x direction (width).
+//     h     The number of sample points in the y direction (height).
+//     d     The number of sample points in the z direction (depth).
+//     vol   The volume to put samples into.
+//     cl    The cell list to put cells whose sampling was deferred.
+//
+//  Programmer: Hank Childs
+//  Creation:   December 14, 2003
+//
+//  Modifications:
+//
+//    Hank Childs, Fri Nov 19 14:50:58 PST 2004
+//    Initialize gridsAreInWorldSpace.
+//
+//    Jeremy Meredith, Thu Feb 15 13:11:34 EST 2007
+//    Added an ability to extract voxels using the world-space version
+//    even when they're really in image space.
+//
+//    Hank Childs, Wed Aug 27 11:11:28 PDT 2008
+//    Initialize spatial coordinates array.
+//
+//    Hank Childs, Wed Dec 24 11:22:43 PST 2008
+//    Remove reference to ProportionSpaceToZBufferSpace data member.
+//
+//    Kathleen Biagas, Fri Jul 13 09:23:55 PDT 2012
+//    Use double instead of float.
+//
+// ****************************************************************************
+
+avtOSPRayVoxelExtractor::avtOSPRayVoxelExtractor(int w, int h, int d,
+                                             avtVolume *vol, avtCellList *cl)
+    : avtVoxelExtractor(w, h, d, vol, cl)
+{
+    ospray_core = NULL;
+    model_to_screen_transform = vtkMatrix4x4::New();
+    screen_to_model_transform = vtkMatrix4x4::New();
+
+    proc  = 0;
+    patch = 0;
+    drawn = 0;
+    imgDims[0] = imgDims[1] = 0;             // size of the patch
+    imgLowerLeft[0] = imgLowerLeft[1] = 0;   // coordinates in the whole image
+    imgUpperRight[0] = imgUpperRight[1] = 0; // coordinates in the whole image
+    eyeSpaceDepth  = -1;
+    clipSpaceDepth = -1;
+
+    finalImage = NULL;                         // the image data
+
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRayVoxelExtractor destructor
+//
+//  Purpose:
+//      Defines the destructor.  Note: this should not be inlined in the header
+//      because it causes problems for certain compilers.
+//
+//  Programmer: Hank Childs
+//  Creation:   February 5, 2004
+//
+//  Modifications:
+//
+//    Hank Childs, Sun Nov 21 10:35:40 PST 2004
+//    Delete the view to world transform.
+//
+//    Hank Childs, Wed Aug 27 11:10:51 PDT 2008
+//    Delete the spatial coordinate arrays.
+//
+//    Hank Childs, Wed Dec 24 11:22:43 PST 2008
+//    Remove reference to ProportionSpaceToZBufferSpace data member.
+//
+// ****************************************************************************
+
+avtOSPRayVoxelExtractor::~avtOSPRayVoxelExtractor()
+{
+    model_to_screen_transform->Delete();
+    screen_to_model_transform->Delete();
+
+    if (finalImage != NULL)
+        delete []finalImage;
+
+    finalImage = NULL;
+}
+
+// ****************************************************************************
+//  Method: avtOSPRayVoxelExtractor::Extract
+//
+//  Purpose:
+//      Extracts the grid into the sample points.
+//
+//  Programmer: Hank Childs
+//  Creation:   November 19, 2004
+//
+//  Modifications:
+//    Jeremy Meredith, Thu Feb 15 13:11:34 EST 2007
+//    Added an ability to extract voxels using the world-space version
+//    even when they're really in image space.
+//
+//    Hank Childs, Fri Jun  1 16:40:10 PDT 2007
+//    Added support for non-scalars.
+//
+// ****************************************************************************
+
+void
+avtOSPRayVoxelExtractor::Extract(vtkRectilinearGrid *rgrid,
+                std::vector<std::string> &varnames, std::vector<int> &varsizes)
+{
+    if (gridsAreInWorldSpace || pretendGridsAreInWorldSpace)
+        ExtractWorldSpaceGridOSPRay(rgrid, varnames, varsizes);
+    else {
+        ospray::Exception("Attempt to extract an image space grid,"
+                          "however, RayCasting OSPRay supports only"
+                          "world space grid extraction");
+        //ExtractImageSpaceGrid(rgrid, varnames, varsizes);
+    }
+}
+
+
+// ****************************************************************************
+//  Method: avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay
+//
+//  Purpose:
+//      Compute region that patch covers
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 14, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay(vtkRectilinearGrid *rgrid,
+                 std::vector<std::string> &varnames, std::vector<int> &varsize)
+{
+    StackTimer t0("Calling avtOSPRayVoxelExtractor::"
+                  "ExtractWorldSpaceGridOSPRay");
+    //=======================================================================//
+    // Initialization
+    //=======================================================================//
+    // Flag to indicate if the patch is drawn
+    ospray::Context* ospray = (ospray::Context*)ospray_core;
+    drawn = 0;
+    
+    //=======================================================================//
+    // Register data and early skipping
+    //=======================================================================//
+    int w_min;
+    int w_max;
+    int h_min;
+    int h_max;
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Register Data (VisIt preparation)");
+        // Some of our sampling routines need a chance to pre-process the data.
+        // Register the grid here so we can do that.
+        // Stores the values in a structure so that it can be used
+        RegisterGrid(rgrid, varnames, varsize);
+        // Determine what range we are dealing with on this iteration.
+        w_min = restrictedMinWidth;
+        w_max = restrictedMaxWidth + 1;
+        h_min = restrictedMinHeight;
+        h_max = restrictedMaxHeight + 1;
+        imgWidth = imgHeight = 0;
+        /*
+        // Let's find out if this range can even intersect the dataset.
+        // If not, just skip it.
+        if (!FrustumIntersectsGrid(w_min, w_max, h_min, h_max)) { return; }
+        */
+    }
+    
+    //=======================================================================//
+    // obtain data pointers & ghost region information
+    //=======================================================================//
+    void* volumePointer = NULL;
+    int   volumeDataType;
+    int nX = 0, nY = 0, nZ = 0;
+    bool ghost_bound[6] = {false};
+    double volumeCube[6];
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Compute metadata & ghost boundary "
+                      "(Pre-OSPRay preparation)");
+        // Calculate patch dimensions for point array and cell array
+        //   This is to check if the patch is a cell data or a point data
+        //   I have to assume cell dataset has a higher priority
+        if (ncell_arrays > 0) {
+
+            ospout << "[avtOSPRayVoxelExtractor] Cell Dataset "
+                   << std::endl << std::endl;
+            if (DebugStream::Level5() || ospray::visit::CheckVerbose())
+                for (int i = 0; i < ncell_arrays; ++i)
+                    ospout << "  variable_name: "
+                           << rgrid->GetCellData()->GetArray(i)->GetName()
+                           << std::endl
+                           << "  idx_cell_arrays: " << i << std::endl
+                           << "  cell_index["    << i << "] "
+                           << cell_index[i]      << std::endl
+                           << "  cell_size["     << i << "] "
+                           << cell_size[i]       << std::endl
+                           << "  cell_vartypes[" << i << "] "
+                           << cell_vartypes[i]   << std::endl << std::endl;
+            if (rgrid->GetCellData()->GetArray(ncell_arrays-1)->GetName() !=
+                ospray->GetVariableName())
+            {
+                ospray::Exception("Error: primary variable " +
+                                  ospray->GetVariableName() +
+                                  " not found.");               
+            }
+            if (cell_size[ncell_arrays-1] != 1)
+            {
+                ospray::Exception("Error: non-scalar variable " +
+                                  ospray->GetVariableName() +
+                                  " of length " +
+                                  std::to_string(cell_size[ncell_arrays-1]) +
+                                  " found.");
+            }
+            nX = dims[0] - 1;
+            nY = dims[1] - 1;
+            nZ = dims[2] - 1;
+            volumePointer = cell_arrays[ncell_arrays-1];
+            volumeDataType = cell_vartypes[ncell_arrays-1];
+        }
+        else if (npt_arrays > 0) {
+            ospout << "[avtOSPRayVoxelExtractor] Point Dataset "
+                   << std::endl << std::endl;
+            if (DebugStream::Level5() || ospray::visit::CheckVerbose())
+                for (int i = 0; i < npt_arrays; ++i)
+                    ospout << "  variable_name: "
+                           << rgrid->GetPointData()->GetArray(i)->GetName()
+                           << std::endl
+                           << "  idx_pt_arrays: " << i << std::endl
+                           << "  pt_index["    << i << "] "
+                           << pt_index[i]      << std::endl
+                           << "  pt_size["     << i << "] "
+                           << pt_size[i]       << std::endl
+                           << "  pt_vartypes[" << i << "] "
+                           << pt_vartypes[i]   << std::endl << std::endl;
+            if (rgrid->GetPointData()->GetArray(npt_arrays-1)->GetName() !=
+                ospray->GetVariableName())
+            {
+                ospray::Exception("Error: primary variable " +
+                                  ospray->GetVariableName() +
+                                  " not found.");               
+            }
+            if (pt_size[npt_arrays-1] != 1)
+            {
+                ospray::Exception("Error: non-scalar variable " +
+                                  ospray->GetVariableName() +
+                                  " of length " +
+                                  std::to_string(pt_size[npt_arrays-1]) +
+                                  " found.");
+            }
+            nX = dims[0];
+            nY = dims[1];
+            nZ = dims[2];
+            volumePointer = pt_arrays[npt_arrays-1];
+            volumeDataType = pt_vartypes[npt_arrays-1];
+        } else {
+            ospray::Exception("dataset found is neither nodal nor zonal. "
+                              "OSPRay does not know how to handle it.");
+        }
+        ospout << "[avtOSPRayVoxelExtractor] patch dimension "
+               << nX << " " << nY << " " << nZ << std::endl;
+        // Calculate ghost region boundaries
+        //   ghost_boundaries is an array to indicate if the patch contains
+        //   any ghost regions in six different directions
+        // Here I assume the patch is larger than 3-cube
+        // If not then you might want to dig into this code and see if
+        // there will be any special boundary cases
+        //
+        // debug5 << "VAR: ghost value " << (int)ghosts[0] << std::endl;
+        //
+        if (ghosts != NULL) {
+            int gnX = 0, gnY = 0, gnZ = 0;
+            gnX = dims[0] - 1;
+            gnY = dims[1] - 1;
+            gnZ = dims[2] - 1;  
+            for (int y = 1; y < (gnY-1); ++y) {
+                for (int z = 1; z < (gnZ-1); ++z) {
+                    if (!ghost_bound[0]) {
+                        if (ghosts[z*gnY*gnX+y*gnX        ] != 0)
+                            { ghost_bound[0] = true; }
+                    }
+                    if (!ghost_bound[3]) {
+                        if (ghosts[z*gnY*gnX+y*gnX+(gnX-1)] != 0)
+                            { ghost_bound[3] = true; }
+                    }
+                    if (ghost_bound[0] && ghost_bound[3]) { break; }
+                }
+            }
+            for (int x = 1; x < (gnX-1); ++x) {
+                for (int z = 1; z < (gnZ-1); ++z) {
+                    if (!ghost_bound[1]) {
+                        if (ghosts[z*gnY*gnX            +x] != 0)
+                            { ghost_bound[1] = true; }
+                    }
+                    if (!ghost_bound[4]) {
+                        if (ghosts[z*gnY*gnX+(gnY-1)*gnX+x] != 0)
+                            { ghost_bound[4] = true; }
+                    }
+                    if (ghost_bound[1] && ghost_bound[4]) { break; }
+                }
+            }
+            for (int x = 1; x < (gnX-1); ++x) {
+                for (int y = 1; y < (gnY-1); ++y) {
+                    if (!ghost_bound[2]) {
+                        if (ghosts[                y*gnX+x] != 0) 
+                            { ghost_bound[2] = true; }
+                    }
+                    if (!ghost_bound[5]) {
+                        if (ghosts[(gnZ-1)*gnY*gnX+y*gnX+x] != 0)
+                            { ghost_bound[5] = true; }
+                    }
+                    if (ghost_bound[2] && ghost_bound[5]) { break; }
+                }
+            }
+        }
+        // Data bounding box
+        volumeCube[0] = X[0];
+        volumeCube[2] = Y[0];
+        volumeCube[4] = Z[0];
+        if (ncell_arrays > 0) { 
+          volumeCube[1] = X[nX];
+          volumeCube[3] = Y[nY];
+          volumeCube[5] = Z[nZ];
+        } else {
+          volumeCube[1] = X[nX-1];
+          volumeCube[3] = Y[nY-1];
+          volumeCube[5] = Z[nZ-1];
+        }
+    }
+
+    //=======================================================================//
+    // Determine the screen size of the patch being processed
+    //=======================================================================//
+    int patchScreenExtents[4];
+    double patch_center[3];
+    double patch_depth;
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Get screen size of the patch (Pre-OSPRay preparation)");
+        double renderingDepthsExtents[2];
+        ospray::ProjectWorldToScreenCube(volumeCube, w_max, h_max, 
+                                         viewInfo.imagePan, viewInfo.imageZoom,
+                                         model_to_screen_transform, 
+                                         patchScreenExtents, 
+                                         renderingDepthsExtents);
+        xMin = patchScreenExtents[0];
+        xMax = patchScreenExtents[1];
+        yMin = patchScreenExtents[2];
+        yMax = patchScreenExtents[3];
+        ospout << "[avtOSPRayVoxelExtractor] patch ghost bounds:"
+               << "   " << ghost_bound[0] << " " << ghost_bound[3] 
+               << " | " << ghost_bound[1] << " " << ghost_bound[4] 
+               << " | " << ghost_bound[2] << " " << ghost_bound[5]
+               << std::endl;   
+        patch_center[0] = (volumeCube[0] + volumeCube[1])/2.0;
+        patch_center[1] = (volumeCube[2] + volumeCube[3])/2.0;
+        patch_center[2] = (volumeCube[4] + volumeCube[5])/2.0;        
+        patch_depth = // use the norm of patch center as patch depth
+            std::sqrt((patch_center[0]-viewInfo.camera[0])*
+                      (patch_center[0]-viewInfo.camera[0])+
+                      (patch_center[1]-viewInfo.camera[1])*
+                      (patch_center[1]-viewInfo.camera[1])+
+                      (patch_center[2]-viewInfo.camera[2])*
+                      (patch_center[2]-viewInfo.camera[2]));
+        eyeSpaceDepth = patch_depth;
+        clipSpaceDepth = renderingDepthsExtents[0];
+    }
+
+    //=======================================================================//
+    // create framebuffer
+    //=======================================================================//
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Create ImgArray (Pre-OSPRay preparation)");
+        ospout << "[avtOSPRayVoxelExtractor] patch extents " 
+               << xMin << " " << xMax << " "
+               << yMin << " " << yMax << std::endl;
+        if (xMin < renderingExtents[0]) { xMin = renderingExtents[0]; }
+        if (yMin < renderingExtents[2]) { yMin = renderingExtents[2]; }    
+        if (xMax > renderingExtents[1]) { xMax = renderingExtents[1]; }
+        if (yMax > renderingExtents[3]) { yMax = renderingExtents[3]; }
+        imgWidth  = xMax-xMin;
+        imgHeight = yMax-yMin;
+        finalImage = new float[((imgWidth)*4) * imgHeight];
+    }
+
+    //=======================================================================//
+    // Render using OSPRay
+    //=======================================================================//
+    double volumePBox[6];
+    double volumeBBox[6];
+    {
+        StackTimer t1("avtOSPRayVoxelExtractor::ExtractWorldSpaceGridOSPRay "
+                      "Using OSPRay");
+        {
+            StackTimer t2("avtOSPRayVoxelExtractor::"
+                          "ExtractWorldSpaceGridOSPRay "
+                          "OSPRay bbox and clip (OSPRay preparation)");
+            // shift grid and make it cel centered for cell data
+            // for cell centered data, we put the voxel on its left boundary
+            volumePBox[0] = X[0];
+            volumePBox[1] = Y[0];
+            volumePBox[2] = Z[0];
+            if (ncell_arrays > 0) { 
+              /* zonal data need to occupy a whole cell */
+              volumePBox[3] = X[nX];
+              volumePBox[4] = Y[nY];
+              volumePBox[5] = Z[nZ];
+            } else {
+              volumePBox[3] = X[nX-1];
+              volumePBox[4] = Y[nY-1];
+              volumePBox[5] = Z[nZ-1];
+            }
+            // compute boundingbox and clipping plane for ospray
+            if (ncell_arrays > 0) {
+                volumeBBox[0] = ghost_bound[0]?(X[0]+X[1])/2.:volumePBox[0];
+                volumeBBox[1] = ghost_bound[1]?(Y[0]+Y[1])/2.:volumePBox[1];
+                volumeBBox[2] = ghost_bound[2]?(Z[0]+Z[1])/2.:volumePBox[2];
+                volumeBBox[3] = 
+                    ghost_bound[3] ? (X[nX]+X[nX-1])/2. : volumePBox[3];
+                volumeBBox[4] = 
+                    ghost_bound[4] ? (Y[nY]+Y[nY-1])/2. : volumePBox[4];
+                volumeBBox[5] = 
+                    ghost_bound[5] ? (Z[nZ]+Z[nZ-1])/2. : volumePBox[5];
+            }
+            else {
+                volumeBBox[0] = ghost_bound[0] ? X[1] : volumePBox[0];
+                volumeBBox[1] = ghost_bound[1] ? Y[1] : volumePBox[1];
+                volumeBBox[2] = ghost_bound[2] ? Z[1] : volumePBox[2];
+                volumeBBox[3] = ghost_bound[3] ? X[nX-2] : volumePBox[3];
+                volumeBBox[4] = ghost_bound[4] ? Y[nY-2] : volumePBox[4];
+                volumeBBox[5] = ghost_bound[5] ? Z[nZ-2] : volumePBox[5];
+            }
+            ospout << "[avtOSPRayVoxelExtractor] patch data position:" 
+                   << " " << volumePBox[0]
+                   << " " << volumePBox[1]
+                   << " " << volumePBox[2]
+                   << " |"
+                   << " " << volumePBox[3]
+                   << " " << volumePBox[4]
+                   << " " << volumePBox[5]
+                   << std::endl;  
+            ospout << "[avtOSPRayVoxelExtractor] patch data bbox:" 
+                   << " " << volumeBBox[0]
+                   << " " << volumeBBox[1]
+                   << " " << volumeBBox[2]
+                   << " |"
+                   << " " << volumeBBox[3]
+                   << " " << volumeBBox[4]
+                   << " " << volumeBBox[5]
+                   << std::endl; 
+        }
+        // Create volume and model
+        {
+            StackTimer t2("avtOSPRayVoxelExtractor::"
+                          "ExtractWorldSpaceGridOSPRay "
+                          "OSPRay Create Volume");
+            ospray->SetupPatch(patch, volumeDataType,
+                               (size_t)nX * (size_t)nY * (size_t)nZ,
+                               volumePointer, X, Y, Z, nX, nY, nZ,
+                               volumePBox, volumeBBox);
+        }
+        // Render Volume
+        {
+            StackTimer t2("avtOSPRayVoxelExtractor::"
+                          "ExtractWorldSpaceGridOSPRay "
+                          "OSPRay Render Volume");
+            if ((scalarRange[1] >= tFVisibleRange[0]) &&
+                (scalarRange[0] <= tFVisibleRange[1])) {
+                ospray->RenderPatch(patch, xMin, xMax, yMin, yMax,
+                                    imgWidth, imgHeight, finalImage);
+                drawn = 1;
+                
+            }
+        }
+    }
+
+    //=======================================================================//
+    // Send rays
+    //=======================================================================//
+    imgDims[0] = imgWidth;
+    imgDims[1] = imgHeight;
+    imgLowerLeft[0] = xMin;
+    imgLowerLeft[1] = yMin;
+    imgUpperRight[0] = xMax; 
+    imgUpperRight[1] = yMax;
+
+    //=======================================================================//
+    // Deallocate memory if not used
+    //=======================================================================//
+    if (drawn == 0)
+    { 
+        if (finalImage != NULL) 
+        { 
+            delete []finalImage; finalImage = NULL; 
+        } 
+    }
+}
+
+
+// ****************************************************************************
+//  Method: avtSLIVRVoxelExtractor::getImageDimensions
+//
+//  Purpose:
+//      Transfers the metadata of the patch
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 14, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRayVoxelExtractor::GetImageDimensions(int &inUse, int dims[2],
+                                            int screen_ll[2],
+                                            int screen_ur[2],
+                                            float &eyeDepth,
+                                            float &clipDepth)
+{
+    inUse = drawn;
+    dims[0] = imgDims[0];
+    dims[1] = imgDims[1];
+    screen_ll[0] = imgLowerLeft[0];
+    screen_ll[1] = imgLowerLeft[1];
+    screen_ur[0] = imgUpperRight[0];
+    screen_ur[1] = imgUpperRight[1];
+    eyeDepth  = eyeSpaceDepth;
+    clipDepth = clipSpaceDepth;
+}
+
+// ****************************************************************************
+//  Method: avtSLIVRVoxelExtractor::getComputedImage
+//
+//  Purpose:
+//      Allocates space to the pointer address and copy the image generated
+//      to it
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 14, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtOSPRayVoxelExtractor::GetComputedImage(float *image)
+{
+    memcpy(image, finalImage, imgDims[0]*4*imgDims[1]*sizeof(float));
+    if (finalImage != NULL)
+        delete []finalImage;
+    finalImage = NULL;
+}
diff --git a/avt/Filters/avtOSPRayVoxelExtractor.h b/avt/Filters/avtOSPRayVoxelExtractor.h
new file mode 100644
index 0000000000..cf976c3e6a
--- /dev/null
+++ b/avt/Filters/avtOSPRayVoxelExtractor.h
@@ -0,0 +1,184 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************* //
+//                            avtOSPRayVoxelExtractor.h                      //
+// ************************************************************************* //
+
+#ifndef AVT_OSPRAY_VOXEL_EXTRACTOR_H
+#define AVT_OSPRAY_VOXEL_EXTRACTOR_H
+
+#include <filters_exports.h>
+
+#include <avtVoxelExtractor.h>
+#include <avtOSPRayCommon.h>
+#include <avtOpacityMap.h>
+
+#include <DebugStream.h>
+
+#include <vtkMatrix3x3.h>
+#include <vtkMatrix4x4.h>
+#include <vtkCamera.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <algorithm>
+
+class     vtkRectilinearGrid;
+class     vtkMatrix4x4;
+
+// ****************************************************************************
+//  Class: avtOSPRayVoxelExtractor
+//
+//  Purpose:
+//      Extracts sample points from a collection of voxels.  It assumes that 
+//      the voxels it has been given are in camera space and does not try to
+//      populate points that are not in the cube [-1, 1], [-1, 1], [-1, 1].
+//
+//  Programmer: Hank Childs
+//  Creation:   December 14, 2003
+//
+//  Modifications:
+//
+//    Hank Childs, Thu Feb  5 17:11:06 PST 2004
+//    Moved inlined constructor and destructor definitions to .C files
+//    because certain compilers have problems with them.
+//
+//    Hank Childs, Fri Nov 19 14:50:58 PST 2004
+//    Added support for accepting grids that need to do a world space to
+//    image space conversion as well.  Also changed API to AVTFILTERS_API.
+//
+//    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
+//    Added support for rectilinear grids with an inherent transform.
+//
+//    Hank Childs, Fri Jun  1 15:28:14 PDT 2007
+//    Added support for non-scalars.
+//
+//    Hank Childs, Wed Aug 27 11:24:53 PDT 2008
+//    Add support for non-floats.
+//
+//    Hank Childs, Wed Dec 24 11:24:47 PST 2008
+//    Remove data member ProportionSpaceToZBufferSpace, as we now do our
+//    sampling in even intervals (wbuffer).
+//
+//    Kathleen Biagas, Fri Jul 13 09:44:45 PDT 2012
+//    Use double internally instead of float.
+//
+//    Qi Wu, Sun Jul 1 2018
+//    Added support for ospray volume rendering.
+//
+// ****************************************************************************
+using namespace ospray;
+class AVTFILTERS_API avtOSPRayVoxelExtractor : public avtVoxelExtractor
+{
+  public:
+                     avtOSPRayVoxelExtractor(int, int, int, avtVolume *,
+                                            avtCellList *);
+    virtual         ~avtOSPRayVoxelExtractor();
+
+    void             Extract(vtkRectilinearGrid *,
+                             std::vector<std::string> &varnames,
+                             std::vector<int> &varsize);
+
+    // void             SetVariableInformation(std::vector<std::string> &names,
+    //                                         std::vector<int> varsize);
+
+    void             SetProcIdPatchID(int c, int p)   { proc = c; patch = p; };
+    void             SetOSPRay(OSPVisItContext* o)        { ospray_core = o; };
+    void             SetViewInfo(const avtViewInfo & v)      { viewInfo = v; };
+    void             SetSamplingRate(double r)           { samplingRate = r; };
+    void             SetRenderingExtents(int extents[4]) 
+    {
+        renderingExtents[0] = extents[0];
+        renderingExtents[1] = extents[1];
+        renderingExtents[2] = extents[2];       
+        renderingExtents[3] = extents[3];
+    };
+    void             SetMVPMatrix(vtkMatrix4x4 *mvp)
+    {
+        model_to_screen_transform->DeepCopy(mvp); 
+        vtkMatrix4x4::Invert(model_to_screen_transform, 
+                             screen_to_model_transform); 
+    };
+    void             SetScalarRange(double r[2])
+    {
+        scalarRange[0] = r[0];
+        scalarRange[1] = r[1];
+    };
+    void             SetTFVisibleRange(double r[2])
+    {
+        tFVisibleRange[0] = r[0];
+        tFVisibleRange[1] = r[1];
+    };
+    void             GetImageDimensions(int&,int dims[2],int screen_ll[2],
+                                        int screen_ur[2],float &, float &);
+    void             GetComputedImage(float *image);
+
+  protected:
+    // the output image
+    float           *finalImage;
+    // some meta information
+    bool             drawn;  // whether the patch is drawn or not
+    int              patch;  // id of the patch
+    int              proc;   // id of the processor
+    // fields
+    avtViewInfo      viewInfo;
+    OSPVisItContext *ospray_core;    
+    double           samplingRate;    
+    int              renderingExtents[4];
+    // matrix
+    vtkMatrix4x4    *model_to_screen_transform;
+    vtkMatrix4x4    *screen_to_model_transform;
+    // others
+    double           scalarRange[2];
+    double           tFVisibleRange[2];
+    int              imgWidth;
+    int              imgHeight;
+    int              imgDims[2];       // size of the patch
+    int              imgLowerLeft[2];  // coordinates in the whole image
+    int              imgUpperRight[2]; // coordinates in the whole image
+    float            eyeSpaceDepth;    // for blending patches
+    float            clipSpaceDepth;   // clip space depth for blending with bg
+    int              xMin, xMax, yMin, yMax;
+
+    void             ExtractWorldSpaceGridOSPRay(vtkRectilinearGrid *,  
+                                   std::vector<std::string> &varnames,
+                                           std::vector<int> &varsize);
+};
+
+#endif
diff --git a/avt/Filters/avtSLIVRCommon.C b/avt/Filters/avtSLIVRCommon.C
new file mode 100644
index 0000000000..fba43591d1
--- /dev/null
+++ b/avt/Filters/avtSLIVRCommon.C
@@ -0,0 +1,38 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+#include <avtSLIVRCommon.h>
diff --git a/avt/Filters/imgMetaData.h b/avt/Filters/avtSLIVRCommon.h
similarity index 98%
rename from avt/Filters/imgMetaData.h
rename to avt/Filters/avtSLIVRCommon.h
index eddea3f89b..641ae817c0 100644
--- a/avt/Filters/imgMetaData.h
+++ b/avt/Filters/avtSLIVRCommon.h
@@ -35,8 +35,8 @@
 * DAMAGE.
 *
 *****************************************************************************/
-#ifndef IMG_METADATA_H
-#define IMG_METADATA_H
+#ifndef AVT_SLIVR_COMMON_H
+#define AVT_SLIVR_COMMON_H
 #include <stdio.h>
 #include <string>
 #include <iostream>
diff --git a/avt/Filters/avtImgCommunicator.C b/avt/Filters/avtSLIVRImageCompositor.C
similarity index 94%
rename from avt/Filters/avtImgCommunicator.C
rename to avt/Filters/avtSLIVRImageCompositor.C
index d02d0c66da..fc7cfd12af 100644
--- a/avt/Filters/avtImgCommunicator.C
+++ b/avt/Filters/avtSLIVRImageCompositor.C
@@ -37,25 +37,25 @@
 *****************************************************************************/
 
 // ************************************************************************* //
-//                         avtImgCommunicator.C                              //
+//                         avtSLIVRImageCompositor.C                         //
 // ************************************************************************* //
-#include <cmath>
+
 #include <avtParallel.h>
+#include <avtSLIVRImageCompositor.h>
 #include <ImproperUseException.h>
+#include <DebugStream.h>
 
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>     /* srand, rand */
 #include <time.h>       /* time */
 
-#include <avtImgCommunicator.h>
+#include <algorithm>
+#include <cmath>
 #include <fstream>
-#include <DebugStream.h>
 #include <limits>
-#include <algorithm>
 #include <set>
 
-
 #if defined (_MSC_VER) && (_MSC_VER < 1800) && !defined(round)
 inline double round(double x) {return (x-floor(x)) > 0.5 ? ceil(x) : floor(x);}
 #endif
@@ -63,7 +63,7 @@ inline double round(double x) {return (x-floor(x)) > 0.5 ? ceil(x) : floor(x);}
 enum blendDirection {FRONT_TO_BACK = 0, BACK_TO_FRONT = 1};
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::avtImgCommunicator
+//  Method: avtSLIVRImageCompositor::avtSLIVRImageCompositor
 //
 //  Purpose: Constructor
 //
@@ -73,7 +73,7 @@ enum blendDirection {FRONT_TO_BACK = 0, BACK_TO_FRONT = 1};
 //  Modifications:
 //
 // ****************************************************************************
-avtImgCommunicator::avtImgCommunicator()
+avtSLIVRImageCompositor::avtSLIVRImageCompositor()
 {
   #ifdef PARALLEL
     MPI_Comm_size(VISIT_MPI_COMM, &num_procs);
@@ -99,7 +99,7 @@ avtImgCommunicator::avtImgCommunicator()
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::~avtImgCommunicator
+//  Method: avtSLIVRImageCompositor::~avtSLIVRImageCompositor
 //
 //  Purpose:
 //
@@ -109,7 +109,7 @@ avtImgCommunicator::avtImgCommunicator()
 //  Modifications:
 //
 // ****************************************************************************
-avtImgCommunicator::~avtImgCommunicator()
+avtSLIVRImageCompositor::~avtSLIVRImageCompositor()
 {
     if (my_id == 0)
     {
@@ -121,7 +121,7 @@ avtImgCommunicator::~avtImgCommunicator()
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::
+//  Method: avtSLIVRImageCompositor::
 //
 //  Purpose:
 //    Barrier, useful for debugging
@@ -132,7 +132,7 @@ avtImgCommunicator::~avtImgCommunicator()
 //  Modifications:
 //
 // ****************************************************************************
-void avtImgCommunicator::barrier(){
+void avtSLIVRImageCompositor::barrier(){
   #ifdef PARALLEL
     MPI_Barrier( MPI_COMM_WORLD );
   #endif
@@ -141,7 +141,7 @@ void avtImgCommunicator::barrier(){
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::getcompositedImage
+//  Method: avtSLIVRImageCompositor::getcompositedImage
 //
 //  Purpose:
 //      Returns the whole image if needed
@@ -152,7 +152,7 @@ void avtImgCommunicator::barrier(){
 //  Modifications:
 //
 // ****************************************************************************
-void avtImgCommunicator::getcompositedImage(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage)
+void avtSLIVRImageCompositor::getcompositedImage(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage)
 {
     for (int i=0; i< imgBufferHeight; i++)
         for (int j=0; j<imgBufferWidth; j++){
@@ -172,7 +172,7 @@ void avtImgCommunicator::getcompositedImage(int imgBufferWidth, int imgBufferHei
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::
+//  Method: avtSLIVRImageCompositor::
 //
 //  Purpose:
 //       Fills an image with a specific color
@@ -184,7 +184,7 @@ void avtImgCommunicator::getcompositedImage(int imgBufferWidth, int imgBufferHei
 //
 // ****************************************************************************
 void
-avtImgCommunicator::colorImage(float *& srcImage, int widthSrc, int heightSrc, float _color[4])
+avtSLIVRImageCompositor::colorImage(float *& srcImage, int widthSrc, int heightSrc, float _color[4])
 {
     for (int _y=0; _y<heightSrc; _y++)
         for (int _x=0; _x<widthSrc; _x++)
@@ -201,7 +201,7 @@ avtImgCommunicator::colorImage(float *& srcImage, int widthSrc, int heightSrc, f
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::placeInImage
+//  Method: avtSLIVRImageCompositor::placeInImage
 //
 //  Purpose:
 //      Puts srcImage into dstImage
@@ -213,7 +213,7 @@ avtImgCommunicator::colorImage(float *& srcImage, int widthSrc, int heightSrc, f
 //
 // ****************************************************************************
 void
-avtImgCommunicator::placeInImage(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
+avtSLIVRImageCompositor::placeInImage(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
 {
     int widthSrc, heightSrc, widthDst;
     widthSrc  = srcExtents[1] - srcExtents[0];
@@ -240,7 +240,7 @@ avtImgCommunicator::placeInImage(float * srcImage, int srcExtents[4], float *& d
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::blendWithBackground
+//  Method: avtSLIVRImageCompositor::blendWithBackground
 //
 //  Purpose:
 //      Blends _image with the backgroundColor
@@ -252,7 +252,7 @@ avtImgCommunicator::placeInImage(float * srcImage, int srcExtents[4], float *& d
 //
 // **************************************************************************
 void
-avtImgCommunicator::blendWithBackground(float *_image, int extents[4], float backgroundColor[4])
+avtSLIVRImageCompositor::blendWithBackground(float *_image, int extents[4], float backgroundColor[4])
 {
     int numPixels = (extents[3]-extents[2]) * (extents[1]-extents[0]);
 
@@ -271,7 +271,7 @@ avtImgCommunicator::blendWithBackground(float *_image, int extents[4], float bac
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::
+//  Method: avtSLIVRImageCompositor::
 //
 //  Purpose:
 //      Blends tow patches in a front to back manner
@@ -283,7 +283,7 @@ avtImgCommunicator::blendWithBackground(float *_image, int extents[4], float bac
 //
 // **************************************************************************
 void
-avtImgCommunicator::blendFrontToBack(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4])
+avtSLIVRImageCompositor::blendFrontToBack(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4])
 {
     int widthSrc, heightSrc, widthDst;
     widthSrc  = srcExtents[1] - srcExtents[0];
@@ -313,7 +313,7 @@ avtImgCommunicator::blendFrontToBack(float * srcImage, int srcExtents[4], int bl
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::
+//  Method: avtSLIVRImageCompositor::
 //
 //  Purpose:
 //      Blends tow patches in a back to front manner
@@ -325,7 +325,7 @@ avtImgCommunicator::blendFrontToBack(float * srcImage, int srcExtents[4], int bl
 //
 // **************************************************************************
 void
-avtImgCommunicator::blendBackToFront(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4])
+avtSLIVRImageCompositor::blendBackToFront(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4])
 {
     int widthSrc, heightSrc, widthDst;
     widthSrc  = srcExtents[1] - srcExtents[0];
@@ -350,7 +350,7 @@ avtImgCommunicator::blendBackToFront(float * srcImage, int srcExtents[4], int bl
 }
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::
+//  Method: avtSLIVRImageCompositor::
 //
 //  Purpose:
 //      Blends tow patches in a front to back manner
@@ -362,7 +362,7 @@ avtImgCommunicator::blendBackToFront(float * srcImage, int srcExtents[4], int bl
 //
 // **************************************************************************
 void
-avtImgCommunicator::blendFrontToBack(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
+avtSLIVRImageCompositor::blendFrontToBack(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
 {
     int widthSrc, heightSrc, widthDst;
     widthSrc  = srcExtents[1] - srcExtents[0];
@@ -396,7 +396,7 @@ avtImgCommunicator::blendFrontToBack(float * srcImage, int srcExtents[4], float
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::
+//  Method: avtSLIVRImageCompositor::
 //
 //  Purpose:
 //      Blends tow patches in a back to front manner
@@ -408,7 +408,7 @@ avtImgCommunicator::blendFrontToBack(float * srcImage, int srcExtents[4], float
 //
 // **************************************************************************
 void
-avtImgCommunicator::blendBackToFront(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
+avtSLIVRImageCompositor::blendBackToFront(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
 {
     int widthSrc, heightSrc, widthDst;
     widthSrc  = srcExtents[1] - srcExtents[0];
@@ -441,7 +441,7 @@ avtImgCommunicator::blendBackToFront(float * srcImage, int srcExtents[4], float
 }
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::regionAllocation
+//  Method: avtSLIVRImageCompositor::regionAllocation
 //
 //  Purpose:
 //      Arbitrarily allocates regions to MPI ranks
@@ -453,7 +453,7 @@ avtImgCommunicator::blendBackToFront(float * srcImage, int srcExtents[4], float
 //
 // ***************************************************************************
 void
-avtImgCommunicator::regionAllocation(int numMPIRanks, int *& regions)
+avtSLIVRImageCompositor::regionAllocation(int numMPIRanks, int *& regions)
 {
     regions = new int[numMPIRanks];
 
@@ -463,7 +463,7 @@ avtImgCommunicator::regionAllocation(int numMPIRanks, int *& regions)
 }
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::
+//  Method: avtSLIVRImageCompositor::
 //
 //  Purpose:
 //
@@ -474,7 +474,7 @@ avtImgCommunicator::regionAllocation(int numMPIRanks, int *& regions)
 //
 // **************************************************************************
 void
-avtImgCommunicator::updateBoundingBox(int currentBoundingBox[4], int imageExtents[4])
+avtSLIVRImageCompositor::updateBoundingBox(int currentBoundingBox[4], int imageExtents[4])
 {
     if ( (currentBoundingBox[0] == 0 && currentBoundingBox[1] == 0) && (currentBoundingBox[2] == 0 && currentBoundingBox[3] == 0))
     {
@@ -501,7 +501,7 @@ avtImgCommunicator::updateBoundingBox(int currentBoundingBox[4], int imageExtent
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::gatherDepthAtRoot
+//  Method: avtSLIVRImageCompositor::gatherDepthAtRoot
 //
 //  Purpose:
 //      Used by Serial Direct Send
@@ -513,7 +513,7 @@ avtImgCommunicator::updateBoundingBox(int currentBoundingBox[4], int imageExtent
 //
 // **************************************************************************
 void
-avtImgCommunicator::gatherDepthAtRoot(int numlocalPatches, float *localPatchesDepth, int &totalPatches, int *& patchCountPerRank, float *& allPatchesDepth)
+avtSLIVRImageCompositor::gatherDepthAtRoot(int numlocalPatches, float *localPatchesDepth, int &totalPatches, int *& patchCountPerRank, float *& allPatchesDepth)
 {
   #ifdef PARALLEL
     //
@@ -563,7 +563,7 @@ avtImgCommunicator::gatherDepthAtRoot(int numlocalPatches, float *localPatchesDe
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::serialDirectSend
+//  Method: avtSLIVRImageCompositor::serialDirectSend
 //
 //  Purpose:
 //      A very simple compositing that we can fall back to if Parallel direct send is buggy.
@@ -576,7 +576,7 @@ avtImgCommunicator::gatherDepthAtRoot(int numlocalPatches, float *localPatchesDe
 //
 // **************************************************************************
 void
-avtImgCommunicator::serialDirectSend(int numPatches, float *localPatchesDepth, int *extents, float *imgData, float backgroundColor[4], int width, int height)
+avtSLIVRImageCompositor::serialDirectSend(int numPatches, float *localPatchesDepth, int *extents, float *imgData, float backgroundColor[4], int width, int height)
 {
   #ifdef PARALLEL
     //debug5 << "serialDirectSend" << std::endl;
@@ -699,7 +699,7 @@ avtImgCommunicator::serialDirectSend(int numPatches, float *localPatchesDepth, i
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::parallelDirectSend
+//  Method: avtSLIVRImageCompositor::parallelDirectSend
 //
 //  Purpose:
 //      Parallel Direct Send rendering that can blend convex patches from each MPI rank.
@@ -712,7 +712,7 @@ avtImgCommunicator::serialDirectSend(int numPatches, float *localPatchesDepth, i
 //
 // **************************************************************************
 void
-avtImgCommunicator::parallelDirectSend(float *imgData, int imgExtents[4], int region[], int numRegions, int tags[2], int fullImageExtents[4])
+avtSLIVRImageCompositor::parallelDirectSend(float *imgData, int imgExtents[4], int region[], int numRegions, int tags[2], int fullImageExtents[4])
 {
   #ifdef PARALLEL
     //
@@ -998,7 +998,7 @@ avtImgCommunicator::parallelDirectSend(float *imgData, int imgExtents[4], int re
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::findRegionsForPatch
+//  Method: avtSLIVRImageCompositor::findRegionsForPatch
 //
 //  Purpose:
 //      Needed by Parallel Direct Send to determine the regions a patch will overlap
@@ -1010,7 +1010,7 @@ avtImgCommunicator::parallelDirectSend(float *imgData, int imgExtents[4], int re
 //
 // **************************************************************************
 int
-avtImgCommunicator::findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to)
+avtSLIVRImageCompositor::findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to)
 {
     from = to = 0;
     if (patchExtents[1]-patchExtents[0] <=0 || patchExtents[3]-patchExtents[2] <=0)
@@ -1051,7 +1051,7 @@ avtImgCommunicator::findRegionsForPatch(int patchExtents[4], int screenProjected
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::computeRegionExtents
+//  Method: avtSLIVRImageCompositor::computeRegionExtents
 //
 //  Purpose:
 //      Compute extents for each region
@@ -1063,7 +1063,7 @@ avtImgCommunicator::findRegionsForPatch(int patchExtents[4], int screenProjected
 //
 // **************************************************************************
 void
-avtImgCommunicator::computeRegionExtents(int numRanks, int height)
+avtSLIVRImageCompositor::computeRegionExtents(int numRanks, int height)
 {
     int regionHeight = round((float)height/numRanks);
     regularRegionSize = regionHeight;
@@ -1093,7 +1093,7 @@ avtImgCommunicator::computeRegionExtents(int numRanks, int height)
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::parallelDirectSendManyPatches
+//  Method: avtSLIVRImageCompositor::parallelDirectSendManyPatches
 //
 //  Purpose:
 //      Parallel Direct Send rendering that can blend individual patches
@@ -1105,7 +1105,7 @@ avtImgCommunicator::computeRegionExtents(int numRanks, int height)
 //
 // **************************************************************************
 int
-avtImgCommunicator::parallelDirectSendManyPatches(std::multimap<int, imgData> imgDataHashMap, std::vector<imgMetaData> imageMetaPatchVector, int numPatches, int region[], int numRegions, int tags[2], int fullImageExtents[4])
+avtSLIVRImageCompositor::parallelDirectSendManyPatches(std::multimap<int, imgData> imgDataHashMap, std::vector<imgMetaData> imageMetaPatchVector, int numPatches, int region[], int numRegions, int tags[2], int fullImageExtents[4])
 {
     int myRegionHeight = 0;
   #ifdef PARALLEL
@@ -1539,7 +1539,7 @@ avtImgCommunicator::parallelDirectSendManyPatches(std::multimap<int, imgData> im
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::gatherImages
+//  Method: avtSLIVRImageCompositor::gatherImages
 //
 //  Purpose:
 //      Gather images from Parallel Direct Send
@@ -1551,7 +1551,7 @@ avtImgCommunicator::parallelDirectSendManyPatches(std::multimap<int, imgData> im
 //
 // **************************************************************************
 void
-avtImgCommunicator::gatherImages(int regionGather[], int totalNumRanks, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight)
+avtSLIVRImageCompositor::gatherImages(int regionGather[], int totalNumRanks, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight)
 {
   #ifdef PARALLEL
     debug5 << "gatherImages starting... totalNumRanks: " << totalNumRanks << ", compositingDone: " << compositingDone
diff --git a/avt/Filters/avtImgCommunicator.h b/avt/Filters/avtSLIVRImageCompositor.h
similarity index 94%
rename from avt/Filters/avtImgCommunicator.h
rename to avt/Filters/avtSLIVRImageCompositor.h
index 4a69d2231b..b413d6ffa5 100644
--- a/avt/Filters/avtImgCommunicator.h
+++ b/avt/Filters/avtSLIVRImageCompositor.h
@@ -37,18 +37,20 @@
 *****************************************************************************/
 
 // ************************************************************************* //
-//                          avtImgCommunicator.h                             //
+//                          avtSLIVRImageCompositor.h                        //
 // ************************************************************************* //
 
-#ifndef AVT_IMG_COMMUNICATOR_H
-#define AVT_IMG_COMMUNICATOR_H
+#ifndef AVT_SLIVR_IMAGE_COMPOSITOR_H
+#define AVT_SLIVR_IMAGE_COMPOSITOR_H
 
 #include <filters_exports.h>
 #include <pipeline_exports.h>
-#include <imgMetaData.h>
-#include <avtSamplePointExtractor.h>
+
+#include <avtSLIVRCommon.h>
+
 #include <algorithm>
 #include <string>
+#include <map>
 
 #ifdef PARALLEL
 #   include <mpi.h>
@@ -76,7 +78,7 @@ struct imageBuffer{
 //
 // ****************************************************************************
 
-class avtImgCommunicator
+class avtSLIVRImageCompositor
 {
     int num_procs;
     int my_id;
@@ -130,10 +132,10 @@ public:
     int intermediateImageBB[4];
 
 
-    avtImgCommunicator();
-    ~avtImgCommunicator();
+    avtSLIVRImageCompositor();
+    ~avtSLIVRImageCompositor();
 
-    virtual const char *GetType(void) { return "avtImgCommunicator"; };
+    virtual const char *GetType(void) { return "avtSLIVRImageCompositor"; };
     virtual const char *GetDescription(void) { return "Doing compositing for ray casting SLIVR";};
 
     int clamp(int value, int _min, int _max){ return std::max( std::min(value,_max), _min); }
diff --git a/avt/Filters/avtSLIVRRayTracer.C b/avt/Filters/avtSLIVRRayTracer.C
index d4eef7ac12..68b393ec9b 100644
--- a/avt/Filters/avtSLIVRRayTracer.C
+++ b/avt/Filters/avtSLIVRRayTracer.C
@@ -85,7 +85,6 @@ bool SLIVRsortImgMetaDataByEyeSpaceDepth(imgMetaData const& before, imgMetaData
 
 avtSLIVRRayTracer::avtSLIVRRayTracer() : avtRayTracerBase()
 {
-
     panPercentage[0] = 0;
     panPercentage[1] = 0;
     lighting = false;
@@ -250,7 +249,6 @@ avtSLIVRRayTracer::Execute()
     extractor.SetTransferFn(transferFn1D);
     extractor.SetInput(trans.GetOutput());
 
-
     //
     // Ray casting: SLIVR ~ Before Rendering
     //
@@ -271,6 +269,7 @@ avtSLIVRRayTracer::Execute()
 
     //
     // Camera Settings
+    //
     vtkCamera *sceneCam = vtkCamera::New();
     sceneCam->SetPosition(view.camera[0],view.camera[1],view.camera[2]);
     sceneCam->SetFocalPoint(view.focus[0],view.focus[1],view.focus[2]);
diff --git a/avt/Filters/avtSLIVRRayTracer.h b/avt/Filters/avtSLIVRRayTracer.h
index cd1b4abfc7..7082831d3a 100644
--- a/avt/Filters/avtSLIVRRayTracer.h
+++ b/avt/Filters/avtSLIVRRayTracer.h
@@ -46,7 +46,7 @@
 #include <filters_exports.h>
 
 #include <avtRayTracerBase.h>
-#include <avtImgCommunicator.h>
+#include <avtSLIVRImageCompositor.h>
 
 class   vtkMatrix4x4;
 
@@ -116,7 +116,7 @@ class AVTFILTERS_API avtSLIVRRayTracer : public avtRayTracerBase
 
     virtual void          Execute(void);
 
-    avtImgCommunicator    imgComm;
+    avtSLIVRImageCompositor    imgComm;
     bool                  lighting;
     double                lightPosition[4];
     double                lightDirection[3];
diff --git a/avt/Filters/avtSLIVRSamplePointExtractor.C b/avt/Filters/avtSLIVRSamplePointExtractor.C
index 6c15476ff7..fa078a7f2c 100644
--- a/avt/Filters/avtSLIVRSamplePointExtractor.C
+++ b/avt/Filters/avtSLIVRSamplePointExtractor.C
@@ -124,7 +124,10 @@ avtSLIVRSamplePointExtractor::avtSLIVRSamplePointExtractor(int w, int h, int d)
     : avtSamplePointExtractorBase(w, h, d)
 {
     slivrVoxelExtractor = NULL;
+
     patchCount = 0;
+    imageMetaPatchVector.clear();
+    imgDataHashMap.clear();
 
     modelViewProj = vtkMatrix4x4::New();
 
@@ -177,7 +180,6 @@ avtSLIVRSamplePointExtractor::~avtSLIVRSamplePointExtractor()
     delImgPatches();
 }
 
-
 // ****************************************************************************
 //  Method: avtSLIVRSamplePointExtractor::SetUpExtractors
 //
@@ -239,8 +241,9 @@ avtSLIVRSamplePointExtractor::SetUpExtractors(void)
     {
         delete slivrVoxelExtractor;
     }
-    slivrVoxelExtractor = new avtSLIVRVoxelExtractor(width, height, depth, volume,cl);
-//    slivrVoxelExtractor->SetJittering(jitter);
+    slivrVoxelExtractor = new avtSLIVRVoxelExtractor(width, height, depth,
+                                                                                                         volume,cl);
+    //slivrVoxelExtractor->SetJittering(jitter);
     if (shouldDoTiling)
     {
         slivrVoxelExtractor->Restrict(width_min, width_max-1,
@@ -249,6 +252,32 @@ avtSLIVRSamplePointExtractor::SetUpExtractors(void)
 }
 
 // ****************************************************************************
+//  Method: avtSLIVRSamplePointExtractor::InitSampling
+//
+//  Purpose:
+//      Initialize sampling, called by base class ExecuteTree method before.
+//      the actual iteration starts. This function might be useful for
+//      children classes
+//
+//  Arguments:
+//      dt      The dataset tree that should be processed.
+//
+//  Programmer: Qi WU 
+//  Creation:   April 18, 2018
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void
+avtSLIVRSamplePointExtractor::InitSampling(avtDataTree_p dt)
+{
+    patchCount = 0;
+    imageMetaPatchVector.clear();
+    imgDataHashMap.clear();
+}
+
+// ****************************************************************************
 //  Method: avtSLIVRSamplePointExtractor::DoSampling
 //
 //  Purpose:
@@ -268,18 +297,9 @@ avtSLIVRSamplePointExtractor::SetUpExtractors(void)
 void
 avtSLIVRSamplePointExtractor::DoSampling(vtkDataSet *ds, int idx)
 {
-    //initialize sampling state
-    patchCount = 0;
-    imageMetaPatchVector.clear();
-    imgDataHashMap.clear();
-
     double _scalarRange[2];
     ds->GetScalarRange(_scalarRange);
 
-    double _tfRange[2];
-    _tfRange[0] = transferFn1D->GetMin();
-    _tfRange[1] = transferFn1D->GetMax();
-
     double _tfVisibleRange[2];
     _tfVisibleRange[0] = transferFn1D->GetMinVisibleScalar();
     _tfVisibleRange[1] = transferFn1D->GetMaxVisibleScalar();
@@ -322,7 +342,7 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
 {
     StackTimer t0("avtSLIVRSamplePointExtractor::RasterBasedSample");
 
-    //debug5 << PAR_Rank() << " avtSLIVRSamplePointExtractor::RasterBasedSample  " << num << std::endl;
+    
     if (ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
     {
         avtDataAttributes &atts = GetInput()->GetInfo().GetAttributes();
@@ -339,15 +359,16 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
             varsizes.push_back(samples->GetVariableSize(i));
         }
 
-        // Use SLIVR mass voxel extractor.
-
         //
         // Compositing Setup
+        //
         slivrVoxelExtractor->SetGridsAreInWorldSpace(
-            rectilinearGridsAreInWorldSpace, viewInfo, aspect, xform);
+            rectilinearGridsAreInWorldSpace, view, aspect, xform);
 
-        slivrVoxelExtractor->setDepthBuffer(depthBuffer, bufferExtents[1]*bufferExtents[3]);
-        slivrVoxelExtractor->setRGBBuffer(rgbColorBuffer, bufferExtents[1],bufferExtents[3]);
+        slivrVoxelExtractor->setDepthBuffer(depthBuffer,
+                                            bufferExtents[1]*bufferExtents[3]);
+        slivrVoxelExtractor->setRGBBuffer(rgbColorBuffer,
+                                          bufferExtents[1],bufferExtents[3]);
         slivrVoxelExtractor->setBufferExtents(bufferExtents);
 
         slivrVoxelExtractor->SetViewDirection(view_direction);
@@ -363,11 +384,9 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
         slivrVoxelExtractor->SetMatProperties(materialProperties);
         slivrVoxelExtractor->SetTransferFn(transferFn1D);
 
-        //debug5 << PAR_Rank() << " avtSLIVRSamplePointExtractor::RasterBasedSample extract ...  " << num << std::endl;
-
-        slivrVoxelExtractor->Extract((vtkRectilinearGrid *) ds, varnames, varsizes);
 
-        //debug5 << PAR_Rank() << " avtSLIVRSamplePointExtractor::RasterBasedSample extract done!" << num << std::endl;
+        slivrVoxelExtractor->Extract((vtkRectilinearGrid *) ds,
+                                                                         varnames, varsizes);
 
         //
         // Get rendering results
@@ -375,7 +394,12 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
         imgMetaData      tmpImageMetaPatch;
         tmpImageMetaPatch = initMetaPatch(patchCount);
 
-        slivrVoxelExtractor->getImageDimensions(tmpImageMetaPatch.inUse, tmpImageMetaPatch.dims, tmpImageMetaPatch.screen_ll, tmpImageMetaPatch.screen_ur, tmpImageMetaPatch.eye_z, tmpImageMetaPatch.clip_z);
+        slivrVoxelExtractor->getImageDimensions(tmpImageMetaPatch.inUse,
+                                                                                                tmpImageMetaPatch.dims,
+                                                                                                tmpImageMetaPatch.screen_ll,
+                                                                                                tmpImageMetaPatch.screen_ur,
+                                                                                                tmpImageMetaPatch.eye_z,
+                                                                                                tmpImageMetaPatch.clip_z);
         if (tmpImageMetaPatch.inUse == 1)
         {
             tmpImageMetaPatch.avg_z = tmpImageMetaPatch.eye_z;
@@ -385,11 +409,14 @@ avtSLIVRSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
             imgData tmpImageDataHash;
             tmpImageDataHash.procId = tmpImageMetaPatch.procId;
             tmpImageDataHash.patchNumber = tmpImageMetaPatch.patchNumber;
-            tmpImageDataHash.imagePatch = new float[ tmpImageMetaPatch.dims[0]*tmpImageMetaPatch.dims[1] * 4 ];
+            tmpImageDataHash.imagePatch =
+                                new float[tmpImageMetaPatch.dims[0] *
+                                                  tmpImageMetaPatch.dims[1] * 4];
 
             slivrVoxelExtractor->getComputedImage(tmpImageDataHash.imagePatch);
-            imgDataHashMap.insert( std::pair<int, imgData> (tmpImageDataHash.patchNumber , tmpImageDataHash) );
-            //writeArrayToPPM("/home/pascal/Desktop/debugImages/local_" + toStr(tmpImageMetaPatch.procId) + "_"+ toStr(tmpImageMetaPatch.patchNumber), tmpImageDataHash.imagePatch, tmpImageMetaPatch.dims[0], tmpImageMetaPatch.dims[1]);
+            imgDataHashMap.insert
+                                (std::pair<int, imgData>(tmpImageDataHash.patchNumber,
+                                                                                 tmpImageDataHash));
 
             patchCount++;
         }
diff --git a/avt/Filters/avtSLIVRSamplePointExtractor.h b/avt/Filters/avtSLIVRSamplePointExtractor.h
index 371d231158..e4e13d9209 100644
--- a/avt/Filters/avtSLIVRSamplePointExtractor.h
+++ b/avt/Filters/avtSLIVRSamplePointExtractor.h
@@ -52,7 +52,7 @@
 
 #include <vtkMatrix4x4.h>
 
-#include <imgMetaData.h>
+#include <avtSLIVRCommon.h>
 
 class  avtSLIVRVoxelExtractor;
 
@@ -163,10 +163,13 @@ class AVTFILTERS_API avtSLIVRSamplePointExtractor
     typedef std::multimap<int, imgData>::iterator iter_t;
 
   protected:
+    virtual void              InitSampling(avtDataTree_p dt);
     virtual void              DoSampling(vtkDataSet *, int);
     virtual void              SetUpExtractors(void);
     virtual void              SendJittering(void);
-    virtual bool              FilterUnderstandsTransformedRectMesh(void);
+    virtual bool              FilterUnderstandsTransformedRectMesh(void);   
+    void                      RasterBasedSample(vtkDataSet *, int num=0);
+    imgMetaData               initMetaPatch(int id);    // initialize a patch
 
     double                    minMaxSpatialBounds[6];
     double                    avgPatchExtents[3];
@@ -192,9 +195,6 @@ class AVTFILTERS_API avtSLIVRSamplePointExtractor
     double                    lightDirection[3];
     double                    materialProperties[4];
 
-    imgMetaData               initMetaPatch(int id);    // initialize a patch
-
-    void                      RasterBasedSample(vtkDataSet *, int num=0);
 };
 
 
diff --git a/avt/Filters/avtSLIVRVoxelExtractor.C b/avt/Filters/avtSLIVRVoxelExtractor.C
index a35f629c9b..31d376a0ae 100644
--- a/avt/Filters/avtSLIVRVoxelExtractor.C
+++ b/avt/Filters/avtSLIVRVoxelExtractor.C
@@ -37,7 +37,7 @@
 *****************************************************************************/
 
 // ************************************************************************* //
-//                            avtSLIVRVoxelExtractor.C                        //
+//                            avtSLIVRVoxelExtractor.C                       //
 // ************************************************************************* //
 
 #include <avtSLIVRVoxelExtractor.h>
diff --git a/avt/Filters/avtSLIVRVoxelExtractor.h b/avt/Filters/avtSLIVRVoxelExtractor.h
index 3e17c52e5b..3fd3dd3133 100644
--- a/avt/Filters/avtSLIVRVoxelExtractor.h
+++ b/avt/Filters/avtSLIVRVoxelExtractor.h
@@ -46,7 +46,7 @@
 #include <filters_exports.h>
 
 #include <avtVoxelExtractor.h>
-
+#include <avtSLIVRCommon.h>
 #include <avtOpacityMap.h>
 
 #include <DebugStream.h>
@@ -59,7 +59,7 @@ class     vtkMatrix4x4;
 #include <stdlib.h>
 #include <stdio.h>
 #include <algorithm>
-#include "imgMetaData.h"
+
 
 // ****************************************************************************
 //  Class: avtSLIVRVoxelExtractor
diff --git a/avt/Filters/avtSamplePointExtractor.C b/avt/Filters/avtSamplePointExtractor.C
index a599aaac79..52a67bff5d 100644
--- a/avt/Filters/avtSamplePointExtractor.C
+++ b/avt/Filters/avtSamplePointExtractor.C
@@ -628,7 +628,7 @@ avtSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
         }
 
         massVoxelExtractor->SetGridsAreInWorldSpace(
-            rectilinearGridsAreInWorldSpace, viewInfo, aspect, xform);
+            rectilinearGridsAreInWorldSpace, view, aspect, xform);
         massVoxelExtractor->SetTransferFn(transferFn1D);
         massVoxelExtractor->Extract((vtkRectilinearGrid *) ds, varnames, varsizes);
         return;
diff --git a/avt/Filters/avtSamplePointExtractorBase.C b/avt/Filters/avtSamplePointExtractorBase.C
index 15a70c1348..3f85520548 100644
--- a/avt/Filters/avtSamplePointExtractorBase.C
+++ b/avt/Filters/avtSamplePointExtractorBase.C
@@ -190,7 +190,7 @@ avtSamplePointExtractorBase::SetRectilinearGridsAreInWorldSpace(bool val,
                  const avtViewInfo &v, double a)
 {
     rectilinearGridsAreInWorldSpace = val;
-    viewInfo = v;
+    view = v;
     aspect = a;
 }
 
@@ -207,7 +207,8 @@ avtSamplePointExtractorBase::SetRectilinearGridsAreInWorldSpace(bool val,
 // ****************************************************************************
 
 void
-avtSamplePointExtractorBase::RestrictToTile(int wmin, int wmax, int hmin, int hmax)
+avtSamplePointExtractorBase::RestrictToTile(int wmin, int wmax,
+                                                                                        int hmin, int hmax)
 {
     shouldDoTiling = true;
     width_min  = wmin;
@@ -338,28 +339,38 @@ struct datatree_childindex
 void
 avtSamplePointExtractorBase::ExecuteTree(avtDataTree_p dt)
 {
-    StackTimer t0(std::string(GetType()) + std::string("::ExecuteTree"));
+    /////////////////////////
+    // Check memory before //
+    /////////////////////////
+    if (DebugStream::Level5())
+    { 
+        unsigned long m_size, m_rss;
+        avtMemory::GetMemorySize(m_size, m_rss);
+        debug5 << "RAR_Rank: " << PAR_Rank() << " "
+               << GetType() << "::ExecuteTree " 
+               << " Initial Memory Usage: "
+               << m_size << " rss (MB): "
+               << m_rss/(1024*1024) << endl;
+    }
 
-    //check memory
-    unsigned long m_size, m_rss;
-    avtMemory::GetMemorySize(m_size, m_rss);
-    debug5 << PAR_Rank() << " ~ " << GetType() << "::ExecuteTree  .. .  " 
-           << "    Memory use before: " << m_size << "  rss (MB): "
-           << m_rss/(1024*1024) << endl;
+    //
+    // Start timing
+    //
+    StackTimer t0(std::string(GetType()) + std::string("::ExecuteTree"));
 
+    //
+    // Call this function for initialization if necessary by children classes
+    //
+    InitSampling(dt);   
 
     if (*dt == NULL || (dt->GetNChildren() <= 0 && (!(dt->HasData()))))
         return;
 
-    debug5 << " ~ " << GetType() << "::dt->GetNChildren()  "
-           << dt->GetNChildren() << endl;
-
     //
     // Process tree
-    std::stack<datatree_childindex*> nodes;
-
-    //iterative depth-first sampling
-    nodes.push(new datatree_childindex(dt,0));
+    //
+    std::stack<datatree_childindex*> nodes;    
+    nodes.push(new datatree_childindex(dt,0)); //iterative depth-first sampling
     while (!nodes.empty())
     {
         datatree_childindex *ci=nodes.top();
@@ -372,7 +383,8 @@ avtSamplePointExtractorBase::ExecuteTree(avtDataTree_p dt)
             {
                 if (ch->ChildIsPresent(i))
                 {
-                    if (*ch == NULL || (ch->GetNChildren() <= 0 && (!(ch->HasData()))))
+                    if (*ch == NULL || (ch->GetNChildren() <= 0 &&
+                                        (!(ch->HasData()))))
                         continue;
                     nodes.push(new datatree_childindex(ch->GetChild(i),i));
                 }
@@ -381,15 +393,12 @@ avtSamplePointExtractorBase::ExecuteTree(avtDataTree_p dt)
             continue;
         }
 
-        //do the work
         nodes.pop();
 
         if (*ch == NULL || (ch->GetNChildren() <= 0 && (!(ch->HasData()))))
             continue;
 
-        //
         // Get the dataset for this leaf in the tree.
-        //
         vtkDataSet *ds = ch->GetDataRepresentation().GetDataVTK();
 
         // Performed by derived classes
@@ -399,12 +408,19 @@ avtSamplePointExtractorBase::ExecuteTree(avtDataTree_p dt)
         currentNode++;
     }
 
-
-    //check memory after
-    avtMemory::GetMemorySize(m_size, m_rss);
-    debug5 << PAR_Rank() << " ~ Memory use after: " << m_size
-           << "  rss (MB): " << m_rss/(1024*1024)
-           <<  "   ... " << GetType() << "::ExecuteTree done@!!!" << endl;
+    /////////////////////////
+    // Check memory before //
+    /////////////////////////
+    if (DebugStream::Level5())
+    { 
+        unsigned long m_size, m_rss;
+        avtMemory::GetMemorySize(m_size, m_rss);
+        debug5 << "RAR_Rank: " << PAR_Rank() << " "
+               << GetType() << "::ExecuteTree " 
+               << " Final Memory Usage: "
+               << m_size << " rss (MB): "
+               << m_rss/(1024*1024) << endl;
+    }
 }
 
 
diff --git a/avt/Filters/avtSamplePointExtractorBase.h b/avt/Filters/avtSamplePointExtractorBase.h
index ce7fc8b00c..29656c95f9 100644
--- a/avt/Filters/avtSamplePointExtractorBase.h
+++ b/avt/Filters/avtSamplePointExtractorBase.h
@@ -166,7 +166,7 @@ class AVTFILTERS_API avtSamplePointExtractorBase
     bool                      jitter;
 
     bool                      rectilinearGridsAreInWorldSpace;
-    avtViewInfo               viewInfo;
+    avtViewInfo               view; // controlled by SetRectilinearGridsAreInWorldSpace
     double                    aspect;
 
     avtOpacityMap             *transferFn1D;
@@ -186,12 +186,14 @@ class AVTFILTERS_API avtSamplePointExtractorBase
       int                               nVars;
     } LoadingInfo;
 
-    void                      GetLoadingInfoForArrays(vtkDataSet *, LoadingInfo &);
+    void                      GetLoadingInfoForArrays(vtkDataSet *,
+                                                      LoadingInfo &);
 
     virtual bool              FilterUnderstandsTransformedRectMesh() = 0;
     virtual void              SetUpExtractors(void) = 0;
     virtual void              SendJittering(void) = 0;
     virtual void              DoSampling(vtkDataSet *ds, int idx) = 0;
+    virtual void              InitSampling(avtDataTree_p dt) {};
 
 };
 
diff --git a/avt/Pipeline/Data/avtOpacityMap.C b/avt/Pipeline/Data/avtOpacityMap.C
index a35f50db81..8f42c9bfbd 100644
--- a/avt/Pipeline/Data/avtOpacityMap.C
+++ b/avt/Pipeline/Data/avtOpacityMap.C
@@ -78,7 +78,7 @@ avtOpacityMap::avtOpacityMap(int te)
     tableEntries = te;
     table = new RGBA[tableEntries];
   
-    transferFn1D = new _RGBA[tableEntries]();
+    transferFn1D = new RGBAF[tableEntries]();
     // RGBA contains a padded byte after the B and before the A.  Use a memset
     // to make sure this inaccessible byte is initialized.  This will allow
     // us to avoid purify issues.
@@ -104,8 +104,8 @@ avtOpacityMap::avtOpacityMap(const avtOpacityMap &obj)
     tableEntries = obj.tableEntries;
     table = new RGBA[tableEntries];
     memcpy(table, obj.table, tableEntries * sizeof(RGBA));
-    transferFn1D = new _RGBA[tableEntries];
-    memcpy(transferFn1D, obj.transferFn1D, tableEntries * sizeof(_RGBA));
+    transferFn1D = new RGBAF[tableEntries];
+    memcpy(transferFn1D, obj.transferFn1D, tableEntries * sizeof(RGBAF));
     min = obj.min;
     max = obj.max;
     range = obj.range;
@@ -122,8 +122,8 @@ void avtOpacityMap::operator = (const avtOpacityMap &obj)
     tableEntries = obj.tableEntries;
     table = new RGBA[tableEntries];
     memcpy(table, obj.table, tableEntries * sizeof(RGBA));
-    transferFn1D = new _RGBA[tableEntries];
-    memcpy(transferFn1D, obj.transferFn1D, tableEntries * sizeof(_RGBA));
+    transferFn1D = new RGBAF[tableEntries];
+    memcpy(transferFn1D, obj.transferFn1D, tableEntries * sizeof(RGBAF));
     min = obj.min;
     max = obj.max;
     range = obj.range;
@@ -270,7 +270,7 @@ avtOpacityMap::SetTable(unsigned char *arr, int te, double attenuation)
 
     tableEntries = te;
     table = new RGBA[tableEntries];
-    transferFn1D = new _RGBA[tableEntries];
+    transferFn1D = new RGBAF[tableEntries];
     for (int i = 0 ; i < tableEntries ; i++)
     {
         table[i].R = arr[i*4];
@@ -378,7 +378,7 @@ avtOpacityMap::SetTableFloat(unsigned char *arr, int te, double attenuation, flo
     }
 
     tableEntries = te;
-    transferFn1D = new _RGBA[tableEntries]();
+    transferFn1D = new RGBAF[tableEntries]();
     minVisibleScalarIndex =  maxVisibleScalarIndex = -1;
     for (int i = 0 ; i < tableEntries ; i++)
     {
@@ -392,21 +392,76 @@ avtOpacityMap::SetTableFloat(unsigned char *arr, int te, double attenuation, flo
         transferFn1D[i].A = alpha;
         if (alpha != 0 && minVisibleScalarIndex == -1){
             minVisibleScalarIndex = i;
-            //debug5 << "starting alpha = 0 at i= " << i << std::endl;
         }
 
-        //debug5 << i << " : " << transferFn1D[i].R << ", " << transferFn1D[i].G << ", " << transferFn1D[i].B <<  ", " << transferFn1D[i].A << std::endl;
     }
     for (int i=tableEntries-1; i>=0; i--)
     {
         if (transferFn1D[i].A != 0 && maxVisibleScalarIndex == -1){
             maxVisibleScalarIndex = i;
-            //debug5 << "ending alpha = 0 at i= " << i << std::endl;
         }
     }
 
+    //
+    // We need to set the intermediate vars again since the table size has
+    // potentially changed.
+    //
+    SetIntermediateVars();
+}
 
-    //debug5 << "minVisibleScalarIndex: " << minVisibleScalarIndex << "   maxVisibleScalarIndex: " << maxVisibleScalarIndex << std::endl;
+
+// ****************************************************************************
+//  Method: avtOpacityMap::SetTableFloatNOC
+//
+//  Purpose:
+//      A version of function SetTableFloat that does not apply the opacity
+//      correction term to it
+//
+//  Arguments:
+//      arr             The new table in RGBA format.
+//      te              The number of entries in arr.
+//      attenuation     The attenuation parameter specified
+//      over            Reducing based on the number of slices
+//
+//  Programmer: Qi WU
+//  Creation:   Sat Jun 10 22:21:27 MST 2018
+//
+// ****************************************************************************
+void
+avtOpacityMap::SetTableFloatNOC(unsigned char *arr, int te, double attenuation)
+{
+    if (attenuation < -1. || attenuation > 1.)
+    {
+        debug1 << "Bad attenuation value " << attenuation << std::endl;
+        EXCEPTION0(ImproperUseException);
+    }
+
+    if (transferFn1D != NULL) { delete [] transferFn1D; }
+
+    tableEntries = te;
+    transferFn1D = new RGBAF[tableEntries]();
+    minVisibleScalarIndex = maxVisibleScalarIndex = -1;
+
+    for (int i = 0 ; i < tableEntries ; i++)
+    {
+        double bp = tan(1.570796327 * (0.5 - attenuation*0.49999));
+        double alpha = pow((float) arr[i*4+3]/255.0f, (float)bp);
+        transferFn1D[i].R = (float)arr[i*4+0]/255.0f;
+        transferFn1D[i].G = (float)arr[i*4+1]/255.0f;
+        transferFn1D[i].B = (float)arr[i*4+2]/255.0f;
+        transferFn1D[i].A = alpha;
+        if (transferFn1D[i].A != 0 && minVisibleScalarIndex == -1) {
+            minVisibleScalarIndex = i;
+        }
+
+    }
+
+    for (int i=tableEntries-1; i>=0; i--)
+    {
+        if (transferFn1D[i].A != 0 && maxVisibleScalarIndex == -1){
+            maxVisibleScalarIndex = i;
+        }
+    }
 
     //
     // We need to set the intermediate vars again since the table size has
@@ -414,6 +469,8 @@ avtOpacityMap::SetTableFloat(unsigned char *arr, int te, double attenuation, flo
     //
     SetIntermediateVars();
 }
+
+
 // ****************************************************************************
 //  Method: avtOpacityMap::GetMinVisibleScalar
 //
@@ -455,26 +512,35 @@ double avtOpacityMap::GetMaxVisibleScalar()
 //  Programmer: Pascal Grosset
 //  Creation:   July 14, 2016
 //
+//  Modifications:
+//
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Code formatting
+//
 // ****************************************************************************
-void avtOpacityMap::computeVisibleRange()
+void avtOpacityMap::ComputeVisibleRange()
 {
     double scalarRange = max - min;
     if (minVisibleScalarIndex == 0)
         minVisibleScalar =  min;
     else
-        minVisibleScalar = ( ((float)minVisibleScalarIndex/(tableEntries-1)) * scalarRange) + min;
+        minVisibleScalar = (((float)minVisibleScalarIndex/(tableEntries-1)) *
+                            scalarRange) + min;
     
-
-
     if (maxVisibleScalarIndex == tableEntries-1)
         maxVisibleScalar =  max;
     else
-        maxVisibleScalar = ( ((float)maxVisibleScalarIndex/(tableEntries-1)) * scalarRange) + min;
-
-
-     debug5 << "max: " << max << "  min: " << min << "  scalarRange: " << scalarRange << "  minVisibleScalarIndex: " << minVisibleScalarIndex <<
-             "  maxVisibleScalarIndex: " << maxVisibleScalarIndex << "   tableEntries: " << tableEntries << 
-             "  maxVisibleScalar: " << maxVisibleScalar << "   minVisibleScalar: " << minVisibleScalar << std::endl;
+        maxVisibleScalar = (((float)maxVisibleScalarIndex/(tableEntries-1)) * 
+                            scalarRange) + min;
+
+     debug5 << " max: " << max << " min: " << min 
+            << " scalarRange: " << scalarRange 
+            << " minVisibleScalarIndex: " << minVisibleScalarIndex 
+            << " maxVisibleScalarIndex: " << maxVisibleScalarIndex 
+            << " tableEntries: " << tableEntries
+            << " maxVisibleScalar: " << maxVisibleScalar 
+            << " minVisibleScalar: " << minVisibleScalar 
+            << std::endl;
 }
 
 // ****************************************************************************
@@ -535,9 +601,6 @@ avtOpacityMap::SetTable(RGBA *arr, int te, double attenuation)
 }
 
 
-
-
-
 // ****************************************************************************
 //  Method: avtOpacityMap::GetOpacity
 //
diff --git a/avt/Pipeline/Data/avtOpacityMap.h b/avt/Pipeline/Data/avtOpacityMap.h
index 3a430c1807..ccd31c74bf 100644
--- a/avt/Pipeline/Data/avtOpacityMap.h
+++ b/avt/Pipeline/Data/avtOpacityMap.h
@@ -54,7 +54,7 @@ struct RGBA
     float         A;
 };
 
-struct _RGBA
+struct RGBAF
 {
     float R;
     float G;
@@ -62,6 +62,8 @@ struct _RGBA
     float A;
 };
 
+// added by Qi, for using RGBAF nicely outside the function
+
 // ****************************************************************************
 //  Class: avtOpacityMap
 //
@@ -87,6 +89,11 @@ struct _RGBA
 //    Define private copy constructor and assignment operator to prevent
 //    accidental use of default, bitwise copy implementations.
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Add function 'SetTableFloatNOC' to generate a transfer function without
+//    the opacity correction term. This function will be used for OSPRay 
+//    volume rendering
+//
 // ****************************************************************************
 
 class PIPELINE_API avtOpacityMap
@@ -99,9 +106,14 @@ class PIPELINE_API avtOpacityMap
     void operator = (const avtOpacityMap &obj);
 
     const RGBA                  *GetTable(void) { return table; };
+    const RGBAF                 *GetTableFloat(void) { return transferFn1D; };
     void                         SetTable(unsigned char *, int, double = 1.);
-    void                         SetTable(unsigned char *arr, int te, double attenuation, float over);
-    void                         SetTableFloat(unsigned char *arr, int te, double attenuation, float over);
+    void                         SetTable(unsigned char *arr, int te, 
+                                               double attenuation, float over);
+    void                         SetTableFloat(unsigned char *arr, int te,
+                                               double attenuation, float over);
+    void                         SetTableFloatNOC(unsigned char *arr, int te,
+                                                           double attenuation);
     void                         SetTable(RGBA *, int, double = 1.);
     const RGBA                  &GetOpacity(double);
 
@@ -114,20 +126,21 @@ class PIPELINE_API avtOpacityMap
     double                       GetMinVisibleScalar();
     double                       GetMaxVisibleScalar();
     
-    void                         computeVisibleRange();
+    void                         ComputeVisibleRange();
 
     inline int                   Quantize(const double &);
     int                          GetNumberOfTableEntries(void)
                                                       { return tableEntries; };
 
     float                        QuantizeValF(const double &val);
-    int                          QueryTF(double scalarValue, double color[4]) const;
+    int                          QueryTF(double scalarValue, 
+                                         double color[4]) const;
     float                        QueryAlpha(double scalarValue) const;
 
-    friend PIPELINE_API ostream &operator << (ostream &, const avtOpacityMap &);
+    friend PIPELINE_API ostream &operator <<(ostream &, const avtOpacityMap &);
   protected:
     RGBA                        *table;
-    _RGBA                       *transferFn1D;
+    RGBAF                       *transferFn1D;
     int                          tableEntries;
 
     double                       max, min;
@@ -214,11 +227,13 @@ avtOpacityMap::QuantizeValF(const double &val){
 //  Method: avtOpacityMap::QueryTF
 //
 //  Purpose:
-//      Queries a Transfer function for the color based on the scalr value passed in 
+//      Queries a Transfer function for the color based on the scalr value
+//      passed in 
 //
 //  Arguments:
 //      scalarValue     scalar value
-//      color           the color queried from the transfer function based on the scalar value
+//      color           the color queried from the transfer function based on
+//                      the scalar value
 //
 //  Returns: 
 //
@@ -230,6 +245,9 @@ avtOpacityMap::QuantizeValF(const double &val){
 //    Qi Wu, Tue Aug 8 12:47:52 MT 2017
 //    Fixed index overflow problem when the scalar value reaches its maximum
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Fix bad coding formats
+//
 // ****************************************************************************
 inline int
 avtOpacityMap::QueryTF(double scalarValue, double color[4]) const
@@ -237,7 +255,7 @@ avtOpacityMap::QueryTF(double scalarValue, double color[4]) const
     if (scalarValue <= min){
         int index = 0;
 
-        _RGBA colorRGBA = transferFn1D[index];
+        RGBAF colorRGBA = transferFn1D[index];
         color[0] = colorRGBA.R;
         color[1] = colorRGBA.G;
         color[2] = colorRGBA.B;
@@ -248,7 +266,7 @@ avtOpacityMap::QueryTF(double scalarValue, double color[4]) const
 
     if (scalarValue >= max){
         int index = tableEntries-1;
-        _RGBA colorRGBA = transferFn1D[index];
+        RGBAF colorRGBA = transferFn1D[index];
         color[0] = colorRGBA.R;
         color[1] = colorRGBA.G;
         color[2] = colorRGBA.B;
@@ -258,11 +276,12 @@ avtOpacityMap::QueryTF(double scalarValue, double color[4]) const
     }
 
     int indexLow, indexHigh;
-    _RGBA colorRGBALow, colorRGBAHigh;
+    RGBAF colorRGBALow, colorRGBAHigh;
     double colorLow[4], colorHigh[4];
     float indexPos, indexDiff;
 
-    indexPos  = (scalarValue-min)/(max-min) * (tableEntries-1);    // multiplier = 1.0/(max-min) * tableEntries
+    indexPos  = (scalarValue-min)/(max-min) * (tableEntries-1); 
+    // ^^^^ multiplier = 1.0/(max-min) * tableEntries
     indexLow  = (int)indexPos;
     indexHigh = (int)(indexPos+1.0);
 
diff --git a/avt/Plotter/CMakeLists.txt b/avt/Plotter/CMakeLists.txt
index 4ca2625d9b..79a18e9f03 100644
--- a/avt/Plotter/CMakeLists.txt
+++ b/avt/Plotter/CMakeLists.txt
@@ -77,6 +77,12 @@
 #   Remove vtkRenderingVolumeOpenGL2 from link line. Moved module init back
 #   into volume plot.
 #
+#   Qi WU, Sat Jun 10 22:21:27 MST 2018
+#   Remove the old VISIT_OSPRAY configurations because they are too old. 
+#   Additional Note: The FindOSPRay.cmake file is broken for a recent version
+#                    of OSPRay. We should use the built-inosprayConfig.cmake
+#                    file to find OSPRay instead.
+#
 #****************************************************************************/
 
 #if(VISIT_OSPRAY)
@@ -217,14 +223,9 @@ TARGET_LINK_LIBRARIES(avtplotter_ser
     visitcommon avtmath avtview avtfilters_ser avtpipeline_ser visit_vtk 
     lightweight_visit_vtk vtkFiltersHybrid vtkRenderingOpenGL2 
     vtkRenderingFreeType ${OPENGL_LIBRARIES})
-
 IF(VISIT_OSPRAY)
-    MESSAGE(STATUS "OSPRAY_TARGET_LINK_LIBRARIES: " ${OSPRAY_TARGET_LINK_LIBRARIES})
-    MESSAGE(STATUS "OSPRAY_LIBRARIES: " ${OSPRAY_LIBRARIES})
-    MESSAGE(STATUS "OSPRAY_INCLUDE_DIRS: " ${OSPRAY_INCLUDE_DIRS})
-    TARGET_LINK_LIBRARIES(avtplotter_ser ${OSPRAY_TARGET_LINK_LIBRARIES}
-        ${OSPRAY_LIBRARIES} ${VTK_LIBRARIES})
-    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS} ${VISIT_SOURCE_DIR}/../../VTK-6.1.0/Parallel/Core)
+    TARGET_LINK_LIBRARIES(avtplotter_ser ${OSPRAY_LIBRARIES} ${VTK_LIBRARIES})
+    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS})
 ENDIF(VISIT_OSPRAY)
 VISIT_INSTALL_TARGETS(avtplotter_ser)
 
@@ -233,12 +234,9 @@ IF(VISIT_PARALLEL)
     ADD_PARALLEL_LIBRARY(avtplotter_par ${AVTPLOTTER_SOURCES})
     TARGET_LINK_LIBRARIES(avtplotter_par visitcommon avtmath avtview avtfilters_par avtpipeline_par visit_vtk lightweight_visit_vtk vtkFiltersHybrid vtkRenderingOpenGL2 vtkRenderingFreeType ${OPENGL_LIBRARIES})
     IF(VISIT_OSPRAY)
-        TARGET_LINK_LIBRARIES(avtplotter_par ${OSPRAY_TARGET_LINK_LIBRARIES}
-            ${OSPRAY_LIBRARIES} ${VTK_LIBRARIES})
-        INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS})
+      TARGET_LINK_LIBRARIES(avtplotter_par ${OSPRAY_LIBRARIES})
+      INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS})
     ENDIF(VISIT_OSPRAY)
-
     VISIT_INSTALL_TARGETS(avtplotter_par)
 ENDIF(VISIT_PARALLEL)
 
-
diff --git a/avt/Plotter/OSPRay/CMake/FindOSPRay.cmake b/avt/Plotter/OSPRay/CMake/FindOSPRay.cmake
deleted file mode 100644
index 02ecdda96d..0000000000
--- a/avt/Plotter/OSPRay/CMake/FindOSPRay.cmake
+++ /dev/null
@@ -1,105 +0,0 @@
-## ======================================================================================= ##
-## Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  ##
-## All rights reserved.                                                                    ##
-##                                                                                         ##
-## Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     ##
-## except in compliance with the License.                                                  ##
-## A copy of the License is included with this software in the file LICENSE.               ##
-## If your copy does not contain the License, you may obtain a copy of the License at:     ##
-##                                                                                         ##
-##     http://opensource.org/licenses/BSD-3-Clause                                         ##
-##                                                                                         ##
-## Unless required by applicable law or agreed to in writing, software distributed under   ##
-## the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY ##
-## KIND, either express or implied.                                                        ##
-## See the License for the specific language governing permissions and limitations under   ##
-## limitations under the License.                                                          ##
-## ======================================================================================= ##
-
-
-###############################################################################
-# Find OSPRay
-# defines:
-# OSPRAY_FOUND
-# OSPRAY_INCLUDE_DIRS
-# OSPRAY_LIBRARIES
-
-# guess that OSPRay is installed in a peer directory (if in dev) or in a peer to the ParaView source
-FIND_PATH(OSPRAY_DIR ospray
-  HINTS ${PROJECT_SOURCE_DIR}/../OSPRay  ${PROJECT_SOURCE_DIR}/../../../OSPRay
-  DOC "OSPRay base directory"
-  )
-IF(NOT OSPRAY_DIR)
-  MESSAGE("Could not find OSPRay base directory. Please set OSPRAY_DIR to the root of your local OSPRay git repository.")
-ENDIF(NOT OSPRAY_DIR)
-
-FIND_PATH(OSPRAY_CMAKE_DIR ospray.cmake
-  HINTS ${PROJECT_SOURCE_DIR}/../OSPRay/cmake ${PROJECT_SOURCE_DIR}/../../../OSPRay/cmake ${OSPRAY_DIR}/cmake
-  DOC "OSPRay cmake directory"
-  )
-IF(NOT OSPRAY_CMAKE_DIR)
-  MESSAGE("Could not find OSPRay cmake directory. Please set OSPRAY_CMAKE_DIR to the cmake directory of your local OSPRay git repository, usually <root>/cmake.")
-ENDIF(NOT OSPRAY_CMAKE_DIR)
-
-FIND_PATH(OSPRAY_BUILD_DIR ospModelViewer
-  HINTS ${OSPRAY_DIR}/build ${PROJECT_SOURCE_DIR}/../OSPRay/build ${PROJECT_SOURCE_DIR}/../OSPRay ${PROJECT_SOURCE_DIR}/../../../OSPRay/build ${PROJECT_SOURCE_DIR}/../../../OSPRay
-  DOC "OSPRay build directory"
-  )
-IF(NOT OSPRAY_BUILD_DIR)
-  MESSAGE("Could not find OSPRay build directory. Please set OSPRAY_BUILD_DIR to the directory where OSPRay was built.")
-ENDIF(NOT OSPRAY_BUILD_DIR)
-
-if (OSPRAY_BUILD_DIR)
-    SET(VISIT_OSPRAY ON TYPE BOOL)
-  LOAD_CACHE(${OSPRAY_BUILD_DIR} READ_WITH_PREFIX OSP_ 
-    OSPRAY_BUILD_MIC_SUPPORT
-    OSPRAY_BUILD_MPI_DEVICE
-    OSPRAY_COMPILER
-    OSPRAY_XEON_TARGET
-    )
-
-  SET(OSPRAY_INCLUDE_DIRS
-    ${OSPRAY_DIR}
-    ${OSPRAY_DIR}/ospray
-    ${OSPRAY_DIR}/ospray/embree/common
-    ${OSPRAY_DIR}/ospray/embree
-    ${OSPRAY_DIR}/ospray/include
-    )
-
-  SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${OSPRAY_CMAKE_DIR} ${OSPRAY_DIR})
-  # which compiler was used to build OSPRay
-  SET(OSPRAY_CC ${OSP_OSPRAY_COMPILER} CACHE STRING "OSPRay Compiler (ICC, GCC, CLANG)")
-  # whehter to build in MIC/xeon phi support
-  SET(OSPRAY_MIC ${OSP_OSPRAY_BUILD_MIC_SUPPORT} CACHE BOOL "Was OSPRay buit with Xeon Phi Support?")
-  # whehter to build in MIC/xeon phi support
-  SET(OSPRAY_MPI ${OSP_OSPRAY_BUILD_MPI_DEVICE} CACHE BOOL "Was OSPRay built with MPI Remote/Distributed rendering support?")
-  # the arch we're targeting for the non-MIC/non-xeon phi part of ospray
-  SET(OSPRAY_XEON_TARGET ${OSP_OSPRAY_XEON_TARGET} CACHE STRING "OSPRay target ISA on host (SSE,AVX,AVX2)")
-
-  ADD_DEFINITIONS(${OSPRAY_EMBREE_CXX_FLAGS})
-endif(OSPRAY_BUILD_DIR)
-
-# MESSAGE("ospray_dir ${OSPRAY_DIR}")
-# SET(OSPRAY_DIR2 ${OSPRAY_DIR})
-# INCLUDE(${OSPRAY_DIR}/cmake/ospray.cmake)
-# SET(OSPRAY_DIR ${OSPRAY_DIR2})
-# MESSAGE("ospray_dir ${OSPRAY_DIR}")
-
-if(OSPRAY_CMAKE_DIR)
-  INCLUDE(${OSPRAY_CMAKE_DIR}/ospray.cmake)
-  INCLUDE(${OSPRAY_CMAKE_DIR}/mpi.cmake)
-endif(OSPRAY_CMAKE_DIR)
-
-SET(LIB_OSPRAY_EMBREE LIB_OSPRAY_EMBREE-NOTFOUND)
-SET(LIB_OSPRAY LIB_OSPRAY-NOTFOUND)
-FIND_LIBRARY(LIB_OSPRAY_EMBREE ospray_embree ${OSPRAY_BUILD_DIR})
-FIND_LIBRARY(LIB_OSPRAY ospray ${OSPRAY_BUILD_DIR})
-IF (OSPRAY_MIC)
-  # Xeon Phi specific build ops here
-ENDIF(OSPRAY_MIC)
-
-SET(OSPRAY_LIBRARIES
-  ${LIB_OSPRAY_EMBREE}
-  ${LIB_OSPRAY}
-  )
-
diff --git a/avt/Plotter/OSPRay/README b/avt/Plotter/OSPRay/README
deleted file mode 100644
index 139597f9cb..0000000000
--- a/avt/Plotter/OSPRay/README
+++ /dev/null
@@ -1,2 +0,0 @@
-
-
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/CMake/FindOSPRay.cmake b/avt/Plotter/OSPRay/vtkOSPRay/CMake/FindOSPRay.cmake
deleted file mode 100644
index 3d5e0851dd..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/CMake/FindOSPRay.cmake
+++ /dev/null
@@ -1,95 +0,0 @@
-## ======================================================================================= ##
-## Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  ##
-##                                                                                         ##
-## Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     ##
-## except in compliance with the License.                                                  ##
-## A copy of the License is included with this software in the file LICENSE.               ##
-## If your copy does not contain the License, you may obtain a copy of the License at:     ##
-##                                                                                         ##
-##     http://opensource.org/licenses/BSD-3-Clause                                         ##
-##                                                                                         ##
-## Unless required by applicable law or agreed to in writing, software distributed under   ##
-## the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY ##
-## KIND, either express or implied.                                                        ##
-## See the License for the specific language governing permissions and limitations under   ##
-## limitations under the License.                                                          ##
-## ======================================================================================= ##
-
-###############################################################################
-# Find OSPRay
-# defines:
-# OSPRAY_FOUND
-# OSPRAY_INCLUDE_DIRS
-# OSPRAY_LIBRARIES
-
-# guess that OSPRay is installed in a peer directory
-FIND_PATH(OSPRAY_DIR ospray
-  HINTS ${PROJECT_SOURCE_DIR}/../OSPRay 
-  DOC "OSPRay base directory"
-  )
-IF(NOT OSPRAY_DIR)
-  MESSAGE("Could not find OSPRay base directory. Please set OSPRAY_DIR to the root of your local OSPRay git repository.")
-ENDIF(NOT OSPRAY_DIR)
-
-FIND_PATH(OSPRAY_CMAKE_DIR ospray.cmake
-  HINTS ${PROJECT_SOURCE_DIR}/../OSPRay/cmake
-  DOC "OSPRay cmake directory"
-  )
-IF(NOT OSPRAY_CMAKE_DIR)
-  MESSAGE("Could not find OSPRay cmake directory. Please set OSPRAY_CMAKE_DIR to the cmake directory of your local OSPRay git repository, usually <root>/cmake.")
-ENDIF(NOT OSPRAY_CMAKE_DIR)
-
-FIND_PATH(OSPRAY_BUILD_DIR ospModelViewer
-  HINTS ${PROJECT_SOURCE_DIR}/../OSPRay/build ${PROJECT_SOURCE_DIR}/../OSPRay
-  DOC "OSPRay build directory"
-  )
-IF(NOT OSPRAY_BUILD_DIR)
-  MESSAGE("Could not find OSPRay build directory. Please set OSPRAY_BUILD_DIR to the directory where OSPRay was built.")
-ENDIF(NOT OSPRAY_BUILD_DIR)
-
-LOAD_CACHE(${OSPRAY_BUILD_DIR} READ_WITH_PREFIX OSP_ 
-  OSPRAY_BUILD_MIC_SUPPORT
-  OSPRAY_BUILD_MPI_DEVICE
-  OSPRAY_COMPILER
-  OSPRAY_XEON_TARGET
-  )
-
-SET(OSPRAY_INCLUDE_DIRS
-  ${OSPRAY_DIR}
-  ${OSPRAY_DIR}/ospray
-  ${OSPRAY_DIR}/ospray/embree/common
-  ${OSPRAY_DIR}/ospray/embree
-  ${OSPRAY_DIR}/ospray/include
-  )
-
-SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${OSPRAY_CMAKE_DIR} ${OSPRAY_DIR})
-# which compiler was used to build OSPRay
-SET(OSPRAY_CC ${OSP_OSPRAY_COMPILER} CACHE STRING "OSPRay Compiler (ICC, GCC, CLANG)")
-# whehter to build in MIC/xeon phi support
-SET(OSPRAY_MIC ${OSP_OSPRAY_BUILD_MIC_SUPPORT} CACHE BOOL "Was OSPRay buit with Xeon Phi Support?")
-# whehter to build in MIC/xeon phi support
-SET(OSPRAY_MPI ${OSP_OSPRAY_BUILD_MPI_DEVICE} CACHE BOOL "Was OSPRay built with MPI Remote/Distributed rendering support?")
-# the arch we're targeting for the non-MIC/non-xeon phi part of ospray
-SET(OSPRAY_XEON_TARGET ${OSP_OSPRAY_XEON_TARGET} CACHE STRING "OSPRay target ISA on host (SSE,AVX,AVX2)")
-
-ADD_DEFINITIONS(${OSPRAY_EMBREE_CXX_FLAGS})
-MESSAGE("ospray_dir ${OSPRAY_DIR}")
-SET(OSPRAY_DIR2 ${OSPRAY_DIR})
-INCLUDE(${OSPRAY_DIR}/cmake/ospray.cmake)
-SET(OSPRAY_DIR ${OSPRAY_DIR2})
-MESSAGE("ospray_dir ${OSPRAY_DIR}")
-INCLUDE(${OSPRAY_DIR}/cmake/mpi.cmake)
-
-SET(LIB_OSPRAY_EMBREE LIB_OSPRAY_EMBREE-NOTFOUND)
-SET(LIB_OSPRAY LIB_OSPRAY-NOTFOUND)
-FIND_LIBRARY(LIB_OSPRAY_EMBREE ospray_embree ${OSPRAY_BUILD_DIR})
-FIND_LIBRARY(LIB_OSPRAY ospray ${OSPRAY_BUILD_DIR})
-IF (OSPRAY_MIC)
-  # Xeon Phi specific build ops here
-ENDIF(OSPRAY_MIC)
-
-SET(OSPRAY_LIBRARIES
-  ${LIB_OSPRAY_EMBREE}
-  ${LIB_OSPRAY}
-  )
-
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/CMakeLists.txt b/avt/Plotter/OSPRay/vtkOSPRay/CMakeLists.txt
deleted file mode 100755
index 87595764c4..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/CMakeLists.txt
+++ /dev/null
@@ -1,122 +0,0 @@
-## ======================================================================================= ##
-## Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  ##
-## All rights reserved.                                                                    ##
-##                                                                                         ##
-## Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     ##
-## except in compliance with the License.                                                  ##
-## A copy of the License is included with this software in the file LICENSE.               ##
-## If your copy does not contain the License, you may obtain a copy of the License at:     ##
-##                                                                                         ##
-##     http://opensource.org/licenses/BSD-3-Clause                                         ##
-##                                                                                         ##
-## Unless required by applicable law or agreed to in writing, software distributed under   ##
-## the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY ##
-## KIND, either express or implied.                                                        ##
-## See the License for the specific language governing permissions and limitations under   ##
-## limitations under the License.                                                          ##
-## ======================================================================================= ##
-
-# vtkOSPRay is an interface from VTK's rendering classes to OSPRay,
-# a "real time" Ray Tracer.
-
-# It creates a library that includes OSPRay specific subclasses
-# of VTK's rendering classes, Renderer, Camera, etc.
-# These can be instantiated by name, or by using object factory overloading
-# at post compile time (ie, set VTK_AUTOLOAD_PATH to vtkOSPRay's build
-# directory and run a normal vtk app)
-
-project(vtkOSPRay)
-
-
-
-#Configure vtkOSPRay source proper ############################################
-
-# Define a flag
-if (BUILD_AGAINST_PARAVIEW)
-    add_definitions(-DVTKOSPRAY_FOR_PARAVIEW)
-endif(BUILD_AGAINST_PARAVIEW)
-
-# Set vtkOSPRay source files.
-SET ( OSPRAY_CLASSES
-    vtkOSPRayActor.cxx
-    #vtkOSPRayRenderable.cxx
-    vtkOSPRayCamera.cxx
-    vtkOSPRayLight.cxx
-    vtkOSPRayManager.cxx
-    vtkOSPRayPolyDataMapper.cxx
-    vtkOSPRayProperty.cxx
-    vtkOSPRayRenderer.cxx
-    vtkOSPRayTestSource.cxx
-    vtkOSPRayTexture.cxx
-    vtkOSPRayVolumeRayCastMapper.h
-    vtkOSPRayVolumeRayCastMapper.cxx
-    vtkOSPRayPVLODVolume.cxx
-    )
-
-IF (BUILD_AGAINST_PARAVIEW)
-    add_definitions(-DVTKOSPRAY_FOR_PARAVIEW)
-    # paraview uses its own LOD actor, put it in here
-    SET ( OSPRAY_CLASSES ${OSPRAY_CLASSES}
-        vtkOSPRayLODActor.cxx
-        vtkPVOSPRayRepresentation.cxx
-        vtkPVOSPRayRepresentation.h
-        vtkPVOSPRayOutlineRepresentation.cxx
-        vtkPVOSPRayOutlineRepresentation.h
-        # pnav - ParaView 4.3 is unhappy with some code in these, disabling for now
-        #        something changed between the VTK in PV 4.1 and PV 4.3
-        vtkPVOSPRayImageVolumeRepresentation.cxx
-        vtkPVOSPRayImageVolumeRepresentation.h
-        vtkOSPRayCompositeMapper.cxx)
-ENDIF (BUILD_AGAINST_PARAVIEW)
-
-add_definitions(
-    -DvtkCommonCore_EXPORTS
-    -DvtkPVClientServerCoreRendering_EXPORTS
-    -DvtkRenderingVolume_EXPORTS
-    -DvtkPVVTKExtensionsRendering_EXPORTS
-    )
-
-SET ( OSPRAY_SRCS
-    ${OSPRAY_CLASSES}
-    #   vtkOSPRayObjectFactory.cxx
-    )
-
-set (${vtk-module}_NO_HeaderTest 1)
-
-vtk_module_library(${vtk-module} ${OSPRAY_SRCS} ${MOCSrcs} ${UISrcs})
-find_package(OSPRay)
-
-
-# setup include paths
-INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})
-INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR})
-INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR}/vtkOSPRay)
-INCLUDE_DIRECTORIES(${PROJECT_BINARY_DIR})
-INCLUDE_DIRECTORIES(${PROJECT_BINARY_DIR}/vtkOSPRay)
-INCLUDE_DIRECTORIES(${PROJECT_BINARY_DIR}/Base)
-INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR}/Base)
-
-
-# if(PARAVIEW_BUILD_QT_GUI)
-#   INCLUDE(${QT_USE_FILE})
-# endif(PARAVIEW_BUILD_QT_GUI)
-FIND_PACKAGE(Qt4 REQUIRED)
-INCLUDE(${QT_USE_FILE})
-
-if(VTK_USE_X)
-    vtk_module_link_libraries(${vtk-module}
-        LINK_PRIVATE ${OSPRAY_LIBRARIES} ${QT_LIBRARIES} ${X11_LIBRARIES} ${X11_Xt_LIB})
-elseif(VTK_USE_COCOA)
-    vtk_module_link_libraries(${vtk-module} ${OSPRAY_LIBRARIES} ${QT_LIBRARIES} "-framework OpenGL -framework Cocoa")
-    target_link_libraries(${vtk-module} ${OSPRAY_LIBRARIES} ${QT_LIBRARIES} ${VTK_LIBRARIES})
-endif()
-
-# OSPRay_Core uses MMTime which is in it's own special library.
-if(WIN32)
-    TARGET_LINK_LIBRARIES(${PROJECT_NAME} LINK_PRIVATE Winmm)
-endif()
-
-#Examples ####################################################################
-#IF ( BUILD_EXAMPLES )
-#ADD_SUBDIRECTORY(Examples)
-#ENDIF ( BUILD_EXAMPLES )
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/LICENSE b/avt/Plotter/OSPRay/vtkOSPRay/LICENSE
deleted file mode 100644
index 66d0235bcd..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/LICENSE
+++ /dev/null
@@ -1,77 +0,0 @@
-/*=========================================================================
-Copyright (c) 2014 - 2015, Texas Advanced Computing Center, The University of Texas at Austin.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-
-3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-=========================================================================*/
-
-
-
-Portions of this code are derived from the MantaView module developed at Los Alamos National Laboratory, which is licensed as follows:
-/*=========================================================================
-
-Copyright (c) 2007, Los Alamos National Security, LLC
-
-All rights reserved.
-
-Copyright 2007. Los Alamos National Security, LLC.
-This software was produced under U.S. Government contract DE-AC52-06NA25396
-for Los Alamos National Laboratory (LANL), which is operated by
-Los Alamos National Security, LLC for the U.S. Department of Energy.
-The U.S. Government has rights to use, reproduce, and distribute this software.
-NEITHER THE GOVERNMENT NOR LOS ALAMOS NATIONAL SECURITY, LLC MAKES ANY WARRANTY,
-EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE.
-If software is modified to produce derivative works, such modified software
-should be clearly marked, so as not to confuse it with the version available
-from LANL.
-
-Additionally, redistribution and use in source and binary forms, with or
-without modification, are permitted provided that the following conditions
-are met:
--   Redistributions of source code must retain the above copyright notice,
-    this list of conditions and the following disclaimer.
--   Redistributions in binary form must reproduce the above copyright notice,
-    this list of conditions and the following disclaimer in the documentation
-    and/or other materials provided with the distribution.
--   Neither the name of Los Alamos National Security, LLC, Los Alamos National
-    Laboratory, LANL, the U.S. Government, nor the names of its contributors
-    may be used to endorse or promote products derived from this software
-    without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL LOS ALAMOS NATIONAL SECURITY, LLC OR
-CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-=========================================================================*/
-
-
-
-
-Portions of this code utilize the Visualization Toolkit (VTK) interface, which is licensed as follows:
-/*=========================================================================
-
-  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
-  All rights reserved.
-  See http://www.kitware.com/Copyright.htm for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
\ No newline at end of file
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/R b/avt/Plotter/OSPRay/vtkOSPRay/R
deleted file mode 100644
index 096a02db9d..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/R
+++ /dev/null
@@ -1 +0,0 @@
-Binary file vtkOSPRay_src.tar matches
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/README b/avt/Plotter/OSPRay/vtkOSPRay/README
deleted file mode 100755
index 139597f9cb..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/README
+++ /dev/null
@@ -1,2 +0,0 @@
-
-
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/README.md b/avt/Plotter/OSPRay/vtkOSPRay/README.md
deleted file mode 100644
index eb244451f6..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/README.md
+++ /dev/null
@@ -1,9 +0,0 @@
-vtkOSPRay <a href="https://tacc.github.io/vtkOSPRay/">https://tacc.github.io/vtkOSPRay</a>
-======
-
-<h2>About</h2>
-The base VTK code without ParaView is contained in the VTK directory and makes up vtkOSPRay.  vtkOSPRay is a VTK module which utilizes Intel's OSPRay ray tracing framework (http://ospray.github.io) for rendering.  This offers a performant CPU rendering package with enhanced image quality and includes plugins for the commonly used visualization tools ParaView and VisIt.
-
-<h2>Building</h2>
-vtkOSPRay is currently built as part of the pvOSPRay and visitOSPRay builds. A stand-alone library build process will be released soon.
-
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/module.cmake b/avt/Plotter/OSPRay/vtkOSPRay/module.cmake
deleted file mode 100755
index 5a091d988d..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/module.cmake
+++ /dev/null
@@ -1,48 +0,0 @@
-## ======================================================================================= ##
-## Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  ##
-## All rights reserved.                                                                    ##
-##                                                                                         ##
-## Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     ##
-## except in compliance with the License.                                                  ##
-## A copy of the License is included with this software in the file LICENSE.               ##
-## If your copy does not contain the License, you may obtain a copy of the License at:     ##
-##                                                                                         ##
-##     http://opensource.org/licenses/BSD-3-Clause                                         ##
-##                                                                                         ##
-## Unless required by applicable law or agreed to in writing, software distributed under   ##
-## the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY ##
-## KIND, either express or implied.                                                        ##
-## See the License for the specific language governing permissions and limitations under   ##
-## limitations under the License.                                                          ##
-## ======================================================================================= ##
-
-set (_vtk_modules)
-if(PARAVIEW_USE_MPI)
-  list(APPEND _vtk_modules vtkParallelMPI)
-endif()
-
-if (BUILD_AGAINST_PARAVIEW)
-  list(APPEND _vtk_modules vtkPVClientServerCoreRendering)
-endif()
-
-if (VTK_RENDERING_BACKEND STREQUAL "OpenGL2")
-  message("GL2")
-  list(APPEND _vtk_modules vtkRenderingOpenGL2)
-else()
-  message("GL1")
-  list(APPEND _vtk_modules vtkRenderingOpenGL)
-endif()
-
-vtk_module(vtkOSPRay
-  DEPENDS
-    vtkFiltersCore
-    vtkParallelCore
-    vtkFiltersHybrid
-    ${_vtk_modules}
-  TEST_DEPENDS
-    vtkTestingRendering
-    vtkIOPLY
-  TEST_LABELS
-    PARAVIEW
-  EXCLUDE_FROM_WRAP_HIERARCHY
-)
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRay.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRay.h
deleted file mode 100755
index f39a3952f1..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRay.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRay.h -
-// .SECTION Description
-//
-#ifndef __vtkOSPRay_h
-#define __vtkOSPRay_h
-
-#include "ospray/ospray.h"
-
-#include "vtkConfigure.h"
-#include "vtkOSPRayModule.h"
-
-#if defined(__APPLE__) && (defined(VTK_USE_CARBON) || defined(VTK_USE_COCOA))
-# include <OpenGL/gl.h> // Include OpenGL API.
-#else
-#include "vtkOpenGL.h"
-#endif
-
-#define DEBUG(x) {   std::cout << __PRETTY_FUNCTION__ << ":" << __LINE__ << " " << x << std::endl; }
-#define USE_OSPRAY 1
-#define USE_VBOS 0
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayActor.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayActor.cxx
deleted file mode 100755
index 5dd2cf854f..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayActor.cxx
+++ /dev/null
@@ -1,165 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "ospray/ospray.h"
-
-#define GL_GLEXT_PROTOTYPES
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayActor.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkOSPRayRenderer.h"
-#include "vtkMapper.h"
-
-#include "vtkDataSet.h"
-#include "vtkObjectFactory.h"
-#include "vtkRendererCollection.h"
-#include "vtkTimerLog.h"
-
-#include <map>
-#include <algorithm>
-
-
-#include "vtkInformation.h"
-#include "vtkInformationVector.h"
-
-vtkStandardNewMacro(vtkOSPRayActor);
-
-//----------------------------------------------------------------------------
-vtkOSPRayActor::vtkOSPRayActor()
-{
-  this->OSPRayManager = NULL;
-  this->SortType = DYNBVH;
-  this->OSPRayModel = ospNewModel();
-  LastFrame=-1;
-  Renderable = NULL;
-}
-
-// now some OSPRay resources, ignored previously, can be de-allocated safely
-//
-vtkOSPRayActor::~vtkOSPRayActor()
-{
-  if (this->OSPRayManager)
-  {
-    this->ReleaseGraphicsResources(NULL);
-    this->OSPRayManager->Delete();
-  }
-  // delete this->OSPRayModel;
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::PrintSelf( ostream & os, vtkIndent indent )
-{
-  this->Superclass::PrintSelf( os, indent );
-}
-
-//----------------------------------------------------------------------------
-vtkProperty *vtkOSPRayActor::MakeProperty()
-{
-  return vtkOSPRayProperty::New();
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::ReleaseGraphicsResources( vtkWindow * win )
-{
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::Render( vtkRenderer * ren, vtkMapper * mapper )
-{
-  if ( vtkOSPRayRenderer * OSPRayRenderer = vtkOSPRayRenderer::SafeDownCast( ren ) )
-  {
-    if (!this->OSPRayManager)
-    {
-      this->OSPRayManager = OSPRayRenderer->GetOSPRayManager();
-      this->OSPRayManager->Register(this);
-    }
-    // if (LastFrame < OSPRayRenderer->GetFrame())
-    // {
-      // printf("creating new model for actor\n");
-      // this->OSPRayModel = ospNewModel();
-    // }
-
-    // TODO: be smarter on update or create rather than create every time
-    // build transformation (with AffineTransfrom and Instance?)
-
-    // TODO: the way "real FLAT" shading is done right now (by not supplying vertex
-    // normals), changing from FLAT to Gouraud shading needs to create a new mesh.
-
-      mapper->Render(ren, this);
-      LastFrame = OSPRayRenderer->GetFrame();
-    }
-      UpdateObjects(ren);
-  }
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::SetVisibility(int newval)
-{
-  if (newval == this->GetVisibility())
-  {
-    return;
-  }
-  if (this->OSPRayManager && !newval)
-  {
-  }
-  this->Superclass::SetVisibility(newval);
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::RemoveObjects()
-{
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::PreRender()
-{
-  // std::cout << __PRETTY_FUNCTION__ << std::endl;
-  // this->OSPRayModel = ospNewModel();
-}
-
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::UpdateObjects( vtkRenderer * ren )
-{
-  vtkOSPRayRenderer * OSPRayRenderer =
-  vtkOSPRayRenderer::SafeDownCast( ren );
-  if (!OSPRayRenderer)
-  {
-    return;
-  }
-
-  //Remove whatever we used to show in the scene
-  if (!this->OSPRayManager)
-  {
-    return;
-  }
-
-  if (!this->OSPRayModel)
-    return;
-
-  if (!this->GetVisibility())
-    return;
-  
-  Renderable = new vtkOSPRayRenderable(this->OSPRayModel);
-  OSPRayRenderer->AddOSPRayRenderable(Renderable);
-
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayActor.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayActor.h
deleted file mode 100755
index 401a8f8d87..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayActor.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayActor - vtkActor for OSPRay Ray traced scenes
-// .SECTION Description
-// vtkOSPRayActor is a concrete implementation of the abstract class vtkActor.
-// vtkOSPRayActor interfaces to the OSPRay Raytracer library.
-
-#ifndef __vtkOSPRayActor_h
-#define __vtkOSPRayActor_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkOSPRayRenderable.h"
-#include "vtkActor.h"
-#include <map>
-#include <vector>
-
-
-//BTX
-namespace OSPRay {
-class Group;
-class AccelerationStructure;
-class Object;
-};
-//ETX
-
-namespace osp
-{
-  class Model;
-}
-
-class vtkTimeStamp;
-class vtkOSPRayProperty;
-class vtkOSPRayRenderer;
-class vtkOSPRayManager;
-
-
-
-class VTKOSPRAY_EXPORT vtkOSPRayActor : public vtkActor
-{
-public:
-  static vtkOSPRayActor *New();
-  vtkTypeMacro(vtkOSPRayActor,vtkActor);
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-
-  //Description:
-  // Overriden to help ensure that a OSPRay compatible class is created.
-  vtkProperty * MakeProperty();
-
-  // Description:
-  // This causes the actor to be rendered. It in turn will render the actor's
-  // property, texture map and then mapper. If a property hasn't been
-  // assigned, then the actor will create one automatically. Note that a side
-  // effect of this method is that the pipeline will be updated.
-  void Render(vtkRenderer *ren, vtkMapper *mapper);
-
-  // Description:
-  // Release any graphics resources that are being consumed by this actor.
-  // The parameter window could be used to determine which graphic
-  // resources to release.
-  void ReleaseGraphicsResources(vtkWindow *);
-
-  //Description:
-  // Overridden to schedule a transaction to hide the object
-  virtual void SetVisibility(int);
-
-  //Description:
-  // Transaction callback that hides the object
-  void RemoveObjects();
-
-  void PreRender();
-
-  //Description:
-  //Lets you choose the OSPRay space sorting (acceleration) structure
-  //type used internally. Default is 0=DYNBVH
-  vtkSetMacro(SortType, int);
-  vtkGetMacro(SortType, int);
-
-  int GetLastFrame() { return LastFrame; }
-
- protected:
-  vtkOSPRayActor();
-  ~vtkOSPRayActor();
-
-  virtual void CreateOwnLODs () {}
-  virtual void UpdateOwnLODs() {}
-
- private:
-  vtkOSPRayActor(const vtkOSPRayActor&);  // Not implemented.
-  void operator=(const vtkOSPRayActor&);  // Not implemented.
-
-  void UpdateObjects(vtkRenderer *);
-
-  int SortType;
-
-  //BTX
-  enum {DYNBVH, RECURSIVEGRID3};
-  //ETX
-
-  vtkOSPRayManager *OSPRayManager;
-  vtkOSPRayRenderable* Renderable;
-
-public:
-  int LastFrame;
-  vtkTimeStamp MeshMTime;
-  osp::Model* OSPRayModel;
-  std::map<int, osp::Model*> cache;
-};
-
-#endif // __vtkOSPRayActor_h
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCamera.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCamera.cxx
deleted file mode 100755
index 5d48dc39de..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCamera.cxx
+++ /dev/null
@@ -1,113 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayCamera.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayRenderer.h"
-
-#include "vtkObjectFactory.h"
-
-#include <math.h>
-
-#ifndef __APPLE__
-#include <GL/glu.h>
-#else
-#include <OpenGL/glu.h>
-#endif
-
-   vtkStandardNewMacro(vtkOSPRayCamera);
-
-//----------------------------------------------------------------------------
-   vtkOSPRayCamera::vtkOSPRayCamera()
-   {
-    this->OSPRayManager = NULL;
-  }
-
-//----------------------------------------------------------------------------
-  vtkOSPRayCamera::~vtkOSPRayCamera()
-  {
-    if (this->OSPRayManager)
-    {
-      this->OSPRayManager->Delete();
-    }
-  }
-
-//----------------------------------------------------------------------------
-  void vtkOSPRayCamera::OrientOSPRayCamera(vtkRenderer *ren)
-  {
-    vtkOSPRayRenderer * OSPRayRenderer = vtkOSPRayRenderer::SafeDownCast(ren);
-    if (!OSPRayRenderer)
-    {
-      return;
-    }
-    OSPRayRenderer->ClearAccumulation();
-
-    if (!this->OSPRayManager)
-    {
-      this->OSPRayManager = OSPRayRenderer->GetOSPRayManager();
-      this->OSPRayManager->Register(this);
-    }
-
-  // for figuring out aspect ratio
-    int lowerLeft[2];
-    int usize, vsize;
-    ren->GetTiledSizeAndOrigin(&usize, &vsize, lowerLeft, lowerLeft + 1);
-
-    double *eye, *lookat, *up, vfov;
-    eye    = this->Position;
-    lookat = this->FocalPoint;
-    up     = this->ViewUp;
-    vfov   = this->ViewAngle;
-
-    OSPCamera ospCamera = ((OSPCamera)this->OSPRayManager->OSPRayCamera);
-    if (vsize == 0)
-      return;
-    ospSetf(ospCamera,"aspect",float(usize)/float(vsize));
-    ospSetf(ospCamera,"fovy",vfov);
-    Assert(ospCamera != NULL && "could not create camera");
-    ospSet3f(ospCamera,"pos",eye[0], eye[1], eye[2]);
-    ospSet3f(ospCamera,"up",up[0], up[1], up[2]);
-    ospSet3f(ospCamera,"dir",lookat[0]-eye[0],lookat[1]-eye[1],lookat[2]-eye[2]);
-    ospCommit(ospCamera);
-
-  }
-
-//----------------------------------------------------------------------------
-// called by Renderer::UpdateCamera()
-  void vtkOSPRayCamera::Render(vtkRenderer *ren)
-  {
-    int lowerLeft[2];
-    int usize, vsize;
-    ren->GetTiledSizeAndOrigin(&usize, &vsize, lowerLeft, lowerLeft + 1);
-    double newAspect = float(usize)/float(vsize);
-    if (this->GetMTime() > this->LastRenderTime || (newAspect != this->Aspect) )
-    {
-      this->Aspect = newAspect;
-      this->OrientOSPRayCamera(ren);
-
-      this->LastRenderTime.Modified();
-
-    }
-  }
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCamera.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCamera.h
deleted file mode 100755
index b27f64f0e9..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCamera.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayCamera - OSPRay camera
-// .SECTION Description
-// vtkOSPRayCamera is a concrete implementation of the abstract class
-// vtkCamera.  vtkOSPRayCamera interfaces to the OSPRay Raytracer library.
-
-#ifndef __vtkOSPRayCamera_h
-#define __vtkOSPRayCamera_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkCamera.h"
-
-//BTX
-namespace OSPRay {
-class Camera;
-}
-//ETX
-
-class vtkTimeStamp;
-class vtkOSPRayManager;
-
-class VTKOSPRAY_EXPORT vtkOSPRayCamera : public vtkCamera
-{
-public:
-  static vtkOSPRayCamera *New();
-  vtkTypeMacro(vtkOSPRayCamera,vtkCamera);
-
-  void Render(vtkRenderer *ren);
-
-protected:
-   vtkOSPRayCamera();
-  ~vtkOSPRayCamera();
-
-private:
-  vtkOSPRayCamera(const vtkOSPRayCamera&);  // Not implemented.
-  void operator=(const vtkOSPRayCamera&);  // Not implemented.
-
-  void OrientOSPRayCamera(vtkRenderer *);
-
-  vtkTimeStamp LastRenderTime;
-
-  vtkOSPRayManager *OSPRayManager;
-  double Aspect;
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCompositeMapper.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCompositeMapper.cxx
deleted file mode 100755
index 22fd342943..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCompositeMapper.cxx
+++ /dev/null
@@ -1,45 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "vtkOSPRayCompositeMapper.h"
-
-#include "vtkOSPRayPolyDataMapper.h"
-#include "vtkObjectFactory.h"
-
-vtkStandardNewMacro(vtkOSPRayCompositeMapper);
-
-vtkOSPRayCompositeMapper::vtkOSPRayCompositeMapper()
-{
-}
-
-vtkOSPRayCompositeMapper::~vtkOSPRayCompositeMapper()
-{
-}
-
-vtkPolyDataMapper * vtkOSPRayCompositeMapper::MakeAMapper()
-{
-  return vtkOSPRayPolyDataMapper::New();
-}
-
-void vtkOSPRayCompositeMapper::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os,indent);
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCompositeMapper.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCompositeMapper.h
deleted file mode 100755
index 250bbbf290..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCompositeMapper.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayCompositeMapper - OSPRayMapper for composite data
-// .SECTION Description
-// This class is an adapter between composite data produced by the data
-// processing pipeline and the non composite capable vtkOSPRayPolyDataMapper.
-
-#ifndef __vtkOSPRayCompositeMapper_h
-#define __vtkOSPRayCompositeMapper_h
-
-#include "vtkCompositePolyDataMapper.h"
-#include "vtkOSPRayModule.h"
-class vtkPolyDataMapper;
-
-class VTKOSPRAY_EXPORT vtkOSPRayCompositeMapper :
-  public vtkCompositePolyDataMapper
-{
-
-public:
-  static vtkOSPRayCompositeMapper *New();
-  vtkTypeMacro(vtkOSPRayCompositeMapper, vtkCompositePolyDataMapper);
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-
-protected:
-  vtkOSPRayCompositeMapper();
-  ~vtkOSPRayCompositeMapper();
-
-  // Description:
-  // Need to define the type of data handled by this mapper.
-  virtual vtkPolyDataMapper * MakeAMapper();
-
-private:
-  vtkOSPRayCompositeMapper(const vtkOSPRayCompositeMapper&);  // Not implemented.
-  void operator=(const vtkOSPRayCompositeMapper&);    // Not implemented.
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayConfigure.h.in b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayConfigure.h.in
deleted file mode 100755
index 2ecddcc9de..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayConfigure.h.in
+++ /dev/null
@@ -1,37 +0,0 @@
-/*=========================================================================
-This source has no copyright.  It is intended to be copied by users
-wishing to create their own VTK classes locally.
-=========================================================================*/
-#ifndef __@PROJECT_NAME@Configure_h
-#define __@PROJECT_NAME@Configure_h
-
-// Define @PROJECT_NAME@_SHARED if the library was built shared.
-#if @BUILD_SHARED_LIBS@
-# define @PROJECT_NAME@_SHARED
-#endif
-
-#if @BUILD_AGAINST_PARAVIEW@
-# define VTKOSPRAY_FOR_PARAVIEW
-#endif
-
-// Disable warning caused from static VTK and shared @PROJECT_NAME@.
-#if defined(_MSC_VER) && defined(@PROJECT_NAME@_SHARED)
-# pragma warning (disable: 4275) /* non-DLL-interface base class used */
-#endif
-
-// Setup export/import macro for DLL.  The symbol
-// "@PROJECT_NAME@_EXPORTS" is defined by CMake when building source
-// files for a shared library named "@PROJECT_NAME@".  For these
-// sources we should export if building a shared library.  For other
-// sources we should import if using a shared library.
-#if defined(_WIN32) && defined(VTK_BUILD_SHARED_LIBS)
-# if defined(@PROJECT_NAME@_EXPORTS)
-#  define VTK_@PROJECT_NAME@_EXPORT __declspec(dllexport)
-# else
-#  define VTK_@PROJECT_NAME@_EXPORT __declspec(dllimport)
-# endif
-#else
-# define VTK_@PROJECT_NAME@_EXPORT
-#endif
-
-#endif // __@PROJECT_NAME@Configure_h
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLODActor.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLODActor.cxx
deleted file mode 100755
index 5f1692c254..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLODActor.cxx
+++ /dev/null
@@ -1,56 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayLODActor -
-// .SECTION Description
-//
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayLODActor.h"
-#include "vtkObjectFactory.h"
-#include "vtkOSPRayActor.h"
-#include "vtkMatrix4x4.h"
-
-vtkStandardNewMacro(vtkOSPRayLODActor);
-
-//----------------------------------------------------------------------------
-vtkOSPRayLODActor::vtkOSPRayLODActor()
-{
-  this->Device->Delete();
-  this->Device = vtkOSPRayActor::New();
-  vtkMatrix4x4 *m;
-  m = vtkMatrix4x4::New();
-  this->Device->SetUserMatrix(m);
-  m->Delete();
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayLODActor::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os,indent);
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayLODActor::SetVisibility(int newval)
-{
-  this->Device->SetVisibility(newval);
-  this->Superclass::SetVisibility(newval);
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLODActor.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLODActor.h
deleted file mode 100755
index a132a1a290..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLODActor.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayLODActor.h -
-// .SECTION Description
-//
-
-#ifndef __vtkOSPRayLODActor_h
-#define __vtkOSPRayLODActor_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkPVLODActor.h"
-
-class VTKOSPRAY_EXPORT vtkOSPRayLODActor : public vtkPVLODActor
-{
-public:
-  static vtkOSPRayLODActor *New();
-  vtkTypeMacro(vtkOSPRayLODActor,vtkPVLODActor);
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-
-  vtkActor * GetDevice() { return  this->Device; }
-  virtual void SetVisibility(int);
-
-protected:
-  vtkOSPRayLODActor();
-  ~vtkOSPRayLODActor() {};
-
-private:
-  vtkOSPRayLODActor(const vtkOSPRayLODActor&);  // Not implemented.
-  void operator=(const vtkOSPRayLODActor&);  // Not implemented.
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLight.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLight.cxx
deleted file mode 100755
index bb4a56df35..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLight.cxx
+++ /dev/null
@@ -1,136 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayLight.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayRenderer.h"
-
-#include "vtkObjectFactory.h"
-
-#include <math.h>
-
-vtkStandardNewMacro(vtkOSPRayLight);
-
-//----------------------------------------------------------------------------
-vtkOSPRayLight::vtkOSPRayLight()
-{
-  this->OSPRayManager = NULL;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayLight::~vtkOSPRayLight()
-{
-  if (this->OSPRayManager)
-    {
-    this->OSPRayManager->Delete();
-    }
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayLight::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os,indent);
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayLight::Render(vtkRenderer *ren, int /* not used */)
-{
-  vtkOSPRayRenderer *renderer = vtkOSPRayRenderer::SafeDownCast(ren);
-  if (!renderer)
-    {
-    return;
-    }
-
-  // if (!this->OSPRayLight)
-    {
-    CreateLight(ren);
-    }
-  // else
-    {
-    // UpdateLight(ren);
-    }
-}
-
-//----------------------------------------------------------------------------
-// called in Transaction context, it is safe to modify the engine state here
-void vtkOSPRayLight::CreateLight(vtkRenderer *ren)
-{
-  vtkOSPRayRenderer *OSPRayRenderer = vtkOSPRayRenderer::SafeDownCast(ren);
-  if (!OSPRayRenderer)
-    {
-    return;
-    }
-
-    if (!this->OSPRayManager)
-    {
-    this->OSPRayManager = OSPRayRenderer->GetOSPRayManager();
-    this->OSPRayManager->Register(this);
-    }
-
-  OSPRenderer renderer = ((OSPRenderer)this->OSPRayManager->OSPRayRenderer);
-      std::vector<OSPLight> pointLights;
-      std::vector<OSPLight> directionalLights;
-
-
-  double *color, *position, *focal, direction[3];
-
-  // OSPRay Lights only have one "color"
-  color    = this->GetDiffuseColor();
-  position = this->GetTransformedPosition();
-  focal    = this->GetTransformedFocalPoint();
-
-  if (this->GetPositional())
-    {
-    OSPLight ospLight = ospNewLight(renderer, "OBJPointLight");
-    ospSetString(ospLight, "name", "point" );
-    ospSet3f(ospLight, "color", color[0],color[1],color[2]);
-    ospSet3f(ospLight, "position", position[0],position[1],position[2]);
-    ospCommit(ospLight);
-    pointLights.push_back(ospLight);
-    OSPData pointLightArray = ospNewData(pointLights.size(), OSP_OBJECT, &pointLights[0], 0);
-    ospSetData(renderer, "pointLights", pointLightArray);
-    }
-  else
-    {
-    direction[0] = position[0] - focal[0];
-    direction[1] = position[1] - focal[1];
-    direction[2] = position[2] - focal[2];
-    OSPLight ospLight = ospNewLight(renderer, "DirectionalLight");
-    ospSetString(ospLight, "name", "sun" );
-    ospSet3f(ospLight, "color", color[0],color[1],color[2]);
-    ospSet3f(ospLight, "direction", direction[0],direction[1],direction[2]);
-    ospCommit(ospLight);
-    directionalLights.push_back(ospLight);
-    OSPData pointLightArray = ospNewData(directionalLights.size(), OSP_OBJECT, &directionalLights[0], 0);
-    ospSetData(renderer, "directionalLights", pointLightArray);
-
-    }
-}
-
-//------------------------------------------------------------------------------
-void vtkOSPRayLight::UpdateLight(vtkRenderer *ren)
-{
-  CreateLight(ren);
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLight.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLight.h
deleted file mode 100755
index ab25783231..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLight.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayLight - OSPRay light
-// .SECTION Description
-// vtkOSPRayLight is a concrete implementation of the abstract class vtkLight.
-// vtkOSPRayLight interfaces to the OSPRay Raytracer library.
-
-#ifndef __vtkOSPRayLight_h
-#define __vtkOSPRayLight_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkLight.h"
-
-//BTX
-namespace OSPRay {
-class Light;
-}
-//ETX
-
-class vtkOSPRayRenderer;
-class vtkTimeStamp;
-class vtkOSPRayManager;
-
-class VTKOSPRAY_EXPORT vtkOSPRayLight : public vtkLight
-{
-public:
-  static vtkOSPRayLight *New();
-  vtkTypeMacro(vtkOSPRayLight, vtkLight);
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-
-  // Description:
-  // Implement base class method.
-  void Render(vtkRenderer *ren, int light_index);
-
-protected:
-  vtkOSPRayLight();
-  ~vtkOSPRayLight();
-
-private:
-  vtkOSPRayLight(const vtkOSPRayLight&); // Not implemented.
-  void operator=(const vtkOSPRayLight&); // Not implemented.
-
-  void CreateLight(vtkRenderer *);
-  void UpdateLight(vtkRenderer *ren);
-
-  vtkOSPRayManager *OSPRayManager;
-
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayManager.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayManager.cxx
deleted file mode 100755
index 310083f73a..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayManager.cxx
+++ /dev/null
@@ -1,76 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "ospray/ospray.h"
-
-#include "vtkOSPRayManager.h"
-#include "vtkObjectFactory.h"
-#include "vtkOSPRay.h"
-
-vtkOSPRayManager* vtkOSPRayManager::__singleton = NULL;
-
-// vtkStandardNewMacro(vtkOSPRayManager);
-
-vtkOSPRayManager* vtkOSPRayManager::New()
-{
-  return vtkOSPRayManager::Singleton();
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayManager::vtkOSPRayManager()
-{
-  VolumeModelLastFrame=-1;
-  if (1)
-  {
-    int ac =1;
-    const char* av[] = {"pvOSPRay\0","--osp:verbose\0"};
-    ospInit(&ac, av);
-  }
-  else  //coi
-  {
-    int ac =2;
-    const char* av[] = {"pvOSPRay\0","--osp:coi","\0"};
-    ospInit(&ac, av);
-  }
-  this->OSPRayVolumeRenderer = (osp::Renderer*)ospNewRenderer("raycast_volume_renderer");
-  this->OSPRayCamera = ospNewCamera("perspective");
-  this->OSPRayModel = ospNewModel();
-  this->OSPRayVolumeModel = this->OSPRayModel;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayManager::~vtkOSPRayManager()
-{
-
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayManager::PrintSelf( ostream& os, vtkIndent indent )
-{
-  this->Superclass::PrintSelf( os, indent );
-}
-
-vtkOSPRayManager* vtkOSPRayManager::Singleton()
-{
-  if (!__singleton)
-    __singleton = new vtkOSPRayManager();
-  return __singleton;
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayManager.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayManager.h
deleted file mode 100755
index df0c994862..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayManager.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayManager - persistant access to OSPRay engine
-// .SECTION Description
-// vtkOSPRayManager is a reference counted wrapper around the OSPRay engine.
-// Because it is reference counted, it outlives all vtkOSPRay classes that
-// reference it. That means that they can safely use it to manage their
-// own OSPRay side resources and that the engine itself will be destructed
-// when the wrapper is.
-//
-// Carson: This class initializes OSPRay and must be called through
-// the singleton before any OSPRay code is used.
-//
-
-#ifndef __vtkOSPRayManager_h
-#define __vtkOSPRayManager_h
-
-#include "vtkObject.h"
-#include "vtkOSPRayModule.h"
-#include <vector>
-
-
-//BTX
-namespace OSPRay {
-class Camera;
-class Factory;
-class Group;
-class LightSet;
-class OSPRayInterface;
-class Scene;
-class SyncDisplay;
-};
-//ETX
-
-namespace osp
-{
-class Renderer;
-class Model;
-class Camera;
-}
-
-
-class VTKOSPRAY_EXPORT vtkOSPRayManager : public vtkObject
-{
-public:
-  vtkTypeMacro(vtkOSPRayManager,vtkObject);
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-  static vtkOSPRayManager* Singleton();
-  static vtkOSPRayManager* New();
-
-protected:
-  vtkOSPRayManager();
-  ~vtkOSPRayManager();
-
-private:
-  vtkOSPRayManager(const vtkOSPRayManager&);  // Not implemented.
-  void operator=(const vtkOSPRayManager&);  // Not implemented.
-
-  static vtkOSPRayManager* __singleton;
-
-public:
-//
-//  OSPRay vars
-//
-  osp::Model* OSPRayModel;
-  osp::Renderer*    OSPRayRenderer;
-  osp::Camera*      OSPRayCamera;
-  osp::Model* OSPRayDynamicModel;
-  osp::Renderer*    OSPRayVolumeRenderer;
-  osp::Model* OSPRayVolumeModel;
-  vtkTimeStamp  VolumeModelBuildTime;
-  int VolumeModelLastFrame;
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayModule.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayModule.h
deleted file mode 100755
index 7566a539d5..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayModule.h
+++ /dev/null
@@ -1,41 +0,0 @@
-
-#ifndef VTKOSPRAY_EXPORT_H
-#define VTKOSPRAY_EXPORT_H
-
-#ifdef VTKOSPRAY_STATIC_DEFINE
-#  define VTKOSPRAY_EXPORT
-#  define VTKOSPRAY_NO_EXPORT
-#else
-#  ifndef VTKOSPRAY_EXPORT
-#    ifdef vtkOSPRay_EXPORTS
-        /* We are building this library */
-#      define VTKOSPRAY_EXPORT __attribute__((visibility("default")))
-#    else
-        /* We are using this library */
-#      define VTKOSPRAY_EXPORT __attribute__((visibility("default")))
-#    endif
-#  endif
-
-#  ifndef VTKOSPRAY_NO_EXPORT
-#    define VTKOSPRAY_NO_EXPORT __attribute__((visibility("hidden")))
-#  endif
-#endif
-
-#ifndef VTKOSPRAY_DEPRECATED
-#  define VTKOSPRAY_DEPRECATED __attribute__ ((__deprecated__))
-#  define VTKOSPRAY_DEPRECATED_EXPORT VTKOSPRAY_EXPORT __attribute__ ((__deprecated__))
-#  define VTKOSPRAY_DEPRECATED_NO_EXPORT VTKOSPRAY_NO_EXPORT __attribute__ ((__deprecated__))
-#endif
-
-#define DEFINE_NO_DEPRECATED 0
-#if DEFINE_NO_DEPRECATED
-# define VTKOSPRAY_NO_DEPRECATED
-#endif
-
-/* AutoInit dependencies.  */
-// #include "vtkFiltersCoreModule.h"
-// #include "vtkFiltersHybridModule.h"
-//#include "vtkPVClientServerCoreRenderingModule.h"
-//#include "vtkRenderingOpenGLModule.h"
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.cxx
deleted file mode 100755
index d38fb79488..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.cxx
+++ /dev/null
@@ -1,148 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayObjectFactory -
-// .SECTION Description
-//
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayRenderer.h"
-
-#include "vtkOSPRayObjectFactory.h"
-
-#include "vtkDebugLeaks.h"
-#include "vtkDynamicLoader.h"
-#include "vtkOverrideInformation.h"
-#include "vtkOverrideInformationCollection.h"
-#include "vtkVersion.h"
-
-#include "vtkOSPRayActor.h"
-#include "vtkOSPRayCamera.h"
-#include "vtkOSPRayLight.h"
-#include "vtkOSPRayPolyDataMapper.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkOSPRayTexture.h"
-
-#ifdef VTKOSPRAY_FOR_PARAVIEW
-#include "vtkOSPRayLODActor.h"
-#endif
-
-#include <DebugStream.h>
-
-vtkStandardNewMacro(vtkOSPRayObjectFactory);
-
-//----------------------------------------------------------------------------
-void vtkOSPRayObjectFactory::PrintSelf(ostream& os, vtkIndent indent)
-{
-  os << indent << "VTK OSPRay object factory" << endl;
-}
-
-//----------------------------------------------------------------------------
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayActor);
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayCamera);
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayLight);
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayPolyDataMapper);
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayProperty);
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayRenderer);
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayTexture);
-#ifdef VTKOSPRAY_FOR_PARAVIEW
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayLODActor);
-#endif
-
-//----------------------------------------------------------------------------
-vtkOSPRayObjectFactory::vtkOSPRayObjectFactory()
-{
-#ifdef VTKOSPRAY_FOR_PARAVIEW
-  this->RegisterOverride("vtkPVLODActor",
-                         "vtkOSPRayLODActor",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayLODActor);
-#endif
-
-  vtkOverrideInformationCollection *oic = 
-      vtkOverrideInformationCollection::New();
-
-  vtkObjectFactory::GetOverrideInformation("vtkActor", oic);
-  if(oic->GetNumberOfItems() != 0)
-      vtkObjectFactory::SetAllEnableFlags(0, "vtkActor");
-  this->RegisterOverride("vtkActor",
-                         "vtkOSPRayActor",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayActor);
-  vtkObjectFactory::GetOverrideInformation("vtkCamera", oic);
-  if(oic->GetNumberOfItems() != 0)
-      vtkObjectFactory::SetAllEnableFlags(0, "vtkCamera");
-  this->RegisterOverride("vtkCamera",
-                         "vtkOSPRayCamera",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayCamera);
-  vtkObjectFactory::GetOverrideInformation("vtkPolyDataMapper", oic);
-  if(oic->GetNumberOfItems() != 0)
-      vtkObjectFactory::SetAllEnableFlags(0, "vtkPolyDataMapper");
-  this->RegisterOverride("vtkPolyDataMapper",
-                         "vtkOSPRayPolyDataMapper",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayPolyDataMapper);
-  vtkObjectFactory::GetOverrideInformation("vtkProperty", oic);
-  if(oic->GetNumberOfItems() != 0)
-      vtkObjectFactory::SetAllEnableFlags(0, "vtkProperty");
-  this->RegisterOverride("vtkProperty",
-                         "vtkOSPRayProperty",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayProperty);
-  vtkObjectFactory::GetOverrideInformation("vtkRenderer", oic);
-  if(oic->GetNumberOfItems() != 0)
-      vtkObjectFactory::SetAllEnableFlags(0, "vtkRenderer");
-  this->RegisterOverride("vtkRenderer",
-                         "vtkOSPRayRenderer",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayRenderer);
-  vtkObjectFactory::GetOverrideInformation("vtkTexture", oic);
-  if(oic->GetNumberOfItems() != 0)
-      vtkObjectFactory::SetAllEnableFlags(0, "vtkTexture");
-  this->RegisterOverride("vtkTexture",
-                         "vtkOSPRayTexture",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayTexture);
-}
-
-//----------------------------------------------------------------------------
-//ALOK: removing this because it conflicts with vtkManta
-//VTK_FACTORY_INTERFACE_IMPLEMENT(vtkOSPRayObjectFactory);
-
-//----------------------------------------------------------------------------
-const char *vtkOSPRayObjectFactory::GetVTKSourceVersion()
-{
-  return VTK_SOURCE_VERSION;
-}
-
-//----------------------------------------------------------------------------
-const char *vtkOSPRayObjectFactory::GetDescription()
-{
-  return "VTK OSPRay Object Factory";
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.h
deleted file mode 100755
index 539281142a..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayObjectFactory -
-// .SECTION Description
-//
-#ifndef __vtkOSPRayObjectFactory_h
-#define __vtkOSPRayObjectFactory_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkObjectFactory.h"
-
-class VTKOSPRAY_EXPORT vtkOSPRayObjectFactory : public vtkObjectFactory
-{
-
-public:
-  // Methods from vtkObject
-  vtkTypeMacro(vtkOSPRayObjectFactory,vtkObjectFactory);
-  static vtkOSPRayObjectFactory *New();
-  void PrintSelf(ostream& os, vtkIndent indent);
-  virtual const char* GetVTKSourceVersion();
-  virtual const char* GetDescription();
-
-protected:
-  vtkOSPRayObjectFactory();
-  ~vtkOSPRayObjectFactory() {}
-
-private:
-  vtkOSPRayObjectFactory(const vtkOSPRayObjectFactory&); // Not implemented.
-  void operator=(const vtkOSPRayObjectFactory&);   // Not implemented.
-};
-
-#endif /* vtkOSPRayObjectFactory_h */
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPVLODVolume.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPVLODVolume.cxx
deleted file mode 100755
index c6f35b6f9a..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPVLODVolume.cxx
+++ /dev/null
@@ -1,401 +0,0 @@
-/*=========================================================================
-
-  Program:   ParaView
-  Module:    vtkOSPRayPVLODVolume.cxx
-
-  Copyright (c) Kitware, Inc.
-  All rights reserved.
-  See Copyright.txt or http://www.paraview.org/HTML/Copyright.html for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-#include "vtkOSPRayPVLODVolume.h"
-
-#include "vtkDataSet.h"
-#include "vtkImageData.h"
-#include "vtkLODProp3D.h"
-#include "vtkMapper.h"
-#include "vtkMath.h"
-#include "vtkObjectFactory.h"
-#include "vtkProperty.h"
-#include "vtkTransform.h"
-#include "vtkUnstructuredGridBase.h"
-#include "vtkUnstructuredGridVolumeMapper.h"
-#include "vtkVolumeMapper.h"
-#include "vtkVolumeProperty.h"
-
-#include <math.h>
-
-//-----------------------------------------------------------------------------
-vtkStandardNewMacro(vtkOSPRayPVLODVolume);
-
-//----------------------------------------------------------------------------
-vtkOSPRayPVLODVolume::vtkOSPRayPVLODVolume()
-{
-  this->LODProp = vtkLODProp3D::New();
-  this->LODProp->AutomaticLODSelectionOff();
-  this->LODProp->AutomaticPickLODSelectionOff();
-
-  this->HighLODId = -1;
-  this->LowLODId = -1;
-
-  this->MapperBounds[0] = this->MapperBounds[1] = this->MapperBounds[2] = 0;
-  this->MapperBounds[3] = this->MapperBounds[4] = this->MapperBounds[5] = 0;
-
-  this->EnableLOD = 0;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayPVLODVolume::~vtkOSPRayPVLODVolume()
-{
-  this->LODProp->Delete();
-}
-
-//----------------------------------------------------------------------------
-int vtkOSPRayPVLODVolume::SelectLOD()
-{
-  if (this->LowLODId < 0)
-    {
-    return this->HighLODId;
-    }
-  if (this->HighLODId < 0)
-    {
-    return this->LowLODId;
-    }
-
-  if (this->EnableLOD)
-    {
-    return this->LowLODId;
-    }
-
-  return this->HighLODId;
-}
-
-
-//-----------------------------------------------------------------------------
-bool vtkOSPRayPVLODVolume::CanRender()
-{
-  int lodid =this->LODProp->GetSelectedLODID();
-  if (lodid >= 0)
-    {
-    vtkAbstractMapper3D* mapper = this->LODProp->GetLODMapper(lodid);
-    if (vtkVolumeMapper* imageVolumeMapper = vtkVolumeMapper::SafeDownCast(mapper))
-      {
-      int unused = 0;
-      vtkDataSet* input = imageVolumeMapper->GetInput();
-      vtkDataArray* scalars = input == NULL? NULL :
-        vtkAbstractMapper::GetScalars(input,
-          imageVolumeMapper->GetScalarMode(),
-          imageVolumeMapper->GetArrayAccessMode(),
-          imageVolumeMapper->GetArrayId(),
-          imageVolumeMapper->GetArrayName(),
-          unused);
-      return scalars != NULL;
-      }
-    else if (vtkUnstructuredGridVolumeMapper* ugMapper = vtkUnstructuredGridVolumeMapper::SafeDownCast(mapper))
-      {
-      int unused = 0;
-      vtkDataSet* input = ugMapper->GetInput();
-      vtkDataArray* scalars = input == NULL? NULL :
-        vtkAbstractMapper::GetScalars(input,
-          ugMapper->GetScalarMode(),
-          ugMapper->GetArrayAccessMode(),
-          ugMapper->GetArrayId(),
-          ugMapper->GetArrayName(),
-          unused);
-      return scalars != NULL;
-      }
-    }
-  return true;
-}
-
-//-----------------------------------------------------------------------------
-int vtkOSPRayPVLODVolume::RenderOpaqueGeometry(vtkViewport *vp)
-{
-  if (!this->CanRender()) { return 1; }
-  int retval = this->LODProp->RenderOpaqueGeometry(vp);
-
-  this->EstimatedRenderTime = this->LODProp->GetEstimatedRenderTime();
-
-  return retval;
-}
-
-//-----------------------------------------------------------------------------
-int vtkOSPRayPVLODVolume::RenderTranslucentPolygonalGeometry(vtkViewport *vp)
-{
-  if (!this->CanRender()) { return 1; }
-  //std::cout << __PRETTY_FUNCTION__ << " 1" << std::endl;
-  int retval = this->LODProp->RenderTranslucentPolygonalGeometry(vp);
-
-  this->EstimatedRenderTime = this->LODProp->GetEstimatedRenderTime();
-
-  return retval;
-}
-
-
-//-----------------------------------------------------------------------------
-int vtkOSPRayPVLODVolume::RenderVolumetricGeometry(vtkViewport *vp)
-{
-  int retval = this->LODProp->RenderVolumetricGeometry(vp);
-
-  this->EstimatedRenderTime = this->LODProp->GetEstimatedRenderTime();
-
-  return retval;
-}
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::ReleaseGraphicsResources(vtkWindow *renWin)
-{
-  this->Superclass::ReleaseGraphicsResources(renWin);
-  this->LODProp->ReleaseGraphicsResources(renWin);
-}
-
-
-//-----------------------------------------------------------------------------
-// Get the bounds for this Actor as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax).
-double *vtkOSPRayPVLODVolume::GetBounds()
-{
-  int i,n;
-  double *bounds, bbox[24], *fptr;
-
-  int lod = this->SelectLOD();
-  if (lod < 0)
-    {
-    return this->Bounds;
-    }
-
-  vtkAbstractMapper3D *mapper = this->LODProp->GetLODMapper(lod);
-
-  vtkDebugMacro( << "Getting Bounds" );
-
-  // get the bounds of the Mapper if we have one
-  if (!mapper)
-    {
-    return this->Bounds;
-    }
-
-  bounds = mapper->GetBounds();
-  // Check for the special case when the mapper's bounds are unknown
-  if (!bounds)
-    {
-    return bounds;
-    }
-
-  // Check for the special case when the actor is empty.
-  if (bounds[0] > bounds[1])
-    {
-    memcpy( this->MapperBounds, bounds, 6*sizeof(double) );
-    vtkMath::UninitializeBounds(this->Bounds);
-    this->BoundsMTime.Modified();
-    return this->Bounds;
-    }
-
-  // Check if we have cached values for these bounds - we cache the
-  // values returned by this->Mapper->GetBounds() and we store the time
-  // of caching. If the values returned this time are different, or
-  // the modified time of this class is newer than the cached time,
-  // then we need to rebuild.
-  if ( ( memcmp( this->MapperBounds, bounds, 6*sizeof(double) ) != 0 ) ||
-       ( this->GetMTime() > this->BoundsMTime ) )
-    {
-    vtkDebugMacro( << "Recomputing bounds..." );
-
-    memcpy( this->MapperBounds, bounds, 6*sizeof(double) );
-
-    // fill out vertices of a bounding box
-    bbox[ 0] = bounds[1]; bbox[ 1] = bounds[3]; bbox[ 2] = bounds[5];
-    bbox[ 3] = bounds[1]; bbox[ 4] = bounds[2]; bbox[ 5] = bounds[5];
-    bbox[ 6] = bounds[0]; bbox[ 7] = bounds[2]; bbox[ 8] = bounds[5];
-    bbox[ 9] = bounds[0]; bbox[10] = bounds[3]; bbox[11] = bounds[5];
-    bbox[12] = bounds[1]; bbox[13] = bounds[3]; bbox[14] = bounds[4];
-    bbox[15] = bounds[1]; bbox[16] = bounds[2]; bbox[17] = bounds[4];
-    bbox[18] = bounds[0]; bbox[19] = bounds[2]; bbox[20] = bounds[4];
-    bbox[21] = bounds[0]; bbox[22] = bounds[3]; bbox[23] = bounds[4];
-
-    // save the old transform
-    this->Transform->Push();
-    this->Transform->SetMatrix(this->GetMatrix());
-
-    // and transform into actors coordinates
-    fptr = bbox;
-    for (n = 0; n < 8; n++)
-      {
-      this->Transform->TransformPoint(fptr,fptr);
-      fptr += 3;
-      }
-
-    this->Transform->Pop();
-
-    // now calc the new bounds
-    this->Bounds[0] = this->Bounds[2] = this->Bounds[4] = VTK_DOUBLE_MAX;
-    this->Bounds[1] = this->Bounds[3] = this->Bounds[5] = -VTK_DOUBLE_MAX;
-    for (i = 0; i < 8; i++)
-      {
-      for (n = 0; n < 3; n++)
-        {
-        if (bbox[i*3+n] < this->Bounds[n*2])
-          {
-          this->Bounds[n*2] = bbox[i*3+n];
-          }
-        if (bbox[i*3+n] > this->Bounds[n*2+1])
-          {
-          this->Bounds[n*2+1] = bbox[i*3+n];
-          }
-        }
-      }
-    this->BoundsMTime.Modified();
-    }
-
-  return this->Bounds;
-}
-
-
-//-----------------------------------------------------------------------------
-int vtkOSPRayPVLODVolume::HasTranslucentPolygonalGeometry()
-{
-  if (this->SelectLOD() == this->LowLODId)
-    {
-    return 1;
-    }
-  return 0;
-}
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::ShallowCopy(vtkProp *prop)
-{
-  vtkOSPRayPVLODVolume *a = vtkOSPRayPVLODVolume::SafeDownCast(prop);
-  if ( a != NULL )
-    {
-    this->LODProp->ShallowCopy(a->LODProp);
-    }
-
-  // Now do superclass
-  this->vtkVolume::ShallowCopy(prop);
-}
-
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::SetProperty(vtkVolumeProperty *property)
-{
-  this->Superclass::SetProperty(property);
-
-  this->UpdateLODProperty();
-}
-
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::SetMapper(vtkAbstractVolumeMapper *mapper)
-{
-  if (this->HighLODId >= 0)
-    {
-    if (mapper == this->LODProp->GetLODMapper(this->HighLODId)) return;
-    this->LODProp->RemoveLOD(this->HighLODId);
-    this->HighLODId = -1;
-    }
-
-  if (mapper)
-    {
-    this->HighLODId = this->LODProp->AddLOD(mapper, this->GetProperty(), 1.0);
-    this->UpdateLODProperty();
-    }
-}
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::SetLODMapper(vtkAbstractVolumeMapper *mapper)
-{
-  if (this->LowLODId >= 0)
-    {
-    if (mapper == this->LODProp->GetLODMapper(this->LowLODId)) return;
-    this->LODProp->RemoveLOD(this->LowLODId);
-    this->LowLODId = -1;
-    }
-
-  if (mapper)
-    {
-    this->LowLODId = this->LODProp->AddLOD(mapper, this->GetProperty(), 0.0);
-    this->UpdateLODProperty();
-    }
-}
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::SetLODMapper(vtkMapper *mapper)
-{
-  if (this->LowLODId >= 0)
-    {
-    if (mapper == this->LODProp->GetLODMapper(this->LowLODId)) return;
-    this->LODProp->RemoveLOD(this->LowLODId);
-    this->LowLODId = -1;
-    }
-
-  if (mapper)
-    {
-    vtkProperty *property = vtkProperty::New();
-    property->SetOpacity(0.5);
-    this->LowLODId = this->LODProp->AddLOD(mapper, property, 0.0);
-    property->Delete();
-    this->UpdateLODProperty();
-    }
-}
-
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::SetAllocatedRenderTime(double t, vtkViewport *v)
-{
-  this->Superclass::SetAllocatedRenderTime(t, v);
-
-  // This is a good time to update the LODProp.
-  this->LODProp->SetUserMatrix(this->GetMatrix());
-
-  int lod = this->SelectLOD();
-  if (lod < 0)
-    {
-    vtkErrorMacro(<< "You must give me a mapper!");
-    }
-  this->LODProp->SetSelectedLODID(lod);
-  this->LODProp->SetSelectedPickLODID(lod);
-
-  this->LODProp->SetAllocatedRenderTime(t, v);
-}
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::UpdateLODProperty()
-{
-  if (!this->Property)
-    {
-    vtkErrorMacro("No property is defined cannot update.");
-    return;
-    }
-
-  if (this->HighLODId >= 0)
-    {
-    this->LODProp->SetLODProperty(this->HighLODId, this->Property);
-    }
-
-  if (this->LowLODId >= 0)
-    {
-    vtkMapper *mapper;
-    this->LODProp->GetLODMapper(this->LowLODId, &mapper);
-    if (mapper)
-      {
-      }
-    else
-      {
-      // This is a volume mapper.  Just share the property.
-      this->LODProp->SetLODProperty(this->LowLODId, this->Property);
-      }
-    }
-}
-
-
-//----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os,indent);
-
-  os << indent << "EnableLOD: " << this->EnableLOD << endl;
-  os << indent << "LODProp: " << endl;
-  this->LODProp->PrintSelf(os, indent.GetNextIndent());
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPVLODVolume.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPVLODVolume.h
deleted file mode 100755
index 83f58604da..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPVLODVolume.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/*=========================================================================
-
-  Program:   ParaView
-  Module:    vtkOSPRayPVLODVolume.h
-
-  Copyright (c) Kitware, Inc.
-  All rights reserved.
-  See Copyright.txt or http://www.paraview.org/HTML/Copyright.html for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-// .NAME vtkOSPRayPVLODVolume - an actor that supports multiple levels of detail
-// .SECTION Description
-// vtkOSPRayPVLODVolume is much like vtkPVLODActor except that it works on
-// volumes instead of surfaces.  This just has two mappers: full res and
-// LOD, and this actor knows which is which.
-
-// .SECTION see also
-// vtkActor vtkRenderer vtkLODProp3D vtkLODActor
-
-#ifndef __vtkOSPRayPVLODVolume_h
-#define __vtkOSPRayPVLODVolume_h
-
-#include "vtkVolume.h"
-#include "vtkPVVTKExtensionsRenderingModule.h" // needed for export macro
-
-class vtkLODProp3D;
-class vtkMapper;
-
-class VTKPVVTKEXTENSIONSRENDERING_EXPORT vtkOSPRayPVLODVolume : public vtkVolume
-{
-public:
-  vtkTypeMacro(vtkOSPRayPVLODVolume,vtkVolume);
-  void PrintSelf(ostream& os, vtkIndent indent);
-
-  static vtkOSPRayPVLODVolume *New();
-
-  // Description:
-  // This method is used internally by the rendering process.
-  virtual int RenderOpaqueGeometry(vtkViewport *viewport);
-  virtual int RenderVolumetricGeometry(vtkViewport *viewport);
-  virtual int RenderTranslucentPolygonalGeometry( vtkViewport *);
-
-  // Description:
-  // Does this prop have some translucent polygonal geometry?
-  virtual int HasTranslucentPolygonalGeometry();
-
-  // Description:
-  // Release any graphics resources that are being consumed by this actor.
-  // The parameter window could be used to determine which graphic
-  // resources to release.
-  virtual void ReleaseGraphicsResources(vtkWindow *);
-
-  // Description:
-  // Set the high res input.  Overloads the virtual vtkVolume method.
-  virtual void SetMapper(vtkAbstractVolumeMapper *);
-
-  // Description:
-  // This sets the low res input.
-  virtual void SetLODMapper(vtkAbstractVolumeMapper *);
-  virtual void SetLODMapper(vtkMapper *);
-
-  // Description:
-  // Sets the volume propery.  Overloads the virtual vtkVolume method.
-  virtual void SetProperty(vtkVolumeProperty *property);
-
-  // Description:
-  // Shallow copy of an LOD actor. Overloads the virtual vtkProp method.
-  virtual void ShallowCopy(vtkProp *prop);
-
-  // Description:
-  // Get the bounds of the current mapper.
-  virtual double *GetBounds();
-
-  // Description:
-  // Overloads the virtual vtkProp method.
-  virtual void SetAllocatedRenderTime(double t, vtkViewport *v);
-
-  // Description:
-  // When set, LODMapper, if present it used, otherwise the regular mapper is
-  // used.
-  vtkSetMacro(EnableLOD, int);
-  vtkGetMacro(EnableLOD, int);
-protected:
-  vtkOSPRayPVLODVolume();
-  ~vtkOSPRayPVLODVolume();
-
-  // Description:
-  // Since volume mapper are notorious for segfaulting when the scalar array is
-  // missing we use this method to validate that we can actually render the
-  // data.
-  bool CanRender();
-
-  vtkLODProp3D *LODProp;
-  int HighLODId;
-  int LowLODId;
-  int EnableLOD;
-  int SelectLOD();
-  double MapperBounds[6];
-  vtkTimeStamp BoundsMTime;
-  virtual void UpdateLODProperty();
-private:
-  vtkOSPRayPVLODVolume(const vtkOSPRayPVLODVolume&); // Not implemented.
-  void operator=(const vtkOSPRayPVLODVolume&); // Not implemented.
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.cxx
deleted file mode 100755
index beec2db666..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.cxx
+++ /dev/null
@@ -1,1018 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas
-   at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use
-   this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the
-   License at:
-
-http://opensource.org/licenses/BSD-3-Clause
-
-Unless required by applicable law or agreed to in writing, software
-distributed under
-the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
-CONDITIONS OF ANY
-KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under
-limitations under the License.
-
-pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules
-(PVLANL)
-Copyright (c) 2007, Los Alamos National Security, LLC
-=======================================================================================
-*/
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayActor.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayPolyDataMapper.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkOSPRayRenderer.h"
-#include "vtkOSPRayTexture.h"
-
-#include "vtkAppendPolyData.h"
-#include "vtkCellArray.h"
-#include "vtkCellData.h"
-#include "vtkCommand.h"
-#include "vtkDataArray.h"
-#include "vtkDoubleArray.h"
-#include "vtkFloatArray.h"
-#include "vtkGenericCell.h"
-#include "vtkGlyph3D.h"
-#include "vtkImageData.h"
-#include "vtkMatrix4x4.h"
-#include "vtkObjectFactory.h"
-#include "vtkPointData.h"
-#include "vtkPoints.h"
-#include "vtkPolyData.h"
-#include "vtkProperty.h"
-#include "vtkScalarsToColors.h"
-#include "vtkSphereSource.h"
-#include "vtkTransform.h"
-#include "vtkTubeFilter.h"
-#include "vtkUnsignedCharArray.h"
-
-#include "vtkInformation.h"
-#include "vtkInformationVector.h"
-
-#include <vector>
-
-#include <math.h>
-#include <algorithm>
-
-
-vtkStandardNewMacro(vtkOSPRayPolyDataMapper);
-
-namespace vtkosp {
-    class Vec3 {
-        public:
-            Vec3(float x, float y, float z) {
-                vals[0] = x;
-                vals[1] = y;
-                vals[2] = z;
-            }
-            float operator[](unsigned int i) const { return vals[i]; }
-            float x() { return vals[0]; }
-            float y() { return vals[1]; }
-            float z() { return vals[2]; }
-
-            float vals[3];
-    };
-    class Vec4 {
-        public:
-            Vec4(float x, float y, float z, float w) {
-                vals[0] = x;
-                vals[1] = y;
-                vals[2] = z;
-                vals[3] = w;
-            }
-            float operator[](unsigned int i) const { return vals[i]; }
-            float x() { return vals[0]; }
-            float y() { return vals[1]; }
-            float z() { return vals[2]; }
-            float w() { return vals[3]; }
-
-            float vals[4];
-    };
-    class Vec2 {
-        public:
-            Vec2(float x, float y) {
-                vals[0] = x;
-                vals[1] = y;
-            }
-            float operator[](unsigned int i) const { return vals[i]; }
-            float x() { return vals[0]; }
-            float y() { return vals[1]; }
-
-            float vals[2];
-    };
-    class Mesh {
-        public:
-            size_t size() { return vertex_indices.size() / 3; }
-            std::vector<size_t> vertex_indices;
-            std::vector<Vec3> vertices;
-            std::vector<Vec3> vertexNormals;
-            std::vector<Vec2> texCoords;
-            std::vector<size_t> texture_indices;
-            std::vector<size_t> normal_indices;
-            std::vector<Vec4> colors;
-            std::vector<ospray::vec3fa> wireframe_vertex;
-            std::vector<int> wireframe_index;
-            std::vector<ospray::vec3f> points_vertex;
-    };
-}
-
-int vtkOSPRayPolyDataMapper::timestep = 0;  // HACK!
-void* alignedMalloc(size_t size, size_t align=64)
-{
-    if (size == 0) return NULL;
-    char* base = (char*)malloc(size + align + sizeof(int));
-    if (base == NULL) throw std::bad_alloc();
-
-    char* unaligned = base + sizeof(int);
-    char*   aligned = unaligned + align - ((size_t)unaligned & (align - 1));
-    ((int*)aligned)[-1] = (int)((size_t)aligned - (size_t)base);
-    return aligned;
-}
-
-void alignedFree(const void* ptr) {
-    if (ptr == NULL) return;
-    int ofs = ((int*)ptr)[-1];
-    free((char*)ptr - ofs);
-}
-
-//----------------------------------------------------------------------------
-// Construct empty object.
-vtkOSPRayPolyDataMapper::vtkOSPRayPolyDataMapper() {
-    this->InternalColorTexture = NULL;
-    this->OSPRayManager = NULL;
-    this->PointSize = 1.0;
-    this->LineWidth = 1.0;
-    this->Representation = VTK_SURFACE;
-}
-
-//----------------------------------------------------------------------------
-// Destructor (don't call ReleaseGraphicsResources() since it is virtual
-vtkOSPRayPolyDataMapper::~vtkOSPRayPolyDataMapper() {
-    if (this->InternalColorTexture) {
-        this->InternalColorTexture->Delete();
-    }
-
-    if (this->OSPRayManager) {
-        this->OSPRayManager->Delete();
-    }
-
-}
-
-//----------------------------------------------------------------------------
-// Release the graphics resources used by this mapper.  In this case, release
-// the display list if any.
-void vtkOSPRayPolyDataMapper::ReleaseGraphicsResources(vtkWindow *win) {
-    this->Superclass::ReleaseGraphicsResources(win);
-
-    if (this->InternalColorTexture) {
-        this->InternalColorTexture->Delete();
-    }
-    this->InternalColorTexture = NULL;
-}
-
-//----------------------------------------------------------------------------
-// Receives from Actor -> maps data to primitives
-// called by Mapper->Render() (which is called by Actor->Render())
-void vtkOSPRayPolyDataMapper::RenderPiece(vtkRenderer *ren, vtkActor *act) {
-    vtkOSPRayRenderer *OSPRayRenderer = vtkOSPRayRenderer::SafeDownCast(ren);
-    if (!OSPRayRenderer) {
-        return;
-    }
-    if (!this->OSPRayManager) {
-        this->OSPRayManager = OSPRayRenderer->GetOSPRayManager();
-        this->OSPRayManager->Register(this);
-    }
-
-    // write geometry, first ask the pipeline to update data
-    vtkPolyData *input = this->GetInput();
-    if (input == NULL) {
-        vtkErrorMacro(<< "No input to vtkOSPRayPolyDataMapper!");
-        return;
-    } else {
-        this->InvokeEvent(vtkCommand::StartEvent, NULL);
-
-        // Static = 1:  this mapper does NOT need to propagate updates to other
-        // mappers
-        // down the pipeline and therefore saves the time that would be otherwise
-        // taken
-        if (!this->Static) {
-            this->Update();
-        }
-
-        this->InvokeEvent(vtkCommand::EndEvent, NULL);
-
-        vtkIdType numPts = input->GetNumberOfPoints();
-        if (numPts == 0) {
-            vtkDebugMacro(<< "No points from the input to vtkOSPRayPolyDataMapper!");
-            input = NULL;
-            return;
-        }
-    }
-
-    if (this->LookupTable == NULL) {
-        this->CreateDefaultLookupTable();
-    }
-
-    // For vertex coloring, this sets this->Colors as side effect.
-    // For texture map coloring, this sets ColorCoordinates
-    // and ColorTextureMap as a side effect.
-    this->MapScalars(act->GetProperty()->GetOpacity());
-
-    if (this->ColorTextureMap) {
-        if (!this->InternalColorTexture) {
-            this->InternalColorTexture = vtkOSPRayTexture::New();
-            this->InternalColorTexture->RepeatOff();
-        }
-        this->InternalColorTexture->SetInputData(this->ColorTextureMap);
-    }
-
-    // if something has changed, regenerate OSPRay primitives if required
-    if (this->GetMTime() > this->BuildTime ||
-            input->GetMTime() > this->BuildTime ||
-            act->GetProperty()->GetMTime() > this->BuildTime ||
-            act->GetMatrix()->GetMTime() > this->BuildTime) {
-
-        // If we are coloring by texture, then load the texture map.
-        // Use Map as indicator, because texture hangs around.
-        if (this->ColorTextureMap) {
-            this->InternalColorTexture->Load(ren, true);
-        }
-
-        this->Draw(ren, act);
-        this->BuildTime.Modified();
-    }
-
-    this->Update();
-    input = NULL;
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayPolyDataMapper::DrawPolygons(vtkPolyData *polys,
-        vtkPoints *ptarray,
-        vtkosp::Mesh *mesh
-        ) {
-
-    int total_triangles = 0;
-    vtkCellArray *cells = polys->GetPolys();
-    vtkIdType npts = 0, *index = 0, cellNum = 0;
-
-    switch (this->Representation) {
-        case VTK_POINTS: {
-                             double coord[3];
-                             for (cells->InitTraversal(); cells->GetNextCell(npts, index); cellNum++) {
-                                 ptarray->GetPoint(index[0], coord);
-                                 mesh->points_vertex.push_back
-                                     (ospray::vec3f(coord[0], coord[1], coord[2]));
-                                 for (vtkIdType i = 1; i < npts; i++) {
-
-                                     ptarray->GetPoint(index[i], coord);
-                                     mesh->points_vertex.push_back
-                                         (ospray::vec3f(coord[0], coord[1], coord[2]));
-                                 }
-                             }
-                         }  // VTK_POINTS;
-                         break;
-        case VTK_WIREFRAME: {
-                                double coord0[3];
-                                for (cells->InitTraversal(); cells->GetNextCell(npts, index); cellNum++) {
-                                    ptarray->GetPoint(index[0], coord0);
-                                    mesh->wireframe_vertex.push_back(
-                                            ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-                                    for (vtkIdType i = 1; i < npts; i++) {
-
-                                        mesh->wireframe_index.push_back(mesh->wireframe_vertex.size() - 1);
-                                        ptarray->GetPoint(index[i], coord0);
-                                        mesh->wireframe_vertex.push_back(
-                                                ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-                                    }
-                                }
-                            }  // VTK_WIREFRAME:
-                            break;
-        case VTK_SURFACE: {
-                              // write polygons with on the fly triangulation, assuming polygons are
-                              // simple and
-                              // can be triangulated into "fans"
-                              for (cells->InitTraversal(); cells->GetNextCell(npts, index); cellNum++) {
-                                  int triangle[3];
-
-                                  // the first triangle
-                                  triangle[0] = index[0];
-                                  triangle[1] = index[1];
-                                  triangle[2] = index[2];
-                                  mesh->vertex_indices.push_back(triangle[0]);
-                                  mesh->vertex_indices.push_back(triangle[1]);
-                                  mesh->vertex_indices.push_back(triangle[2]);
-
-                                  if (!mesh->vertexNormals.empty()) {
-                                      mesh->normal_indices.push_back(triangle[0]);
-                                      mesh->normal_indices.push_back(triangle[1]);
-                                      mesh->normal_indices.push_back(triangle[2]);
-                                  }
-
-                                  if (!mesh->texCoords.empty()) {
-                                      if (this->CellScalarColor) {
-                                          mesh->texture_indices.push_back(cellNum);
-                                          mesh->texture_indices.push_back(cellNum);
-                                          mesh->texture_indices.push_back(cellNum);
-                                      } else {
-                                          mesh->texture_indices.push_back(triangle[0]);
-                                          mesh->texture_indices.push_back(triangle[1]);
-                                          mesh->texture_indices.push_back(triangle[2]);
-                                      }
-                                  }
-                                  total_triangles++;
-
-                                  // the remaining triangles, of which
-                                  // each introduces a triangle after extraction
-                                  for (int i = 3; i < npts; i++) {
-                                      triangle[1] = triangle[2];
-                                      triangle[2] = index[i];
-                                      mesh->vertex_indices.push_back(triangle[0]);
-                                      mesh->vertex_indices.push_back(triangle[1]);
-                                      mesh->vertex_indices.push_back(triangle[2]);
-
-                                      if (!mesh->vertexNormals.empty()) {
-                                          mesh->normal_indices.push_back(triangle[0]);
-                                          mesh->normal_indices.push_back(triangle[1]);
-                                          mesh->normal_indices.push_back(triangle[2]);
-                                      }
-
-                                      if (!mesh->texCoords.empty()) {
-                                          if (this->CellScalarColor) {
-                                              mesh->texture_indices.push_back(cellNum);
-                                              mesh->texture_indices.push_back(cellNum);
-                                              mesh->texture_indices.push_back(cellNum);
-                                          } else {
-                                              mesh->texture_indices.push_back(triangle[0]);
-                                              mesh->texture_indices.push_back(triangle[1]);
-                                              mesh->texture_indices.push_back(triangle[2]);
-                                          }
-                                      }
-                                      total_triangles++;
-                                  }
-                              }
-
-                              for (int i = 0; i < total_triangles; i++) {
-                              }
-
-                              for (cells->InitTraversal();
-                                      this->Edges && cells->GetNextCell(npts, index); cellNum++) {
-                                  double coord0[3];
-                                  ptarray->GetPoint(index[0], coord0);
-                                  mesh->wireframe_vertex.push_back(
-                                          ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-                                  for (vtkIdType i = 1; i < npts; i++) {
-                                      mesh->wireframe_index.push_back(mesh->wireframe_vertex.size() - 1);
-                                      ptarray->GetPoint(index[i], coord0);
-                                      mesh->wireframe_vertex.push_back(
-                                              ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-                                  }
-                              }
-
-
-                          }  // VTK_SURFACE
-                          break;
-        default:
-                          std::cerr << "unknwon representation type\n";
-                          break;
-    }
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayPolyDataMapper::DrawTStrips(vtkPolyData *polys,
-        vtkPoints *ptarray,
-        vtkosp::Mesh *mesh)
-{
-
-    // total number of triangles
-    int total_triangles = 0;
-
-    vtkCellArray *cells = polys->GetStrips();
-    vtkIdType npts = 0, *index = 0, cellNum = 0;
-    ;
-
-    switch (this->Representation) {
-        case VTK_POINTS: {
-                             for (cells->InitTraversal(); cells->GetNextCell(npts, index); cellNum++) {
-                                 double coord[3];
-                                 for (int i = 0; i < npts; i++) {
-                                     ptarray->GetPoint(index[i], coord);
-                                 }
-                                 total_triangles++;
-                             }
-                         }  // VTK_POINTS;
-                         break;
-        case VTK_WIREFRAME: {
-                                double coord0[3];
-                                double coord1[3];
-                                double coord2[3];
-                                for (cells->InitTraversal(); cells->GetNextCell(npts, index); cellNum++) {
-                                    ptarray->GetPoint(index[0], coord0);
-                                    mesh->wireframe_vertex.push_back(
-                                            ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-                                    for (vtkIdType i = 2; i < npts; i++) {
-                                        mesh->wireframe_index.push_back(mesh->wireframe_vertex.size() - 1);
-                                        ptarray->GetPoint(index[0], coord0);
-                                        mesh->wireframe_vertex.push_back(
-                                                ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-                                    }
-                                }
-                            }  // VTK_WIREFRAME:
-                            break;
-        case VTK_SURFACE: {
-                              for (cells->InitTraversal(); cells->GetNextCell(npts, index); cellNum++) {
-                                  // count of the i-th triangle in a strip
-                                  int numtriangles2 = 0;
-
-                                  int triangle[3];
-                                  // the first triangle
-                                  triangle[0] = index[0];
-                                  triangle[1] = index[1];
-                                  triangle[2] = index[2];
-                                  mesh->vertex_indices.push_back(triangle[0]);
-                                  mesh->vertex_indices.push_back(triangle[1]);
-                                  mesh->vertex_indices.push_back(triangle[2]);
-
-                                  if (!mesh->vertexNormals.empty()) {
-                                      mesh->normal_indices.push_back(triangle[0]);
-                                      mesh->normal_indices.push_back(triangle[1]);
-                                      mesh->normal_indices.push_back(triangle[2]);
-                                  }
-
-                                  if (!mesh->texCoords.empty()) {
-                                      if (this->CellScalarColor) {
-                                          mesh->texture_indices.push_back(cellNum);
-                                          mesh->texture_indices.push_back(cellNum);
-                                          mesh->texture_indices.push_back(cellNum);
-                                      } else {
-                                          mesh->texture_indices.push_back(triangle[0]);
-                                          mesh->texture_indices.push_back(triangle[1]);
-                                          mesh->texture_indices.push_back(triangle[2]);
-                                      }
-                                  }
-
-                                  total_triangles++;
-                                  numtriangles2++;
-
-                                  // the rest of triangles
-                                  for (int i = 3; i < npts; i++) {
-                                      int tmp[3];
-                                      if (numtriangles2 % 2 == 1) {
-                                          // an odd triangle
-                                          tmp[0] = triangle[1];
-                                          tmp[1] = triangle[2];
-                                          tmp[2] = index[i];
-
-                                          triangle[0] = tmp[0];
-                                          triangle[1] = tmp[2];
-                                          triangle[2] = tmp[1];
-                                      } else {
-                                          // an even triangle
-                                          tmp[0] = triangle[1];
-                                          tmp[1] = triangle[2];
-                                          tmp[2] = index[i];
-
-                                          triangle[0] = tmp[1];
-                                          triangle[1] = tmp[0];
-                                          triangle[2] = tmp[2];
-                                      }
-
-                                      mesh->vertex_indices.push_back(triangle[0]);
-                                      mesh->vertex_indices.push_back(triangle[1]);
-                                      mesh->vertex_indices.push_back(triangle[2]);
-
-                                      if (!mesh->vertexNormals.empty()) {
-                                          mesh->normal_indices.push_back(triangle[0]);
-                                          mesh->normal_indices.push_back(triangle[1]);
-                                          mesh->normal_indices.push_back(triangle[2]);
-                                      }
-
-                                      if (!mesh->texCoords.empty()) {
-                                          if (this->CellScalarColor) {
-                                              mesh->texture_indices.push_back(cellNum);
-                                              mesh->texture_indices.push_back(cellNum);
-                                              mesh->texture_indices.push_back(cellNum);
-                                          } else {
-                                              mesh->texture_indices.push_back(triangle[0]);
-                                              mesh->texture_indices.push_back(triangle[1]);
-                                              mesh->texture_indices.push_back(triangle[2]);
-                                          }
-                                      }
-
-                                      total_triangles++;
-                                      numtriangles2++;
-                                  }
-                              }
-
-
-                          } break;
-
-        default:
-                          std::cerr << "unkown representation type\n";
-    }
-}
-
-void FindAllData(vtkPolyData *polydata) {
-
-    std::cout << "------------------------------------------------ " << std::endl;
-
-    std::cout << "Normals: " << polydata->GetPointData()->GetNormals()
-        << std::endl;
-
-    vtkIdType numberOfPointArrays = polydata->GetPointData()->GetNumberOfArrays();
-    std::cout << "Number of PointData arrays: " << numberOfPointArrays
-        << std::endl;
-
-    vtkIdType numberOfCellArrays = polydata->GetCellData()->GetNumberOfArrays();
-    std::cout << "Number of CellData arrays: " << numberOfCellArrays << std::endl;
-
-    std::cout << "Type table/key: " << std::endl;
-    ;
-    // more values can be found in <VTK_DIR>/Common/vtkSetGet.h
-    std::cout << VTK_UNSIGNED_CHAR << " unsigned char" << std::endl;
-    std::cout << VTK_UNSIGNED_INT << " unsigned int" << std::endl;
-    std::cout << VTK_FLOAT << " float" << std::endl;
-    std::cout << VTK_DOUBLE << " double" << std::endl;
-
-    for (vtkIdType i = 0; i < numberOfPointArrays; i++) {
-        int dataTypeID = polydata->GetPointData()->GetArray(i)->GetDataType();
-        int arrayTypeID = polydata->GetPointData()->IsArrayAnAttribute(i);
-        std::cout << "Array " << i << ": "
-            << polydata->GetPointData()->GetArrayName(i)
-            << " (type: " << dataTypeID << ")" << arrayTypeID << std::endl;
-    }
-
-    for (vtkIdType i = 0; i < numberOfCellArrays; i++) {
-        int dataTypeID = polydata->GetCellData()->GetArray(i)->GetDataType();
-        std::cout << "Array " << i << ": "
-            << polydata->GetCellData()->GetArrayName(i)
-            << " (type: " << dataTypeID << ")" << std::endl;
-    }
-    std::cout << "------------------------------------------------ " << std::endl;
-}
-
-//----------------------------------------------------------------------------
-// Draw method for OSPRay.
-void vtkOSPRayPolyDataMapper::Draw(vtkRenderer *renderer, vtkActor *actor) {
-    vtkOSPRayActor *OSPRayActor = vtkOSPRayActor::SafeDownCast(actor);
-    if (!OSPRayActor) {
-        return;
-    }
-    vtkOSPRayProperty *OSPRayProperty =
-        vtkOSPRayProperty::SafeDownCast(OSPRayActor->GetProperty());
-    if (!OSPRayProperty) {
-        return;
-    }
-    vtkOSPRayRenderer *OSPRayRenderer = vtkOSPRayRenderer::SafeDownCast(renderer);
-
-    vtkPolyData *input = this->GetInput();
-
-    vtkInformation *inputInfo = this->GetInput()->GetInformation();
-    // std::cout << __PRETTY_FUNCTION__ << " (" << this << ") " << "actor: (" <<
-    // OSPRayActor << ") mode: (" << OSPRayActor->OSPRayModel << ") " << std::endl;
-
-
-    // if (inputInfo && inputInfo->Has(vtkDataObject::DATA_TIME_STEP())) {
-    //   double time = inputInfo->Get(vtkDataObject::DATA_TIME_STEP());
-    //   timestep = time;
-    //   if (OSPRayActor->cache[time] != NULL) {
-
-    //     OSPRayActor->OSPRayModel = OSPRayActor->cache[time];
-    //     return;
-
-    //   }
-
-    // } else if (!inputInfo) {
-    // } else {
-    //   if (OSPRayActor->cache[timestep] != NULL) {
-    //   }
-    // }
-    OSPRayActor->MeshMTime.Modified();
-
-    // Compute we need to for color
-    this->Representation = OSPRayProperty->GetRepresentation();
-    this->Edges = OSPRayProperty->GetEdgeVisibility();
-
-    this->CellScalarColor = false;
-    if ((this->ScalarMode == VTK_SCALAR_MODE_USE_CELL_DATA ||
-                this->ScalarMode == VTK_SCALAR_MODE_USE_CELL_FIELD_DATA ||
-                this->ScalarMode == VTK_SCALAR_MODE_USE_FIELD_DATA ||
-                !input->GetPointData()->GetScalars()) &&
-            this->ScalarMode != VTK_SCALAR_MODE_USE_POINT_FIELD_DATA) {
-        this->CellScalarColor = true;
-    }
-
-    OSPMaterial ospMaterial = NULL;
-    vtkosp::Mesh *mesh = new vtkosp::Mesh();
-
-    // force create a new material every time this is called in case the renderer
-    // has changed
-    osp::Material *osmat = 0;
-    if (!osmat) {
-        OSPRayProperty->CreateOSPRayProperty();
-        ospMaterial = ((OSPMaterial)OSPRayProperty->GetOSPRayMaterial());
-    } else
-        ospMaterial = ((OSPMaterial)osmat);
-
-    if (!this->ScalarVisibility || (!this->Colors && !this->ColorCoordinates)) {
-
-    } else if (this->Colors) {
-        if (OSPRayProperty->GetInterpolation() == VTK_FLAT) {
-        } else {
-            if (OSPRayProperty->GetOpacity() < 1.0) {
-            } else {
-                if (OSPRayProperty->GetSpecular() == 0) {
-                } else {
-                }
-            }
-        }
-
-        for (int i = 0; i < this->Colors->GetNumberOfTuples(); i++) {
-            unsigned char *color = this->Colors->GetPointer(4 * i);
-            mesh->colors.push_back(vtkosp::Vec4(color[0] / 255.0, color[1] / 255.0,
-                        color[2] / 255.0, 1));
-        }
-
-    } else if (this->ColorCoordinates) {
-        osp::Texture2D *texture = this->InternalColorTexture->GetOSPRayTexture();
-        Assert(texture);
-        ospSetObject(ospMaterial, "map_Kd", ((OSPTexture2D)(texture)));
-        ospCommit(ospMaterial);
-
-        for (int i = 0; i < this->ColorCoordinates->GetNumberOfTuples(); i++) {
-            double *tcoord = this->ColorCoordinates->GetTuple(i);
-            if (tcoord[0] >= 1.0) tcoord[0] = 0.99999;  // avoid sampling texture at 1
-            mesh->texCoords.push_back(vtkosp::Vec2(tcoord[0], tcoord[1]));
-        }
-
-    } else if (input->GetPointData()->GetTCoords() && actor->GetTexture()) {
-        vtkOSPRayTexture *osprayTexture =
-            vtkOSPRayTexture::SafeDownCast(actor->GetTexture());
-        if (osprayTexture) {
-            ospSetObject(ospMaterial, "map_Kd",
-                    ((OSPTexture2D)(osprayTexture->GetOSPRayTexture())));
-            ospCommit(ospMaterial);
-        }
-
-        vtkDataArray *tcoords = input->GetPointData()->GetTCoords();
-        for (int i = 0; i < tcoords->GetNumberOfTuples(); i++) {
-            double *tcoord = tcoords->GetTuple(i);
-            if (tcoord[0] >= 1.0) tcoord[0] = 0.99999;  // avoid sampling texture at 1
-            mesh->texCoords.push_back(vtkosp::Vec2(tcoord[0], tcoord[1]));
-        }
-    }
-
-    // transform point coordinates according to actor's transformation matrix
-    vtkTransform *transform = vtkTransform::New();
-    transform->SetMatrix(actor->GetMatrix());
-    vtkPoints *points = vtkPoints::New();
-    transform->TransformPoints(input->GetPoints(), points);
-
-    // obtain the OpenGL-based point size and line width
-    // that are specified through vtkProperty
-    this->PointSize = OSPRayProperty->GetPointSize();
-    this->LineWidth = OSPRayProperty->GetLineWidth();
-    if (this->PointSize < 0.0) {
-        this->PointSize = 1.0;
-    }
-    if (this->LineWidth < 0.0) {
-        this->LineWidth = 1.0;
-    }
-    this->PointSize = sqrt(this->PointSize) * 0.010;
-    this->LineWidth = sqrt(this->LineWidth) * 0.005;
-
-    // convert VTK_VERTEX cells to OSPRay spheres
-    if (input->GetNumberOfVerts() > 0) {
-        vtkCellArray *ca = input->GetVerts();
-        ca->InitTraversal();
-        vtkIdType npts;
-        vtkIdType *pts;
-        vtkPoints *ptarray = points;
-        double coord[3];
-        vtkIdType cell;
-        vtkIdType point;
-        while ((cell = ca->GetNextCell(npts, pts)))
-        {
-            for (int p = 0; p < npts; p++)
-            {
-                point = pts[p];
-                ptarray->GetPoint(point, coord);
-                mesh->points_vertex.push_back
-                    (ospray::vec3f(coord[0], coord[1], coord[2]));
-            }
-        }
-    }
-
-    std::vector<ospray::vec3fa> slVertex;
-    std::vector<ospray::vec3fa> slColors;
-    std::vector<int> slIndex;
-    float slRadius;
-
-    // convert VTK_LINE type cells to OSPRay cylinders
-    if (input->GetNumberOfLines() > 0) {
-        vtkCellArray *ca = input->GetLines();
-        ca->InitTraversal();
-        vtkIdType npts;
-        vtkIdType *pts;
-        vtkPoints *ptarray = points;
-        std::vector<ospray::vec3fa> tmpColors;
-        int scalarSize = ptarray->GetNumberOfPoints();
-        double coord0[3];
-        vtkIdType cell;
-
-        vtkScalarsToColors *vstc = GetLookupTable();
-        vtkDataArray *scalar = input->GetPointData()->GetScalars(NULL);
-        if (scalar) {
-            int vectorSize = (scalar) ? scalar->GetNumberOfComponents() : 0;
-            unsigned char *output = new unsigned char[scalarSize * 4];
-            vstc->SetVectorModeToMagnitude();
-            vstc->MapVectorsThroughTable(scalar->GetVoidPointer(0), output,
-                    scalar->GetDataType(), scalarSize,
-                    vectorSize, VTK_RGBA);
-            for (int ii = 0; ii < scalarSize; ii++) {
-                double color[3];
-                for (int jj = 0; jj < 3; jj++) {
-                    color[jj] = float(output[ii * 4 + jj]) / 255.0;
-                }
-                tmpColors.push_back(ospray::vec3fa(color[0], color[1], color[2]));
-            }
-        } else if (vstc) {
-
-            if (this->ColorCoordinates) {
-                //std::cout << "Tex coords " << this->ColorCoordinates->GetSize() << std::endl;
-                double* minmax = vstc->GetRange();
-                //std::cout << "m: " << minmax[0] << " M:" << minmax[1] << std::endl;
-
-                double scale = minmax[1] - minmax[0];
-
-                for (int i = 0; i < scalarSize; i++) {
-                    double *tcoord = this->ColorCoordinates->GetTuple(i);
-                    double *color = vstc->GetColor((tcoord[0] * scale) + minmax[0]);
-                    tmpColors.push_back(ospray::vec3fa(color[0], color[1], color[2]));
-                }
-
-            } else {
-                double solidColor[3];
-                OSPRayProperty->GetDiffuseColor(solidColor);
-                for (int i = 0; i < scalarSize; i++) {
-                    tmpColors.push_back(
-                            ospray::vec3fa(solidColor[0], solidColor[1], solidColor[2]));
-                }
-            }
-        }
-
-        std::vector<ospray::vec3fa> tmpPoints;
-        for (int ii = 0; ii < ptarray->GetNumberOfPoints(); ii++) {
-            ptarray->GetPoint(ii, coord0);
-            tmpPoints.push_back(ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-        }
-
-        slRadius = this->LineWidth / 0.005;
-
-        while ((cell = ca->GetNextCell(npts, pts))) {
-            if (npts <= 2) continue;
-            slVertex.push_back(tmpPoints[pts[0]]);
-            slColors.push_back(tmpColors[pts[0]]);
-            for (vtkIdType i = 1; i < npts; i++) {
-                slIndex.push_back(slVertex.size() - 1);
-                slVertex.push_back(tmpPoints[pts[i]]);
-                slColors.push_back(tmpColors[pts[i]]);
-            }
-        }
-
-    }
-
-    // convert coordinates to OSPRay format
-    for (int i = 0; i < points->GetNumberOfPoints(); i++) {
-        double *pos = points->GetPoint(i);
-        bool wasNan = false;
-        int fixIndex = i - 1;
-        do {
-            wasNan = false;
-            for (int j = 0; j < 3; j++) {
-                if (std::isnan(pos[j])) {
-                    wasNan = true;
-                }
-            }
-            if (wasNan && fixIndex >= 0) pos = points->GetPoint(fixIndex--);
-        } while (wasNan == true && fixIndex >= 0);
-        mesh->vertices.push_back(vtkosp::Vec3(pos[0], pos[1], pos[2]));
-    }
-
-    // Do flat shading by not supplying vertex normals to OSPRay
-    if (OSPRayProperty->GetInterpolation() != VTK_FLAT) {
-        vtkPointData *pointData = input->GetPointData();
-        if (pointData->GetNormals()) {
-            vtkDataArray *normals = vtkFloatArray::New();
-            normals->SetNumberOfComponents(3);
-            transform->TransformNormals(pointData->GetNormals(), normals);
-            for (int i = 0; i < normals->GetNumberOfTuples(); i++) {
-                double *normal = normals->GetTuple(i);
-                mesh->vertexNormals.push_back(
-                        vtkosp::Vec3(normal[0], normal[1], normal[2]));
-            }
-            normals->Delete();
-        }
-    }
-
-
-    // convert polygons to OSPRay format
-    if (input->GetNumberOfPolys() > 0) {
-        this->DrawPolygons(input, points, mesh /*, sphereGroup, tubeGroup*/);
-    }
-
-    // convert triangle strips to OSPRay format
-    if (input->GetNumberOfStrips() > 0) {
-        this->DrawTStrips(input, points, mesh /*, sphereGroup, tubeGroup*/);
-    }
-
-    // delete transformed point coordinates
-    transform->Delete();
-    points->Delete();
-
-    if (mesh->size() ||
-            mesh->wireframe_vertex.size() ||
-            slVertex.size() ||
-            mesh->points_vertex.size()) {
-        //
-        // ospray
-        //
-        OSPRenderer renderer = ((OSPRenderer) this->OSPRayManager->OSPRayRenderer);
-        // OSPRayActor->OSPRayModel = ospNewModel();
-        //TODO: There should be a better way to clear geometries than to remake model
-        // printf("actor frame: %d renderer frame: %d\n", OSPRayActor->GetLastFrame(),OSPRayRenderer->GetFrame());
-        if (OSPRayActor->GetLastFrame() < OSPRayRenderer->GetFrame())
-        {
-            // printf("new actor model\n");
-            OSPRayActor->OSPRayModel = ospNewModel();
-            OSPRayActor->LastFrame = OSPRayRenderer->GetFrame();
-        }
-
-        if (mesh->size() && !mesh->points_vertex.size()) {
-
-            size_t numNormals = mesh->vertexNormals.size();
-            size_t numTexCoords = mesh->texCoords.size();
-            size_t numPositions = mesh->vertices.size();
-            size_t numTriangles = mesh->vertex_indices.size() / 3;
-
-            // printf("building mesh with numTriangles %d\n", numTriangles);
-
-
-            ospray::vec3fa *vertices = (ospray::vec3fa *)alignedMalloc(
-                    sizeof(ospray::vec3fa) * numPositions);
-            ospray::vec3i *triangles = (ospray::vec3i *)alignedMalloc(
-                    sizeof(ospray::vec3i) * numTriangles);
-            ospray::vec3fa *normals = (ospray::vec3fa *)alignedMalloc(
-                    sizeof(ospray::vec3fa) * numNormals);
-
-            for (size_t i = 0; i < numPositions; i++) {
-                vertices[i] =
-                    ospray::vec3fa(mesh->vertices[i].x(), mesh->vertices[i].y(),
-                            mesh->vertices[i].z());
-            }
-            for (size_t i = 0, mi = 0; i < numTriangles; i++, mi += 3) {
-                triangles[i] = embree::Vec3i(mesh->vertex_indices[mi + 0],
-                        mesh->vertex_indices[mi + 1],
-                        mesh->vertex_indices[mi + 2]);
-            }
-
-            for (size_t i = 0; i < numNormals; i++) {
-                normals[i] = ospray::vec3fa(mesh->vertexNormals[i].x(),
-                        mesh->vertexNormals[i].y(),
-                        mesh->vertexNormals[i].z());
-            }
-
-            OSPGeometry ospMesh = ospNewTriangleMesh();
-            OSPData position = ospNewData(numPositions, OSP_FLOAT3A, &vertices[0]);
-            ospSetData(ospMesh, "position", position);
-
-            if (!mesh->normal_indices.empty()) {
-                OSPData normal =
-                    ospNewData(mesh->vertexNormals.size(), OSP_FLOAT3A, &normals[0]);
-                ospSetData(ospMesh, "vertex.normal", normal);
-            }
-
-            OSPData index = ospNewData(numTriangles, OSP_INT3, &triangles[0]);
-            ospSetData(ospMesh, "index", index);
-
-            if (!mesh->texCoords.empty()) {
-                OSPData texcoord =
-                    ospNewData(mesh->texCoords.size(), OSP_FLOAT2, &mesh->texCoords[0]);
-                assert(mesh->texCoords.size() > 0);
-                ospSetData(ospMesh, "vertex.texcoord", texcoord);
-            }
-            if (!mesh->colors.empty()) {
-                // note: to share data use OSP_DATA_SHARED_BUFFER
-                OSPData colors =
-                    ospNewData(mesh->colors.size(), OSP_FLOAT4, &mesh->colors[0]);
-                ospSetData(ospMesh, "vertex.color", colors);
-            }
-
-            if (!ospMaterial) {
-                OSPRayProperty->CreateOSPRayProperty();
-                ospMaterial = ((OSPMaterial)OSPRayProperty->GetOSPRayMaterial());
-            }
-
-            ospSetMaterial(ospMesh, ospMaterial);
-            ospCommit(ospMesh);
-
-            ospAddGeometry(OSPRayActor->OSPRayModel, ospMesh);
-
-        }
-
-        if (mesh->points_vertex.size()) {
-            double Color[3];
-            OSPRayProperty->GetColor(Color);
-            OSPMaterial pointMat = ospNewMaterial(renderer, "default");
-            if (pointMat) {
-                ospSet3f(pointMat, "kd", Color[0], Color[1], Color[2]);
-                ospCommit(pointMat);
-            }
-            OSPGeometry ospMesh = ospNewGeometry("spheres");
-            OSPData vertex = ospNewData(mesh->points_vertex.size(), OSP_FLOAT3,
-                    &mesh->points_vertex[0]);
-            ospSetObject(ospMesh, "spheres", vertex);
-            ospSet1i(ospMesh, "bytes_per_sphere", 3*sizeof(float));
-            ospSet1i(ospMesh, "offset_center", 0*sizeof(float));
-            ospSet1i(ospMesh, "offset_radius", -1);//3*sizeof(float));
-            ospSet1f(ospMesh, "radius", this->PointSize);
-            ospSet1i(ospMesh, "offset_materialID", -1);
-            ospSet1i(ospMesh, "materialID", 0);
-            ospAddGeometry(OSPRayActor->OSPRayModel, ospMesh);
-            if (pointMat)
-            {
-                ospSetMaterial(ospMesh, pointMat);
-            }
-            ospCommit(vertex);
-            ospCommit(ospMesh);
-            ospRelease(vertex);
-            ospRelease(ospMesh);
-        }
-
-        if (mesh->wireframe_vertex.size()) {
-            double edgeColor[3];
-            OSPRayProperty->GetEdgeColor(edgeColor);
-            OSPMaterial wireMat = ospNewMaterial(renderer, "default");
-            if (wireMat) {
-                ospSet3f(wireMat, "kd", edgeColor[0], edgeColor[1], edgeColor[2]);
-                ospCommit(wireMat);
-            }
-            OSPGeometry wireGeometry = ospNewGeometry("streamlines");
-            Assert(wireGeometry);
-            OSPData vertex = ospNewData(mesh->wireframe_vertex.size(), OSP_FLOAT3A,
-                    &mesh->wireframe_vertex[0]);
-            OSPData index = ospNewData(mesh->wireframe_index.size(), OSP_INT,
-                    &mesh->wireframe_index[0]);
-            ospSetObject(wireGeometry, "vertex", vertex);
-            ospSetObject(wireGeometry, "index", index);
-            ospSet1f(wireGeometry, "radius", this->LineWidth);
-
-            if (wireMat) ospSetMaterial(wireGeometry, wireMat);
-
-            ospCommit(wireGeometry);
-            ospAddGeometry(OSPRayActor->OSPRayModel, wireGeometry);
-        }
-
-        if (slVertex.size()) {
-            double solidColor[3];
-            OSPGeometry slGeometry = ospNewGeometry("streamlines");
-            Assert(slGeometry);
-            OSPData vertex = ospNewData(slVertex.size(), OSP_FLOAT3A, &slVertex[0]);
-            OSPData color = ospNewData(slColors.size(), OSP_FLOAT3A, &slColors[0]);
-            OSPData index = ospNewData(slIndex.size(), OSP_INT, &slIndex[0]);
-            ospSetObject(slGeometry, "vertex", vertex);
-            ospSetObject(slGeometry, "vertex.color", color);
-            ospSetObject(slGeometry, "index", index);
-            ospSet1f(slGeometry, "radius", slRadius);
-            ospCommit(slGeometry);
-            ospAddGeometry(OSPRayActor->OSPRayModel, slGeometry);
-
-        }
-
-        ospCommit(OSPRayActor->OSPRayModel);
-        if (inputInfo && inputInfo->Has(vtkDataObject::DATA_TIME_STEP())) {
-            double time = inputInfo->Get(vtkDataObject::DATA_TIME_STEP());
-            OSPRayActor->cache[time] = OSPRayActor->OSPRayModel;
-        } else {
-            OSPRayActor->cache[timestep] = OSPRayActor->OSPRayModel;
-        }
-
-    } else {
-        delete mesh;
-    }
-
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.h
deleted file mode 100755
index 3678475ed6..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayPolyDataMapper -
-// .SECTION Description
-//
-// .NAME vtkOSPRayPolyDataMapper - a PolyDataMapper for the OSPRay library
-// .SECTION Description
-// vtkOSPRayPolyDataMapper is a subclass of vtkPolyDataMapper.
-// vtkOSPRayPolyDataMapper is a geometric PolyDataMapper for the OSPRay
-// Raytracer library.
-
-#ifndef __vtkOSPRayPolyDataMapper_h
-#define __vtkOSPRayPolyDataMapper_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkPolyDataMapper.h"
-#include "vtkOSPRayTexture.h"
-
-#include <map>
-
-class vtkSphereSource;
-class vtkGlyph3D;
-class vtkTubeFilter;
-class vtkAppendPolyData;
-
-//BTX
-namespace OSPRay {
-class Mesh;
-class Group;
-}
-//ETX
-class vtkCellArray;
-class vtkPoints;
-class vtkProperty;
-class vtkRenderWindow;
-class vtkOSPRayRenderer;
-class vtkOSPRayManager;
-
-namespace vtkosp
-{
-  class Mesh;
-}
-namespace osp
-{
-  class Model;
-}
-
-class VTKOSPRAY_EXPORT vtkOSPRayPolyDataMapper : public vtkPolyDataMapper
-{
-public:
-  static vtkOSPRayPolyDataMapper *New();
-  vtkTypeMacro(vtkOSPRayPolyDataMapper,vtkPolyDataMapper);
-
-  // Description:
-  // Implement superclass render method.
-  virtual void RenderPiece(vtkRenderer *ren, vtkActor *a);
-
-  // Description:
-  // Release any graphics resources that are being consumed by this mapper.
-  // The parameter window could be used to determine which graphic
-  // resources to release.
-  void ReleaseGraphicsResources(vtkWindow *);
-
-  // Description:
-  // Draw method for OSPRay.
-  virtual void Draw(vtkRenderer *ren, vtkActor *a);
-
-protected:
-  vtkOSPRayPolyDataMapper();
-  ~vtkOSPRayPolyDataMapper();
-
-  //BTX
-  void DrawPolygons(vtkPolyData *, vtkPoints *,
-                    vtkosp::Mesh * );
-  void DrawTStrips(vtkPolyData *, vtkPoints *,
-                    vtkosp::Mesh* );
-  //ETX
-
-private:
-  vtkOSPRayPolyDataMapper(const vtkOSPRayPolyDataMapper&); // Not implemented.
-  void operator=(const vtkOSPRayPolyDataMapper&); // Not implemented.
-
-  vtkOSPRayManager *OSPRayManager;
-
-  vtkOSPRayTexture* InternalColorTexture;
-  int Representation;
-  int Edges;
-  double PointSize;
-  double LineWidth;
-  std::map<int, osp::Model*> cache;
-  bool CellScalarColor;
-  static int timestep;
-//BTX
-  class Helper;
-  Helper *MyHelper;
-//ETX
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayProperty.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayProperty.cxx
deleted file mode 100755
index efd77e4254..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayProperty.cxx
+++ /dev/null
@@ -1,138 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkOSPRayRenderer.h"
-
-#include "vtkObjectFactory.h"
-
-
-#include <cstring>
-
-
-
-
-vtkStandardNewMacro(vtkOSPRayProperty);
-
-//----------------------------------------------------------------------------
-vtkOSPRayProperty::vtkOSPRayProperty()
-{
-  this->MaterialType = NULL;
-  this->SetMaterialType("default");
-  this->OSPRayManager = NULL;
-  this->OSPRayMaterial= NULL;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayProperty::~vtkOSPRayProperty()
-{
-  if (this->OSPRayManager)
-  {
-    this->OSPRayManager->Delete();
-  }
-  delete[] this->MaterialType;
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayProperty::PrintSelf( ostream & os, vtkIndent indent )
-{
-  this->Superclass::PrintSelf( os, indent );
-}
-
-//------------------------------------------------------------------------------
-void vtkOSPRayProperty::ReleaseGraphicsResources(vtkWindow *win)
-{
-  this->Superclass::ReleaseGraphicsResources(win);
-  if (!this->OSPRayManager)
-  {
-    return;
-  }
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayProperty::Render( vtkActor *vtkNotUsed(anActor),
- vtkRenderer * ren)
-{
-  vtkOSPRayRenderer * OSPRayRenderer = vtkOSPRayRenderer::SafeDownCast( ren );
-  if (!OSPRayRenderer)
-  {
-    return;
-  }
-  if (!this->OSPRayManager)
-  {
-    this->OSPRayManager = OSPRayRenderer->GetOSPRayManager();
-    this->OSPRayManager->Register(this);
-  }
-
-  double * diffuse  = this->GetDiffuseColor();
-
-
-  if ( this->GetMTime() > this->OSPRayMaterialMTime )
-  {
-      CreateOSPRayProperty();
-    this->OSPRayMaterialMTime.Modified();
-  }
-
-}
-
-//----------------------------------------------------------------------------
-// Implement base class method.
-void vtkOSPRayProperty::BackfaceRender( vtkActor * vtkNotUsed( anActor ),
- vtkRenderer * vtkNotUsed( ren ) )
-{
-  cerr
-  << "vtkOSPRayProperty::BackfaceRender(), backface rendering "
-  << "is not supported by OSPRay"
-  << endl;
-}
-
-
-//----------------------------------------------------------------------------
-void vtkOSPRayProperty::CreateOSPRayProperty()
-{
-
-  double * diffuse  = this->GetDiffuseColor();
-  double * specular = this->GetSpecularColor();
-
-
-
-          OSPRenderer renderer = ((OSPRenderer)this->OSPRayManager->OSPRayRenderer);
-
-          this->OSPRayMaterial = ospNewMaterial(renderer,"OBJMaterial");
-          OSPMaterial oMaterial = (OSPMaterial)this->OSPRayMaterial;
-          Assert(oMaterial);
-          float diffusef[] = {(float)diffuse[0], (float)diffuse[1], (float)diffuse[2]};
-          float specularf[] = {(float)specular[0],(float)specular[1],(float)specular[2]};
-          ospSet3fv(oMaterial,"Kd",diffusef);
-          ospSet3fv(oMaterial,"Ks",specularf);
-          ospSet1f(oMaterial,"Ns",float(this->GetSpecularPower()*.5));
-          ospSet1f(oMaterial,"d", float(this->GetOpacity()));
-
-          ospCommit(oMaterial);
-
-
-
-  }
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayProperty.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayProperty.h
deleted file mode 100755
index 5ab2b76c39..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayProperty.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOpenProperty - OSPRay property
-// .SECTION Description
-// vtkOSPRayProperty is a concrete implementation of the abstract class
-// vtkProperty. vtkOSPRayProperty interfaces to the OSPRay Raytracer library.
-
-#ifndef __vtkOSPRayProperty_h
-#define __vtkOSPRayProperty_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkProperty.h"
-
-//BTX
-namespace OSPRay {
-  class Material;
-}
-//ETX
-
-namespace osp
-{
-  class Material;
-  class OSPTexture2D;
-}
-
-class vtkOSPRayRenderer;
-class vtkOSPRayManager;
-
-class VTKOSPRAY_EXPORT vtkOSPRayProperty : public vtkProperty
-{
-public:
-  static vtkOSPRayProperty *New();
-  vtkTypeMacro(vtkOSPRayProperty,vtkProperty) ;
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-
-  // Description:
-  // Implement base class method.
-  void Render(vtkActor *a, vtkRenderer *ren);
-
-  // Description:
-  // Implement base class method.
-  void BackfaceRender(vtkActor *a, vtkRenderer *ren);
-
-  // Description:
-  // Release any graphics resources that are being consumed by this
-  // property. The parameter window could be used to determine which graphic
-  // resources to release.
-  virtual void ReleaseGraphicsResources(vtkWindow *win);
-
-  // functions that change parameters of various materials
-  vtkSetStringMacro(MaterialType);
-  vtkGetStringMacro(MaterialType);
-  vtkSetMacro(Reflectance, float);
-  vtkGetMacro(Reflectance, float);
-  vtkSetMacro(Eta, float);
-  vtkGetMacro(Eta, float);
-  vtkSetMacro(Thickness, float);
-  vtkGetMacro(Thickness, float);
-  vtkSetMacro(N, float);
-  vtkGetMacro(N, float);
-  vtkSetMacro(Nt, float);
-  vtkGetMacro(Nt, float);
-    vtkSetMacro(OSPRayMaterial, osp::Material*);
-  vtkGetMacro(OSPRayMaterial, osp::Material*);
-
-  //Description:
-  //Internal callbacks for OSPRay thread use.
-  //Do not call them directly.
-  void CreateOSPRayProperty();
-
-protected:
-  vtkOSPRayProperty();
-  ~vtkOSPRayProperty();
-
-private:
-  vtkOSPRayProperty(const vtkOSPRayProperty&);  // Not implemented.
-  void operator=(const vtkOSPRayProperty&);  // Not implemented.
-
-  // the last time OSPRayMaterial is modified
-  vtkTimeStamp OSPRayMaterialMTime;
-
-  osp::OSPTexture2D* DiffuseTexture;
-
-  // type of material to use. possible values are: "lambertian", "phong",
-  // "transparent", "thindielectric", "dielectric", "metal", "orennayer"
-  char * MaterialType;
-
-  // amount of reflection to use. should be between 0.0 and 1.0
-  float Reflectance;
-
-  // the index of refraction for a material. used with the thin dielectric
-  // material
-  float Eta;
-
-  // how thick the material is. used with the thin dielectric material
-  float Thickness;
-
-  // index of refraction for outside material. used in dielectric material
-  float N;
-
-  // index of refraction for inside material (transmissive). used in
-  // dielectric material
-  float Nt;
-
-  vtkOSPRayManager *OSPRayManager;
-  osp::Material* OSPRayMaterial;
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderable.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderable.cxx
deleted file mode 100755
index 986e7d9263..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderable.cxx
+++ /dev/null
@@ -1 +0,0 @@
-#include "vtkOSPRayRenderable.h"
\ No newline at end of file
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderable.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderable.h
deleted file mode 100755
index b7256129ab..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderable.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* =======================================================================================
-Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-All rights reserved.
-
-Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-except in compliance with the License.
-A copy of the License is included with this software in the file LICENSE.
-If your copy does not contain the License, you may obtain a copy of the License at:
-
-http://opensource.org/licenses/BSD-3-Clause
-
-Unless required by applicable law or agreed to in writing, software distributed under
-the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-KIND, either express or implied.
-See the License for the specific language governing permissions and limitations under
-limitations under the License.
-
-pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-Copyright (c) 2007, Los Alamos National Security, LLC
-======================================================================================= */
-
-#ifndef __vtkOSPRayRenderable_h
-#define __vtkOSPRayRenderable_h
-
-#include "vtkOSPRay.h"
-
-
-class vtkOSPRayRenderable
-{
-public:
-vtkOSPRayRenderable(OSPModel model)
-: model(model)
-{
-instance = ospNewInstance(model, osp::affine3f(embree::one));
-}
-OSPGeometry instance;
-OSPModel model;
-};
-
-#endif
\ No newline at end of file
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderer.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderer.cxx
deleted file mode 100755
index 0062050b7b..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderer.cxx
+++ /dev/null
@@ -1,721 +0,0 @@
-/* =======================================================================================
- Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
- All rights reserved.
-
- Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
- except in compliance with the License.
- A copy of the License is included with this software in the file LICENSE.
- If your copy does not contain the License, you may obtain a copy of the License at:
-
- http://opensource.org/licenses/BSD-3-Clause
-
- Unless required by applicable law or agreed to in writing, software distributed under
- the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- KIND, either express or implied.
- See the License for the specific language governing permissions and limitations under
- limitations under the License.
-
- pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
- Copyright (c) 2007, Los Alamos National Security, LLC
- ======================================================================================= */
-
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayCamera.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayRenderer.h"
-
-#include "vtkActor.h"
-#include "vtkCuller.h"
-#include "vtkLight.h"
-#include "vtkLightCollection.h"
-#include "vtkObjectFactory.h"
-#include "vtkRendererCollection.h"
-#include "vtkRenderWindow.h"
-#include "vtkTimerLog.h"
-
-#include "vtkImageData.h"
-#include "vtkPNGWriter.h"
-#include "vtkPolyDataMapper.h"
-#include "vtkPolyData.h"
-//#include "vtkMultiProcessController.h"
-
-#include <vtkSmartPointer.h>
-#include <vtkCommand.h>
-#include <vtkRenderer.h>
-#include <vtkRendererCollection.h>
-#include <vtkRenderWindow.h>
-#include <vtkRenderWindowInteractor.h>
-
-
-#include "vtkOSPRayActor.h"
-#include <DebugStream.h>
-
-//  VBOs
-//
-#if USE_VBOS
-#include <GL/glu.h>
-#include <assert.h>
-#endif
-
-
-#include <string>
-
-vtkStandardNewMacro(vtkOSPRayRenderer);
-
-class vtkTimerCallback : public vtkCommand
-{
-public:
-  static vtkTimerCallback *New()
-  {
-    vtkTimerCallback *cb = new vtkTimerCallback;
-    cb->TimerCount = 0;
-    return cb;
-  }
-
-  virtual void Execute(vtkObject *vtkNotUsed(caller), unsigned long eventId,
-                       void *vtkNotUsed(callData))
-  {
-    if (vtkCommand::TimerEvent == eventId)
-    {
-      ++this->TimerCount;
-    }
-  }
-
-private:
-  int TimerCount;
-
-};
-
-//----------------------------------------------------------------------------
-vtkOSPRayRenderer::vtkOSPRayRenderer()
-:
-prog_flag(false),
-Accumulate(false)
-{
-    debug5 << "ALOK: vtkOSPRayRenderer constructor" << endl;
-  Frame=0;
-  HasVolume= false;
-  ClearAccumFlag=false;
-  //ComputeDepth = vtkMultiProcessController::GetGlobalController()->GetNumberOfProcesses() > 1;
-  ComputeDepth = 0;
-
-  this->EngineInited=false;
-  this->NumberOfWorkers = 1;
-  this->EnableShadows = -1;
-  this->Samples = 1;
-  this->MaxDepth = 5;
-  this->EnableVolumeShading = 0;
-
-  this->ImageX = -1;
-  this->ImageY = -1;
-
-  this->backgroundRGB[0] = 0.0;
-  this->backgroundRGB[1] = 0.0;
-  this->backgroundRGB[2] = 0.0;
-  AccumCounter=0;
-  MaxAccum=1024;
-  this->SetAmbient( 0.1, 0.1, 0.1 );
-
-  this->OSPRayManager = vtkOSPRayManager::Singleton();
-
-  OSPModel oModel = (OSPModel)this->OSPRayManager->OSPRayModel;
-  OSPCamera oCamera = (OSPCamera)this->OSPRayManager->OSPRayCamera;
-  this->EnableAO=false;
-  bool ao = EnableAO;
-  EnableAO=-1;
-  SetEnableAO(ao);
-  OSPRenderer oRenderer = (OSPRenderer)this->OSPRayManager->OSPRayRenderer;
-  OSPRenderer vRenderer = (OSPRenderer)this->OSPRayManager->OSPRayVolumeRenderer;
-  ospSet3f(vRenderer, "bgColor", backgroundRGB[0], backgroundRGB[1], backgroundRGB[2]);
-  OSPModel vModel = (OSPModel)this->OSPRayManager->OSPRayVolumeModel;
-  SetEnableShadows(0);
-
-  ospSetObject(vRenderer,"world",vModel);
-  ospSetObject(vRenderer,"model",vModel);
-  ospSetObject(vRenderer,"camera",oCamera);
-  ospCommit(vRenderer);
-
-  Assert(oRenderer != NULL && "could not create renderer");
-  Assert(vRenderer != NULL && "could not create renderer");
-
-  ospSetObject(oRenderer,"world",oModel);
-  ospSetObject(oRenderer,"model",oModel);
-  ospSetObject(oRenderer,"camera",oCamera);
-  ospSet1i(oRenderer,"spp",Samples);
-  ospSet3f(oRenderer,"bgColor",1,1,1);
-  ospCommit(oModel);
-  ospCommit(oCamera);
-  ospCommit(oRenderer);
-
-  this->ColorBuffer = NULL;
-  this->DepthBuffer = NULL;
-  this->osp_framebuffer = NULL;
-
-  StatisticFramesPerOutput = 100;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayRenderer::~vtkOSPRayRenderer()
-{
-  if (this->osp_framebuffer)
-  {
-    ospFreeFrameBuffer(this->osp_framebuffer);
-    this->osp_framebuffer = NULL;
-  }
-
-  if (this->ColorBuffer)
-  {
-    delete[] this->ColorBuffer;
-    this->ColorBuffer = NULL;
-  }
-
-  if (this->DepthBuffer)
-  {
-    delete[] this->DepthBuffer;
-    this->DepthBuffer = NULL;
-  }
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::InitEngine()
-{
-  this->EngineInited = true;
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetBackground(double r, double g, double b)
-{
-  OSPRenderer oRenderer = (OSPRenderer)this->OSPRayManager->OSPRayRenderer;
-  OSPRenderer vRenderer = (OSPRenderer)this->OSPRayManager->OSPRayVolumeRenderer;
-  ospSet3f(oRenderer,"bgColor",r,g,b);
-  ospSet3f(vRenderer,"bgColor",r,g,b);
-
-  backgroundRGB[0] = r;
-  backgroundRGB[1] = g;
-  backgroundRGB[2] = b;
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::ClearLights(void)
-{
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::Clear()
-{
-}
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::ClearAccumulation()
-{
-  if (osp_framebuffer)
-    ospFrameBufferClear(osp_framebuffer, OSP_FB_ACCUM);
-  AccumCounter=0;
-}
-
-
-//----------------------------------------------------------------------------
-// Ask lights to load themselves into graphics pipeline.
-int vtkOSPRayRenderer::UpdateLights()
-{
-  OSPRenderer renderer = ((OSPRenderer)this->OSPRayManager->OSPRayRenderer);
-  OSPRenderer vRenderer = ((OSPRenderer)this->OSPRayManager->OSPRayVolumeRenderer);
-  std::vector<OSPLight> lights;
-
-
-  // convert VTK lights into OSPRay lights
-  vtkCollectionSimpleIterator sit;
-  this->Lights->InitTraversal( sit );
-
-  vtkLight *vLight = NULL;
-  bool noneOn = true;
-  for ( this->Lights->InitTraversal( sit );
-       ( vLight = this->Lights->GetNextLight( sit ) ) ; )
-  {
-    if ( vLight->GetSwitch() )
-    {
-      noneOn = false;
-    }
-    vtkLight* light = vLight;
-
-    double *color, *position, *focal, direction[3];
-
-    // OSPRay Lights only have one "color"
-    color    = light->GetDiffuseColor();
-    position = light->GetTransformedPosition();
-    focal    = light->GetTransformedFocalPoint();
-
-    if (light->GetPositional())
-    {
-      OSPLight ospLight = ospNewLight(renderer, "OBJPointLight");
-      ospSetString(ospLight, "name", "point" );
-      ospSet3f(ospLight, "color", color[0],color[1],color[2]);
-      ospSet3f(ospLight, "position", position[0],position[1],position[2]);
-      ospCommit(ospLight);
-      lights.push_back(ospLight);
-    }
-    else
-    {
-      direction[0] = position[0] - focal[0];
-      direction[1] = position[1] - focal[1];
-      direction[2] = position[2] - focal[2];
-      OSPLight ospLight = ospNewLight(renderer, "DirectionalLight");
-      ospSetString(ospLight, "name", "directional" );
-      float scale = 0.8;
-      ospSet3f(ospLight, "color", color[0]*scale,color[1]*scale,color[2]*scale);
-      osp::vec3f dir(-direction[0],-direction[1],-direction[2]);
-      dir = normalize(dir);
-      ospSet3f(ospLight, "direction", dir.x,dir.y,dir.z);
-      ospCommit(ospLight);
-      lights.push_back(ospLight);
-    }
-
-    if (noneOn)
-    {
-      {
-        cerr
-        << "No light defined, creating a headlight at camera position" << endl;
-      }
-    }
-    else
-    {
-    }
-  }
-  {
-
-  }
-  {
-  }
-
-  OSPData lightsArray = ospNewData(lights.size(), OSP_OBJECT, &lights[0], 0);
-  ospSetData(renderer, "lights",lightsArray);
-  ospSetData(vRenderer, "lights",lightsArray);
-  ospCommit(renderer);
-
-  return 0;
-}
-
-//----------------------------------------------------------------------------
-vtkCamera* vtkOSPRayRenderer::MakeCamera()
-{
-  return vtkOSPRayCamera::New();
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::UpdateSize()
-{
-}
-
-void vtkOSPRayRenderer::PreRender()
-{
-  if ((!prog_flag) || ClearAccumFlag)
-  {
-    if (osp_framebuffer)
-      ospFrameBufferClear(osp_framebuffer, OSP_FB_COLOR | (ComputeDepth ? OSP_FB_DEPTH : 0) | OSP_FB_ACCUM);
-    AccumCounter=0;
-    ClearAccumFlag=false;
-  }
-  else
-    prog_flag = false;
-
-  if (this->GetLayer() != 0 && this->GetActors()->GetNumberOfItems() == 0)
-  {
-    return;
-  }
-
-  vtkTimerLog::MarkStartEvent("OSPRay Dev Render");
-
-  if (!this->EngineInited )
-  {
-    this->InitEngine();
-  }
-
-  vtkTimerLog::MarkStartEvent("Geometry");
-
-  this->Clear();
-
-  this->UpdateSize();
-
-
-  HasVolume = false;
-  OSPRenderer oRenderer = (OSPRenderer)this->OSPRayManager->OSPRayRenderer;
-  this->OSPRayManager->OSPRayModel = ospNewModel();
-  this->OSPRayManager->OSPRayVolumeModel = this->OSPRayManager->OSPRayModel;  //TODO: the volume and geometry are now managed in the same model object, can remove volumemodel entirely
-  OSPModel oModel = (OSPModel)this->OSPRayManager->OSPRayModel;
-  OSPCamera oCamera = (OSPCamera)this->OSPRayManager->OSPRayCamera;
-  ospSetObject(oRenderer,"world",oModel);
-  ospSetObject(oRenderer,"model",oModel);
-  ospSetObject(oRenderer,"camera",oCamera);
-
-
-  ospCommit(this->OSPRayManager->OSPRayModel);
-  ospCommit(this->OSPRayManager->OSPRayRenderer);
-
-  this->UpdateCamera();
-
-
-  this->UpdateLightGeometry();
-  this->UpdateLights();
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::DeviceRender()
-{
-    debug5 << "ALOK: beginning of vtkOSPRayRenderer::DeviceRender()" << endl;
-  static vtkTimerLog* timer = vtkTimerLog::New();
-  timer->StartTimer();
-  PreRender();
-
-  this->UpdateGeometry();
-
-  vtkTimerLog::MarkEndEvent("Geometry");
-
-  vtkTimerLog::MarkStartEvent("Total LayerRender");
-  this->LayerRender();
-
-  vtkTimerLog::MarkEndEvent("Total LayerRender");
-
-  vtkTimerLog::MarkEndEvent("OSPRay Dev Render");
-  Frame++;
-  timer->StopTimer();
-  #if GATHER_STATS
-  Statistics.push(std::make_pair("DeviceRender", timer->GetElapsedTime()));
-  if ( (StatisticFramesPerOutput > 0) && ( (Frame % StatisticFramesPerOutput) == 0) )
-  {
-    while (!Statistics.empty())
-    {
-      std::cout << Statistics.front().first << " " << Statistics.front().second;
-      Statistics.pop();
-    }
-  }
-  #endif
-    debug5 << "ALOK: end of vtkOSPRayRenderer::DeviceRender()" << endl;
-}
-
-//----------------------------------------------------------------------------
-// let the renderer display itself appropriately based on its layer index
-void vtkOSPRayRenderer::LayerRender()
-{
-    debug5 << "ALOK: beginning of vtkOSPRayRenderer::Layereender()" << endl;
-  int     i, j;
-  int     rowLength,  OSPRaySize[2];
-  int     minWidth,   minHeight;
-  int     hOSPRayDiff, hRenderDiff;
-  int     renderPos[2];
-  int*    renderSize  = NULL;
-  int*    renWinSize  = NULL;
-  bool    stereoDumy;
-  float*  OSPRayBuffer = NULL;
-  double* renViewport = NULL;
-
-  // collect some useful info
-  renderSize = this->GetSize();
-  renWinSize = this->GetRenderWindow()->GetActualSize();
-  renViewport= this->GetViewport();
-  renderPos[0] = int( renViewport[0] * renWinSize[0] + 0.5f );
-  renderPos[1] = int( renViewport[1] * renWinSize[1] + 0.5f );
-  minWidth = renderSize[0];
-  minHeight =renderSize[1];
-  hOSPRayDiff = 0;
-  hRenderDiff = 0;
-  // memory allocation and acess to the OSPRay image
-  int size = renderSize[0]*renderSize[1];
-  if (this->ImageX != renderSize[0] || this->ImageY != renderSize[1])
-  {
-    this->ImageX = renderSize[0];
-    this->ImageY = renderSize[1];
-
-    if (this->ColorBuffer) delete[] this->ColorBuffer;
-    this->ColorBuffer = new float[ size ];
-
-    if (this->DepthBuffer) delete[] this->DepthBuffer;
-    this->DepthBuffer = new float[ size ];
-
-    if (this->osp_framebuffer) ospFreeFrameBuffer(this->osp_framebuffer);
-    this->osp_framebuffer = ospNewFrameBuffer(osp::vec2i(renderSize[0], renderSize[1]), OSP_RGBA_I8, OSP_FB_COLOR | (ComputeDepth ? OSP_FB_DEPTH : 0) | OSP_FB_ACCUM);
-    ospFrameBufferClear(osp_framebuffer, OSP_FB_ACCUM);
-    AccumCounter=0;
-  }
-  if (HasVolume && !EnableAO)
-  {
-    OSPRenderer vRenderer = (OSPRenderer)this->OSPRayManager->OSPRayVolumeRenderer;
-    OSPModel vModel = (OSPModel)this->OSPRayManager->OSPRayVolumeModel;
-    OSPCamera oCamera = (OSPCamera)this->OSPRayManager->OSPRayCamera;
-
-    ospSetObject(vRenderer,"world",vModel);
-    ospSetObject(vRenderer,"model",vModel);
-    ospSetObject(vRenderer,"camera",oCamera);
-
-    ospCommit(vModel);
-    ospCommit(vRenderer);
-
-
-    ospRenderFrame(this->osp_framebuffer,vRenderer,OSP_FB_COLOR|OSP_FB_ACCUM);
-    AccumCounter++;
-  }
-  else
-  {
-    OSPRenderer renderer = ((OSPRenderer)this->OSPRayManager->OSPRayRenderer);
-    OSPModel ospModel = ((OSPModel)this->OSPRayManager->OSPRayModel);
-
-    ospCommit(renderer);
-    ospCommit(ospModel);
-
-    ospRenderFrame(this->osp_framebuffer,renderer,OSP_FB_COLOR|OSP_FB_ACCUM);
-    AccumCounter++;
-  }
-
-  //
-  // Copy Depth Buffer
-  //
-  if (ComputeDepth)
-  {
-    double *clipValues = this->GetActiveCamera()->GetClippingRange();
-    double viewAngle = this->GetActiveCamera()->GetViewAngle();
-
-    // Closest point is center of near clipping plane - farthest is
-    // corner of far clipping plane
-    double clipMin = clipValues[0];
-    double clipMax = clipValues[1] / pow(cos(viewAngle / 2.0), 2.0);
-    double clipDiv = 1.0 / (clipMax - clipMin);
-
-    const void *b = ospMapFrameBuffer(this->osp_framebuffer, OSP_FB_DEPTH);
-
-    float *s = (float *)b;
-    float *d = this->DepthBuffer;
-    for (int i = 0; i < size; i++, s++, d++)
-      *d = std::isinf(*s) ? 1.0 : (*s - clipMin) * clipDiv;
-    ospUnmapFrameBuffer(b, this->osp_framebuffer);
-
-    this->GetRenderWindow()->MakeCurrent();
-    glDepthFunc(GL_ALWAYS);
-
-    this->GetRenderWindow()->SetZbufferData(renderPos[0], renderPos[1],
-                                            renderPos[0] + renderSize[0] - 1, renderPos[1] + renderSize[1] - 1, this->DepthBuffer);
-  }
-  //
-  // Copy RGBA Buffer
-  //
-
-  const void* rgba = ospMapFrameBuffer(this->osp_framebuffer);
-  // memcpy((void *)this->ColorBuffer, rgba, size*sizeof(float));
-  glDrawPixels(renderSize[0],renderSize[1],GL_RGBA,GL_UNSIGNED_BYTE,rgba);
-  ospUnmapFrameBuffer(rgba, this->osp_framebuffer);
-    debug5 << "ALOK: end of vtkOSPRayRenderer::LayerRender()" << endl;
-  return;
-  //ALOK: Nothing below this runs!
-
-  vtkTimerLog::MarkStartEvent("Image Conversion");
-
-  // let layer #0 initialize GL depth buffer
-  if ( this->GetLayer() == 0 )
-  {
-    this->GetRenderWindow()->
-    SetRGBACharPixelData( renderPos[0],  renderPos[1],
-                         renderPos[0] + renderSize[0] - 1,
-                         renderPos[1] + renderSize[1] - 1,
-                         (unsigned char*)this->ColorBuffer, 0, 0 );
-    glFinish();
-  }
-  else
-  {
-    //layers on top add the colors of their non background pixels
-    unsigned char*  GLbakBuffer = NULL;
-    GLbakBuffer = this->GetRenderWindow()->
-    GetRGBACharPixelData( renderPos[0],  renderPos[1],
-                         renderPos[0] + renderSize[0] - 1,
-                         renderPos[1] + renderSize[1] - 1, 0 );
-
-    bool anyhit = false;
-    unsigned char *optr = GLbakBuffer;
-    unsigned char *iptr = (unsigned char*)this->ColorBuffer;
-    float *zptr = this->DepthBuffer;
-    for ( j = 0; j < renderSize[1]; j++)
-    {
-      for ( i = 0; i < renderSize[0]; i++)
-      {
-        const float z = *zptr;
-        if (z > 0 && z < 1.0)
-        {
-          anyhit = true;
-          *(optr+0) = *(iptr+0);
-          *(optr+1) = *(iptr+1);
-          *(optr+2) = *(iptr+2);
-          *(optr+3) = *(iptr+3);
-        }
-        optr+=4;
-        iptr+=4;
-        zptr++;
-      }
-    }
-
-    if (anyhit)
-    {
-      // submit the modified RGB colors to GL BACK buffer
-      this->GetRenderWindow()->
-      SetRGBACharPixelData( renderPos[0],  renderPos[1],
-                           renderPos[0] + renderSize[0] - 1,
-                           renderPos[1] + renderSize[1] - 1,
-                           GLbakBuffer, 0, 0 );
-    }
-
-    delete [] GLbakBuffer;
-  }
-
-  vtkTimerLog::MarkEndEvent("Image Conversion");
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::PrintSelf( ostream& os, vtkIndent indent )
-{
-  this->Superclass::PrintSelf( os, indent );
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetNumberOfWorkers( int newval )
-{
-  if (this->NumberOfWorkers == newval)
-  {
-    return;
-  }
-}
-
-void vtkOSPRayRenderer::AddOSPRayRenderable(vtkOSPRayRenderable* inst)
-{
-  ospAddGeometry((OSPModel)this->OSPRayManager->OSPRayModel,inst->instance);
-  renderables.push_back(inst);
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetEnableShadows( int newval )
-{
-  if (this->EnableShadows == newval)
-  {
-    return;
-  }
-  this->EnableShadows = newval;
-
-  OSPRenderer renderer = ((OSPRenderer)this->OSPRayManager->OSPRayRenderer);
-  ospSet1i(renderer,"shadowsEnabled", this->EnableShadows);
-  ospCommit(renderer);
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetSamples( int newval )
-{
-  if (this->Samples == newval || newval < 1)
-  {
-    return;
-  }
-
-  this->Samples = newval;
-
-
-  OSPRenderer renderer = ((OSPRenderer)this->OSPRayManager->OSPRayRenderer);
-
-  Assert(renderer);
-
-  ospSet1i(renderer,"spp",Samples);
-  ospCommit(renderer);
-
-  OSPRenderer vRenderer = ((OSPRenderer)this->OSPRayManager->OSPRayVolumeRenderer);
-
-  Assert(vRenderer);
-
-  ospSet1i(vRenderer,"spp",Samples);
-  ospCommit(vRenderer);
-
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetEnableAO( int newval )
-{
-  if (this->EnableAO == newval)
-  {
-    return;
-  }
-
-  this->EnableAO = newval;
-
-  UpdateOSPRayRenderer();
-
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetEnablePathtracing( int newval )
-{
-  if (this->EnablePathtracing == newval)
-  {
-    return;
-  }
-
-  this->EnablePathtracing = newval;
-
-  UpdateOSPRayRenderer();
-
-}
-
-
-void vtkOSPRayRenderer::SetEnableVolumeShading( int newval )
-{
-  EnableVolumeShading = newval;
-}
-
-void vtkOSPRayRenderer::UpdateOSPRayRenderer()
-{
-  OSPModel oModel = (OSPModel)this->OSPRayManager->OSPRayModel;
-  OSPCamera oCamera = (OSPCamera)this->OSPRayManager->OSPRayCamera;
-
-  if (EnableAO != 0)
-  {
-    this->OSPRayManager->OSPRayRenderer = (osp::Renderer*)ospNewRenderer("ao4");
-  }
-  else if (EnablePathtracing != 0)
-  {
-    this->OSPRayManager->OSPRayRenderer = (osp::Renderer*)ospNewRenderer("pathtracer");
-  }
-  else
-  {
-    this->OSPRayManager->OSPRayRenderer = (osp::Renderer*)ospNewRenderer("raycast_volume_renderer");
-    // this->OSPRayManager->OSPRayRenderer = (osp::Renderer*)ospNewRenderer("obj");
-  }
-  OSPRenderer oRenderer = (OSPRenderer)this->OSPRayManager->OSPRayRenderer;
-
-  Assert(oRenderer != NULL && "could not create renderer");
-
-  ospSetObject(oRenderer,"dynamic_model",ospNewModel());
-  ospSetObject(oRenderer,"world",oModel);
-  ospSetObject(oRenderer,"model",oModel);
-  ospSetObject(oRenderer,"camera",oCamera);
-  ospCommit(oRenderer);
-
-  ospSet1i(oRenderer,"spp",Samples);
-  ospSet1f(oRenderer,"epsilon", 10e-2);
-  ospSet1i(oRenderer,"shadowsEnabled", this->EnableShadows);
-
-  ospCommit(oRenderer);
-  SetBackground(backgroundRGB[0],backgroundRGB[1],backgroundRGB[2]);
-
-  vtkActorCollection *actorList = this->GetActors();
-  actorList->InitTraversal();
-
-  int numActors = actorList->GetNumberOfItems();
-  for(int i=0; i<numActors; i++) {
-    vtkActor *a = actorList->GetNextActor();
-    a->Modified();
-  }
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetMaxDepth( int newval )
-{
-  if (this->MaxDepth == newval)
-  {
-    return;
-  }
-
-  this->MaxDepth = newval;
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderer.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderer.h
deleted file mode 100755
index 36ca7b239f..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderer.h
+++ /dev/null
@@ -1,243 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayRenderer - Renderer that uses OSPRay ray tracer instead of GL.
-// .SECTION Description
-// vtkOSPRayRenderer is a concrete implementation of the abstract class
-// vtkRenderer. vtkOSPRayRenderer interfaces to the OSPRay graphics library.
-
-#ifndef __vtkOSPRayRenderer_h
-#define __vtkOSPRayRenderer_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkOpenGLRenderer.h"
-
-#include "vtkOSPRay.h"
-
-#include "vtkOSPRayRenderable.h"
-#include <queue>
-#include <utility>
-#include <string>
-
-
-//BTX
-namespace OSPRay {
-class OSPRayInterface;
-class Scene;
-class Group;
-class LightSet;
-class Factory;
-class Camera;
-class SyncDisplay;
-class Light;
-}
-//ETX
-
-class vtkOSPRayManager;
-
-class VTKOSPRAY_EXPORT vtkOSPRayRenderer : public vtkOpenGLRenderer
-{
-public:
-  static vtkOSPRayRenderer *New();
-  vtkTypeMacro(vtkOSPRayRenderer, vtkOpenGLRenderer);
-  void PrintSelf(ostream& os, vtkIndent indent);
-
-  //Description:
-  // Overridden to use OSPRay callbacks to do the work.
-  virtual void SetBackground(double rgb[3])
-    { this->Superclass::SetBackground(rgb); }
-  virtual void SetBackground(double r, double g, double b);
-
-  //Description:
-  //Changes the number of OSPRay rendering threads.
-  //More is faster.
-  //Default is 1.
-  void SetNumberOfWorkers(int);
-  vtkGetMacro(NumberOfWorkers, int);
-
-  //Description:
-  //Turns on or off shadow rendering.
-  //Default is off.
-  void SetEnableShadows(int);
-  vtkGetMacro(EnableShadows, int);
-
-    //Description:
-  //Turns on or off shadow rendering.
-  //Default is off.
-  void SetEnableAO(int);
-  vtkGetMacro(EnableAO, int);
-
-  //Description:
-  //Turns on or off shadow rendering.
-  //Default is off.
-  void SetEnablePathtracing(int);
-  vtkGetMacro(EnablePathtracing, int);
-  //Description:
-  //Turns on or off shadow rendering.
-  //Default is off.
-  void SetEnableVolumeShading(int);
-  vtkGetMacro(EnableVolumeShading, int);
-
-  //Description:
-  //Controls multisample (anitaliased) rendering.
-  //More looks better, but is slower.
-  //Default is 1.
-  void SetSamples(int);
-  vtkGetMacro(Samples, int);
-
-  vtkGetMacro(Accumulate, bool);
-  void SetAccumulate(bool st)
-  {
-    Accumulate = st;
-  }
-
-  //Description:
-  //Controls maximum ray bounce depth.
-  //More looks better, but is slower.
-  //Default is 5 meaning a couple of bounces.
-  void SetMaxDepth(int);
-  vtkGetMacro(MaxDepth, int);
-
-  // Description:
-  // Ask lights to load themselves into graphics pipeline.
-  int UpdateLights(void);
-
-  // Description:
-  // Turns off all lighting
-  void ClearLights(void);
-
-
-  void Clear();
-  void ClearAccumulation();
-
-  //Description:
-  //Access to the OSPRay rendered image
-  float * GetColorBuffer()
-  {
-    return this->ColorBuffer;
-  }
-  float * GetDepthBuffer()
-  {
-    return this->DepthBuffer;
-  }
-
-  //Setup ospray world, camera etc. before
-  // renders are called in the geometry
-  void PreRender();
-  // Description:
-  // Concrete render method. Do not call this directly. The pipeline calls
-  // it during Renderwindow::Render()
-  void DeviceRender();
-
-  void LayerRender();
-
-  //Description:
-  //All classes that make OSPRay calls should get hold of this and
-  //Register it so that the Manager, and thus the OSPRay engine
-  //outlive themselves, and thus guarantee that they can safely make
-  //OSPRay API calls whenever they need to.
-  vtkOSPRayManager* GetOSPRayManager()
-  {
-    return this->OSPRayManager;
-  }
-
-  void SetHasVolume(bool st) { HasVolume=st;}
-  void SetProgressiveRenderFlag() {prog_flag = true; }
-  void SetClearAccumFlag() {ClearAccumFlag = true; }
-  int GetAccumCounter() { return AccumCounter; }
-  int GetMaxAccumulation() { return MaxAccum; }
-  int GetFrame() { return Frame; }
-  vtkSetMacro(ComputeDepth, bool);
-
-  void AddOSPRayRenderable(vtkOSPRayRenderable* inst);
-
-protected:
-  vtkOSPRayRenderer();
-  ~vtkOSPRayRenderer();
-
-  //lets OSPRay engine know when viewport changes
-  void UpdateSize();
-
-  // OSPRay renderer does not support picking.
-  virtual void DevicePickRender() {};
-  virtual void StartPick(unsigned int vtkNotUsed(pickFromSizev)) {};
-  virtual void UpdatePickId() {};
-  virtual void DonePick() {};
-  virtual unsigned int GetPickedId() { return 0; };
-  virtual unsigned int GetNumPickedIds() { return 0; };
-  virtual int GetPickedIds( unsigned int vtkNotUsed(atMost), unsigned int * vtkNotUsed(callerBuffer) )
-  {
-    return 0;
-  };
-  virtual double GetPickedZ() { return 0.0f; };
-  //creates the internal OSPRay renderer object
-
-  void UpdateOSPRayRenderer();
-
-private:
-  vtkOSPRayRenderer(const vtkOSPRayRenderer&); // Not implemented.
-  void operator=(const vtkOSPRayRenderer&); // Not implemented.
-
-  void InitEngine();
-
-  //Description:
-  // Overriden to help ensure that a OSPRay compatible class is created.
-  vtkCamera * MakeCamera();
-  std::vector<vtkOSPRayRenderable*> renderables;
-
-  bool IsStereo;
-  bool EngineInited;
-  bool EngineStarted;
-
-  int ImageX;
-  int ImageY;
-  OSPFrameBuffer osp_framebuffer;
-
-  float *ColorBuffer;
-  float *DepthBuffer;
-
-
-  int ChannelId;
-
-  vtkOSPRayManager *OSPRayManager;
-
-  int NumberOfWorkers;
-  int EnableShadows;
-  int EnableAO;
-  int EnablePathtracing;
-  int EnableVolumeShading;
-  int Samples;
-  int MaxDepth;
-  bool Accumulate;
-  int AccumCounter;
-  int MaxAccum;
-  bool prog_flag;
-  int Frame;
-  bool ComputeDepth;
-  bool HasVolume;
-  bool ClearAccumFlag;
-
-  double backgroundRGB[3];
-  std::queue<std::pair<std::string, double> > Statistics;
-  int StatisticFramesPerOutput;
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTestSource.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTestSource.cxx
deleted file mode 100755
index 67bdc456b3..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTestSource.cxx
+++ /dev/null
@@ -1,207 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayTestSource - produce triangles to benchmark OSPRay with
-
-#include "vtkOSPRayTestSource.h"
-#include "vtkObjectFactory.h"
-
-#include "vtkInformation.h"
-#include "vtkInformationVector.h"
-#include "vtkMath.h"
-#include "vtkStreamingDemandDrivenPipeline.h"
-#include "vtkIdTypeArray.h"
-#include "vtkCellArray.h"
-
-vtkStandardNewMacro(vtkOSPRayTestSource);
-
-//----------------------------------------------------------------------------
-vtkOSPRayTestSource::vtkOSPRayTestSource()
-{
-  this->SetNumberOfInputPorts(0);
-  this->Resolution = 100;
-
-  //Give it some geometric coherence
-  this->DriftFactor = 0.1;
-  //Give it some memory coherence
-  this->SlidingWindow = 0.01;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayTestSource::~vtkOSPRayTestSource()
-{
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayTestSource::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os,indent);
-
-  os << indent << "Resolution: " << this->Resolution << endl;
-  os << indent << "DriftFactor: " << this->DriftFactor << endl;
-  os << indent << "SlidingWindow: " << this->SlidingWindow << endl;
-}
-
-//----------------------------------------------------------------------------
-int vtkOSPRayTestSource::RequestInformation(
-  vtkInformation *vtkNotUsed(info),
-  vtkInformationVector **vtkNotUsed(inputV),
-  vtkInformationVector *output)
-{
-  return 1;
-}
-
-//----------------------------------------------------------------------------
-int vtkOSPRayTestSource::RequestData(vtkInformation *vtkNotUsed(info),
-                                    vtkInformationVector **vtkNotUsed(inputV),
-                                    vtkInformationVector *output)
-{
-  vtkInformation *outInfo = output->GetInformationObject(0);
-  int Rank = 0;
-  if (outInfo->Has(vtkStreamingDemandDrivenPipeline::UPDATE_PIECE_NUMBER()))
-    {
-    Rank =
-      outInfo->Get(
-        vtkStreamingDemandDrivenPipeline::UPDATE_PIECE_NUMBER());
-    }
-  int Processors = 1;
-  if (outInfo->Has(
-        vtkStreamingDemandDrivenPipeline::UPDATE_NUMBER_OF_PIECES()))
-    {
-    Processors =
-      outInfo->Get(
-        vtkStreamingDemandDrivenPipeline::UPDATE_NUMBER_OF_PIECES());
-    }
-
-
-  vtkPolyData *outPD =
-    vtkPolyData::SafeDownCast(outInfo->Get(vtkDataObject::DATA_OBJECT()));
-  if (!outPD)
-    {
-    return VTK_ERROR;
-    }
-
-  outPD->Initialize();
-  outPD->Allocate();
-
-  vtkIdType myStart = this->Resolution/Processors * Rank;
-  vtkIdType myEnd = this->Resolution/Processors * (Rank+1);
-
-  vtkIdType indices[3];
-  vtkIdType minIndex = this->Resolution;
-  vtkIdType maxIndex = 0;
-  for (vtkIdType i = 0; i < this->Resolution; i++)
-    {
-    double offset;
-    indices[0] = -1;
-    indices[1] = -2;
-    indices[2] = -3;
-
-    for (vtkIdType c = 0; c < 3; c++)
-      {
-      offset = vtkMath::Random()*this->SlidingWindow*this->Resolution -
-        (this->SlidingWindow*this->Resolution/2.0);
-      indices[c] = ((vtkIdType)((double)i+c + offset));
-      if (indices[c] < 0 || indices[c] >= this->Resolution)
-        {
-        indices[c] = ((vtkIdType)((double)i+c - offset));
-        }
-
-      if (indices[0] == indices[1] ||
-          indices[0] == indices[2] ||
-          indices[2] == indices[1])
-        {
-        c--;
-        }
-      }
-
-    if (i >= myStart && i < myEnd)
-      {
-      //remember index range for this slice so we can readjust
-      for (int c = 0; c < 3; c++)
-        {
-        if (indices[c] < minIndex)
-          {
-          minIndex = indices[c];
-          }
-        if (indices[c] > maxIndex)
-          {
-          maxIndex = indices[c];
-          }
-        }
-
-      outPD->InsertNextCell(VTK_TRIANGLE, 3, indices);
-      }
-    if (i % (this->Resolution/10) == 0)
-      {
-      double frac = (double)i/this->Resolution * 0.33;
-      this->UpdateProgress(frac);
-      }
-    }
-
-
-  //shift indices to 0, because each processor only produces local points
-  vtkCellArray *polys = outPD->GetPolys();
-  polys->InitTraversal();
-  vtkIdType npts;
-  vtkIdType *thePts;
-  vtkIdType i = 0;
-  vtkIdType nCells = polys->GetNumberOfCells();
-  while(polys->GetNextCell(npts, thePts))
-    {
-    for (vtkIdType c = 0; c < npts; c++)
-      {
-      thePts[c] = thePts[c] - minIndex;
-      }
-    i++;
-    if (i % (nCells/10) == 0)
-      {
-      double frac = (double)i/nCells * 0.33 + 0.33;
-      this->UpdateProgress(frac);
-      }
-    }
-
-  vtkPoints *pts = vtkPoints::New();
-  double X = vtkMath::Random();
-  double Y = vtkMath::Random();
-  double Z = vtkMath::Random();
-  for (i = 0; (i < this->Resolution || i <= maxIndex); i++)
-    {
-    X = X+vtkMath::Random() * this->DriftFactor - this->DriftFactor*0.5;
-    Y = Y+vtkMath::Random() * this->DriftFactor - this->DriftFactor*0.5;
-    Z = Z+vtkMath::Random() * this->DriftFactor - this->DriftFactor*0.5;
-    if (i >= minIndex && i <= maxIndex)
-      {
-      pts->InsertNextPoint(X, Y, Z);
-      }
-
-    if (i % (this->Resolution/10) == 0)
-      {
-      double frac = (double)i/this->Resolution * 0.33 + 0.66;
-      this->UpdateProgress(frac);
-      }
-    }
-  outPD->SetPoints(pts);
-  pts->Delete();
-
-
-  return 1;
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTestSource.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTestSource.h
deleted file mode 100755
index 690ccb0201..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTestSource.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayTestSource - produce triangles to benchmark OSPRay with
-// .SECTION Description
-// This class produces polydata with a configurable number of triangles.
-// It respects parallelism, so that parallel scaling can be tested, and the
-// produced data is invariant with respect to the number of processors.
-// Configuration options change the charactersitics of the generated "scene"
-
-#ifndef __vtkOSPRayTestSource_h
-#define __vtkOSPRayTestSource_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkPolyDataAlgorithm.h"
-
-class VTKOSPRAY_EXPORT vtkOSPRayTestSource : public vtkPolyDataAlgorithm
-{
-public:
-  // Description:
-  // Create a new instance with (50,50,50) points in the (u-v-w) directions.
-  static vtkOSPRayTestSource *New();
-  vtkTypeMacro(vtkOSPRayTestSource,vtkPolyDataAlgorithm);
-  void PrintSelf(ostream& os, vtkIndent indent);
-
-  // Description:
-  // Set/Get the number of triangles to produce.
-  // Default is 100 triangles
-  vtkSetMacro(Resolution,vtkIdType);
-  vtkGetMacro(Resolution,vtkIdType);
-
-  // Description:
-  // Set/Get the spatial locality
-  // 0.0 behind infinite, 1.0 being none,
-  // this affects distance beteen sequential points
-  // Default is 0.1
-  vtkSetMacro(DriftFactor,double);
-  vtkGetMacro(DriftFactor,double);
-
-  // Description:
-  // Set/Get the memory locality
-  // 0.0 behind infinite (tri uses sequential pts),
-  // 1.0 being none (tri uses any point)
-  // Default is 0.01
-  vtkSetMacro(SlidingWindow,double);
-  vtkGetMacro(SlidingWindow,double);
-
-protected:
-  vtkOSPRayTestSource();
-  ~vtkOSPRayTestSource();
-
-  int RequestInformation(vtkInformation *info, vtkInformationVector **input,
-                         vtkInformationVector *output);
-
-  int RequestData(vtkInformation *info, vtkInformationVector **input,
-                  vtkInformationVector *output);
-
-  vtkIdType Resolution;
-  double DriftFactor;
-  double SlidingWindow;
-
-private:
-
-  vtkOSPRayTestSource(const vtkOSPRayTestSource&);  // Not implemented.
-  void operator=(const vtkOSPRayTestSource&);  // Not implemented.
-
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTexture.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTexture.cxx
deleted file mode 100755
index ba6c6f00f5..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTexture.cxx
+++ /dev/null
@@ -1,219 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayRenderer.h"
-#include "vtkOSPRayTexture.h"
-
-#include "vtkHomogeneousTransform.h"
-#include "vtkImageData.h"
-#include "vtkLookupTable.h"
-#include "vtkObjectFactory.h"
-#include "vtkPointData.h"
-#include "vtkTransform.h"
-
-
-
-
-#include <math.h>
-
-
-vtkStandardNewMacro(vtkOSPRayTexture);
-
-//----------------------------------------------------------------------------
-// Initializes an instance, generates a unique index.
-vtkOSPRayTexture::vtkOSPRayTexture()
-: OSPRayTexture(NULL)
-{
-  this->OSPRayManager = NULL;
-  this->OSPRayTexture = NULL;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayTexture::~vtkOSPRayTexture()
-{
-  if (this->OSPRayManager)
-  {
-    this->DeleteOSPRayTexture();
-
-    this->OSPRayManager->Delete();
-  }
-}
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayTexture::DeleteOSPRayTexture()
-{
-  if (!this->OSPRayTexture)
-  {
-    return;
-  }
-
-  this->OSPRayTexture = NULL;
-
-}
-
-//-----------------------------------------------------------------------------
-// Release the graphics resources used by this texture.
-void vtkOSPRayTexture::ReleaseGraphicsResources(vtkWindow *win)
-{
-  this->Superclass::ReleaseGraphicsResources( win );
-  if (!this->OSPRayManager)
-  {
-    return;
-  }
-
-  this->DeleteOSPRayTexture();
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayTexture::Load(vtkRenderer *ren, bool nearest)
-{
-  vtkImageData *input = this->GetInput();
-
-  vtkOSPRayRenderer* renderer =
-  vtkOSPRayRenderer::SafeDownCast(ren);
-  if (!renderer)
-  {
-    return;
-  }
-  if (!this->OSPRayManager)
-  {
-    this->OSPRayManager = renderer->GetOSPRayManager();
-    this->OSPRayManager->Register(this);
-  }
-
-  if (this->GetMTime() > this->LoadTime.GetMTime() ||
-    input->GetMTime()> this->LoadTime.GetMTime() ||
-      (this->GetLookupTable() && this->GetLookupTable()->GetMTime() > this->LoadTime.GetMTime())
-      )
-      {
-        int bytesPerPixel=4;
-        int size[3];
-        vtkDataArray *scalars;
-        unsigned char *dataPtr;
-        int xsize, ysize;
-
-    // Get the scalars the user choose to color with.
-        scalars = this->GetInputArrayToProcess(0, input);
-    // make sure scalars are non null
-        if (!scalars)
-        {
-          vtkErrorMacro(<< "No scalar values found for texture input!");
-          return;
-        }
-
-    // get some info
-        input->GetDimensions(size);
-
-        if (input->GetNumberOfCells() == scalars->GetNumberOfTuples())
-        {
-      // we are using cell scalars. Adjust image size for cells.
-          for (int kk = 0; kk < 3; kk++)
-          {
-            if (size[kk] > 1)
-            {
-              size[kk]--;
-            }
-          }
-        }
-
-        bytesPerPixel = scalars->GetNumberOfComponents();
-
-    // make sure using unsigned char data of color scalars type
-        if (this->MapColorScalarsThroughLookupTable ||
-          scalars->GetDataType() != VTK_UNSIGNED_CHAR)
-        {
-          dataPtr = this->MapScalarsToColors(scalars);
-          bytesPerPixel = 4;
-        }
-        else
-        {
-          dataPtr = static_cast<vtkUnsignedCharArray *> (scalars)->GetPointer(0);
-        }
-
-    // we only support 2d texture maps right now
-    // so one of the three sizes must be 1, but it
-    // could be any of them, so lets find it
-        if (size[0] == 1)
-        {
-          xsize = size[1];
-          ysize = size[2];
-        }
-        else
-        {
-          xsize = size[0];
-          if (size[1] == 1)
-          {
-            ysize = size[2];
-          }
-          else
-          {
-            ysize = size[1];
-            if (size[2] != 1)
-            {
-              vtkErrorMacro(<< "3D texture maps currently are not supported!");
-              return;
-            }
-          }
-        }
-        pixels.resize(xsize*ysize*3);  //TODO: Carson: memory leak
-        for (int i=0; i < xsize*ysize; i++)
-        {
-            unsigned char *color = &dataPtr[(i)*bytesPerPixel];
-            pixels[i*3+0] = color[0];
-            pixels[i*3+1] = color[1];
-            pixels[i*3+2] = color[2];
-        }
-
-        OSPDataType type = OSP_VOID_PTR;
-
-        if (bytesPerPixel == 4)
-        {
-          type = OSP_UCHAR3;
-        }
-        else
-        {
-          printf("error! bytesperpixel !=4\n");
-          Assert(0);
-          type = OSP_UCHAR3;
-        }
-
-        this->OSPRayTexture = (osp::Texture2D*)ospNewTexture2D(xsize,
-         ysize,
-         type,
-         &pixels[0],
-         nearest ? OSP_TEXTURE_FILTER_NEAREST : 0);
-
-        ospCommit((OSPTexture2D)this->OSPRayTexture);
-
-        this->LoadTime.Modified();
-      }
-    }
-
-//----------------------------------------------------------------------------
-    void vtkOSPRayTexture::PrintSelf(ostream& os, vtkIndent indent)
-    {
-      this->Superclass::PrintSelf(os,indent);
-    }
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTexture.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTexture.h
deleted file mode 100755
index c44e7ec521..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTexture.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayTexture -
-// .SECTION Description
-//
-
-#ifndef __vtkOSPRayTexture_h
-#define __vtkOSPRayTexture_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkTexture.h"
-
-//BTX
-#include "vtkWeakPointer.h" // needed for vtkWeakPointer.
-//ETX
-#include <vector>
-
-//BTX
-namespace OSPRay {
-}
-//ETX
-namespace osp
-{
-  class Texture2D;
-}
-
-class vtkRenderWindow;
-class vtkOSPRayManager;
-
-class VTKOSPRAY_EXPORT vtkOSPRayTexture : public vtkTexture
-{
-public:
-  static vtkOSPRayTexture *New();
-  vtkTypeMacro(vtkOSPRayTexture,vtkTexture);
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-
-  // Description:
-  // Implement base class method.
-  void Load(vtkRenderer *ren, bool nearest = false);
-
-  // Description:
-  // Release any graphics resources that are being consumed by this texture.
-  // The parameter window could be used to determine which graphic
-  // resources to release. Using the same texture object in multiple
-  // render windows is NOT currently supported.
-  void ReleaseGraphicsResources(vtkWindow *);
-  //BTX
-  vtkSetMacro(OSPRayTexture, osp::Texture2D*);
-  vtkGetMacro(OSPRayTexture, osp::Texture2D*);
-  //ETX
-
-  //BTX
-protected:
-  vtkOSPRayTexture();
-  ~vtkOSPRayTexture();
-
-  vtkTimeStamp   LoadTime;
-
-private:
-  vtkOSPRayTexture(const vtkOSPRayTexture&);  // Not implemented.
-  void operator=(const vtkOSPRayTexture&);  // Not implemented.
-
-  void DeleteOSPRayTexture();
-
-  osp::Texture2D* OSPRayTexture;
-  std::vector<unsigned char> pixels;
-  //ETX
-
-  vtkOSPRayManager *OSPRayManager;
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.cxx
deleted file mode 100755
index ab3a7b9b6d..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.cxx
+++ /dev/null
@@ -1,1363 +0,0 @@
-/*=========================================================================
-
-Program:   Visualization Toolkit
-Module:    vtkOSPRayVolumeRayCastMapper.cxx
-
-Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
-All rights reserved.
-See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
-
-This software is distributed WITHOUT ANY WARRANTY; without even
-the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-#include "vtkOSPRayVolumeRayCastMapper.h"
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-#include "ospray/volume/BlockBrickedVolume.h"
-
-#include "vtkCamera.h"
-#include "vtkDataArray.h"
-#include "vtkEncodedGradientEstimator.h"
-#include "vtkEncodedGradientShader.h"
-#include "vtkFiniteDifferenceGradientEstimator.h"
-#include "vtkGarbageCollector.h"
-#include "vtkGraphicsFactory.h"
-#include "vtkImageData.h"
-#include "vtkMath.h"
-#include "vtkMultiThreader.h"
-#include "vtkObjectFactory.h"
-#include "vtkPlaneCollection.h"
-#include "vtkPointData.h"
-#include "vtkRenderWindow.h"
-#include "vtkRenderer.h"
-#include "vtkTimerLog.h"
-#include "vtkTransform.h"
-#include "vtkVolumeProperty.h"
-#include "vtkVolumeRayCastFunction.h"
-#include "vtkRayCastImageDisplayHelper.h"
-#include "vtkStreamingDemandDrivenPipeline.h"
-#include "vtkColorTransferFunction.h"
-#include "vtkPiecewiseFunction.h"
-#include "vtkTimerLog.h"
-#include "vtkInformation.h"
-#include "vtkInformationVector.h"
-#include "vtkInformation.h"
-#include "vtkInformationDoubleKey.h"
-#include "vtkInformationDoubleVectorKey.h"
-
-#include "vtkOSPRayRenderer.h"
-#include "vtkOSPRayManager.h"
-
-#include <math.h>
-
-#include <DebugStream.h>
-
-vtkStandardNewMacro(vtkOSPRayVolumeRayCastMapper);
-
-vtkCxxSetObjectMacro(vtkOSPRayVolumeRayCastMapper,VolumeRayCastFunction,
-        vtkVolumeRayCastFunction );
-
-// A tolerance for bounds, historically equal to 2^(-23) and used
-// to counter a small numerical precision issue with the old
-// QuickFloor() function.  It should not be needed anymore.
-// #define VTK_RAYCAST_FLOOR_TOL 1.1920928955078125e-07
-#define VTK_RAYCAST_FLOOR_TOL 0
-
-#define vtkVRCMultiplyPointMacro( A, B, M ) \
-    B[0] = A[0]*M[0]  + A[1]*M[1]  + A[2]*M[2]  + M[3]; \
-B[1] = A[0]*M[4]  + A[1]*M[5]  + A[2]*M[6]  + M[7]; \
-B[2] = A[0]*M[8]  + A[1]*M[9]  + A[2]*M[10] + M[11]; \
-B[3] = A[0]*M[12] + A[1]*M[13] + A[2]*M[14] + M[15]; \
-if ( B[3] != 1.0 ) { B[0] /= B[3]; B[1] /= B[3]; B[2] /= B[3]; }
-
-#define vtkVRCMultiplyNormalMacro( A, B, M ) \
-    B[0] = A[0]*M[0]  + A[1]*M[4]  + A[2]*M[8]; \
-B[1] = A[0]*M[1]  + A[1]*M[5]  + A[2]*M[9]; \
-B[2] = A[0]*M[2]  + A[1]*M[6]  + A[2]*M[10]
-
-// Construct a new vtkOSPRayVolumeRayCastMapper with default values
-vtkOSPRayVolumeRayCastMapper::vtkOSPRayVolumeRayCastMapper()
-{
-    this->VolumeAdded=false;
-    this->NumColors = 128;
-    this->SampleDistance             =  1.0;
-    this->ImageSampleDistance        =  1.0;
-    this->MinimumImageSampleDistance =  1.0;
-    this->MaximumImageSampleDistance = 10.0;
-    this->AutoAdjustSampleDistances  =  1;
-    this->VolumeRayCastFunction      = NULL;
-
-    this->GradientEstimator  = vtkFiniteDifferenceGradientEstimator::New();
-    this->GradientShader     = vtkEncodedGradientShader::New();
-
-    this->PerspectiveMatrix      = vtkMatrix4x4::New();
-    this->ViewToWorldMatrix      = vtkMatrix4x4::New();
-    this->ViewToVoxelsMatrix     = vtkMatrix4x4::New();
-    this->VoxelsToViewMatrix     = vtkMatrix4x4::New();
-    this->WorldToVoxelsMatrix    = vtkMatrix4x4::New();
-    this->VoxelsToWorldMatrix    = vtkMatrix4x4::New();
-
-    this->VolumeMatrix           = vtkMatrix4x4::New();
-
-    this->PerspectiveTransform   = vtkTransform::New();
-    this->VoxelsTransform        = vtkTransform::New();
-    this->VoxelsToViewTransform  = vtkTransform::New();
-
-
-    this->ImageMemorySize[0]     = 0;
-    this->ImageMemorySize[1]     = 0;
-
-    this->Threader               = vtkMultiThreader::New();
-
-    this->Image                  = NULL;
-    this->RowBounds              = NULL;
-    this->OldRowBounds           = NULL;
-
-    this->RenderTimeTable        = NULL;
-    this->RenderVolumeTable      = NULL;
-    this->RenderRendererTable    = NULL;
-    this->RenderTableSize        = 0;
-    this->RenderTableEntries     = 0;
-
-    this->ZBuffer                = NULL;
-    this->ZBufferSize[0]         = 0;
-    this->ZBufferSize[1]         = 0;
-    this->ZBufferOrigin[0]       = 0;
-    this->ZBufferOrigin[1]       = 0;
-
-    this->ImageDisplayHelper     = vtkRayCastImageDisplayHelper::New();
-
-    this->IntermixIntersectingGeometry = 1;
-
-    this->OSPRayManager = vtkOSPRayManager::Singleton();
-
-    this->SharedData = false;
-    if (SharedData)
-        OSPRayVolume = ospNewVolume("shared_structured_volume");
-    else
-        OSPRayVolume = ospNewVolume("block_bricked_volume");
-    transferFunction = ospNewTransferFunction("piecewise_linear");
-    ospCommit(transferFunction);
-    SamplingRate=0.25;
-}
-
-// Destruct a vtkOSPRayVolumeRayCastMapper - clean up any memory used
-vtkOSPRayVolumeRayCastMapper::~vtkOSPRayVolumeRayCastMapper()
-{
-    if ( this->GradientEstimator )
-    {
-        this->GradientEstimator->UnRegister(this);
-        this->GradientEstimator = NULL;
-    }
-
-    this->GradientShader->Delete();
-
-    this->SetVolumeRayCastFunction(NULL);
-
-    this->PerspectiveMatrix->Delete();
-    this->ViewToWorldMatrix->Delete();
-    this->ViewToVoxelsMatrix->Delete();
-    this->VoxelsToViewMatrix->Delete();
-    this->WorldToVoxelsMatrix->Delete();
-    this->VoxelsToWorldMatrix->Delete();
-
-    this->VolumeMatrix->Delete();
-
-    this->VoxelsTransform->Delete();
-    this->VoxelsToViewTransform->Delete();
-    this->PerspectiveTransform->Delete();
-
-    this->ImageDisplayHelper->Delete();
-
-    this->Threader->Delete();
-
-    if ( this->Image )
-    {
-        delete [] this->Image;
-    }
-
-    if ( this->RenderTableSize )
-    {
-        delete [] this->RenderTimeTable;
-        delete [] this->RenderVolumeTable;
-        delete [] this->RenderRendererTable;
-    }
-
-    if ( this->RowBounds )
-    {
-        delete [] this->RowBounds;
-        delete [] this->OldRowBounds;
-    }
-}
-
-float vtkOSPRayVolumeRayCastMapper::RetrieveRenderTime( vtkRenderer *ren,
-        vtkVolume   *vol )
-{
-    int i;
-
-    for ( i = 0; i < this->RenderTableEntries; i++ )
-    {
-        if ( this->RenderVolumeTable[i] == vol &&
-                this->RenderRendererTable[i] == ren )
-        {
-            return this->RenderTimeTable[i];
-        }
-    }
-
-    return 0.0;
-}
-
-void vtkOSPRayVolumeRayCastMapper::StoreRenderTime( vtkRenderer *ren,
-        vtkVolume   *vol,
-        float       time )
-{
-    int i;
-    for ( i = 0; i < this->RenderTableEntries; i++ )
-    {
-        if ( this->RenderVolumeTable[i] == vol &&
-                this->RenderRendererTable[i] == ren )
-        {
-            this->RenderTimeTable[i] = time;
-            return;
-        }
-    }
-
-
-    // Need to increase size
-    if ( this->RenderTableEntries >= this->RenderTableSize )
-    {
-        if ( this->RenderTableSize == 0 )
-        {
-            this->RenderTableSize = 10;
-        }
-        else
-        {
-            this->RenderTableSize *= 2;
-        }
-
-        float       *oldTimePtr     = this->RenderTimeTable;
-        vtkVolume   **oldVolumePtr   = this->RenderVolumeTable;
-        vtkRenderer **oldRendererPtr = this->RenderRendererTable;
-
-        this->RenderTimeTable     = new float [this->RenderTableSize];
-        this->RenderVolumeTable   = new vtkVolume *[this->RenderTableSize];
-        this->RenderRendererTable = new vtkRenderer *[this->RenderTableSize];
-
-        for (i = 0; i < this->RenderTableEntries; i++ )
-        {
-            this->RenderTimeTable[i] = oldTimePtr[i];
-            this->RenderVolumeTable[i] = oldVolumePtr[i];
-            this->RenderRendererTable[i] = oldRendererPtr[i];
-        }
-
-        delete [] oldTimePtr;
-        delete [] oldVolumePtr;
-        delete [] oldRendererPtr;
-    }
-
-    this->RenderTimeTable[this->RenderTableEntries] = time;
-    this->RenderVolumeTable[this->RenderTableEntries] = vol;
-    this->RenderRendererTable[this->RenderTableEntries] = ren;
-
-    this->RenderTableEntries++;
-}
-
-void vtkOSPRayVolumeRayCastMapper::SetNumberOfThreads( int num )
-{
-    this->Threader->SetNumberOfThreads( num );
-}
-
-int vtkOSPRayVolumeRayCastMapper::GetNumberOfThreads()
-{
-    if (this->Threader)
-    {
-        return this->Threader->GetNumberOfThreads();
-    }
-    return 0;
-}
-
-void vtkOSPRayVolumeRayCastMapper::SetGradientEstimator(
-        vtkEncodedGradientEstimator *gradest )
-{
-
-    // If we are setting it to its current value, don't do anything
-    if ( this->GradientEstimator == gradest )
-    {
-        return;
-    }
-
-    // If we already have a gradient estimator, unregister it.
-    if ( this->GradientEstimator )
-    {
-        this->GradientEstimator->UnRegister(this);
-        this->GradientEstimator = NULL;
-    }
-
-    // If we are passing in a non-NULL estimator, register it
-    if ( gradest )
-    {
-        gradest->Register( this );
-    }
-
-    // Actually set the estimator, and consider the object Modified
-    this->GradientEstimator = gradest;
-    this->Modified();
-}
-
-float vtkOSPRayVolumeRayCastMapper::GetGradientMagnitudeScale()
-{
-    if ( !this->GradientEstimator )
-    {
-        vtkErrorMacro( "You must have a gradient estimator set to get the scale" );
-        return 1.0;
-    }
-
-    return this->GradientEstimator->GetGradientMagnitudeScale();
-}
-
-float vtkOSPRayVolumeRayCastMapper::GetGradientMagnitudeBias()
-{
-    if ( !this->GradientEstimator )
-    {
-        vtkErrorMacro( "You must have a gradient estimator set to get the bias" );
-        return 1.0;
-    }
-
-    return this->GradientEstimator->GetGradientMagnitudeBias();
-}
-
-void vtkOSPRayVolumeRayCastMapper::ReleaseGraphicsResources(vtkWindow *)
-{
-}
-
-void vtkOSPRayVolumeRayCastMapper::Render( vtkRenderer *ren, vtkVolume *vol )
-{
-    debug5 << "ALOK: beginning of vtkOSPRayVolumeRayCastMapper::Render" << endl;
-    // make sure that we have scalar input and update the scalar input
-    if ( this->GetInput() == NULL )
-    {
-        vtkErrorMacro(<< "No Input!");
-        return;
-    }
-    else
-    {
-        this->GetInputAlgorithm()->UpdateInformation();
-        vtkStreamingDemandDrivenPipeline::SetUpdateExtentToWholeExtent(
-                this->GetInputInformation());
-        this->GetInputAlgorithm()->Update();
-    }
-    // vol->UpdateTransferFunctions( ren );
-
-    //
-    // OSPRay
-    //
-
-    vtkOSPRayRenderer* OSPRayRenderer =
-        vtkOSPRayRenderer::SafeDownCast(ren);
-    if (!OSPRayRenderer)
-    {
-        debug5 << "ALOK: vtkOSPRayVolumeRayCastMapper::Render(): no OSPRayRenderer" << endl;
-        return;
-    }
-    debug5 << "ALOK: vtkOSPRayVolumeRayCastMapper::Render(): this->OSPRayManager=" << this->OSPRayManager << endl;
-    OSPRayModel = this->OSPRayManager->OSPRayVolumeModel;
-
-    OSPRenderer renderer = this->OSPRayManager->OSPRayVolumeRenderer;
-
-    vtkImageData *data = this->GetInput();
-    vtkDataArray * scalars = this->GetScalars(data, this->ScalarMode,
-            this->ArrayAccessMode, this->ArrayId, this->ArrayName, this->CellFlag);
-
-    void* ScalarDataPointer =
-        this->GetInput()->GetPointData()->GetScalars()->GetVoidPointer(0);
-    int ScalarDataType =
-        this->GetInput()->GetPointData()->GetScalars()->GetDataType();
-
-    int dim[3];
-    data->GetDimensions(dim);
-
-    //
-    // Cache timesteps
-    //
-    double timestep=-1;
-    vtkInformation *inputInfo = this->GetInput()->GetInformation();
-    // // std::cout << __PRETTY_FUNCTION__ << " (" << this << ") " << "actor: (" <<
-    // // OSPRayActor << ") mode: (" << OSPRayActor->OSPRayModel << ") " << std::endl;
-    if (inputInfo && inputInfo->Has(vtkDataObject::DATA_TIME_STEP()))
-    {
-        std::cerr << "has timestep\n";
-        timestep = inputInfo->Get(vtkDataObject::DATA_TIME_STEP());
-        std::cerr << "timestep time: " << timestep << std::endl;
-    }
-    vtkOSPRayVolumeCacheEntry* cacheEntry = Cache[vol][timestep];
-    if (!cacheEntry)
-    {
-        cacheEntry = new vtkOSPRayVolumeCacheEntry();
-        if (SharedData)
-            OSPRayVolume = ospNewVolume("shared_structured_volume");
-        else
-            OSPRayVolume = ospNewVolume("block_bricked_volume");
-        cacheEntry->Volume = OSPRayVolume;
-        Cache[vol][timestep] = cacheEntry;
-
-        //
-        // Send Volumetric data to OSPRay
-        //
-
-        char* buffer = NULL;
-        size_t sizeBytes =  (ScalarDataType == VTK_FLOAT) ? dim[0]*dim[1]*dim[2] *sizeof(float) : dim[0]*dim[1]*dim[2] *sizeof(char);
-
-        buffer = (char*)ScalarDataPointer;
-
-        ospSet3i(OSPRayVolume, "dimensions", dim[0], dim[1], dim[2]);
-        double origin[3];
-        vol->GetOrigin(origin);
-        double *bds = data->GetBounds();
-        origin[0] = bds[0];
-        origin[1] = bds[2];
-        origin[2] = bds[4];
-
-        double spacing[3];
-        data->GetSpacing(spacing);
-        ospSet3f(OSPRayVolume, "gridOrigin", origin[0], origin[1], origin[2]);
-        ospSet3f(OSPRayVolume, "gridSpacing", spacing[0],spacing[1],spacing[2]);
-        ospSetString(OSPRayVolume, "voxelType", (ScalarDataType == VTK_FLOAT) ? "float" : "uchar");
-        if (SharedData)
-        {
-            OSPData voxelData = ospNewData(sizeBytes, OSP_UCHAR, ScalarDataPointer, OSP_DATA_SHARED_BUFFER);
-            ospSetData(OSPRayVolume, "voxelData", voxelData);
-        }
-        else
-        {
-            ospSetRegion(OSPRayVolume, ScalarDataPointer, osp::vec3i(0,0,0), osp::vec3i(dim[0],dim[1],dim[2]));
-        }
-    }
-    OSPRayVolume = cacheEntry->Volume;
-
-    // test for modifications to volume properties
-    if (vol->GetProperty()->GetMTime() > PropertyTime)
-    {
-        OSPRayRenderer->SetClearAccumFlag();
-        vtkVolumeProperty* volProperty = vol->GetProperty();
-        vtkColorTransferFunction* colorTF = volProperty->GetRGBTransferFunction(0);
-        vtkPiecewiseFunction *scalarTF = volProperty->GetScalarOpacity(0);
-        int numNodes = colorTF->GetSize();
-        double* tfData = colorTF->GetDataPointer();
-
-        TFVals.resize(NumColors*3);
-        TFOVals.resize(NumColors);
-        scalarTF->GetTable(data->GetScalarRange()[0],data->GetScalarRange()[1], NumColors, &TFOVals[0]);
-        colorTF->GetTable(data->GetScalarRange()[0],data->GetScalarRange()[1], NumColors, &TFVals[0]);
-
-        OSPData colorData = ospNewData(NumColors, OSP_FLOAT3, &TFVals[0]);// TODO: memory leak?  does ospray manage this>
-        ospSetData(transferFunction, "colors", colorData);
-        OSPData tfAlphaData = ospNewData(NumColors, OSP_FLOAT, &TFOVals[0]);
-        ospSetData(transferFunction, "opacities", tfAlphaData);
-        ospCommit(transferFunction);
-        // this->SamplingRate = volProperty->GetSamplingRate();
-        ospSet1i(OSPRayVolume, "gradientShadingEnabled", volProperty->GetShade());
-        // std::cerr << "samplingRate: " << SamplingRate << std::endl;
-        // OSPRayRenderer->SetSamples(volProperty->GetSamples());
-        PropertyTime.Modified();
-    }
-
-    // test for modifications to input
-    if (this->GetInput()->GetMTime() > this->BuildTime)
-    {
-        // if (VolumeAdded)
-        // {
-        //   VolumeAdded=false;
-        // }
-        //! Create an OSPRay transfer function.
-
-        std::vector<float> isoValues;
-        if (this->GetInput()->GetPointData()->GetScalars("ospIsoValues"))
-        {
-            int num = this->GetInput()->GetPointData()->GetScalars("ospIsoValues")->GetComponent(0,0);
-            for( int i=0; i < num; i++)
-            {
-                float isoValue = this->GetInput()->GetPointData()->GetScalars("ospIsoValues")->GetComponent(0,i+1);
-                isoValues.push_back(isoValue);
-            }
-        }
-
-        if (isoValues.size())
-        {
-            OSPData isovaluesData = ospNewData(isoValues.size(), OSP_FLOAT, &isoValues[0]);
-            ospSetData(OSPRayVolume, "isovalues", isovaluesData);
-        }
-
-        if (this->GetInput()->GetPointData()->GetScalars("ospClipValues"))
-        {
-            float clipValue = this->GetInput()->GetPointData()->GetScalars("ospClipValues")->GetComponent(0,0);
-            int clipAxis = this->GetInput()->GetPointData()->GetScalars("ospClipValues")->GetComponent(0,1);
-
-            std::cout << "clipValue: " << clipValue << std::endl;
-            std::cout << "clipAxis: " << clipAxis << std::endl;
-            osp::vec3f upper(dim[0],dim[1],dim[2]);
-            if (clipAxis == 0)
-                upper.x = clipValue;
-            else if (clipAxis == 1)
-                upper.y = clipValue;
-            else if (clipAxis == 2)
-                upper.z = clipValue;
-            osp::box3f value(osp::vec3f(0,0,0), upper);
-            ospSet3fv(OSPRayVolume, "volumeClippingBoxLower", &value.lower.x);
-            ospSet3fv(OSPRayVolume, "volumeClippingBoxUpper", &value.upper.x);
-        }
-
-        ospSet2f(transferFunction, "valueRange", data->GetScalarRange()[0], data->GetScalarRange()[1]);
-
-        //! Commit the transfer function only after the initial colors and alphas have been set (workaround for Qt signalling issue).
-        ospCommit(transferFunction);
-
-        //TODO: manage memory
-
-        ospSetObject((OSPObject)OSPRayVolume, "transferFunction", transferFunction);
-        this->BuildTime.Modified();
-    }
-    ospSet1f(OSPRayVolume, "samplingRate", SamplingRate);
-    ospCommit(OSPRayVolume);
-    ospAddVolume(OSPRayModel,(OSPVolume)OSPRayVolume);
-    // if (!VolumeAdded)
-    // VolumeAdded = true;
-    ospCommit(OSPRayModel);
-    ospSetObject(renderer, "model", OSPRayModel);
-    ospCommit(renderer);
-    this->OSPRayManager->OSPRayVolumeModel = OSPRayModel;
-
-    OSPRayRenderer->SetHasVolume(true);
-    debug5 << "ALOK: end of vtkOSPRayVolumeRayCastMapper::Render" << endl;
-}
-
-double vtkOSPRayVolumeRayCastMapper::GetZBufferValue(int x, int y)
-{
-    int xPos, yPos;
-
-    xPos = static_cast<int>(static_cast<float>(x) * this->ImageSampleDistance);
-    yPos = static_cast<int>(static_cast<float>(y) * this->ImageSampleDistance);
-
-    xPos = (xPos >= this->ZBufferSize[0])?(this->ZBufferSize[0]-1):(xPos);
-    yPos = (yPos >= this->ZBufferSize[1])?(this->ZBufferSize[1]-1):(yPos);
-
-    return *(this->ZBuffer + yPos*this->ZBufferSize[0] + xPos);
-}
-
-int vtkOSPRayVolumeRayCastMapper::ComputeRowBounds(vtkVolume   *vol,
-        vtkRenderer *ren)
-{
-    float voxelPoint[3];
-    float viewPoint[8][4];
-    int i, j, k;
-    unsigned char *ucptr;
-    float minX, minY, maxX, maxY, minZ, maxZ;
-
-    minX =  1.0;
-    minY =  1.0;
-    maxX = -1.0;
-    maxY = -1.0;
-    minZ =  1.0;
-    maxZ =  0.0;
-
-    float bounds[6];
-    int dim[3];
-
-    this->GetInput()->GetDimensions(dim);
-    bounds[0] = bounds[2] = bounds[4] = 0.0;
-    bounds[1] = static_cast<float>(dim[0]-1) - VTK_RAYCAST_FLOOR_TOL;
-    bounds[3] = static_cast<float>(dim[1]-1) - VTK_RAYCAST_FLOOR_TOL;
-    bounds[5] = static_cast<float>(dim[2]-1) - VTK_RAYCAST_FLOOR_TOL;
-
-    double camPos[3];
-    double worldBounds[6];
-    vol->GetBounds( worldBounds );
-    int insideFlag = 0;
-    ren->GetActiveCamera()->GetPosition( camPos );
-    if ( camPos[0] >= worldBounds[0] &&
-            camPos[0] <= worldBounds[1] &&
-            camPos[1] >= worldBounds[2] &&
-            camPos[1] <= worldBounds[3] &&
-            camPos[2] >= worldBounds[4] &&
-            camPos[2] <= worldBounds[5] )
-    {
-        insideFlag = 1;
-    }
-
-
-    // If we have a simple crop box then we can tighten the bounds
-    // See prior explanation of RoundingTieBreaker
-    if ( this->Cropping && this->CroppingRegionFlags == 0x2000 )
-    {
-        bounds[0] = this->VoxelCroppingRegionPlanes[0];
-        bounds[1] = this->VoxelCroppingRegionPlanes[1] - VTK_RAYCAST_FLOOR_TOL;
-        bounds[2] = this->VoxelCroppingRegionPlanes[2];
-        bounds[3] = this->VoxelCroppingRegionPlanes[3] - VTK_RAYCAST_FLOOR_TOL;
-        bounds[4] = this->VoxelCroppingRegionPlanes[4];
-        bounds[5] = this->VoxelCroppingRegionPlanes[5] - VTK_RAYCAST_FLOOR_TOL;
-    }
-
-
-    // Copy the voxelsToView matrix to 16 floats
-    float voxelsToViewMatrix[16];
-    for ( j = 0; j < 4; j++ )
-    {
-        for ( i = 0; i < 4; i++ )
-        {
-            voxelsToViewMatrix[j*4+i] =
-                static_cast<float>(this->VoxelsToViewMatrix->GetElement(j,i));
-        }
-    }
-
-    // Convert the voxel bounds to view coordinates to find out the
-    // size and location of the image we need to generate.
-    int idx = 0;
-    if ( insideFlag )
-    {
-        minX = -1.0;
-        maxX =  1.0;
-        minY = -1.0;
-        maxY =  1.0;
-        minZ =  0.001;
-        maxZ =  0.001;
-    }
-    else
-    {
-        for ( k = 0; k < 2; k++ )
-        {
-            voxelPoint[2] = bounds[4+k];
-            for ( j = 0; j < 2; j++ )
-            {
-                voxelPoint[1] = bounds[2+j];
-                for ( i = 0; i < 2; i++ )
-                {
-                    voxelPoint[0] = bounds[i];
-                    vtkVRCMultiplyPointMacro( voxelPoint, viewPoint[idx],
-                            voxelsToViewMatrix );
-
-                    minX = (viewPoint[idx][0]<minX)?(viewPoint[idx][0]):(minX);
-                    minY = (viewPoint[idx][1]<minY)?(viewPoint[idx][1]):(minY);
-                    maxX = (viewPoint[idx][0]>maxX)?(viewPoint[idx][0]):(maxX);
-                    maxY = (viewPoint[idx][1]>maxY)?(viewPoint[idx][1]):(maxY);
-                    minZ = (viewPoint[idx][2]<minZ)?(viewPoint[idx][2]):(minZ);
-                    maxZ = (viewPoint[idx][2]>maxZ)?(viewPoint[idx][2]):(maxZ);
-                    idx++;
-                }
-            }
-        }
-    }
-
-    if ( minZ < 0.001 || maxZ > 0.9999 )
-    {
-        minX = -1.0;
-        maxX =  1.0;
-        minY = -1.0;
-        maxY =  1.0;
-        insideFlag = 1;
-    }
-
-    this->MinimumViewDistance =
-        (minZ<0.001)?(0.001):((minZ>0.999)?(0.999):(minZ));
-
-    // We have min/max values from -1.0 to 1.0 now - we want to convert
-    // these to pixel locations. Give a couple of pixels of breathing room
-    // on each side if possible
-    minX = ( minX + 1.0 ) * 0.5 * this->ImageViewportSize[0] - 2;
-    minY = ( minY + 1.0 ) * 0.5 * this->ImageViewportSize[1] - 2;
-    maxX = ( maxX + 1.0 ) * 0.5 * this->ImageViewportSize[0] + 2;
-    maxY = ( maxY + 1.0 ) * 0.5 * this->ImageViewportSize[1] + 2;
-
-    // If we are outside the view frustum return 0 - there is no need
-    // to render anything
-    if ( ( minX < 0 && maxX < 0 ) ||
-            ( minY < 0 && maxY < 0 ) ||
-            ( minX > this->ImageViewportSize[0]-1 &&
-              maxX > this->ImageViewportSize[0]-1 ) ||
-            ( minY > this->ImageViewportSize[1]-1 &&
-              maxY > this->ImageViewportSize[1]-1 ) )
-    {
-        return 0;
-    }
-
-    int oldImageMemorySize[2];
-    oldImageMemorySize[0] = this->ImageMemorySize[0];
-    oldImageMemorySize[1] = this->ImageMemorySize[1];
-
-    // Swap the row bounds
-    int *tmpptr;
-    tmpptr = this->RowBounds;
-    this->RowBounds = this->OldRowBounds;
-    this->OldRowBounds = tmpptr;
-
-
-    // Check the bounds - the volume might project outside of the
-    // viewing box / frustum so clip it if necessary
-    minX = (minX<0)?(0):(minX);
-    minY = (minY<0)?(0):(minY);
-    maxX = (maxX>this->ImageViewportSize[0]-1)?
-        (this->ImageViewportSize[0]-1):(maxX);
-    maxY = (maxY>this->ImageViewportSize[1]-1)?
-        (this->ImageViewportSize[1]-1):(maxY);
-
-    // Create the new image, and set its size and position
-    this->ImageInUseSize[0] = static_cast<int>(maxX - minX + 1.0);
-    this->ImageInUseSize[1] = static_cast<int>(maxY - minY + 1.0);
-
-    // What is a power of 2 size big enough to fit this image?
-    this->ImageMemorySize[0] = 32;
-    this->ImageMemorySize[1] = 32;
-    while ( this->ImageMemorySize[0] < this->ImageInUseSize[0] )
-    {
-        this->ImageMemorySize[0] *= 2;
-    }
-    while ( this->ImageMemorySize[1] < this->ImageInUseSize[1] )
-    {
-        this->ImageMemorySize[1] *= 2;
-    }
-
-    this->ImageOrigin[0] = static_cast<int>(minX);
-    this->ImageOrigin[1] = static_cast<int>(minY);
-
-    // If the old image size is much too big (more than twice in
-    // either direction) then set the old width to 0 which will
-    // cause the image to be recreated
-    if ( oldImageMemorySize[0] > 2*this->ImageMemorySize[0] ||
-            oldImageMemorySize[1] > 2*this->ImageMemorySize[1] )
-    {
-        oldImageMemorySize[0] = 0;
-    }
-
-    // If the old image is big enough (but not too big - we handled
-    // that above) then we'll bump up our required size to the
-    // previous one. This will keep us from thrashing.
-    if ( oldImageMemorySize[0] >= this->ImageMemorySize[0] &&
-            oldImageMemorySize[1] >= this->ImageMemorySize[1] )
-    {
-        this->ImageMemorySize[0] = oldImageMemorySize[0];
-        this->ImageMemorySize[1] = oldImageMemorySize[1];
-    }
-
-    // Do we already have a texture big enough? If not, create a new one and
-    // clear it.
-    if ( !this->Image ||
-            this->ImageMemorySize[0] > oldImageMemorySize[0] ||
-            this->ImageMemorySize[1] > oldImageMemorySize[1] )
-    {
-        // If there is an image there must be row bounds
-        if ( this->Image )
-        {
-            delete [] this->Image;
-            delete [] this->RowBounds;
-            delete [] this->OldRowBounds;
-        }
-
-        this->Image = new unsigned char[(this->ImageMemorySize[0] *
-                this->ImageMemorySize[1] * 4)];
-
-        // Create the row bounds array. This will store the start / stop pixel
-        // for each row. This helps eleminate work in areas outside the bounding
-        // hexahedron since a bounding box is not very tight. We keep the old ones
-        // too to help with only clearing where required
-        this->RowBounds = new int [2*this->ImageMemorySize[1]];
-        this->OldRowBounds = new int [2*this->ImageMemorySize[1]];
-
-        for ( i = 0; i < this->ImageMemorySize[1]; i++ )
-        {
-            this->RowBounds[i*2]      = this->ImageMemorySize[0];
-            this->RowBounds[i*2+1]    = -1;
-            this->OldRowBounds[i*2]   = this->ImageMemorySize[0];
-            this->OldRowBounds[i*2+1] = -1;
-        }
-
-        ucptr = this->Image;
-
-        for ( i = 0; i < this->ImageMemorySize[0]*this->ImageMemorySize[1]; i++ )
-        {
-            *(ucptr++) = 0;
-            *(ucptr++) = 0;
-            *(ucptr++) = 0;
-            *(ucptr++) = 0;
-        }
-    }
-
-    // If we are inside the volume our row bounds indicate every ray must be
-    // cast - we don't need to intersect with the 12 lines
-    if ( insideFlag )
-    {
-        for ( j = 0; j < this->ImageInUseSize[1]; j++ )
-        {
-            this->RowBounds[j*2] = 0;
-            this->RowBounds[j*2+1] = this->ImageInUseSize[0] - 1;
-        }
-    }
-    else
-    {
-        // create an array of lines where the y value of the first vertex is less
-        // than or equal to the y value of the second vertex. There are 12 lines,
-        // each containing x1, y1, x2, y2 values.
-        float lines[12][4];
-        float x1, y1, x2, y2;
-        int xlow, xhigh;
-        int lineIndex[12][2] = {{0,1}, {2,3}, {4,5}, {6,7},
-            {0,2}, {1,3} ,{4,6}, {5,7},
-            {0,4}, {1,5}, {2,6}, {3,7}};
-
-        for ( i = 0; i < 12; i++ )
-        {
-            x1 = (viewPoint[lineIndex[i][0]][0]+1.0) *
-                0.5*this->ImageViewportSize[0] - this->ImageOrigin[0];
-
-            y1 = (viewPoint[lineIndex[i][0]][1]+1.0) *
-                0.5*this->ImageViewportSize[1] - this->ImageOrigin[1];
-
-            x2 = (viewPoint[lineIndex[i][1]][0]+1.0) *
-                0.5*this->ImageViewportSize[0] - this->ImageOrigin[0];
-
-            y2 = (viewPoint[lineIndex[i][1]][1]+1.0) *
-                0.5*this->ImageViewportSize[1] - this->ImageOrigin[1];
-
-            if ( y1 < y2 )
-            {
-                lines[i][0] = x1;
-                lines[i][1] = y1;
-                lines[i][2] = x2;
-                lines[i][3] = y2;
-            }
-            else
-            {
-                lines[i][0] = x2;
-                lines[i][1] = y2;
-                lines[i][2] = x1;
-                lines[i][3] = y1;
-            }
-        }
-
-        // Now for each row in the image, find out the start / stop pixel
-        // If min > max, then no intersection occurred
-        for ( j = 0; j < this->ImageInUseSize[1]; j++ )
-        {
-            this->RowBounds[j*2] = this->ImageMemorySize[0];
-            this->RowBounds[j*2+1] = -1;
-            for ( i = 0; i < 12; i++ )
-            {
-                if ( j >= lines[i][1] && j <= lines[i][3] &&
-                        ( lines[i][1] != lines[i][3] ) )
-                {
-                    x1 = lines[i][0] +
-                        (static_cast<float>(j) - lines[i][1])/(lines[i][3] - lines[i][1]) *
-                        (lines[i][2] - lines[i][0] );
-
-                    xlow  = static_cast<int>(x1 + 1.5);
-                    xhigh = static_cast<int>(x1 - 1.0);
-
-                    xlow = (xlow<0)?(0):(xlow);
-                    xlow = (xlow>this->ImageInUseSize[0]-1)?
-                        (this->ImageInUseSize[0]-1):(xlow);
-
-                    xhigh = (xhigh<0)?(0):(xhigh);
-                    xhigh = (xhigh>this->ImageInUseSize[0]-1)?(
-                            this->ImageInUseSize[0]-1):(xhigh);
-
-                    if ( xlow < this->RowBounds[j*2] )
-                    {
-                        this->RowBounds[j*2] = xlow;
-                    }
-                    if ( xhigh > this->RowBounds[j*2+1] )
-                    {
-                        this->RowBounds[j*2+1] = xhigh;
-                    }
-                }
-            }
-            // If they are the same this is either a point on the cube or
-            // all lines were out of bounds (all on one side or the other)
-            // It is safe to ignore the point (since the ray isn't likely
-            // to travel through it enough to actually take a sample) and it
-            // must be ignored in the case where all lines are out of range
-            if ( this->RowBounds[j*2] == this->RowBounds[j*2+1] )
-            {
-                this->RowBounds[j*2] = this->ImageMemorySize[0];
-                this->RowBounds[j*2+1] = -1;
-            }
-        }
-    }
-
-    for ( j = this->ImageInUseSize[1]; j < this->ImageMemorySize[1]; j++ )
-    {
-        this->RowBounds[j*2] = this->ImageMemorySize[0];
-        this->RowBounds[j*2+1] = -1;
-    }
-
-    for ( j = 0; j < this->ImageMemorySize[1]; j++ )
-    {
-        // New bounds are not overlapping with old bounds - clear between
-        // old bounds only
-        if ( this->RowBounds[j*2+1] < this->OldRowBounds[j*2] ||
-                this->RowBounds[j*2]   > this->OldRowBounds[j*2+1] )
-        {
-            ucptr = this->Image + 4*( j*this->ImageMemorySize[0] +
-                    this->OldRowBounds[j*2] );
-            for ( i = 0;
-                    i <= (this->OldRowBounds[j*2+1] - this->OldRowBounds[j*2]);
-                    i++ )
-            {
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-            }
-        }
-        // New bounds do overlap with old bounds
-        else
-        {
-            // Clear from old min to new min
-            ucptr = this->Image + 4*( j*this->ImageMemorySize[0] +
-                    this->OldRowBounds[j*2] );
-            for ( i = 0;
-                    i < (this->RowBounds[j*2] - this->OldRowBounds[j*2]);
-                    i++ )
-            {
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-            }
-
-            // Clear from new max to old max
-            ucptr = this->Image + 4*( j*this->ImageMemorySize[0] +
-                    this->RowBounds[j*2+1]+1 );
-            for ( i = 0;
-                    i < (this->OldRowBounds[j*2+1] - this->RowBounds[j*2+1]);
-                    i++ )
-            {
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-            }
-
-        }
-    }
-
-    return 1;
-}
-
-
-void vtkOSPRayVolumeRayCastMapper::ComputeMatrices( vtkImageData *data,
-        vtkVolume *vol )
-{
-    // Get the data spacing. This scaling is not accounted for in
-    // the volume's matrix, so we must add it in.
-    double volumeSpacing[3];
-    data->GetSpacing( volumeSpacing );
-
-    // Get the origin of the data.  This translation is not accounted for in
-    // the volume's matrix, so we must add it in.
-    float volumeOrigin[3];
-    double *bds = data->GetBounds();
-    volumeOrigin[0] = bds[0];
-    volumeOrigin[1] = bds[2];
-    volumeOrigin[2] = bds[4];
-
-    // Get the dimensions of the data.
-    int volumeDimensions[3];
-    data->GetDimensions( volumeDimensions );
-
-    vtkTransform *voxelsTransform = this->VoxelsTransform;
-    vtkTransform *voxelsToViewTransform = this->VoxelsToViewTransform;
-
-    // Get the volume matrix. This is a volume to world matrix right now.
-    // We'll need to invert it, translate by the origin and scale by the
-    // spacing to change it to a world to voxels matrix.
-    this->VolumeMatrix->DeepCopy( vol->GetMatrix() );
-    voxelsToViewTransform->SetMatrix( VolumeMatrix );
-
-    // Create a transform that will account for the scaling and translation of
-    // the scalar data. The is the volume to voxels matrix.
-    voxelsTransform->Identity();
-    voxelsTransform->Translate(volumeOrigin[0],
-            volumeOrigin[1],
-            volumeOrigin[2] );
-
-    voxelsTransform->Scale( volumeSpacing[0],
-            volumeSpacing[1],
-            volumeSpacing[2] );
-
-    // Now concatenate the volume's matrix with this scalar data matrix
-    voxelsToViewTransform->PreMultiply();
-    voxelsToViewTransform->Concatenate( voxelsTransform->GetMatrix() );
-
-    // Now we actually have the world to voxels matrix - copy it out
-    this->WorldToVoxelsMatrix->DeepCopy( voxelsToViewTransform->GetMatrix() );
-    this->WorldToVoxelsMatrix->Invert();
-
-    // We also want to invert this to get voxels to world
-    this->VoxelsToWorldMatrix->DeepCopy( voxelsToViewTransform->GetMatrix() );
-
-    // Compute the voxels to view transform by concatenating the
-    // voxels to world matrix with the projection matrix (world to view)
-    voxelsToViewTransform->PostMultiply();
-    voxelsToViewTransform->Concatenate( this->PerspectiveMatrix );
-
-    this->VoxelsToViewMatrix->DeepCopy( voxelsToViewTransform->GetMatrix() );
-
-    this->ViewToVoxelsMatrix->DeepCopy( this->VoxelsToViewMatrix );
-    this->ViewToVoxelsMatrix->Invert();
-}
-
-void vtkOSPRayVolumeRayCastMapper::InitializeClippingPlanes(
-        vtkVolumeRayCastStaticInfo *staticInfo,
-        vtkPlaneCollection *planes )
-{
-    vtkPlane *onePlane;
-    double    worldNormal[3], worldOrigin[3];
-    double    volumeOrigin[4];
-    int      i;
-    float    *worldToVoxelsMatrix;
-    float    *voxelsToWorldMatrix;
-    int      count;
-    float    *clippingPlane;
-    float    t;
-
-    count = planes->GetNumberOfItems();
-    staticInfo->NumberOfClippingPlanes = count;
-
-    if ( !count )
-    {
-        return;
-    }
-
-    worldToVoxelsMatrix = staticInfo->WorldToVoxelsMatrix;
-    voxelsToWorldMatrix = staticInfo->VoxelsToWorldMatrix;
-
-    staticInfo->ClippingPlane = new float [4*count];
-
-    // loop through all the clipping planes
-    for ( i = 0; i < count; i++ )
-    {
-        onePlane = static_cast<vtkPlane *>(planes->GetItemAsObject(i));
-        onePlane->GetNormal(worldNormal);
-        onePlane->GetOrigin(worldOrigin);
-        clippingPlane = staticInfo->ClippingPlane + 4*i;
-        vtkVRCMultiplyNormalMacro( worldNormal,
-                clippingPlane,
-                voxelsToWorldMatrix );
-        vtkVRCMultiplyPointMacro( worldOrigin, volumeOrigin,
-                worldToVoxelsMatrix );
-
-        t = sqrt( clippingPlane[0]*clippingPlane[0] +
-                clippingPlane[1]*clippingPlane[1] +
-                clippingPlane[2]*clippingPlane[2] );
-        if ( t )
-        {
-            clippingPlane[0] /= t;
-            clippingPlane[1] /= t;
-            clippingPlane[2] /= t;
-        }
-
-        clippingPlane[3] = -(clippingPlane[0]*volumeOrigin[0] +
-                clippingPlane[1]*volumeOrigin[1] +
-                clippingPlane[2]*volumeOrigin[2]);
-    }
-}
-
-
-int vtkOSPRayVolumeRayCastMapper::ClipRayAgainstClippingPlanes(
-        vtkVolumeRayCastDynamicInfo *dynamicInfo,
-        vtkVolumeRayCastStaticInfo *staticInfo )
-{
-    float    *clippingPlane;
-    int      i;
-    float    rayDir[3];
-    float    t, point[3], dp;
-    float    *rayStart, *rayEnd;
-
-    rayStart = dynamicInfo->TransformedStart;
-    rayEnd = dynamicInfo->TransformedEnd;
-
-    rayDir[0] = rayEnd[0] - rayStart[0];
-    rayDir[1] = rayEnd[1] - rayStart[1];
-    rayDir[2] = rayEnd[2] - rayStart[2];
-
-    // loop through all the clipping planes
-    for ( i = 0; i < staticInfo->NumberOfClippingPlanes; i++ )
-    {
-        clippingPlane = staticInfo->ClippingPlane + 4*i;
-
-        dp =
-            clippingPlane[0]*rayDir[0] +
-            clippingPlane[1]*rayDir[1] +
-            clippingPlane[2]*rayDir[2];
-
-        if ( dp != 0.0 )
-        {
-            t =
-                -( clippingPlane[0]*rayStart[0] +
-                        clippingPlane[1]*rayStart[1] +
-                        clippingPlane[2]*rayStart[2] + clippingPlane[3]) / dp;
-
-            if ( t > 0.0 && t < 1.0 )
-            {
-                point[0] = rayStart[0] + t*rayDir[0];
-                point[1] = rayStart[1] + t*rayDir[1];
-                point[2] = rayStart[2] + t*rayDir[2];
-
-                if ( dp > 0.0 )
-                {
-                    rayStart[0] = point[0];
-                    rayStart[1] = point[1];
-                    rayStart[2] = point[2];
-                }
-                else
-                {
-                    rayEnd[0] = point[0];
-                    rayEnd[1] = point[1];
-                    rayEnd[2] = point[2];
-                }
-
-                rayDir[0] = rayEnd[0] - rayStart[0];
-                rayDir[1] = rayEnd[1] - rayStart[1];
-                rayDir[2] = rayEnd[2] - rayStart[2];
-
-            }
-            // If the clipping plane is outside the ray segment, then
-            // figure out if that means the ray segment goes to zero (if so
-            // return 0) or doesn't affect it (if so do nothing)
-            else
-            {
-                if ( dp >= 0.0 && t >= 1.0 )
-                {
-                    return 0;
-                }
-                if ( dp <= 0.0 && t <= 0.0 )
-                {
-                    return 0;
-                }
-            }
-        }
-    }
-
-    return 1;
-}
-
-int vtkOSPRayVolumeRayCastMapper::ClipRayAgainstVolume(
-        vtkVolumeRayCastDynamicInfo *dynamicInfo,
-        float bounds[6] )
-{
-    int    loop;
-    float  diff;
-    float  t;
-    float  *rayStart, *rayEnd, *rayDirection;
-
-    rayStart     = dynamicInfo->TransformedStart;
-    rayEnd       = dynamicInfo->TransformedEnd;
-    rayDirection = dynamicInfo->TransformedDirection;
-
-    if ( rayStart[0] >= bounds[1] ||
-            rayStart[1] >= bounds[3] ||
-            rayStart[2] >= bounds[5] ||
-            rayStart[0] < bounds[0] ||
-            rayStart[1] < bounds[2] ||
-            rayStart[2] < bounds[4] )
-    {
-        for ( loop = 0; loop < 3; loop++ )
-        {
-            diff = 0;
-
-            if ( rayStart[loop] < (bounds[2*loop]+0.01) )
-            {
-                diff = (bounds[2*loop]+0.01) - rayStart[loop];
-            }
-            else if ( rayStart[loop] > (bounds[2*loop+1]-0.01) )
-            {
-                diff = (bounds[2*loop+1]-0.01) - rayStart[loop];
-            }
-
-            if ( diff )
-            {
-                if ( rayDirection[loop] != 0.0 )
-                {
-                    t = diff / rayDirection[loop];
-                }
-                else
-                {
-                    t = -1.0;
-                }
-
-                if ( t > 0.0 )
-                {
-                    rayStart[0] += rayDirection[0] * t;
-                    rayStart[1] += rayDirection[1] * t;
-                    rayStart[2] += rayDirection[2] * t;
-                }
-            }
-        }
-    }
-
-    // If the voxel still isn't inside the volume, then this ray
-    // doesn't really intersect the volume
-
-    if ( rayStart[0] >= bounds[1] ||
-            rayStart[1] >= bounds[3] ||
-            rayStart[2] >= bounds[5] ||
-            rayStart[0] < bounds[0] ||
-            rayStart[1] < bounds[2] ||
-            rayStart[2] < bounds[4] )
-    {
-        return 0;
-    }
-
-    // The ray does intersect the volume, and we have a starting
-    // position that is inside the volume
-    if ( rayEnd[0] >= bounds[1] ||
-            rayEnd[1] >= bounds[3] ||
-            rayEnd[2] >= bounds[5] ||
-            rayEnd[0] < bounds[0] ||
-            rayEnd[1] < bounds[2] ||
-            rayEnd[2] < bounds[4] )
-    {
-        for ( loop = 0; loop < 3; loop++ )
-        {
-            diff = 0;
-
-            if ( rayEnd[loop] < (bounds[2*loop]+0.01) )
-            {
-                diff = (bounds[2*loop]+0.01) - rayEnd[loop];
-            }
-            else if ( rayEnd[loop] > (bounds[2*loop+1]-0.01) )
-            {
-                diff = (bounds[2*loop+1]-0.01) - rayEnd[loop];
-            }
-
-            if ( diff )
-            {
-                if ( rayDirection[loop] != 0.0 )
-                {
-                    t = diff / rayDirection[loop];
-                }
-                else
-                {
-                    t = 1.0;
-                }
-
-                if ( t < 0.0 )
-                {
-                    rayEnd[0] += rayDirection[0] * t;
-                    rayEnd[1] += rayDirection[1] * t;
-                    rayEnd[2] += rayDirection[2] * t;
-                }
-            }
-        }
-    }
-
-    // To be absolutely certain our ray remains inside the volume,
-    // recompute the ray direction (since it has changed - it is not
-    // normalized and therefore changes when start/end change) and move
-    // the start/end points in by 1/1000th of the distance.
-    float offset;
-    offset = (rayEnd[0] - rayStart[0])*0.001;
-    rayStart[0] += offset;
-    rayEnd[0]   -= offset;
-
-    offset = (rayEnd[1] - rayStart[1])*0.001;
-    rayStart[1] += offset;
-    rayEnd[1]   -= offset;
-
-    offset = (rayEnd[2] - rayStart[2])*0.001;
-    rayStart[2] += offset;
-    rayEnd[2]   -= offset;
-
-    if ( rayEnd[0] >= bounds[1] ||
-            rayEnd[1] >= bounds[3] ||
-            rayEnd[2] >= bounds[5] ||
-            rayEnd[0] < bounds[0] ||
-            rayEnd[1] < bounds[2] ||
-            rayEnd[2] < bounds[4] )
-    {
-        return 0;
-    }
-
-    return 1;
-}
-
-void vtkOSPRayVolumeRayCastMapper::UpdateShadingTables( vtkRenderer *ren,
-        vtkVolume *vol )
-{
-    int                   shading;
-    vtkVolumeProperty     *volume_property;
-
-    volume_property = vol->GetProperty();
-
-    shading = volume_property->GetShade();
-
-    this->GradientEstimator->SetInputData( this->GetInput() );
-
-    if ( shading )
-    {
-        this->GradientShader->UpdateShadingTable( ren, vol,
-                this->GradientEstimator );
-    }
-}
-
-float vtkOSPRayVolumeRayCastMapper::GetZeroOpacityThreshold( vtkVolume *vol )
-{
-    return( this->VolumeRayCastFunction->GetZeroOpacityThreshold( vol ) );
-}
-
-// Print method for vtkOSPRayVolumeRayCastMapper
-void vtkOSPRayVolumeRayCastMapper::PrintSelf(ostream& os, vtkIndent indent)
-{
-    this->Superclass::PrintSelf(os,indent);
-
-    os << indent << "Sample Distance: " << this->SampleDistance << "\n";
-    os << indent << "Image Sample Distance: "
-        << this->ImageSampleDistance << "\n";
-    os << indent << "Minimum Image Sample Distance: "
-        << this->MinimumImageSampleDistance << "\n";
-    os << indent << "Maximum Image Sample Distance: "
-        << this->MaximumImageSampleDistance << "\n";
-    os << indent << "Auto Adjust Sample Distances: "
-        << this->AutoAdjustSampleDistances << "\n";
-    os << indent << "Intermix Intersecting Geometry: "
-        << (this->IntermixIntersectingGeometry ? "On\n" : "Off\n");
-
-    if ( this->VolumeRayCastFunction )
-    {
-        os << indent << "Ray Cast Function: " << this->VolumeRayCastFunction<<"\n";
-    }
-    else
-    {
-        os << indent << "Ray Cast Function: (none)\n";
-    }
-
-    if ( this->GradientEstimator )
-    {
-        os << indent << "Gradient Estimator: " << (this->GradientEstimator) <<
-            endl;
-    }
-    else
-    {
-        os << indent << "Gradient Estimator: (none)" << endl;
-    }
-
-    if ( this->GradientShader )
-    {
-        os << indent << "Gradient Shader: " << (this->GradientShader) << endl;
-    }
-    else
-    {
-        os << indent << "Gradient Shader: (none)" << endl;
-    }
-
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayVolumeRayCastMapper::ReportReferences(vtkGarbageCollector* collector)
-{
-    this->Superclass::ReportReferences(collector);
-    // These filters share our input and are therefore involved in a
-    // reference loop.
-    vtkGarbageCollectorReport(collector, this->GradientEstimator,
-            "GradientEstimator");
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.h
deleted file mode 100755
index 00b1a39982..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.h
+++ /dev/null
@@ -1,315 +0,0 @@
-/*=========================================================================
-
-  Program:   Visualization Toolkit
-  Module:    vtkOSPRayVolumeRayCastMapper.h
-
-  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
-  All rights reserved.
-  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-
-// .NAME vtkOSPRayVolumeRayCastMapper - A slow but accurate mapper for rendering volumes
-// .SECTION Description
-// This is a software ray caster for rendering volumes in vtkImageData.
-
-// .SECTION see also
-// vtkVolumeMapper
-
- //
- // Carson: 6/18/2015: note that for Paraview 4.3 I had to modify
- //   ParaViewCore/VTKExtensions/Rendering/vtkPVLODVolume.h to not check
- //  for valid scalars before rendering volumetric data.
- //
-
-#ifndef __vtkOSPRayVolumeRayCastMapper_h
-#define __vtkOSPRayVolumeRayCastMapper_h
-
-// #include "vtkRenderingVolumeModule.h" // For export macro
-#include "vtkVolumeMapper.h"
-#include "vtkVolumeRayCastFunction.h" // For vtkVolumeRayCastStaticInfo
-                                      // and vtkVolumeRayCastDynamicInfo
-#include "vtkOSPRayModule.h"
-#include <vector>
-#include <map>
-
-
-
-namespace osp
-{
-  class Volume;
-  class Model;
-  class TransferFunction;
-}
-
-class vtkEncodedGradientEstimator;
-class vtkEncodedGradientShader;
-class vtkMatrix4x4;
-class vtkMultiThreader;
-class vtkPlaneCollection;
-class vtkRenderer;
-class vtkTimerLog;
-class vtkVolume;
-class vtkVolumeRayCastFunction;
-class vtkVolumeTransform;
-class vtkTransform;
-class vtkRayCastImageDisplayHelper;
-
-
-class vtkOSPRayManager;
-
-struct vtkOSPRayVolumeCacheEntry
-{
-  osp::Volume* Volume;
-  vtkTimeStamp BuildTime;
-};
-
-
-// Macro for tri-linear interpolation - do four linear interpolations on
-// edges, two linear interpolations between pairs of edges, then a final
-// interpolation between faces
-#define vtkTrilinFuncMacro(v,x,y,z,a,b,c,d,e,f,g,h)         \
-        t00 =   a + (x)*(b-a);      \
-        t01 =   c + (x)*(d-c);      \
-        t10 =   e + (x)*(f-e);      \
-        t11 =   g + (x)*(h-g);      \
-        t0  = t00 + (y)*(t01-t00);  \
-        t1  = t10 + (y)*(t11-t10);  \
-        v   =  t0 + (z)*(t1-t0);
-
-// Forward declaration needed for use by friend declaration below.
-VTK_THREAD_RETURN_TYPE OSPRayVolumeRayCastMapper_CastRays( void *arg );
-
-class VTKRENDERINGVOLUME_EXPORT vtkOSPRayVolumeRayCastMapper : public vtkVolumeMapper
-{
-public:
-  static vtkOSPRayVolumeRayCastMapper *New();
-  vtkTypeMacro(vtkOSPRayVolumeRayCastMapper,vtkVolumeMapper);
-  void PrintSelf( ostream& os, vtkIndent indent );
-
-  // Description:
-  // Set/Get the distance between samples.  This variable is only
-  // used for sampling ray casting methods.  Methods that compute
-  // a ray value by stepping cell-by-cell are not affected by this
-  // value.
-  vtkSetMacro( SampleDistance, double );
-  vtkGetMacro( SampleDistance, double );
-
-  // Description:
-  // Get / Set the volume ray cast function. This is used to process
-  // values found along the ray to compute a final pixel value.
-  virtual void SetVolumeRayCastFunction(vtkVolumeRayCastFunction*);
-  vtkGetObjectMacro( VolumeRayCastFunction, vtkVolumeRayCastFunction );
-
-  // Description:
-  // Set / Get the gradient estimator used to estimate normals
-  virtual void SetGradientEstimator(vtkEncodedGradientEstimator *gradest);
-  vtkGetObjectMacro( GradientEstimator, vtkEncodedGradientEstimator );
-
-  // Description:
-  // Get the gradient shader.
-  vtkGetObjectMacro( GradientShader, vtkEncodedGradientShader );
-
-  // Description:
-  // Sampling distance in the XY image dimensions. Default value of 1 meaning
-  // 1 ray cast per pixel. If set to 0.5, 4 rays will be cast per pixel. If
-  // set to 2.0, 1 ray will be cast for every 4 (2 by 2) pixels.
-  vtkSetClampMacro( ImageSampleDistance, double, 0.1, 100.0 );
-  vtkGetMacro( ImageSampleDistance, double );
-
-  // Description:
-  // This is the minimum image sample distance allow when the image
-  // sample distance is being automatically adjusted
-  vtkSetClampMacro( MinimumImageSampleDistance, double, 0.1, 100.0 );
-  vtkGetMacro( MinimumImageSampleDistance, double );
-
-  // Description:
-  // This is the maximum image sample distance allow when the image
-  // sample distance is being automatically adjusted
-  vtkSetClampMacro( MaximumImageSampleDistance, double, 0.1, 100.0 );
-  vtkGetMacro( MaximumImageSampleDistance, double );
-
-  // Description:
-  // If AutoAdjustSampleDistances is on, the the ImageSampleDistance
-  // will be varied to achieve the allocated render time of this
-  // prop (controlled by the desired update rate and any culling in
-  // use).
-  vtkSetClampMacro( AutoAdjustSampleDistances, int, 0, 1 );
-  vtkGetMacro( AutoAdjustSampleDistances, int );
-  vtkBooleanMacro( AutoAdjustSampleDistances, int );
-
-  // Description:
-  // Set/Get the number of threads to use. This by default is equal to
-  // the number of available processors detected.
-  void SetNumberOfThreads( int num );
-  int GetNumberOfThreads();
-  vtkSetMacro(SamplingRate, double);
-  vtkGetMacro(SamplingRate, double);
-
-  // Description:
-  // If IntermixIntersectingGeometry is turned on, the zbuffer will be
-  // captured and used to limit the traversal of the rays.
-  vtkSetClampMacro( IntermixIntersectingGeometry, int, 0, 1 );
-  vtkGetMacro( IntermixIntersectingGeometry, int );
-  vtkBooleanMacro( IntermixIntersectingGeometry, int );
-
-//BTX
-  // Description:
-  // WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE
-  // Initialize rendering for this volume.
-  void Render( vtkRenderer *, vtkVolume * );
-
-  // Description:
-  // WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE
-  // Release any graphics resources that are being consumed by this mapper.
-  // The parameter window could be used to determine which graphic
-  // resources to release.
-  void ReleaseGraphicsResources(vtkWindow *);
-
-  // Description:
-  // WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE
-  // Return the scalar value below which all opacities are zero
-  float GetZeroOpacityThreshold( vtkVolume *vol );
-
-  // Description:
-  // WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE
-  // Values needed by the volume
-  virtual float GetGradientMagnitudeScale();
-  virtual float GetGradientMagnitudeBias();
-  virtual float GetGradientMagnitudeScale(int)
-    {return this->GetGradientMagnitudeScale();};
-  virtual float GetGradientMagnitudeBias(int)
-    {return this->GetGradientMagnitudeBias();};
-
-//ETX
-
-protected:
-  vtkOSPRayVolumeRayCastMapper();
-  ~vtkOSPRayVolumeRayCastMapper();
-
-  vtkVolumeRayCastFunction     *VolumeRayCastFunction;
-  vtkEncodedGradientEstimator  *GradientEstimator;
-  vtkEncodedGradientShader     *GradientShader;
-  vtkRayCastImageDisplayHelper *ImageDisplayHelper;
-
-  virtual void ReportReferences(vtkGarbageCollector*);
-
-  // The distance between sample points along the ray
-  int CellFlag;
-  double                       SampleDistance;
-  double                       ImageSampleDistance;
-  double                       MinimumImageSampleDistance;
-  double                       MaximumImageSampleDistance;
-  int                          AutoAdjustSampleDistances;
-
-  double                       WorldSampleDistance;
-  int                          ScalarDataType;
-  void                         *ScalarDataPointer;
-
-  void                         UpdateShadingTables( vtkRenderer *ren,
-                                                    vtkVolume *vol );
-
-  void ComputeMatrices( vtkImageData *data, vtkVolume *vol );
-  int ComputeRowBounds( vtkVolume *vol, vtkRenderer *ren );
-
-  friend VTK_THREAD_RETURN_TYPE OSPRayVolumeRayCastMapper_CastRays( void *arg );
-
-  vtkMultiThreader  *Threader;
-
-  vtkMatrix4x4 *PerspectiveMatrix;
-  vtkMatrix4x4 *ViewToWorldMatrix;
-  vtkMatrix4x4 *ViewToVoxelsMatrix;
-  vtkMatrix4x4 *VoxelsToViewMatrix;
-  vtkMatrix4x4 *WorldToVoxelsMatrix;
-  vtkMatrix4x4 *VoxelsToWorldMatrix;
-
-  vtkMatrix4x4 *VolumeMatrix;
-
-  vtkTransform *PerspectiveTransform;
-  vtkTransform *VoxelsTransform;
-  vtkTransform *VoxelsToViewTransform;
-
-  // This is how big the image would be if it covered the entire viewport
-  int            ImageViewportSize[2];
-
-  // This is how big the allocated memory for image is. This may be bigger
-  // or smaller than ImageFullSize - it will be bigger if necessary to
-  // ensure a power of 2, it will be smaller if the volume only covers a
-  // small region of the viewport
-  int            ImageMemorySize[2];
-
-  // This is the size of subregion in ImageSize image that we are using for
-  // the current image. Since ImageSize is a power of 2, there is likely
-  // wasted space in it. This number will be used for things such as clearing
-  // the image if necessary.
-  int            ImageInUseSize[2];
-
-  // This is the location in ImageFullSize image where our ImageSize image
-  // is located.
-  int            ImageOrigin[2];
-
-  // This is the allocated image
-  unsigned char *Image;
-
-  int  *RowBounds;
-  int  *OldRowBounds;
-
-  float        *RenderTimeTable;
-  vtkVolume   **RenderVolumeTable;
-  vtkRenderer **RenderRendererTable;
-  int           RenderTableSize;
-  int           RenderTableEntries;
-
-  void StoreRenderTime( vtkRenderer *ren, vtkVolume *vol, float t );
-  float RetrieveRenderTime( vtkRenderer *ren, vtkVolume *vol );
-
-  int           IntermixIntersectingGeometry;
-
-  float        *ZBuffer;
-  int           ZBufferSize[2];
-  int           ZBufferOrigin[2];
-
-  float         MinimumViewDistance;
-
-  int           ClipRayAgainstVolume( vtkVolumeRayCastDynamicInfo *dynamicInfo,
-                                      float bounds[6] );
-
-  void          InitializeClippingPlanes( vtkVolumeRayCastStaticInfo *staticInfo,
-                                          vtkPlaneCollection *planes );
-
-  int           ClipRayAgainstClippingPlanes( vtkVolumeRayCastDynamicInfo *dynamicInfo,
-                                              vtkVolumeRayCastStaticInfo *staticInfo);
-
-  // Get the ZBuffer value corresponding to location (x,y) where (x,y)
-  // are indexing into the ImageInUse image. This must be converted to
-  // the zbuffer image coordinates. Nearest neighbor value is returned.
-  double         GetZBufferValue( int x, int y );
-
-//
-//OSPRay
-//
-
-
-  vtkOSPRayManager *OSPRayManager;
-  osp::Volume* OSPRayVolume;
-  osp::Model* OSPRayModel;
-  vtkTimeStamp  BuildTime,PropertyTime;
-  osp::TransferFunction* transferFunction;
-  int NumColors;
-  std::vector<float> TFVals, TFOVals;
-  bool SharedData;
-  bool VolumeAdded;
-  double SamplingRate;
-  std::map< vtkVolume*, std::map< double, vtkOSPRayVolumeCacheEntry* > > Cache;
-
-
-private:
-  vtkOSPRayVolumeRayCastMapper(const vtkOSPRayVolumeRayCastMapper&);  // Not implemented.
-  void operator=(const vtkOSPRayVolumeRayCastMapper&);  // Not implemented.
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayImageVolumeRepresentation.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayImageVolumeRepresentation.cxx
deleted file mode 100755
index 23dbe7ea0a..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayImageVolumeRepresentation.cxx
+++ /dev/null
@@ -1,421 +0,0 @@
-/*=========================================================================
-
-Program:   ParaView
-Module:    vtkPVOSPRayImageVolumeRepresentation.cxx
-
-Copyright (c) Kitware, Inc.
-All rights reserved.
-See Copyright.txt or http://www.paraview.org/HTML/Copyright.html for details.
-
- This software is distributed WITHOUT ANY WARRANTY; without even
- the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-#include "vtkPVOSPRayImageVolumeRepresentation.h"
-
-#include "vtkAlgorithmOutput.h"
-#include "vtkCommand.h"
-#include "vtkExtentTranslator.h"
-#include "vtkImageData.h"
-#include "vtkInformation.h"
-#include "vtkInformationVector.h"
-#include "vtkMath.h"
-#include "vtkObjectFactory.h"
-#include "vtkOutlineSource.h"
-#include "vtkPolyDataMapper.h"
-#include "vtkPVCacheKeeper.h"
-#include "vtkPVLODVolume.h"
-#include "vtkPVRenderView.h"
-#include "vtkRenderer.h"
-#include "vtkSmartPointer.h"
-#include "vtkSmartVolumeMapper.h"
-#include "vtkStreamingDemandDrivenPipeline.h"
-#include "vtkVolumeProperty.h"
-#include "vtkAbstractVolumeMapper.h"
-#include "vtkPExtentTranslator.h"
-
-#include "vtkOSPRayVolumeRayCastMapper.h"
-#include "vtkOSPRayCompositeMapper.h"
-#include "vtkOSPRayLODActor.h"
-#include "vtkOSPRayActor.h"
-#include "vtkOSPRayPolyDataMapper.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkObjectFactory.h"
-#include "vtkVolumeProperty.h"
-#include "vtkPiecewiseFunction.h"
-#include "vtkOSPRayPVLODVolume.h"
-
-#include <map>
-#include <string>
-
-
-
- vtkStandardNewMacro(vtkPVOSPRayImageVolumeRepresentation);
-//----------------------------------------------------------------------------
- vtkPVOSPRayImageVolumeRepresentation::vtkPVOSPRayImageVolumeRepresentation()
- {
-  this->VolumeMapper = vtkOSPRayVolumeRayCastMapper::New();
-
-  this->Property = vtkVolumeProperty::New();
-
-  this->Actor = vtkOSPRayPVLODVolume::New();
-  this->Actor->SetProperty(this->Property);
-
-  this->CacheKeeper = vtkPVCacheKeeper::New();
-
-  this->OutlineSource = vtkOutlineSource::New();
-  this->OutlineMapper = vtkPolyDataMapper::New();
-
-  this->Cache = vtkImageData::New();
-
-  this->CacheKeeper->SetInputData(this->Cache);
-
-  vtkMath::UninitializeBounds(this->DataBounds);
-  this->DataSize = 0;
-
-  this->ColorArrayName = 0;
-  this->ColorAttributeType = POINT_DATA;
-}
-
-//----------------------------------------------------------------------------
-vtkPVOSPRayImageVolumeRepresentation::~vtkPVOSPRayImageVolumeRepresentation()
-{
-  this->VolumeMapper->Delete();
-  this->Property->Delete();
-  this->Actor->Delete();
-  this->OutlineSource->Delete();
-  this->OutlineMapper->Delete();
-  this->CacheKeeper->Delete();
-
-  this->Cache->Delete();
-}
-
-//----------------------------------------------------------------------------
-int vtkPVOSPRayImageVolumeRepresentation::FillInputPortInformation(
-  int, vtkInformation* info)
-{
-  info->Set(vtkAlgorithm::INPUT_REQUIRED_DATA_TYPE(), "vtkImageData");
-  info->Set(vtkAlgorithm::INPUT_IS_OPTIONAL(), 1);
-  return 1;
-}
-
-//----------------------------------------------------------------------------
-int vtkPVOSPRayImageVolumeRepresentation::ProcessViewRequest(
-  vtkInformationRequestKey* request_type,
-  vtkInformation* inInfo, vtkInformation* outInfo)
-{
-  if (!this->Superclass::ProcessViewRequest(request_type, inInfo, outInfo))
-  {
-    return 0;
-  }
-  if (request_type == vtkPVView::REQUEST_UPDATE())
-  {
-    vtkPVRenderView::SetPiece(inInfo, this,
-      this->OutlineSource->GetOutputDataObject(0),
-      this->DataSize);
-    outInfo->Set(vtkPVRenderView::NEED_ORDERED_COMPOSITING(), 1);
-
-    vtkPVRenderView::SetGeometryBounds(inInfo, this->DataBounds);
-
-    vtkPVOSPRayImageVolumeRepresentation::PassOrderedCompositingInformation(
-      this, inInfo);
-
-    vtkPVRenderView::SetRequiresDistributedRendering(inInfo, this, true);
-  }
-  else if (request_type == vtkPVView::REQUEST_UPDATE_LOD())
-  {
-    vtkPVRenderView::SetRequiresDistributedRenderingLOD(inInfo, this, true);
-  }
-  else if (request_type == vtkPVView::REQUEST_RENDER())
-  {
-    this->UpdateMapperParameters();
-
-    vtkAlgorithmOutput* producerPort = vtkPVRenderView::GetPieceProducer(inInfo, this);
-    if (producerPort)
-    {
-      this->OutlineMapper->SetInputConnection(producerPort);
-    }
-  }
-  return 1;
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::PassOrderedCompositingInformation(
-  vtkPVDataRepresentation* self, vtkInformation* inInfo)
-{
-  (void)inInfo;
-  if (self->GetNumberOfInputConnections(0) == 1)
-  {
-    vtkAlgorithmOutput* connection = self->GetInputConnection(0, 0);
-    vtkAlgorithm* inputAlgo = connection->GetProducer();
-    vtkStreamingDemandDrivenPipeline* sddp =
-    vtkStreamingDemandDrivenPipeline::SafeDownCast(inputAlgo->GetExecutive());
-
-    int extent[6] = {1, -1, 1, -1, 1, -1};
-    sddp->GetWholeExtent(sddp->GetOutputInformation(connection->GetIndex()),
-      extent);
-    double origin[3], spacing[3];
-    vtkImageData* image = vtkImageData::SafeDownCast(
-      inputAlgo->GetOutputDataObject(connection->GetIndex()));
-    if (!image)
-    {
-      std::cerr << "expected image data in vtkPVOSPRayImageVolumeRepresentation\n";
-      return;
-    }
-    image->GetOrigin(origin);
-    image->GetSpacing(spacing);
-
-    vtkNew<vtkPExtentTranslator> translator;
-    translator->GatherExtents(image);
-    vtkPVRenderView::SetOrderedCompositingInformation(
-      inInfo, self, translator.GetPointer(), extent, origin, spacing);
-  }
-}
-
-//----------------------------------------------------------------------------
-int vtkPVOSPRayImageVolumeRepresentation::RequestData(vtkInformation* request,
-  vtkInformationVector** inputVector, vtkInformationVector* outputVector)
-{
-  vtkMath::UninitializeBounds(this->DataBounds);
-  this->DataSize = 0;
-
-// Pass caching information to the cache keeper.
-  this->CacheKeeper->SetCachingEnabled(this->GetUseCache());
-  this->CacheKeeper->SetCacheTime(this->GetCacheKey());
-
-  if (inputVector[0]->GetNumberOfInformationObjects()==1)
-  {
-    vtkImageData* input = vtkImageData::GetData(inputVector[0], 0);
-    if (!this->GetUsingCacheForUpdate())
-    {
-      this->Cache->ShallowCopy(input);
-    }
-    this->CacheKeeper->Update();
-
-    this->Actor->SetEnableLOD(0);
-    this->VolumeMapper->SetInputConnection(
-      this->CacheKeeper->GetOutputPort());
-
-    this->OutlineSource->SetBounds(vtkImageData::SafeDownCast(
-      this->CacheKeeper->GetOutputDataObject(0))->GetBounds());
-    this->OutlineSource->GetBounds(this->DataBounds);
-    this->OutlineSource->Update();
-
-    this->DataSize = this->CacheKeeper->GetOutputDataObject(0)->GetActualMemorySize();
-  }
-  else
-  {
-// when no input is present, it implies that this processes is on a node
-// without the data input i.e. either client or render-server, in which case
-// we show only the outline.
-    this->VolumeMapper->RemoveAllInputs();
-//    this->Actor->SetEnableLOD(1);
-  }
-
-  return this->Superclass::RequestData(request, inputVector, outputVector);
-}
-
-//----------------------------------------------------------------------------
-bool vtkPVOSPRayImageVolumeRepresentation::IsCached(double cache_key)
-{
-  return this->CacheKeeper->IsCached(cache_key);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::MarkModified()
-{
-  if (!this->GetUseCache())
-  {
-// Cleanup caches when not using cache.
-    this->CacheKeeper->RemoveAllCaches();
-  }
-  this->Superclass::MarkModified();
-}
-
-//----------------------------------------------------------------------------
-bool vtkPVOSPRayImageVolumeRepresentation::AddToView(vtkView* view)
-{
-  vtkPVRenderView* rview = vtkPVRenderView::SafeDownCast(view);
-  if (rview)
-  {
-    rview->GetRenderer()->AddActor(this->Actor);
-    return true;
-  }
-  return false;
-}
-
-//----------------------------------------------------------------------------
-bool vtkPVOSPRayImageVolumeRepresentation::RemoveFromView(vtkView* view)
-{
-  vtkPVRenderView* rview = vtkPVRenderView::SafeDownCast(view);
-  if (rview)
-  {
-    rview->GetRenderer()->RemoveActor(this->Actor);
-    return true;
-  }
-  return false;
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::UpdateMapperParameters()
-{
-  const char* colorArrayName = NULL;
-  int fieldAssociation = vtkDataObject::FIELD_ASSOCIATION_POINTS;
-
-  vtkInformation *info = this->GetInputArrayInformation(0);
-  if (info &&
-    info->Has(vtkDataObject::FIELD_ASSOCIATION()) &&
-    info->Has(vtkDataObject::FIELD_NAME()))
-  {
-    colorArrayName = info->Get(vtkDataObject::FIELD_NAME());
-    fieldAssociation = info->Get(vtkDataObject::FIELD_ASSOCIATION());
-  }
-
-  this->VolumeMapper->SelectScalarArray(colorArrayName);
-  switch (fieldAssociation)
-  {
-    case vtkDataObject::FIELD_ASSOCIATION_CELLS:
-    this->VolumeMapper->SetScalarMode(VTK_SCALAR_MODE_USE_CELL_FIELD_DATA);
-    break;
-
-    case vtkDataObject::FIELD_ASSOCIATION_NONE:
-    this->VolumeMapper->SetScalarMode(VTK_SCALAR_MODE_USE_FIELD_DATA);
-    break;
-
-    case vtkDataObject::FIELD_ASSOCIATION_POINTS:
-    default:
-    this->VolumeMapper->SetScalarMode(VTK_SCALAR_MODE_USE_POINT_FIELD_DATA);
-    break;
-  }
-
-  vtkOSPRayVolumeRayCastMapper* ospMapper = vtkOSPRayVolumeRayCastMapper::SafeDownCast(this->VolumeMapper);
-  this->Actor->SetMapper(this->VolumeMapper);
-  this->Actor->SetVisibility(colorArrayName != NULL && colorArrayName[0] != 0);
-  this->Actor->SetVisibility(1);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os, indent);
-}
-
-
-//***************************************************************************
-// Forwarded to Actor.
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetOrientation(double x, double y, double z)
-{
-  this->Actor->SetOrientation(x, y, z);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetOrigin(double x, double y, double z)
-{
-  this->Actor->SetOrigin(x, y, z);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetPickable(int val)
-{
-  this->Actor->SetPickable(val);
-}
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetPosition(double x , double y, double z)
-{
-  this->Actor->SetPosition(x, y, z);
-}
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetScale(double x, double y, double z)
-{
-  this->Actor->SetScale(x, y, z);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetVisibility(bool val)
-{
-  this->Superclass::SetVisibility(val);
-  this->Actor->SetVisibility(val? 1 : 0);
-}
-
-//***************************************************************************
-// Forwarded to vtkVolumeProperty.
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetInterpolationType(int val)
-{
-  this->Property->SetInterpolationType(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetColor(vtkColorTransferFunction* lut)
-{
-  this->Property->SetColor(lut);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetScalarOpacity(vtkPiecewiseFunction* pwf)
-{
-  this->Property->SetScalarOpacity(pwf);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetScalarOpacity2(vtkPiecewiseFunction* pwf)
-{
-  this->Property->SetScalarOpacity(pwf);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetScalarOpacityUnitDistance(double val)
-{
-  this->Property->SetScalarOpacityUnitDistance(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetAmbient(double val)
-{
-  this->Property->SetAmbient(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetDiffuse(double val)
-{
-  this->Property->SetDiffuse(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetSpecular(double val)
-{
-  this->Property->SetSpecular(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetSpecularPower(double val)
-{
-  this->Property->SetSpecularPower(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetShade(bool val)
-{
-  this->Property->SetShade(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetIndependantComponents(bool val)
-{
-  this->Property->SetIndependentComponents(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetRequestedRenderMode(int mode)
-{
-}
-
-void vtkPVOSPRayImageVolumeRepresentation::SetSamplingRate(double sr)
-{
-  SamplingRate=sr;
-  vtkOSPRayVolumeRayCastMapper* ospMapper = vtkOSPRayVolumeRayCastMapper::SafeDownCast(this->VolumeMapper);
-  ospMapper->SetSamplingRate(sr);
-}
\ No newline at end of file
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayImageVolumeRepresentation.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayImageVolumeRepresentation.h
deleted file mode 100755
index 5a50a57643..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayImageVolumeRepresentation.h
+++ /dev/null
@@ -1,191 +0,0 @@
-/*=========================================================================
-
-  Program:   ParaView
-  Module:    vtkPVOSPRayImageVolumeRepresentation.h
-
-  Copyright (c) Kitware, Inc.
-  All rights reserved.
-  See Copyright.txt or http://www.paraview.org/HTML/Copyright.html for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-// .NAME vtkPVOSPRayImageVolumeRepresentation - representation for showing image
-// datasets as a volume.
-// .SECTION Description
-// vtkPVOSPRayImageVolumeRepresentation is a representation for volume rendering
-// vtkImageData. Unlike other data-representations used by ParaView, this
-// representation does not support delivery to client (or render server) nodes.
-// In those configurations, it merely delivers a outline for the image to the
-// client and render-server and those nodes simply render the outline.
-
-#ifndef __vtkPVOSPRayImageVolumeRepresentation_h
-#define __vtkPVOSPRayImageVolumeRepresentation_h
-
-#include "vtkPVClientServerCoreRenderingModule.h" //needed for exports
-
-#include "vtkGeometryRepresentationWithFaces.h"
-#include "vtkPVDataRepresentation.h"
-
-class vtkColorTransferFunction;
-class vtkFixedPointVolumeRayCastMapper;
-class vtkImageData;
-class vtkOutlineSource;
-class vtkPiecewiseFunction;
-class vtkPolyDataMapper;
-class vtkPVCacheKeeper;
-class vtkPVLODVolume;
-class vtkAbstractVolumeMapper;
-class vtkSmartVolumeMapper;
-class vtkVolumeProperty;
-class vtkOSPRayPVLODVolume;
-
-
-class VTKPVCLIENTSERVERCORERENDERING_EXPORT vtkPVOSPRayImageVolumeRepresentation : public 
-vtkPVDataRepresentation
-{
-public:
-  static vtkPVOSPRayImageVolumeRepresentation* New();
-  vtkTypeMacro(vtkPVOSPRayImageVolumeRepresentation, vtkPVDataRepresentation);
-  void PrintSelf(ostream& os, vtkIndent indent);
-
-  // This is same a vtkDataObject::FieldAssociation types so you can use those
-  // as well.
-  enum AttributeTypes
-    {
-    POINT_DATA=0,
-    CELL_DATA=1
-    };
-
-  // Description:
-  // Methods to control scalar coloring. ColorAttributeType defines the
-  // attribute type.
-  vtkSetMacro(ColorAttributeType, int);
-  vtkGetMacro(ColorAttributeType, int);
-
-  // Description:
-  // Pick the array to color with.
-  vtkSetStringMacro(ColorArrayName);
-  vtkGetStringMacro(ColorArrayName);
-
-  virtual void SetRepresentation(const char*) {}
-
-  // Description:
-  // vtkAlgorithm::ProcessRequest() equivalent for rendering passes. This is
-  // typically called by the vtkView to request meta-data from the
-  // representations or ask them to perform certain tasks e.g.
-  // PrepareForRendering.
-  virtual int ProcessViewRequest(vtkInformationRequestKey* request_type,
-    vtkInformation* inInfo, vtkInformation* outInfo);
-
-  // Description:
-  // This needs to be called on all instances of vtkGeometryRepresentation when
-  // the input is modified. This is essential since the geometry filter does not
-  // have any real-input on the client side which messes with the Update
-  // requests.
-  virtual void MarkModified();
-
-  // Description:
-  // Get/Set the visibility for this representation. When the visibility of
-  // representation of false, all view passes are ignored.
-  virtual void SetVisibility(bool val);
-
-  //***************************************************************************
-  // Forwarded to Actor.
-  void SetOrientation(double, double, double);
-  void SetOrigin(double, double, double);
-  void SetPickable(int val);
-  void SetPosition(double, double, double);
-  void SetScale(double, double, double);
-
-  //***************************************************************************
-  // Forwarded to vtkVolumeProperty.
-  void SetInterpolationType(int val);
-  void SetColor(vtkColorTransferFunction* lut);
-  void SetScalarOpacity(vtkPiecewiseFunction* pwf);
-  void SetScalarOpacity2(vtkPiecewiseFunction* pwf);
-  void SetScalarOpacityUnitDistance(double val);
-  void SetAmbient(double);
-  void SetDiffuse(double);
-  void SetSpecular(double);
-  void SetSpecularPower(double);
-  void SetShade(bool);
-  void SetIndependantComponents(bool);
-
-  //***************************************************************************
-  // Forwarded to vtkSmartVolumeMapper.
-  void SetRequestedRenderMode(int);
-
-  // Description:
-  // Provides access to the actor used by this representation.
-  vtkOSPRayPVLODVolume* GetActor() { return this->Actor; }
-
-  // Description:
-  // Helper method to pass input image extent information to the view to use in
-  // determining the cuts for ordered compositing.
-  static void PassOrderedCompositingInformation(
-    vtkPVDataRepresentation* self, vtkInformation* inInfo);
-
-
-  //OSPRay specific values
-  void SetSamplingRate(double sr);
-  vtkGetMacro(SamplingRate,double);
-
-//BTX
-protected:
-  vtkPVOSPRayImageVolumeRepresentation();
-  ~vtkPVOSPRayImageVolumeRepresentation();
-
-  // Description:
-  // Fill input port information.
-  virtual int FillInputPortInformation(int port, vtkInformation* info);
-
-  // Description:
-  virtual int RequestData(vtkInformation*,
-    vtkInformationVector**, vtkInformationVector*);
-
-  // Description:
-  // Adds the representation to the view.  This is called from
-  // vtkView::AddRepresentation().  Subclasses should override this method.
-  // Returns true if the addition succeeds.
-  virtual bool AddToView(vtkView* view);
-
-  // Description:
-  // Removes the representation to the view.  This is called from
-  // vtkView::RemoveRepresentation().  Subclasses should override this method.
-  // Returns true if the removal succeeds.
-  virtual bool RemoveFromView(vtkView* view);
-
-  // Description:
-  // Overridden to check with the vtkPVCacheKeeper to see if the key is cached.
-  virtual bool IsCached(double cache_key);
-
-  // Description:
-  // Passes on parameters to the active volume mapper
-  virtual void UpdateMapperParameters();
-
-  vtkImageData* Cache;
-  vtkPVCacheKeeper* CacheKeeper;
-  vtkAbstractVolumeMapper* VolumeMapper;
-  vtkVolumeProperty* Property;
-  vtkOSPRayPVLODVolume* Actor;
-
-  vtkOutlineSource* OutlineSource;
-  vtkPolyDataMapper* OutlineMapper;;
-
-  int ColorAttributeType;
-  char* ColorArrayName;
-  unsigned long DataSize;
-  double DataBounds[6];
-  double SamplingRate;
-
-private:
-  vtkPVOSPRayImageVolumeRepresentation(const vtkPVOSPRayImageVolumeRepresentation&); // Not implemented
-  void operator=(const vtkPVOSPRayImageVolumeRepresentation&); // Not implemented
-
-//ETX
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayOutlineRepresentation.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayOutlineRepresentation.cxx
deleted file mode 100755
index 7d05839498..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayOutlineRepresentation.cxx
+++ /dev/null
@@ -1,69 +0,0 @@
-/* ======================================================================================= 
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  
-   All rights reserved.
-                                                                                           
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     
-   except in compliance with the License.                                                  
-   A copy of the License is included with this software in the file LICENSE.               
-   If your copy does not contain the License, you may obtain a copy of the License at:     
-                                                                                           
-       http://opensource.org/licenses/BSD-3-Clause                                         
-                                                                                           
-   Unless required by applicable law or agreed to in writing, software distributed under   
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
-   KIND, either express or implied.                                                        
-   See the License for the specific language governing permissions and limitations under   
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "vtkPVOSPRayOutlineRepresentation.h"
-
-#include "vtkCompositePolyDataMapper2.h"
-#include "vtkInformation.h"
-#include "vtkOSPRayCompositeMapper.h"
-#include "vtkOSPRayLODActor.h"
-#include "vtkOSPRayPolyDataMapper.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkObjectFactory.h"
-
-#include "vtkOutlineRepresentation.h"
-
-#include "vtkObjectFactory.h"
-#include "vtkPVGeometryFilter.h"
-
-//-----------------------------------------------------------------------------
-vtkStandardNewMacro(vtkPVOSPRayOutlineRepresentation);
-
-
-//-----------------------------------------------------------------------------
-vtkPVOSPRayOutlineRepresentation::vtkPVOSPRayOutlineRepresentation()
-: vtkPVOSPRayRepresentation()
-{
-
-    this->SetUseOutline(1);
-
-
-  this->SetAmbient(1);
-  this->SetDiffuse(0);
-  this->SetSpecular(0);
-
-  // you cannot select the outline!
-  this->SetPickable(0);
-
-  this->SetSuppressLOD(1);
-  this->SetRepresentation(WIREFRAME);
-}
-
-//-----------------------------------------------------------------------------
-vtkPVOSPRayOutlineRepresentation::~vtkPVOSPRayOutlineRepresentation()
-{
-}
-
-//-----------------------------------------------------------------------------
-void vtkPVOSPRayOutlineRepresentation::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os, indent);
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayOutlineRepresentation.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayOutlineRepresentation.h
deleted file mode 100755
index 4c42cbd1a9..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayOutlineRepresentation.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/* ======================================================================================= 
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  
-   All rights reserved.
-                                                                                           
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     
-   except in compliance with the License.                                                  
-   A copy of the License is included with this software in the file LICENSE.               
-   If your copy does not contain the License, you may obtain a copy of the License at:     
-                                                                                           
-       http://opensource.org/licenses/BSD-3-Clause                                         
-                                                                                           
-   Unless required by applicable law or agreed to in writing, software distributed under   
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
-   KIND, either express or implied.                                                        
-   See the License for the specific language governing permissions and limitations under   
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkPVOSPRayOutlineRepresentation - representation for OSPRay views
-// .SECTION Description
-// This replaces the GL mapper, actor and property for a display pipline
-// with the OSPRay versions of those so that the object can be drawn
-// in an OSPRay renderer within a pvOSPRay view
-
-#ifndef __vtkPVOSPRayOutlineRepresentation_h
-#define __vtkPVOSPRayOutlineRepresentation_h
-
-#include "vtkPVOSPRayRepresentation.h"
-#include "vtkGeometryRepresentationWithFaces.h"
-#include "vtkOSPRayModule.h"
-
-class VTKOSPRAY_EXPORT vtkPVOSPRayOutlineRepresentation :
-  public vtkPVOSPRayRepresentation
-{
-public:
-  static vtkPVOSPRayOutlineRepresentation* New();
-  vtkTypeMacro(vtkPVOSPRayOutlineRepresentation, vtkPVOSPRayRepresentation);
-  void PrintSelf(ostream& os, vtkIndent indent);
-
-  virtual void SetRepresentation(const char*)
-    { this->Superclass::SetRepresentation("Wireframe"); }
-  virtual void SetUseOutline(int)
-    { this->Superclass::SetUseOutline(1); }
-  virtual void SetSuppressLOD(bool)
-    { this->Superclass::SetSuppressLOD(true); }
-  virtual void SetPickable(int)
-    { this->Superclass::SetPickable(0); }
-
-
-//BTX
-protected:
-  vtkPVOSPRayOutlineRepresentation();
-  ~vtkPVOSPRayOutlineRepresentation();
-
-    virtual void SetRepresentation(int)
-    { this->Superclass::SetRepresentation(WIREFRAME); }
-
-private:
-
-  vtkPVOSPRayOutlineRepresentation(const vtkPVOSPRayOutlineRepresentation&); // Not implemented.
-  void operator=(const vtkPVOSPRayOutlineRepresentation&); // Not implemented.
-
-//ETX
-};
-
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayRepresentation.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayRepresentation.cxx
deleted file mode 100755
index abfbe6a117..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayRepresentation.cxx
+++ /dev/null
@@ -1,156 +0,0 @@
-/* ======================================================================================= 
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  
-   All rights reserved.
-                                                                                           
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     
-   except in compliance with the License.                                                  
-   A copy of the License is included with this software in the file LICENSE.               
-   If your copy does not contain the License, you may obtain a copy of the License at:     
-                                                                                           
-       http://opensource.org/licenses/BSD-3-Clause                                         
-                                                                                           
-   Unless required by applicable law or agreed to in writing, software distributed under   
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
-   KIND, either express or implied.                                                        
-   See the License for the specific language governing permissions and limitations under   
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "vtkPVOSPRayRepresentation.h"
-
-#include "vtkCompositePolyDataMapper2.h"
-#include "vtkInformation.h"
-#include "vtkOSPRayCompositeMapper.h"
-#include "vtkOSPRayLODActor.h"
-#include "vtkOSPRayPolyDataMapper.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkOSPRayManager.h"
-#include "vtkObjectFactory.h"
-
-//-----------------------------------------------------------------------------
-vtkStandardNewMacro(vtkPVOSPRayRepresentation);
-
-
-//-----------------------------------------------------------------------------
-vtkPVOSPRayRepresentation::vtkPVOSPRayRepresentation()
-{
-  vtkOSPRayManager::Singleton();
-  this->Mapper->Delete();
-  this->Mapper = vtkOSPRayCompositeMapper::New();
-  this->LODMapper->Delete();
-  this->LODMapper = vtkOSPRayCompositeMapper::New();
-
-  this->Actor->Delete();
-  this->Actor = vtkOSPRayLODActor::New();
-  this->Property->Delete();
-  this->Property = vtkOSPRayProperty::New();
-
-  this->Actor->SetMapper(this->Mapper);
-  this->Actor->SetLODMapper(this->LODMapper);
-  this->Actor->SetProperty(this->Property);
-
-  vtkInformation* keys = vtkInformation::New();
-  this->Actor->SetPropertyKeys(keys);
-  keys->Delete();
-
-  this->SetSuppressLOD(true);
-  this->SuppressLOD = true;
-}
-
-//-----------------------------------------------------------------------------
-vtkPVOSPRayRepresentation::~vtkPVOSPRayRepresentation()
-{
-}
-
-//-----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os, indent);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::SetMaterialType(char *newval)
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  OSPRayProperty->SetMaterialType(newval);
-}
-
-//----------------------------------------------------------------------------
-char * vtkPVOSPRayRepresentation::GetMaterialType()
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  return OSPRayProperty->GetMaterialType();
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::SetReflectance(double newval)
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  OSPRayProperty->SetReflectance(newval);
-}
-
-//----------------------------------------------------------------------------
-double vtkPVOSPRayRepresentation::GetReflectance()
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  return OSPRayProperty->GetReflectance();
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::SetThickness(double newval)
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  OSPRayProperty->SetThickness(newval);
-}
-
-//----------------------------------------------------------------------------
-double vtkPVOSPRayRepresentation::GetThickness()
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  return OSPRayProperty->GetThickness();
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::SetEta(double newval)
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  OSPRayProperty->SetEta(newval);
-}
-
-//----------------------------------------------------------------------------
-double vtkPVOSPRayRepresentation::GetEta()
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  return OSPRayProperty->GetEta();
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::SetN(double newval)
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  OSPRayProperty->SetN(newval);
-}
-
-//----------------------------------------------------------------------------
-double vtkPVOSPRayRepresentation::GetN()
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  return OSPRayProperty->GetN();
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::SetNt(double newval)
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  OSPRayProperty->SetNt(newval);
-}
-
-//----------------------------------------------------------------------------
-double vtkPVOSPRayRepresentation::GetNt()
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  return OSPRayProperty->GetNt();
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayRepresentation.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayRepresentation.h
deleted file mode 100755
index b16a3a0072..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayRepresentation.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/* ======================================================================================= 
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  
-   All rights reserved.
-                                                                                           
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     
-   except in compliance with the License.                                                  
-   A copy of the License is included with this software in the file LICENSE.               
-   If your copy does not contain the License, you may obtain a copy of the License at:     
-                                                                                           
-       http://opensource.org/licenses/BSD-3-Clause                                         
-                                                                                           
-   Unless required by applicable law or agreed to in writing, software distributed under   
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
-   KIND, either express or implied.                                                        
-   See the License for the specific language governing permissions and limitations under   
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkPVOSPRayRepresentation - representation for OSPRay views
-// .SECTION Description
-// This replaces the GL mapper, actor and property for a display pipline
-// with the OSPRay versions of those so that the object can be drawn
-// in an OSPRay renderer within a pvOSPRay view
-
-#ifndef __vtkPVOSPRayRepresentation_h
-#define __vtkPVOSPRayRepresentation_h
-
-#include "vtkGeometryRepresentationWithFaces.h"
-#include "vtkOSPRayModule.h"
-
-class VTKOSPRAY_EXPORT vtkPVOSPRayRepresentation :
-  public vtkGeometryRepresentationWithFaces
-{
-public:
-  static vtkPVOSPRayRepresentation* New();
-  vtkTypeMacro(vtkPVOSPRayRepresentation, vtkGeometryRepresentationWithFaces);
-  void PrintSelf(ostream& os, vtkIndent indent);
-
-  // Description:
-  // control that ray traced rendering characteristics of this object
-  void SetMaterialType(char *);
-  char *GetMaterialType();
-  void SetReflectance(double );
-  double GetReflectance();
-  void SetThickness(double );
-  double GetThickness();
-  void SetEta(double);
-  double GetEta();
-  void SetN(double);
-  double GetN();
-  void SetNt(double);
-  double GetNt();
-  void SetOSPSuppressLOD(bool st) { this->SuppressLOD = st; }
-  bool GetOSPSuppressLOD() { return this->SuppressLOD; }
-
-
-//BTX
-protected:
-  vtkPVOSPRayRepresentation();
-  ~vtkPVOSPRayRepresentation();
-
-private:
-
-  vtkPVOSPRayRepresentation(const vtkPVOSPRayRepresentation&); // Not implemented.
-  void operator=(const vtkPVOSPRayRepresentation&); // Not implemented.
-
-//ETX
-};
-
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRayModule.h b/avt/Plotter/OSPRay/vtkOSPRayModule.h
deleted file mode 100644
index b1b3a97dc0..0000000000
--- a/avt/Plotter/OSPRay/vtkOSPRayModule.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#ifndef VTKOSPRAYMODULE_H
-#define VTKOSPRAYMODULE_H
-
-#define VTKOSPRAY_EXPORT 
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#endif
diff --git a/avt/Plotter/vtk/InitVTKRendering.C b/avt/Plotter/vtk/InitVTKRendering.C
index f99371412f..2d3927c953 100644
--- a/avt/Plotter/vtk/InitVTKRendering.C
+++ b/avt/Plotter/vtk/InitVTKRendering.C
@@ -188,6 +188,9 @@ vtkVisItGraphicsFactory::vtkVisItGraphicsFactory()
 //    Carson Brownlee, Sun May  6 16:25:28 PDT 2012
 //    Add support for Manta.
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Remove the old VISIT_OSPRAY configurations because they are too old. 
+//
 // ****************************************************************************
 
 void
diff --git a/avt/VisWindow/CMakeLists.txt b/avt/VisWindow/CMakeLists.txt
index 0065e9ce15..cdcd528281 100644
--- a/avt/VisWindow/CMakeLists.txt
+++ b/avt/VisWindow/CMakeLists.txt
@@ -183,11 +183,17 @@ LINK_DIRECTORIES(${LIBRARY_OUTPUT_DIRECTORY} ${EAVL_LIBRARY_DIR} )
 #********************************* SERIAL ************************************
 ADD_LIBRARY(avtviswindow_ser ${AVTVISWINDOW_SOURCES})
 TARGET_LINK_LIBRARIES(avtviswindow_ser visitcommon avtview avtmath avtplotter_ser visit_vtk lightweight_visit_vtk vtkFiltersModeling vtkImagingCore vtkInteractionStyle ${OBJC_LIBS})
+IF(VISIT_OSPRAY)
+    TARGET_LINK_LIBRARIES(avtviswindow_ser vtkRenderingOSPRay)
+ENDIF(VISIT_OSPRAY)
 VISIT_INSTALL_TARGETS(avtviswindow_ser)
 
 #********************************* PARALLEL **********************************
 IF(VISIT_PARALLEL)
     ADD_PARALLEL_LIBRARY(avtviswindow_par ${AVTVISWINDOW_SOURCES})
     TARGET_LINK_LIBRARIES(avtviswindow_par visitcommon avtview avtmath avtplotter_par visit_vtk lightweight_visit_vtk vtkFiltersModeling vtkImagingCore vtkInteractionStyle ${OBJC_LIBS})
+    IF(VISIT_OSPRAY)
+        TARGET_LINK_LIBRARIES(avtviswindow_par vtkRenderingOSPRay)
+    ENDIF(VISIT_OSPRAY)
     VISIT_INSTALL_TARGETS(avtviswindow_par)
 ENDIF(VISIT_PARALLEL)
diff --git a/plots/Volume/CMakeLists.txt b/plots/Volume/CMakeLists.txt
index 725a48f704..f4e7e2244f 100644
--- a/plots/Volume/CMakeLists.txt
+++ b/plots/Volume/CMakeLists.txt
@@ -97,6 +97,11 @@ IF(VISIT_SLIVR)
     ADD_DEFINITIONS(-DVISIT_SLIVR)
 ENDIF(VISIT_SLIVR)
 
+IF(VISIT_OSPRAY)
+    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIR})
+    ADD_DEFINITIONS(-DVISIT_OSPRAY)
+ENDIF ()
+
 LINK_DIRECTORIES(${VISIT_LIBRARY_DIR} ${EAVL_LIBRARY_DIR} ${VTKM_LIBRARY_DIR} )
 
 ADD_LIBRARY(IVolumePlot ${LIBI_SOURCES})
@@ -111,6 +116,10 @@ IF(NOT VISIT_SERVER_COMPONENTS_ONLY AND NOT VISIT_ENGINE_ONLY AND NOT VISIT_DBIO
     ADD_LIBRARY(VVolumePlot ${LIBV_SOURCES})
     TARGET_LINK_LIBRARIES(VVolumePlot visitcommon viewer vtkRenderingVolumeOpenGL2 )
 
+    IF(VISIT_OSPRAY)
+      TARGET_LINK_LIBRARIES(VVolumePlot ${OSPRAY_LIBRARIES})
+    ENDIF()
+
     SET(INSTALLTARGETS ${INSTALLTARGETS} GVolumePlot VVolumePlot)
 
     IF(VISIT_PYTHON_SCRIPTING)
@@ -134,12 +143,18 @@ ENDIF(NOT VISIT_SERVER_COMPONENTS_ONLY AND NOT VISIT_ENGINE_ONLY AND NOT VISIT_D
 
 ADD_LIBRARY(EVolumePlot_ser ${LIBE_SOURCES})
 TARGET_LINK_LIBRARIES(EVolumePlot_ser visitcommon avtplotter_ser avtpipeline_ser avtexpressions_ser vtkRenderingVolumeOpenGL2 )
+IF(VISIT_OSPRAY)
+    TARGET_LINK_LIBRARIES(EVolumePlot_ser ${OSPRAY_LIBRARIES})
+ENDIF()
 SET(INSTALLTARGETS ${INSTALLTARGETS} EVolumePlot_ser)
 ADD_TARGET_DEFINITIONS(EVolumePlot_ser ENGINE)
 
 IF(VISIT_PARALLEL)
     ADD_PARALLEL_LIBRARY(EVolumePlot_par ${LIBE_SOURCES})
     TARGET_LINK_LIBRARIES(EVolumePlot_par visitcommon avtplotter_par avtpipeline_par avtexpressions_par vtkRenderingVolumeOpenGL2 )
+    IF(VISIT_OSPRAY)
+        TARGET_LINK_LIBRARIES(EVolumePlot_par ${OSPRAY_LIBRARIES})
+    ENDIF()
     SET(INSTALLTARGETS ${INSTALLTARGETS} EVolumePlot_par)
     ADD_TARGET_DEFINITIONS(EVolumePlot_par ENGINE)
 ENDIF(VISIT_PARALLEL)
diff --git a/plots/Volume/PyVolumeAttributes.C b/plots/Volume/PyVolumeAttributes.C
index 4880d99ad7..3c8a0d74a6 100644
--- a/plots/Volume/PyVolumeAttributes.C
+++ b/plots/Volume/PyVolumeAttributes.C
@@ -78,6 +78,44 @@ PyVolumeAttributes_ToString(const VolumeAttributes *atts, const char *prefix)
     std::string str;
     char tmpStr[1000];
 
+    if(atts->GetOsprayShadowsEnabledFlag())
+        SNPRINTF(tmpStr, 1000, "%sosprayShadowsEnabledFlag = 1\n", prefix);
+    else
+        SNPRINTF(tmpStr, 1000, "%sosprayShadowsEnabledFlag = 0\n", prefix);
+    str += tmpStr;
+    if(atts->GetOsprayUseGridAcceleratorFlag())
+        SNPRINTF(tmpStr, 1000, "%sosprayUseGridAcceleratorFlag = 1\n", prefix);
+    else
+        SNPRINTF(tmpStr, 1000, "%sosprayUseGridAcceleratorFlag = 0\n", prefix);
+    str += tmpStr;
+    if(atts->GetOsprayPreIntegrationFlag())
+        SNPRINTF(tmpStr, 1000, "%sosprayPreIntegrationFlag = 1\n", prefix);
+    else
+        SNPRINTF(tmpStr, 1000, "%sosprayPreIntegrationFlag = 0\n", prefix);
+    str += tmpStr;
+    if(atts->GetOspraySingleShadeFlag())
+        SNPRINTF(tmpStr, 1000, "%sospraySingleShadeFlag = 1\n", prefix);
+    else
+        SNPRINTF(tmpStr, 1000, "%sospraySingleShadeFlag = 0\n", prefix);
+    str += tmpStr;
+    if(atts->GetOsprayOneSidedLightingFlag())
+        SNPRINTF(tmpStr, 1000, "%sosprayOneSidedLightingFlag = 1\n", prefix);
+    else
+        SNPRINTF(tmpStr, 1000, "%sosprayOneSidedLightingFlag = 0\n", prefix);
+    str += tmpStr;
+    if(atts->GetOsprayAoTransparencyEnabledFlag())
+        SNPRINTF(tmpStr, 1000, "%sosprayAoTransparencyEnabledFlag = 1\n", prefix);
+    else
+        SNPRINTF(tmpStr, 1000, "%sosprayAoTransparencyEnabledFlag = 0\n", prefix);
+    str += tmpStr;
+    SNPRINTF(tmpStr, 1000, "%sospraySpp = %d\n", prefix, atts->GetOspraySpp());
+    str += tmpStr;
+    SNPRINTF(tmpStr, 1000, "%sosprayAoSamples = %d\n", prefix, atts->GetOsprayAoSamples());
+    str += tmpStr;
+    SNPRINTF(tmpStr, 1000, "%sosprayAoDistance = %g\n", prefix, atts->GetOsprayAoDistance());
+    str += tmpStr;
+    SNPRINTF(tmpStr, 1000, "%sosprayMinContribution = %g\n", prefix, atts->GetOsprayMinContribution());
+    str += tmpStr;
     if(atts->GetLegendFlag())
         SNPRINTF(tmpStr, 1000, "%slegendFlag = 1\n", prefix);
     else
@@ -181,7 +219,7 @@ PyVolumeAttributes_ToString(const VolumeAttributes *atts, const char *prefix)
     str += tmpStr;
     SNPRINTF(tmpStr, 1000, "%ssamplesPerRay = %d\n", prefix, atts->GetSamplesPerRay());
     str += tmpStr;
-    const char *rendererType_names = "Default, RayCasting, RayCastingIntegration, RayCastingSLIVR";
+    const char *rendererType_names = "Default, RayCasting, RayCastingIntegration, RayCastingSLIVR, RayCastingOSPRay";
     switch (atts->GetRendererType())
     {
       case VolumeAttributes::Default:
@@ -200,6 +238,10 @@ PyVolumeAttributes_ToString(const VolumeAttributes *atts, const char *prefix)
           SNPRINTF(tmpStr, 1000, "%srendererType = %sRayCastingSLIVR  # %s\n", prefix, prefix, rendererType_names);
           str += tmpStr;
           break;
+      case VolumeAttributes::RayCastingOSPRay:
+          SNPRINTF(tmpStr, 1000, "%srendererType = %sRayCastingOSPRay  # %s\n", prefix, prefix, rendererType_names);
+          str += tmpStr;
+          break;
       default:
           break;
     }
@@ -352,6 +394,246 @@ VolumeAttributes_Notify(PyObject *self, PyObject *args)
 }
 
 /*static*/ PyObject *
+VolumeAttributes_SetOsprayShadowsEnabledFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the osprayShadowsEnabledFlag in the object.
+    obj->data->SetOsprayShadowsEnabledFlag(ival != 0);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayShadowsEnabledFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(obj->data->GetOsprayShadowsEnabledFlag()?1L:0L);
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayUseGridAcceleratorFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the osprayUseGridAcceleratorFlag in the object.
+    obj->data->SetOsprayUseGridAcceleratorFlag(ival != 0);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayUseGridAcceleratorFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(obj->data->GetOsprayUseGridAcceleratorFlag()?1L:0L);
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayPreIntegrationFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the osprayPreIntegrationFlag in the object.
+    obj->data->SetOsprayPreIntegrationFlag(ival != 0);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayPreIntegrationFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(obj->data->GetOsprayPreIntegrationFlag()?1L:0L);
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOspraySingleShadeFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the ospraySingleShadeFlag in the object.
+    obj->data->SetOspraySingleShadeFlag(ival != 0);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOspraySingleShadeFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(obj->data->GetOspraySingleShadeFlag()?1L:0L);
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayOneSidedLightingFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the osprayOneSidedLightingFlag in the object.
+    obj->data->SetOsprayOneSidedLightingFlag(ival != 0);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayOneSidedLightingFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(obj->data->GetOsprayOneSidedLightingFlag()?1L:0L);
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayAoTransparencyEnabledFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the osprayAoTransparencyEnabledFlag in the object.
+    obj->data->SetOsprayAoTransparencyEnabledFlag(ival != 0);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayAoTransparencyEnabledFlag(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(obj->data->GetOsprayAoTransparencyEnabledFlag()?1L:0L);
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOspraySpp(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the ospraySpp in the object.
+    obj->data->SetOspraySpp((int)ival);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOspraySpp(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(long(obj->data->GetOspraySpp()));
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayAoSamples(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    int ival;
+    if(!PyArg_ParseTuple(args, "i", &ival))
+        return NULL;
+
+    // Set the osprayAoSamples in the object.
+    obj->data->SetOsprayAoSamples((int)ival);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayAoSamples(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyInt_FromLong(long(obj->data->GetOsprayAoSamples()));
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayAoDistance(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    double dval;
+    if(!PyArg_ParseTuple(args, "d", &dval))
+        return NULL;
+
+    // Set the osprayAoDistance in the object.
+    obj->data->SetOsprayAoDistance(dval);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayAoDistance(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyFloat_FromDouble(obj->data->GetOsprayAoDistance());
+    return retval;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_SetOsprayMinContribution(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+
+    double dval;
+    if(!PyArg_ParseTuple(args, "d", &dval))
+        return NULL;
+
+    // Set the osprayMinContribution in the object.
+    obj->data->SetOsprayMinContribution(dval);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/*static*/ PyObject *
+VolumeAttributes_GetOsprayMinContribution(PyObject *self, PyObject *args)
+{
+    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
+    PyObject *retval = PyFloat_FromDouble(obj->data->GetOsprayMinContribution());
+    return retval;
+}
+
+/*static*/ PyObject *
 VolumeAttributes_SetLegendFlag(PyObject *self, PyObject *args)
 {
     VolumeAttributesObject *obj = (VolumeAttributesObject *)self;
@@ -957,14 +1239,15 @@ VolumeAttributes_SetRendererType(PyObject *self, PyObject *args)
         return NULL;
 
     // Set the rendererType in the object.
-    if(ival >= 0 && ival < 4)
+    if(ival >= 0 && ival < 5)
         obj->data->SetRendererType(VolumeAttributes::Renderer(ival));
     else
     {
         fprintf(stderr, "An invalid rendererType value was given. "
-                        "Valid values are in the range of [0,3]. "
+                        "Valid values are in the range of [0,4]. "
                         "You can also use the following names: "
-                        "Default, RayCasting, RayCastingIntegration, RayCastingSLIVR.");
+                        "Default, RayCasting, RayCastingIntegration, RayCastingSLIVR, RayCastingOSPRay"
+                        ".");
         return NULL;
     }
 
@@ -1301,6 +1584,26 @@ VolumeAttributes_GetMaterialProperties(PyObject *self, PyObject *args)
 
 PyMethodDef PyVolumeAttributes_methods[VOLUMEATTRIBUTES_NMETH] = {
     {"Notify", VolumeAttributes_Notify, METH_VARARGS},
+    {"SetOsprayShadowsEnabledFlag", VolumeAttributes_SetOsprayShadowsEnabledFlag, METH_VARARGS},
+    {"GetOsprayShadowsEnabledFlag", VolumeAttributes_GetOsprayShadowsEnabledFlag, METH_VARARGS},
+    {"SetOsprayUseGridAcceleratorFlag", VolumeAttributes_SetOsprayUseGridAcceleratorFlag, METH_VARARGS},
+    {"GetOsprayUseGridAcceleratorFlag", VolumeAttributes_GetOsprayUseGridAcceleratorFlag, METH_VARARGS},
+    {"SetOsprayPreIntegrationFlag", VolumeAttributes_SetOsprayPreIntegrationFlag, METH_VARARGS},
+    {"GetOsprayPreIntegrationFlag", VolumeAttributes_GetOsprayPreIntegrationFlag, METH_VARARGS},
+    {"SetOspraySingleShadeFlag", VolumeAttributes_SetOspraySingleShadeFlag, METH_VARARGS},
+    {"GetOspraySingleShadeFlag", VolumeAttributes_GetOspraySingleShadeFlag, METH_VARARGS},
+    {"SetOsprayOneSidedLightingFlag", VolumeAttributes_SetOsprayOneSidedLightingFlag, METH_VARARGS},
+    {"GetOsprayOneSidedLightingFlag", VolumeAttributes_GetOsprayOneSidedLightingFlag, METH_VARARGS},
+    {"SetOsprayAoTransparencyEnabledFlag", VolumeAttributes_SetOsprayAoTransparencyEnabledFlag, METH_VARARGS},
+    {"GetOsprayAoTransparencyEnabledFlag", VolumeAttributes_GetOsprayAoTransparencyEnabledFlag, METH_VARARGS},
+    {"SetOspraySpp", VolumeAttributes_SetOspraySpp, METH_VARARGS},
+    {"GetOspraySpp", VolumeAttributes_GetOspraySpp, METH_VARARGS},
+    {"SetOsprayAoSamples", VolumeAttributes_SetOsprayAoSamples, METH_VARARGS},
+    {"GetOsprayAoSamples", VolumeAttributes_GetOsprayAoSamples, METH_VARARGS},
+    {"SetOsprayAoDistance", VolumeAttributes_SetOsprayAoDistance, METH_VARARGS},
+    {"GetOsprayAoDistance", VolumeAttributes_GetOsprayAoDistance, METH_VARARGS},
+    {"SetOsprayMinContribution", VolumeAttributes_SetOsprayMinContribution, METH_VARARGS},
+    {"GetOsprayMinContribution", VolumeAttributes_GetOsprayMinContribution, METH_VARARGS},
     {"SetLegendFlag", VolumeAttributes_SetLegendFlag, METH_VARARGS},
     {"GetLegendFlag", VolumeAttributes_GetLegendFlag, METH_VARARGS},
     {"SetLightingFlag", VolumeAttributes_SetLightingFlag, METH_VARARGS},
@@ -1393,6 +1696,26 @@ VolumeAttributes_compare(PyObject *v, PyObject *w)
 PyObject *
 PyVolumeAttributes_getattr(PyObject *self, char *name)
 {
+    if(strcmp(name, "osprayShadowsEnabledFlag") == 0)
+        return VolumeAttributes_GetOsprayShadowsEnabledFlag(self, NULL);
+    if(strcmp(name, "osprayUseGridAcceleratorFlag") == 0)
+        return VolumeAttributes_GetOsprayUseGridAcceleratorFlag(self, NULL);
+    if(strcmp(name, "osprayPreIntegrationFlag") == 0)
+        return VolumeAttributes_GetOsprayPreIntegrationFlag(self, NULL);
+    if(strcmp(name, "ospraySingleShadeFlag") == 0)
+        return VolumeAttributes_GetOspraySingleShadeFlag(self, NULL);
+    if(strcmp(name, "osprayOneSidedLightingFlag") == 0)
+        return VolumeAttributes_GetOsprayOneSidedLightingFlag(self, NULL);
+    if(strcmp(name, "osprayAoTransparencyEnabledFlag") == 0)
+        return VolumeAttributes_GetOsprayAoTransparencyEnabledFlag(self, NULL);
+    if(strcmp(name, "ospraySpp") == 0)
+        return VolumeAttributes_GetOspraySpp(self, NULL);
+    if(strcmp(name, "osprayAoSamples") == 0)
+        return VolumeAttributes_GetOsprayAoSamples(self, NULL);
+    if(strcmp(name, "osprayAoDistance") == 0)
+        return VolumeAttributes_GetOsprayAoDistance(self, NULL);
+    if(strcmp(name, "osprayMinContribution") == 0)
+        return VolumeAttributes_GetOsprayMinContribution(self, NULL);
     if(strcmp(name, "legendFlag") == 0)
         return VolumeAttributes_GetLegendFlag(self, NULL);
     if(strcmp(name, "lightingFlag") == 0)
@@ -1452,6 +1775,8 @@ PyVolumeAttributes_getattr(PyObject *self, char *name)
         return PyInt_FromLong(long(VolumeAttributes::RayCastingIntegration));
     if(strcmp(name, "RayCastingSLIVR") == 0)
         return PyInt_FromLong(long(VolumeAttributes::RayCastingSLIVR));
+    if(strcmp(name, "RayCastingOSPRay") == 0)
+        return PyInt_FromLong(long(VolumeAttributes::RayCastingOSPRay));
 
     if(strcmp(name, "gradientType") == 0)
         return VolumeAttributes_GetGradientType(self, NULL);
@@ -1528,7 +1853,27 @@ PyVolumeAttributes_setattr(PyObject *self, char *name, PyObject *args)
     Py_INCREF(args);
     PyObject *obj = NULL;
 
-    if(strcmp(name, "legendFlag") == 0)
+    if(strcmp(name, "osprayShadowsEnabledFlag") == 0)
+        obj = VolumeAttributes_SetOsprayShadowsEnabledFlag(self, tuple);
+    else if(strcmp(name, "osprayUseGridAcceleratorFlag") == 0)
+        obj = VolumeAttributes_SetOsprayUseGridAcceleratorFlag(self, tuple);
+    else if(strcmp(name, "osprayPreIntegrationFlag") == 0)
+        obj = VolumeAttributes_SetOsprayPreIntegrationFlag(self, tuple);
+    else if(strcmp(name, "ospraySingleShadeFlag") == 0)
+        obj = VolumeAttributes_SetOspraySingleShadeFlag(self, tuple);
+    else if(strcmp(name, "osprayOneSidedLightingFlag") == 0)
+        obj = VolumeAttributes_SetOsprayOneSidedLightingFlag(self, tuple);
+    else if(strcmp(name, "osprayAoTransparencyEnabledFlag") == 0)
+        obj = VolumeAttributes_SetOsprayAoTransparencyEnabledFlag(self, tuple);
+    else if(strcmp(name, "ospraySpp") == 0)
+        obj = VolumeAttributes_SetOspraySpp(self, tuple);
+    else if(strcmp(name, "osprayAoSamples") == 0)
+        obj = VolumeAttributes_SetOsprayAoSamples(self, tuple);
+    else if(strcmp(name, "osprayAoDistance") == 0)
+        obj = VolumeAttributes_SetOsprayAoDistance(self, tuple);
+    else if(strcmp(name, "osprayMinContribution") == 0)
+        obj = VolumeAttributes_SetOsprayMinContribution(self, tuple);
+    else if(strcmp(name, "legendFlag") == 0)
         obj = VolumeAttributes_SetLegendFlag(self, tuple);
     else if(strcmp(name, "lightingFlag") == 0)
         obj = VolumeAttributes_SetLightingFlag(self, tuple);
diff --git a/plots/Volume/PyVolumeAttributes.h b/plots/Volume/PyVolumeAttributes.h
index a64c8d3a97..f7c940855c 100644
--- a/plots/Volume/PyVolumeAttributes.h
+++ b/plots/Volume/PyVolumeAttributes.h
@@ -44,7 +44,7 @@
 //
 // Functions exposed to the VisIt module.
 //
-#define VOLUMEATTRIBUTES_NMETH 66
+#define VOLUMEATTRIBUTES_NMETH 86
 void           PyVolumeAttributes_StartUp(VolumeAttributes *subj, void *data);
 void           PyVolumeAttributes_CloseDown();
 PyMethodDef *  PyVolumeAttributes_GetMethodTable(int *nMethods);
diff --git a/plots/Volume/QvisVolumePlotWindow.C b/plots/Volume/QvisVolumePlotWindow.C
index 077c86d290..d4fe5a9f55 100644
--- a/plots/Volume/QvisVolumePlotWindow.C
+++ b/plots/Volume/QvisVolumePlotWindow.C
@@ -926,7 +926,6 @@ QvisVolumePlotWindow::CreateOpacityGroup(QWidget *parent, QVBoxLayout *pLayout,
 //   Removed tuvok.
 //
 // ****************************************************************************
-
 void QvisVolumePlotWindow::CreateSamplingGroups(QWidget *parent, QLayout *pLayout)
 {
     //resample group
@@ -968,6 +967,9 @@ void QvisVolumePlotWindow::CreateSamplingGroups(QWidget *parent, QLayout *pLayou
         pLayout->addWidget(defaultGroup);
     }
 
+    //ospray group
+    CreateOSPRayGroups(parent, pLayout);
+	
     //raycasting group
     {
         raycastingGroup = new QGroupBox(parent);
@@ -1057,17 +1059,19 @@ void QvisVolumePlotWindow::EnableDefaultGroup()
 void QvisVolumePlotWindow::UpdateSamplingGroup()
 {
     //hide all groups
+    osprayGroup->setVisible(false);
     resampleGroup->setVisible(false);
     defaultGroup->setVisible(false);
     raycastingGroup->setVisible(false);
-
+    methodsGroup->setVisible(true);
+	
     tfTabs->setTabEnabled(1, true);
 
     //lighting and material properties group, enabled for all but RayCastingIntegration
     lightMaterialPropGroup->setEnabled(true);
     lightingToggle->setEnabled(true);
 
-    //disable material properties (only enabled with lighting for SLIVR, RayCasting w/ Trilinear Sampling)
+    //disable material properties (only enabled with lighting for RayCasting w/ Trilinear Sampling)
     materialProperties->setEnabled(false);
 
     //enable/disable resampleTarget
@@ -1125,7 +1129,7 @@ void QvisVolumePlotWindow::UpdateSamplingGroup()
     case VolumeAttributes::RayCastingSLIVR:
         raycastingGroup->setVisible(true);
         UpdateLowGradientGroup(false);
-        materialProperties->setEnabled(volumeAtts->GetLightingFlag());
+        materialProperties->setEnabled(true);
         EnableSamplingMethods(false);
         samplesPerRayWidget->setEnabled(true);
         rendererSamplesWidget->setEnabled(true);
@@ -1137,6 +1141,28 @@ void QvisVolumePlotWindow::UpdateSamplingGroup()
         break;
 #endif
 
+#ifdef VISIT_OSPRAY
+    case VolumeAttributes::RayCastingOSPRay:
+	osprayGroup->setVisible(true);
+	osprayGroup->setEnabled(true);
+	raycastingGroup->setVisible(true);
+        EnableSamplingMethods(false);	
+        samplesPerRayWidget->setEnabled(true);
+	samplesPerRay->setEnabled(true);
+	samplesPerRayLabel->setEnabled(true);	
+        rendererSamplesWidget->setEnabled(true);
+        rendererSamples->setEnabled(true);
+        rendererSamplesLabel->setEnabled(true);
+	methodsGroup->setVisible(false);
+        centeredDiffButton->setEnabled(false);
+	sobelButton->setEnabled(false);
+	lightingToggle->setEnabled(true);
+	materialProperties->setEnabled(true);
+	lowGradientGroup->setVisible(false);
+        UpdateLowGradientGroup(false);
+        break;
+#endif
+
     default:
         EXCEPTION1(ImproperUseException, "No such renderer type.");
     }        
@@ -1176,6 +1202,9 @@ QvisVolumePlotWindow::CreateRendererOptionsGroup(int maxWidth)
 #ifdef VISIT_SLIVR
     rendererTypesComboBox->addItem(tr("Ray casting: SLIVR"));
 #endif
+#ifdef VISIT_OSPRAY
+    rendererTypesComboBox->addItem(tr("Ray casting: OSPRay"));
+#endif
     connect(rendererTypesComboBox, SIGNAL(activated(int)),
             this, SLOT(rendererTypeChanged(int)));
 
@@ -1190,7 +1219,7 @@ QvisVolumePlotWindow::CreateRendererOptionsGroup(int maxWidth)
     //
     // Create the methods stuff
     //
-    QGroupBox *methodsGroup = new QGroupBox(parent);
+    methodsGroup = new QGroupBox(parent);
     methodsGroup->setTitle(tr("Methods"));
     rendererOptionsLayout->addWidget(methodsGroup);
 
@@ -1279,6 +1308,174 @@ QvisVolumePlotWindow::CreateRendererOptionsGroup(int maxWidth)
     return parent;
 }
 
+void QvisVolumePlotWindow::CreateOSPRayGroups(QWidget *parent, QLayout *pLayout)
+{
+    osprayGroup = new QGroupBox(parent);
+    osprayGroup->setTitle(tr("OSPRay Options"));
+    osprayGroupLayout = new QGridLayout(osprayGroup);
+    pLayout->addWidget(osprayGroup);    
+    // flag: shadow enabled
+    osprayShadowToggle = new QCheckBox(tr("Shadow"), osprayGroup);
+    connect(osprayShadowToggle, SIGNAL(toggled(bool)),
+            this, SLOT(osprayShadowToggled(bool)));
+    // flag: use grid accelerator
+    osprayUseGridAcceleratorToggle = new QCheckBox(tr("Grid Accelerator"),
+    						   osprayGroup);
+    connect(osprayUseGridAcceleratorToggle, SIGNAL(toggled(bool)),
+            this, SLOT(osprayUseGridAcceleratorToggled(bool)));
+    // flag: enable pre integration
+    osprayPreIntegrationToggle =
+    	new QCheckBox(tr("Transfer Function Pre-Integration"),
+    		      osprayGroup);
+    connect(osprayPreIntegrationToggle, SIGNAL(toggled(bool)),
+            this, SLOT(osprayPreIntegrationToggled(bool)));
+    // flag: enable single shade
+    ospraySingleShadeToggle = new QCheckBox(tr("Single Shade"), osprayGroup);
+    connect(ospraySingleShadeToggle, SIGNAL(toggled(bool)),
+            this, SLOT(ospraySingleShadeToggled(bool)));
+    // flag: enable one sided shading
+    osprayOneSidedLightingToggle = new QCheckBox(tr("One-Sided Lighting"),
+    						 osprayGroup);
+    connect(osprayOneSidedLightingToggle, SIGNAL(toggled(bool)),
+            this, SLOT(osprayOneSidedLightingToggled(bool)));
+    // flag: enable ao transparency
+    osprayAoTransparencyToggle = new QCheckBox(tr("Ambient Occlusion (AO) Transparency"),
+    					       osprayGroup);
+    connect(osprayAoTransparencyToggle, SIGNAL(toggled(bool)),
+            this, SLOT(osprayAoTransparencyToggled(bool)));
+    // value: spp
+    ospraySppWidget         = new QWidget(osprayGroup);
+    QHBoxLayout *sppLayout  = new QHBoxLayout(ospraySppWidget);
+    ospraySppLabel          = new QLabel(tr("Samples Per Pixel"), ospraySppWidget);
+    ospraySpp               = new QSpinBox(ospraySppWidget);
+    ospraySpp->setKeyboardTracking(false);
+    ospraySpp->setMinimum(1);
+    ospraySpp->setMaximum(25000);
+    ospraySpp->setSingleStep(1);
+    ospraySpp->setValue(1);
+    ospraySppLabel->setBuddy(ospraySpp);
+    connect(ospraySpp, SIGNAL(valueChanged(int)),
+    	    this, SLOT(ospraySppChanged(int)));
+    sppLayout->addWidget(ospraySppLabel);
+    sppLayout->addWidget(ospraySpp, Qt::AlignLeft);
+    sppLayout->addStretch(QSizePolicy::Maximum);
+    // value: aoSamples
+    osprayAoSamplesWidget        = new QWidget(osprayGroup);
+    QHBoxLayout *aosamplesLayout = new QHBoxLayout(osprayAoSamplesWidget);
+    osprayAoSamplesLabel         = new QLabel(tr("AO Samples"),
+    					      osprayAoSamplesWidget);
+    osprayAoSamples              = new QSpinBox(osprayAoSamplesWidget);
+    osprayAoSamples->setKeyboardTracking(false);
+    osprayAoSamples->setMinimum(0);
+    osprayAoSamples->setMaximum(25000);
+    osprayAoSamples->setSingleStep(1);
+    osprayAoSamples->setValue(0);
+    osprayAoSamplesLabel->setBuddy(osprayAoSamples);
+    connect(osprayAoSamples, SIGNAL(valueChanged(int)),
+    	    this, SLOT(osprayAoSamplesChanged(int)));
+    aosamplesLayout->addWidget(osprayAoSamplesLabel);
+    aosamplesLayout->addWidget(osprayAoSamples, Qt::AlignLeft);
+    aosamplesLayout->addStretch(QSizePolicy::Maximum);
+    // value: aoDistance
+    osprayAoDistanceWidget        = new QWidget(osprayGroup);
+    QHBoxLayout *aodistanceLayout = new QHBoxLayout(osprayAoDistanceWidget);
+    osprayAoDistanceLabel         = new QLabel(tr("AO Distance"),
+    					      osprayAoDistanceWidget);
+    osprayAoDistance              = new QDoubleSpinBox(osprayAoDistanceWidget);
+    osprayAoDistance->setKeyboardTracking(false);
+    osprayAoDistance->setMinimum(100.0);
+    osprayAoDistance->setMaximum(1000000.0);
+    osprayAoDistance->setSingleStep(1.0);
+    osprayAoDistance->setValue(100000.0);
+    osprayAoDistance->setDecimals(1);
+    osprayAoDistanceLabel->setBuddy(osprayAoDistance);
+    connect(osprayAoDistance, SIGNAL(valueChanged(double)),
+    	    this, SLOT(osprayAoDistanceChanged(double)));
+    aodistanceLayout->addWidget(osprayAoDistanceLabel);
+    aodistanceLayout->addWidget(osprayAoDistance, Qt::AlignLeft);
+    aodistanceLayout->addStretch(QSizePolicy::Maximum);
+    // value: min contribution
+    osprayMinContributionWidget        = new QWidget(osprayGroup);
+    QHBoxLayout *mincontributionLayout = new QHBoxLayout(osprayMinContributionWidget);
+    osprayMinContributionLabel         = new QLabel(tr("Minimum Contrinution"),
+    						    osprayMinContributionWidget);
+    osprayMinContribution              = new QDoubleSpinBox(osprayMinContributionWidget);
+    osprayMinContribution->setKeyboardTracking(false);
+    osprayMinContribution->setMinimum(0.001);
+    osprayMinContribution->setMaximum(10000);
+    osprayMinContribution->setSingleStep(0.001);
+    osprayMinContribution->setValue(0.001);
+    osprayMinContribution->setDecimals(3);
+    osprayMinContributionLabel->setBuddy(osprayMinContribution);
+    connect(osprayMinContribution, SIGNAL(valueChanged(double)),
+    	    this, SLOT(osprayMinContributionChanged(double)));
+    mincontributionLayout->addWidget(osprayMinContributionLabel);
+    mincontributionLayout->addWidget(osprayMinContribution, Qt::AlignLeft);
+    mincontributionLayout->addStretch(QSizePolicy::Maximum);
+    // layout
+    osprayGroupLayout->addWidget(osprayShadowToggle,      0,0);
+    osprayGroupLayout->addWidget(ospraySingleShadeToggle, 1,0);
+    osprayGroupLayout->addWidget(osprayUseGridAcceleratorToggle, 0,2);
+    osprayGroupLayout->addWidget(osprayOneSidedLightingToggle,   1,2);
+    osprayGroupLayout->addWidget(osprayPreIntegrationToggle,     0,5,1,5);
+    osprayGroupLayout->addWidget(osprayAoTransparencyToggle,     1,5,1,5);
+    osprayGroupLayout->addWidget(ospraySppWidget,             2,1,1,2,Qt::AlignRight);
+    osprayGroupLayout->addWidget(osprayAoSamplesWidget,       3,1,1,2,Qt::AlignRight);
+    osprayGroupLayout->addWidget(osprayMinContributionWidget, 2,4,1,4,Qt::AlignRight);
+    osprayGroupLayout->addWidget(osprayAoDistanceWidget,      3,4,1,4,Qt::AlignRight);
+}
+
+void QvisVolumePlotWindow::osprayShadowToggled(bool val)
+{
+    volumeAtts->SetOsprayShadowsEnabledFlag(val);
+    Apply();
+}
+void QvisVolumePlotWindow::osprayUseGridAcceleratorToggled(bool val)
+{
+    volumeAtts->SetOsprayUseGridAcceleratorFlag(val);
+    Apply();
+}
+void QvisVolumePlotWindow::osprayPreIntegrationToggled(bool val)
+{
+    volumeAtts->SetOsprayPreIntegrationFlag(val);
+    Apply();
+}
+void QvisVolumePlotWindow::ospraySingleShadeToggled(bool val)
+{
+    volumeAtts->SetOspraySingleShadeFlag(val);
+    Apply();
+}
+void QvisVolumePlotWindow::osprayOneSidedLightingToggled(bool val)
+{
+    volumeAtts->SetOsprayOneSidedLightingFlag(val);
+    Apply();
+};
+void QvisVolumePlotWindow::osprayAoTransparencyToggled(bool val)
+{
+    volumeAtts->SetOsprayAoTransparencyEnabledFlag(val);
+    Apply();
+};
+void QvisVolumePlotWindow::ospraySppChanged(int val)
+{
+    volumeAtts->SetOspraySpp(val);
+    Apply();
+}
+void QvisVolumePlotWindow::osprayAoSamplesChanged(int val)
+{
+    volumeAtts->SetOsprayAoSamples(val);
+    Apply();
+}
+void QvisVolumePlotWindow::osprayAoDistanceChanged(double val)
+{
+    volumeAtts->SetOsprayAoDistance(val);
+    Apply();
+}
+void QvisVolumePlotWindow::osprayMinContributionChanged(double val)
+{
+    volumeAtts->SetOsprayMinContribution(val);
+    Apply();
+}
+
 // ****************************************************************************
 // Method: QvisVolumePlotWindow::UpdateHistogram
 //
@@ -1689,6 +1886,12 @@ QvisVolumePlotWindow::UpdateWindow(bool doAll)
                 rendererTypesComboBox->setCurrentIndex(3);
             }
 #endif
+#ifdef VISIT_OSPRAY
+            else if (volumeAtts->GetRendererType() == VolumeAttributes::RayCastingOSPRay)
+            {
+                rendererTypesComboBox->setCurrentIndex(4);
+            }
+#endif
 
             opacityVariable->setEnabled(true);
             rendererTypesComboBox->blockSignals(false);
@@ -3405,6 +3608,11 @@ QvisVolumePlotWindow::rendererTypeChanged(int val)
         volumeAtts->SetRendererType(VolumeAttributes::RayCastingSLIVR);
         break;
 #endif
+#ifdef VISIT_OSPRAY
+      case 4:
+        volumeAtts->SetRendererType(VolumeAttributes::RayCastingOSPRay);
+        break;
+#endif
       default:
         EXCEPTION1(ImproperUseException,
                    "The Volume plot received a signal for a renderer "
diff --git a/plots/Volume/QvisVolumePlotWindow.h b/plots/Volume/QvisVolumePlotWindow.h
index bf3919c0f8..09fd95b91f 100644
--- a/plots/Volume/QvisVolumePlotWindow.h
+++ b/plots/Volume/QvisVolumePlotWindow.h
@@ -54,6 +54,7 @@ class QRadioButton;
 class QSpinBox;
 class QDoubleSpinBox;
 class QVBoxLayout;
+class QGridLayout;
 class QvisColorTableButton;
 class QvisColorSelectionWidget;
 class QvisGaussianOpacityBar;
@@ -241,9 +242,17 @@ private slots:
     void clearAllGuassians();
     void setGuassians();
     void setManyGuassians();
-
-
-
+    // ospray options
+    void osprayShadowToggled(bool val);
+    void osprayUseGridAcceleratorToggled(bool val);
+    void osprayPreIntegrationToggled(bool val);
+    void ospraySingleShadeToggled(bool val);
+    void osprayOneSidedLightingToggled(bool val);
+    void osprayAoTransparencyToggled(bool val);
+    void ospraySppChanged(int val);
+    void osprayAoSamplesChanged(int val);
+    void osprayAoDistanceChanged(double val);
+    void osprayMinContributionChanged(double val);
 
 private:
     int                      plotType;
@@ -298,6 +307,7 @@ private:
     QCheckBox                *legendToggle;
     QCheckBox                *lightingToggle;
     QCheckBox                *resampleToggle;
+    QGroupBox                *methodsGroup;
     QGroupBox                *lowGradientGroup;
     QLabel                   *lowGradientLightingReductionLabel;
     QComboBox                *lowGradientLightingReductionCombo;
@@ -351,6 +361,28 @@ private:
     QPushButton              *setGaussButton;
     QPushButton              *setManyGaussButton;
 
+    //OSPRay group
+    QGroupBox               *osprayGroup;
+    QGridLayout             *osprayGroupLayout;
+    QCheckBox               *osprayShadowToggle;
+    QCheckBox               *osprayUseGridAcceleratorToggle;
+    QCheckBox               *osprayPreIntegrationToggle;
+    QCheckBox               *ospraySingleShadeToggle;
+    QCheckBox               *osprayOneSidedLightingToggle;
+    QCheckBox               *osprayAoTransparencyToggle;
+    QWidget                 *ospraySppWidget;
+    QLabel                  *ospraySppLabel;
+    QSpinBox                *ospraySpp;
+    QWidget                 *osprayAoSamplesWidget;
+    QLabel                  *osprayAoSamplesLabel;
+    QSpinBox                *osprayAoSamples;
+    QWidget                 *osprayAoDistanceWidget;
+    QLabel                  *osprayAoDistanceLabel;
+    QDoubleSpinBox          *osprayAoDistance;
+    QWidget                 *osprayMinContributionWidget;
+    QLabel                  *osprayMinContributionLabel;
+    QDoubleSpinBox          *osprayMinContribution;
+    
     //Sampling group
     QGroupBox               *resampleGroup;
     QWidget                 *defaultOptions;
@@ -358,6 +390,7 @@ private:
     QGroupBox               *defaultGroup;
     QGroupBox               *raycastingGroup;
     void                    CreateSamplingGroups(QWidget *parent, QLayout *pLayout);
+    void                    CreateOSPRayGroups(QWidget *parent, QLayout *pLayout);
     void                    UpdateSamplingGroup();
     void                    EnableSamplingMethods(bool enable);
     void                    EnableDefaultGroup();
diff --git a/plots/Volume/Volume.xml b/plots/Volume/Volume.xml
index e5d5b42d25..b157272c62 100644
--- a/plots/Volume/Volume.xml
+++ b/plots/Volume/Volume.xml
@@ -37,6 +37,7 @@
         RayCasting
         RayCastingIntegration
         RayCastingSLIVR
+        RayCastingOSPRay
       </Enum>
       <Enum name="GradientType">
         CenteredDifferences
@@ -71,6 +72,38 @@
         Higher
         Highest
       </Enum>
+      
+      <Field name="osprayShadowsEnabledFlag" label="osprayShadowsEnabledFlag" type="bool">
+        false
+      </Field>
+      <Field name="osprayUseGridAcceleratorFlag" label="osprayUseGridAcceleratorFlag" type="bool">
+        false
+      </Field>
+      <Field name="osprayPreIntegrationFlag" label="osprayPreIntegrationFlag" type="bool">
+        false
+      </Field>
+      <Field name="ospraySingleShadeFlag" label="ospraySingleShadeFlag" type="bool">
+        false
+      </Field>
+      <Field name="osprayOneSidedLightingFlag" label="osprayOneSidedLightingFlag" type="bool">
+        false
+      </Field>
+      <Field name="osprayAoTransparencyEnabledFlag" label="osprayAoTransparencyEnabledFlag" type="bool">
+        false
+      </Field>
+      <Field name="ospraySpp" label="ospraySpp" type="int">
+        1
+      </Field>
+      <Field name="osprayAoSamples" label="osprayAoSamples" type="int">
+        0
+      </Field>
+      <Field name="osprayAoDistance" label="osprayAoDistance" type="double">
+        100000.0
+      </Field>
+      <Field name="osprayMinContribution" label="osprayMinContribution" type="double">
+        0.001
+      </Field>
+      
       <Field name="legendFlag" label="legendFlag" type="bool">
         true
       </Field>
diff --git a/plots/Volume/VolumeAttributes.C b/plots/Volume/VolumeAttributes.C
index ba300dabea..019723c3de 100644
--- a/plots/Volume/VolumeAttributes.C
+++ b/plots/Volume/VolumeAttributes.C
@@ -47,20 +47,20 @@
 
 static const char *Renderer_strings[] = {
 "Default", "RayCasting", "RayCastingIntegration", 
-"RayCastingSLIVR"};
+"RayCastingSLIVR", "RayCastingOSPRay"};
 
 std::string
 VolumeAttributes::Renderer_ToString(VolumeAttributes::Renderer t)
 {
     int index = int(t);
-    if(index < 0 || index >= 4) index = 0;
+    if(index < 0 || index >= 5) index = 0;
     return Renderer_strings[index];
 }
 
 std::string
 VolumeAttributes::Renderer_ToString(int t)
 {
-    int index = (t < 0 || t >= 4) ? 0 : t;
+    int index = (t < 0 || t >= 5) ? 0 : t;
     return Renderer_strings[index];
 }
 
@@ -68,7 +68,7 @@ bool
 VolumeAttributes::Renderer_FromString(const std::string &s, VolumeAttributes::Renderer &val)
 {
     val = VolumeAttributes::Default;
-    for(int i = 0; i < 4; ++i)
+    for(int i = 0; i < 5; ++i)
     {
         if(s == Renderer_strings[i])
         {
@@ -323,6 +323,16 @@ VolumeAttributes::LowGradientLightingReduction_FromString(const std::string &s,
 
 void VolumeAttributes::Init()
 {
+    osprayShadowsEnabledFlag = false;
+    osprayUseGridAcceleratorFlag = false;
+    osprayPreIntegrationFlag = false;
+    ospraySingleShadeFlag = false;
+    osprayOneSidedLightingFlag = false;
+    osprayAoTransparencyEnabledFlag = false;
+    ospraySpp = 1;
+    osprayAoSamples = 0;
+    osprayAoDistance = 100000;
+    osprayMinContribution = 0.001;
     legendFlag = true;
     lightingFlag = true;
     SetDefaultColorControlPoints();
@@ -378,6 +388,16 @@ void VolumeAttributes::Init()
 void VolumeAttributes::Copy(const VolumeAttributes &obj)
 {
 
+    osprayShadowsEnabledFlag = obj.osprayShadowsEnabledFlag;
+    osprayUseGridAcceleratorFlag = obj.osprayUseGridAcceleratorFlag;
+    osprayPreIntegrationFlag = obj.osprayPreIntegrationFlag;
+    ospraySingleShadeFlag = obj.ospraySingleShadeFlag;
+    osprayOneSidedLightingFlag = obj.osprayOneSidedLightingFlag;
+    osprayAoTransparencyEnabledFlag = obj.osprayAoTransparencyEnabledFlag;
+    ospraySpp = obj.ospraySpp;
+    osprayAoSamples = obj.osprayAoSamples;
+    osprayAoDistance = obj.osprayAoDistance;
+    osprayMinContribution = obj.osprayMinContribution;
     legendFlag = obj.legendFlag;
     lightingFlag = obj.lightingFlag;
     colorControlPoints = obj.colorControlPoints;
@@ -583,7 +603,17 @@ VolumeAttributes::operator == (const VolumeAttributes &obj) const
         materialProperties_equal = (materialProperties[i] == obj.materialProperties[i]);
 
     // Create the return value
-    return ((legendFlag == obj.legendFlag) &&
+    return ((osprayShadowsEnabledFlag == obj.osprayShadowsEnabledFlag) &&
+            (osprayUseGridAcceleratorFlag == obj.osprayUseGridAcceleratorFlag) &&
+            (osprayPreIntegrationFlag == obj.osprayPreIntegrationFlag) &&
+            (ospraySingleShadeFlag == obj.ospraySingleShadeFlag) &&
+            (osprayOneSidedLightingFlag == obj.osprayOneSidedLightingFlag) &&
+            (osprayAoTransparencyEnabledFlag == obj.osprayAoTransparencyEnabledFlag) &&
+            (ospraySpp == obj.ospraySpp) &&
+            (osprayAoSamples == obj.osprayAoSamples) &&
+            (osprayAoDistance == obj.osprayAoDistance) &&
+            (osprayMinContribution == obj.osprayMinContribution) &&
+            (legendFlag == obj.legendFlag) &&
             (lightingFlag == obj.lightingFlag) &&
             (colorControlPoints == obj.colorControlPoints) &&
             (opacityAttenuation == obj.opacityAttenuation) &&
@@ -758,38 +788,48 @@ VolumeAttributes::NewInstance(bool copy) const
 void
 VolumeAttributes::SelectAll()
 {
-    Select(ID_legendFlag,                    (void *)&legendFlag);
-    Select(ID_lightingFlag,                  (void *)&lightingFlag);
-    Select(ID_colorControlPoints,            (void *)&colorControlPoints);
-    Select(ID_opacityAttenuation,            (void *)&opacityAttenuation);
-    Select(ID_opacityMode,                   (void *)&opacityMode);
-    Select(ID_opacityControlPoints,          (void *)&opacityControlPoints);
-    Select(ID_resampleFlag,                  (void *)&resampleFlag);
-    Select(ID_resampleTarget,                (void *)&resampleTarget);
-    Select(ID_opacityVariable,               (void *)&opacityVariable);
-    Select(ID_compactVariable,               (void *)&compactVariable);
-    Select(ID_freeformOpacity,               (void *)freeformOpacity, 256);
-    Select(ID_useColorVarMin,                (void *)&useColorVarMin);
-    Select(ID_colorVarMin,                   (void *)&colorVarMin);
-    Select(ID_useColorVarMax,                (void *)&useColorVarMax);
-    Select(ID_colorVarMax,                   (void *)&colorVarMax);
-    Select(ID_useOpacityVarMin,              (void *)&useOpacityVarMin);
-    Select(ID_opacityVarMin,                 (void *)&opacityVarMin);
-    Select(ID_useOpacityVarMax,              (void *)&useOpacityVarMax);
-    Select(ID_opacityVarMax,                 (void *)&opacityVarMax);
-    Select(ID_smoothData,                    (void *)&smoothData);
-    Select(ID_samplesPerRay,                 (void *)&samplesPerRay);
-    Select(ID_rendererType,                  (void *)&rendererType);
-    Select(ID_gradientType,                  (void *)&gradientType);
-    Select(ID_scaling,                       (void *)&scaling);
-    Select(ID_skewFactor,                    (void *)&skewFactor);
-    Select(ID_limitsMode,                    (void *)&limitsMode);
-    Select(ID_sampling,                      (void *)&sampling);
-    Select(ID_rendererSamples,               (void *)&rendererSamples);
-    Select(ID_lowGradientLightingReduction,  (void *)&lowGradientLightingReduction);
-    Select(ID_lowGradientLightingClampFlag,  (void *)&lowGradientLightingClampFlag);
-    Select(ID_lowGradientLightingClampValue, (void *)&lowGradientLightingClampValue);
-    Select(ID_materialProperties,            (void *)materialProperties, 4);
+    Select(ID_osprayShadowsEnabledFlag,        (void *)&osprayShadowsEnabledFlag);
+    Select(ID_osprayUseGridAcceleratorFlag,    (void *)&osprayUseGridAcceleratorFlag);
+    Select(ID_osprayPreIntegrationFlag,        (void *)&osprayPreIntegrationFlag);
+    Select(ID_ospraySingleShadeFlag,           (void *)&ospraySingleShadeFlag);
+    Select(ID_osprayOneSidedLightingFlag,      (void *)&osprayOneSidedLightingFlag);
+    Select(ID_osprayAoTransparencyEnabledFlag, (void *)&osprayAoTransparencyEnabledFlag);
+    Select(ID_ospraySpp,                       (void *)&ospraySpp);
+    Select(ID_osprayAoSamples,                 (void *)&osprayAoSamples);
+    Select(ID_osprayAoDistance,                (void *)&osprayAoDistance);
+    Select(ID_osprayMinContribution,           (void *)&osprayMinContribution);
+    Select(ID_legendFlag,                      (void *)&legendFlag);
+    Select(ID_lightingFlag,                    (void *)&lightingFlag);
+    Select(ID_colorControlPoints,              (void *)&colorControlPoints);
+    Select(ID_opacityAttenuation,              (void *)&opacityAttenuation);
+    Select(ID_opacityMode,                     (void *)&opacityMode);
+    Select(ID_opacityControlPoints,            (void *)&opacityControlPoints);
+    Select(ID_resampleFlag,                    (void *)&resampleFlag);
+    Select(ID_resampleTarget,                  (void *)&resampleTarget);
+    Select(ID_opacityVariable,                 (void *)&opacityVariable);
+    Select(ID_compactVariable,                 (void *)&compactVariable);
+    Select(ID_freeformOpacity,                 (void *)freeformOpacity, 256);
+    Select(ID_useColorVarMin,                  (void *)&useColorVarMin);
+    Select(ID_colorVarMin,                     (void *)&colorVarMin);
+    Select(ID_useColorVarMax,                  (void *)&useColorVarMax);
+    Select(ID_colorVarMax,                     (void *)&colorVarMax);
+    Select(ID_useOpacityVarMin,                (void *)&useOpacityVarMin);
+    Select(ID_opacityVarMin,                   (void *)&opacityVarMin);
+    Select(ID_useOpacityVarMax,                (void *)&useOpacityVarMax);
+    Select(ID_opacityVarMax,                   (void *)&opacityVarMax);
+    Select(ID_smoothData,                      (void *)&smoothData);
+    Select(ID_samplesPerRay,                   (void *)&samplesPerRay);
+    Select(ID_rendererType,                    (void *)&rendererType);
+    Select(ID_gradientType,                    (void *)&gradientType);
+    Select(ID_scaling,                         (void *)&scaling);
+    Select(ID_skewFactor,                      (void *)&skewFactor);
+    Select(ID_limitsMode,                      (void *)&limitsMode);
+    Select(ID_sampling,                        (void *)&sampling);
+    Select(ID_rendererSamples,                 (void *)&rendererSamples);
+    Select(ID_lowGradientLightingReduction,    (void *)&lowGradientLightingReduction);
+    Select(ID_lowGradientLightingClampFlag,    (void *)&lowGradientLightingClampFlag);
+    Select(ID_lowGradientLightingClampValue,   (void *)&lowGradientLightingClampValue);
+    Select(ID_materialProperties,              (void *)materialProperties, 4);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -822,6 +862,66 @@ VolumeAttributes::CreateNode(DataNode *parentNode, bool completeSave, bool force
     // Create a node for VolumeAttributes.
     DataNode *node = new DataNode("VolumeAttributes");
 
+    if(completeSave || !FieldsEqual(ID_osprayShadowsEnabledFlag, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayShadowsEnabledFlag", osprayShadowsEnabledFlag));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayUseGridAcceleratorFlag, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayUseGridAcceleratorFlag", osprayUseGridAcceleratorFlag));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayPreIntegrationFlag, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayPreIntegrationFlag", osprayPreIntegrationFlag));
+    }
+
+    if(completeSave || !FieldsEqual(ID_ospraySingleShadeFlag, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("ospraySingleShadeFlag", ospraySingleShadeFlag));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayOneSidedLightingFlag, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayOneSidedLightingFlag", osprayOneSidedLightingFlag));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayAoTransparencyEnabledFlag, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayAoTransparencyEnabledFlag", osprayAoTransparencyEnabledFlag));
+    }
+
+    if(completeSave || !FieldsEqual(ID_ospraySpp, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("ospraySpp", ospraySpp));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayAoSamples, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayAoSamples", osprayAoSamples));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayAoDistance, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayAoDistance", osprayAoDistance));
+    }
+
+    if(completeSave || !FieldsEqual(ID_osprayMinContribution, &defaultObject))
+    {
+        addToParent = true;
+        node->AddNode(new DataNode("osprayMinContribution", osprayMinContribution));
+    }
+
     if(completeSave || !FieldsEqual(ID_legendFlag, &defaultObject))
     {
         addToParent = true;
@@ -1062,6 +1162,26 @@ VolumeAttributes::SetFromNode(DataNode *parentNode)
         return;
 
     DataNode *node;
+    if((node = searchNode->GetNode("osprayShadowsEnabledFlag")) != 0)
+        SetOsprayShadowsEnabledFlag(node->AsBool());
+    if((node = searchNode->GetNode("osprayUseGridAcceleratorFlag")) != 0)
+        SetOsprayUseGridAcceleratorFlag(node->AsBool());
+    if((node = searchNode->GetNode("osprayPreIntegrationFlag")) != 0)
+        SetOsprayPreIntegrationFlag(node->AsBool());
+    if((node = searchNode->GetNode("ospraySingleShadeFlag")) != 0)
+        SetOspraySingleShadeFlag(node->AsBool());
+    if((node = searchNode->GetNode("osprayOneSidedLightingFlag")) != 0)
+        SetOsprayOneSidedLightingFlag(node->AsBool());
+    if((node = searchNode->GetNode("osprayAoTransparencyEnabledFlag")) != 0)
+        SetOsprayAoTransparencyEnabledFlag(node->AsBool());
+    if((node = searchNode->GetNode("ospraySpp")) != 0)
+        SetOspraySpp(node->AsInt());
+    if((node = searchNode->GetNode("osprayAoSamples")) != 0)
+        SetOsprayAoSamples(node->AsInt());
+    if((node = searchNode->GetNode("osprayAoDistance")) != 0)
+        SetOsprayAoDistance(node->AsDouble());
+    if((node = searchNode->GetNode("osprayMinContribution")) != 0)
+        SetOsprayMinContribution(node->AsDouble());
     if((node = searchNode->GetNode("legendFlag")) != 0)
         SetLegendFlag(node->AsBool());
     if((node = searchNode->GetNode("lightingFlag")) != 0)
@@ -1124,7 +1244,7 @@ VolumeAttributes::SetFromNode(DataNode *parentNode)
         if(node->GetNodeType() == INT_NODE)
         {
             int ival = node->AsInt();
-            if(ival >= 0 && ival < 4)
+            if(ival >= 0 && ival < 5)
                 SetRendererType(Renderer(ival));
         }
         else if(node->GetNodeType() == STRING_NODE)
@@ -1234,6 +1354,76 @@ VolumeAttributes::SetFromNode(DataNode *parentNode)
 ///////////////////////////////////////////////////////////////////////////////
 
 void
+VolumeAttributes::SetOsprayShadowsEnabledFlag(bool osprayShadowsEnabledFlag_)
+{
+    osprayShadowsEnabledFlag = osprayShadowsEnabledFlag_;
+    Select(ID_osprayShadowsEnabledFlag, (void *)&osprayShadowsEnabledFlag);
+}
+
+void
+VolumeAttributes::SetOsprayUseGridAcceleratorFlag(bool osprayUseGridAcceleratorFlag_)
+{
+    osprayUseGridAcceleratorFlag = osprayUseGridAcceleratorFlag_;
+    Select(ID_osprayUseGridAcceleratorFlag, (void *)&osprayUseGridAcceleratorFlag);
+}
+
+void
+VolumeAttributes::SetOsprayPreIntegrationFlag(bool osprayPreIntegrationFlag_)
+{
+    osprayPreIntegrationFlag = osprayPreIntegrationFlag_;
+    Select(ID_osprayPreIntegrationFlag, (void *)&osprayPreIntegrationFlag);
+}
+
+void
+VolumeAttributes::SetOspraySingleShadeFlag(bool ospraySingleShadeFlag_)
+{
+    ospraySingleShadeFlag = ospraySingleShadeFlag_;
+    Select(ID_ospraySingleShadeFlag, (void *)&ospraySingleShadeFlag);
+}
+
+void
+VolumeAttributes::SetOsprayOneSidedLightingFlag(bool osprayOneSidedLightingFlag_)
+{
+    osprayOneSidedLightingFlag = osprayOneSidedLightingFlag_;
+    Select(ID_osprayOneSidedLightingFlag, (void *)&osprayOneSidedLightingFlag);
+}
+
+void
+VolumeAttributes::SetOsprayAoTransparencyEnabledFlag(bool osprayAoTransparencyEnabledFlag_)
+{
+    osprayAoTransparencyEnabledFlag = osprayAoTransparencyEnabledFlag_;
+    Select(ID_osprayAoTransparencyEnabledFlag, (void *)&osprayAoTransparencyEnabledFlag);
+}
+
+void
+VolumeAttributes::SetOspraySpp(int ospraySpp_)
+{
+    ospraySpp = ospraySpp_;
+    Select(ID_ospraySpp, (void *)&ospraySpp);
+}
+
+void
+VolumeAttributes::SetOsprayAoSamples(int osprayAoSamples_)
+{
+    osprayAoSamples = osprayAoSamples_;
+    Select(ID_osprayAoSamples, (void *)&osprayAoSamples);
+}
+
+void
+VolumeAttributes::SetOsprayAoDistance(double osprayAoDistance_)
+{
+    osprayAoDistance = osprayAoDistance_;
+    Select(ID_osprayAoDistance, (void *)&osprayAoDistance);
+}
+
+void
+VolumeAttributes::SetOsprayMinContribution(double osprayMinContribution_)
+{
+    osprayMinContribution = osprayMinContribution_;
+    Select(ID_osprayMinContribution, (void *)&osprayMinContribution);
+}
+
+void
 VolumeAttributes::SetLegendFlag(bool legendFlag_)
 {
     legendFlag = legendFlag_;
@@ -1466,6 +1656,66 @@ VolumeAttributes::SetMaterialProperties(const double *materialProperties_)
 ///////////////////////////////////////////////////////////////////////////////
 
 bool
+VolumeAttributes::GetOsprayShadowsEnabledFlag() const
+{
+    return osprayShadowsEnabledFlag;
+}
+
+bool
+VolumeAttributes::GetOsprayUseGridAcceleratorFlag() const
+{
+    return osprayUseGridAcceleratorFlag;
+}
+
+bool
+VolumeAttributes::GetOsprayPreIntegrationFlag() const
+{
+    return osprayPreIntegrationFlag;
+}
+
+bool
+VolumeAttributes::GetOspraySingleShadeFlag() const
+{
+    return ospraySingleShadeFlag;
+}
+
+bool
+VolumeAttributes::GetOsprayOneSidedLightingFlag() const
+{
+    return osprayOneSidedLightingFlag;
+}
+
+bool
+VolumeAttributes::GetOsprayAoTransparencyEnabledFlag() const
+{
+    return osprayAoTransparencyEnabledFlag;
+}
+
+int
+VolumeAttributes::GetOspraySpp() const
+{
+    return ospraySpp;
+}
+
+int
+VolumeAttributes::GetOsprayAoSamples() const
+{
+    return osprayAoSamples;
+}
+
+double
+VolumeAttributes::GetOsprayAoDistance() const
+{
+    return osprayAoDistance;
+}
+
+double
+VolumeAttributes::GetOsprayMinContribution() const
+{
+    return osprayMinContribution;
+}
+
+bool
 VolumeAttributes::GetLegendFlag() const
 {
     return legendFlag;
@@ -1757,38 +2007,48 @@ VolumeAttributes::GetFieldName(int index) const
 {
     switch (index)
     {
-    case ID_legendFlag:                    return "legendFlag";
-    case ID_lightingFlag:                  return "lightingFlag";
-    case ID_colorControlPoints:            return "colorControlPoints";
-    case ID_opacityAttenuation:            return "opacityAttenuation";
-    case ID_opacityMode:                   return "opacityMode";
-    case ID_opacityControlPoints:          return "opacityControlPoints";
-    case ID_resampleFlag:                  return "resampleFlag";
-    case ID_resampleTarget:                return "resampleTarget";
-    case ID_opacityVariable:               return "opacityVariable";
-    case ID_compactVariable:               return "compactVariable";
-    case ID_freeformOpacity:               return "freeformOpacity";
-    case ID_useColorVarMin:                return "useColorVarMin";
-    case ID_colorVarMin:                   return "colorVarMin";
-    case ID_useColorVarMax:                return "useColorVarMax";
-    case ID_colorVarMax:                   return "colorVarMax";
-    case ID_useOpacityVarMin:              return "useOpacityVarMin";
-    case ID_opacityVarMin:                 return "opacityVarMin";
-    case ID_useOpacityVarMax:              return "useOpacityVarMax";
-    case ID_opacityVarMax:                 return "opacityVarMax";
-    case ID_smoothData:                    return "smoothData";
-    case ID_samplesPerRay:                 return "samplesPerRay";
-    case ID_rendererType:                  return "rendererType";
-    case ID_gradientType:                  return "gradientType";
-    case ID_scaling:                       return "scaling";
-    case ID_skewFactor:                    return "skewFactor";
-    case ID_limitsMode:                    return "limitsMode";
-    case ID_sampling:                      return "sampling";
-    case ID_rendererSamples:               return "rendererSamples";
-    case ID_lowGradientLightingReduction:  return "lowGradientLightingReduction";
-    case ID_lowGradientLightingClampFlag:  return "lowGradientLightingClampFlag";
-    case ID_lowGradientLightingClampValue: return "lowGradientLightingClampValue";
-    case ID_materialProperties:            return "materialProperties";
+    case ID_osprayShadowsEnabledFlag:        return "osprayShadowsEnabledFlag";
+    case ID_osprayUseGridAcceleratorFlag:    return "osprayUseGridAcceleratorFlag";
+    case ID_osprayPreIntegrationFlag:        return "osprayPreIntegrationFlag";
+    case ID_ospraySingleShadeFlag:           return "ospraySingleShadeFlag";
+    case ID_osprayOneSidedLightingFlag:      return "osprayOneSidedLightingFlag";
+    case ID_osprayAoTransparencyEnabledFlag: return "osprayAoTransparencyEnabledFlag";
+    case ID_ospraySpp:                       return "ospraySpp";
+    case ID_osprayAoSamples:                 return "osprayAoSamples";
+    case ID_osprayAoDistance:                return "osprayAoDistance";
+    case ID_osprayMinContribution:           return "osprayMinContribution";
+    case ID_legendFlag:                      return "legendFlag";
+    case ID_lightingFlag:                    return "lightingFlag";
+    case ID_colorControlPoints:              return "colorControlPoints";
+    case ID_opacityAttenuation:              return "opacityAttenuation";
+    case ID_opacityMode:                     return "opacityMode";
+    case ID_opacityControlPoints:            return "opacityControlPoints";
+    case ID_resampleFlag:                    return "resampleFlag";
+    case ID_resampleTarget:                  return "resampleTarget";
+    case ID_opacityVariable:                 return "opacityVariable";
+    case ID_compactVariable:                 return "compactVariable";
+    case ID_freeformOpacity:                 return "freeformOpacity";
+    case ID_useColorVarMin:                  return "useColorVarMin";
+    case ID_colorVarMin:                     return "colorVarMin";
+    case ID_useColorVarMax:                  return "useColorVarMax";
+    case ID_colorVarMax:                     return "colorVarMax";
+    case ID_useOpacityVarMin:                return "useOpacityVarMin";
+    case ID_opacityVarMin:                   return "opacityVarMin";
+    case ID_useOpacityVarMax:                return "useOpacityVarMax";
+    case ID_opacityVarMax:                   return "opacityVarMax";
+    case ID_smoothData:                      return "smoothData";
+    case ID_samplesPerRay:                   return "samplesPerRay";
+    case ID_rendererType:                    return "rendererType";
+    case ID_gradientType:                    return "gradientType";
+    case ID_scaling:                         return "scaling";
+    case ID_skewFactor:                      return "skewFactor";
+    case ID_limitsMode:                      return "limitsMode";
+    case ID_sampling:                        return "sampling";
+    case ID_rendererSamples:                 return "rendererSamples";
+    case ID_lowGradientLightingReduction:    return "lowGradientLightingReduction";
+    case ID_lowGradientLightingClampFlag:    return "lowGradientLightingClampFlag";
+    case ID_lowGradientLightingClampValue:   return "lowGradientLightingClampValue";
+    case ID_materialProperties:              return "materialProperties";
     default:  return "invalid index";
     }
 }
@@ -1813,38 +2073,48 @@ VolumeAttributes::GetFieldType(int index) const
 {
     switch (index)
     {
-    case ID_legendFlag:                    return FieldType_bool;
-    case ID_lightingFlag:                  return FieldType_bool;
-    case ID_colorControlPoints:            return FieldType_att;
-    case ID_opacityAttenuation:            return FieldType_float;
-    case ID_opacityMode:                   return FieldType_enum;
-    case ID_opacityControlPoints:          return FieldType_att;
-    case ID_resampleFlag:                  return FieldType_bool;
-    case ID_resampleTarget:                return FieldType_int;
-    case ID_opacityVariable:               return FieldType_variablename;
-    case ID_compactVariable:               return FieldType_variablename;
-    case ID_freeformOpacity:               return FieldType_ucharArray;
-    case ID_useColorVarMin:                return FieldType_bool;
-    case ID_colorVarMin:                   return FieldType_float;
-    case ID_useColorVarMax:                return FieldType_bool;
-    case ID_colorVarMax:                   return FieldType_float;
-    case ID_useOpacityVarMin:              return FieldType_bool;
-    case ID_opacityVarMin:                 return FieldType_float;
-    case ID_useOpacityVarMax:              return FieldType_bool;
-    case ID_opacityVarMax:                 return FieldType_float;
-    case ID_smoothData:                    return FieldType_bool;
-    case ID_samplesPerRay:                 return FieldType_int;
-    case ID_rendererType:                  return FieldType_enum;
-    case ID_gradientType:                  return FieldType_enum;
-    case ID_scaling:                       return FieldType_enum;
-    case ID_skewFactor:                    return FieldType_double;
-    case ID_limitsMode:                    return FieldType_enum;
-    case ID_sampling:                      return FieldType_enum;
-    case ID_rendererSamples:               return FieldType_float;
-    case ID_lowGradientLightingReduction:  return FieldType_enum;
-    case ID_lowGradientLightingClampFlag:  return FieldType_bool;
-    case ID_lowGradientLightingClampValue: return FieldType_double;
-    case ID_materialProperties:            return FieldType_doubleArray;
+    case ID_osprayShadowsEnabledFlag:        return FieldType_bool;
+    case ID_osprayUseGridAcceleratorFlag:    return FieldType_bool;
+    case ID_osprayPreIntegrationFlag:        return FieldType_bool;
+    case ID_ospraySingleShadeFlag:           return FieldType_bool;
+    case ID_osprayOneSidedLightingFlag:      return FieldType_bool;
+    case ID_osprayAoTransparencyEnabledFlag: return FieldType_bool;
+    case ID_ospraySpp:                       return FieldType_int;
+    case ID_osprayAoSamples:                 return FieldType_int;
+    case ID_osprayAoDistance:                return FieldType_double;
+    case ID_osprayMinContribution:           return FieldType_double;
+    case ID_legendFlag:                      return FieldType_bool;
+    case ID_lightingFlag:                    return FieldType_bool;
+    case ID_colorControlPoints:              return FieldType_att;
+    case ID_opacityAttenuation:              return FieldType_float;
+    case ID_opacityMode:                     return FieldType_enum;
+    case ID_opacityControlPoints:            return FieldType_att;
+    case ID_resampleFlag:                    return FieldType_bool;
+    case ID_resampleTarget:                  return FieldType_int;
+    case ID_opacityVariable:                 return FieldType_variablename;
+    case ID_compactVariable:                 return FieldType_variablename;
+    case ID_freeformOpacity:                 return FieldType_ucharArray;
+    case ID_useColorVarMin:                  return FieldType_bool;
+    case ID_colorVarMin:                     return FieldType_float;
+    case ID_useColorVarMax:                  return FieldType_bool;
+    case ID_colorVarMax:                     return FieldType_float;
+    case ID_useOpacityVarMin:                return FieldType_bool;
+    case ID_opacityVarMin:                   return FieldType_float;
+    case ID_useOpacityVarMax:                return FieldType_bool;
+    case ID_opacityVarMax:                   return FieldType_float;
+    case ID_smoothData:                      return FieldType_bool;
+    case ID_samplesPerRay:                   return FieldType_int;
+    case ID_rendererType:                    return FieldType_enum;
+    case ID_gradientType:                    return FieldType_enum;
+    case ID_scaling:                         return FieldType_enum;
+    case ID_skewFactor:                      return FieldType_double;
+    case ID_limitsMode:                      return FieldType_enum;
+    case ID_sampling:                        return FieldType_enum;
+    case ID_rendererSamples:                 return FieldType_float;
+    case ID_lowGradientLightingReduction:    return FieldType_enum;
+    case ID_lowGradientLightingClampFlag:    return FieldType_bool;
+    case ID_lowGradientLightingClampValue:   return FieldType_double;
+    case ID_materialProperties:              return FieldType_doubleArray;
     default:  return FieldType_unknown;
     }
 }
@@ -1869,38 +2139,48 @@ VolumeAttributes::GetFieldTypeName(int index) const
 {
     switch (index)
     {
-    case ID_legendFlag:                    return "bool";
-    case ID_lightingFlag:                  return "bool";
-    case ID_colorControlPoints:            return "att";
-    case ID_opacityAttenuation:            return "float";
-    case ID_opacityMode:                   return "enum";
-    case ID_opacityControlPoints:          return "att";
-    case ID_resampleFlag:                  return "bool";
-    case ID_resampleTarget:                return "int";
-    case ID_opacityVariable:               return "variablename";
-    case ID_compactVariable:               return "variablename";
-    case ID_freeformOpacity:               return "ucharArray";
-    case ID_useColorVarMin:                return "bool";
-    case ID_colorVarMin:                   return "float";
-    case ID_useColorVarMax:                return "bool";
-    case ID_colorVarMax:                   return "float";
-    case ID_useOpacityVarMin:              return "bool";
-    case ID_opacityVarMin:                 return "float";
-    case ID_useOpacityVarMax:              return "bool";
-    case ID_opacityVarMax:                 return "float";
-    case ID_smoothData:                    return "bool";
-    case ID_samplesPerRay:                 return "int";
-    case ID_rendererType:                  return "enum";
-    case ID_gradientType:                  return "enum";
-    case ID_scaling:                       return "enum";
-    case ID_skewFactor:                    return "double";
-    case ID_limitsMode:                    return "enum";
-    case ID_sampling:                      return "enum";
-    case ID_rendererSamples:               return "float";
-    case ID_lowGradientLightingReduction:  return "enum";
-    case ID_lowGradientLightingClampFlag:  return "bool";
-    case ID_lowGradientLightingClampValue: return "double";
-    case ID_materialProperties:            return "doubleArray";
+    case ID_osprayShadowsEnabledFlag:        return "bool";
+    case ID_osprayUseGridAcceleratorFlag:    return "bool";
+    case ID_osprayPreIntegrationFlag:        return "bool";
+    case ID_ospraySingleShadeFlag:           return "bool";
+    case ID_osprayOneSidedLightingFlag:      return "bool";
+    case ID_osprayAoTransparencyEnabledFlag: return "bool";
+    case ID_ospraySpp:                       return "int";
+    case ID_osprayAoSamples:                 return "int";
+    case ID_osprayAoDistance:                return "double";
+    case ID_osprayMinContribution:           return "double";
+    case ID_legendFlag:                      return "bool";
+    case ID_lightingFlag:                    return "bool";
+    case ID_colorControlPoints:              return "att";
+    case ID_opacityAttenuation:              return "float";
+    case ID_opacityMode:                     return "enum";
+    case ID_opacityControlPoints:            return "att";
+    case ID_resampleFlag:                    return "bool";
+    case ID_resampleTarget:                  return "int";
+    case ID_opacityVariable:                 return "variablename";
+    case ID_compactVariable:                 return "variablename";
+    case ID_freeformOpacity:                 return "ucharArray";
+    case ID_useColorVarMin:                  return "bool";
+    case ID_colorVarMin:                     return "float";
+    case ID_useColorVarMax:                  return "bool";
+    case ID_colorVarMax:                     return "float";
+    case ID_useOpacityVarMin:                return "bool";
+    case ID_opacityVarMin:                   return "float";
+    case ID_useOpacityVarMax:                return "bool";
+    case ID_opacityVarMax:                   return "float";
+    case ID_smoothData:                      return "bool";
+    case ID_samplesPerRay:                   return "int";
+    case ID_rendererType:                    return "enum";
+    case ID_gradientType:                    return "enum";
+    case ID_scaling:                         return "enum";
+    case ID_skewFactor:                      return "double";
+    case ID_limitsMode:                      return "enum";
+    case ID_sampling:                        return "enum";
+    case ID_rendererSamples:                 return "float";
+    case ID_lowGradientLightingReduction:    return "enum";
+    case ID_lowGradientLightingClampFlag:    return "bool";
+    case ID_lowGradientLightingClampValue:   return "double";
+    case ID_materialProperties:              return "doubleArray";
     default:  return "invalid index";
     }
 }
@@ -1927,6 +2207,56 @@ VolumeAttributes::FieldsEqual(int index_, const AttributeGroup *rhs) const
     bool retval = false;
     switch (index_)
     {
+    case ID_osprayShadowsEnabledFlag:
+        {  // new scope
+        retval = (osprayShadowsEnabledFlag == obj.osprayShadowsEnabledFlag);
+        }
+        break;
+    case ID_osprayUseGridAcceleratorFlag:
+        {  // new scope
+        retval = (osprayUseGridAcceleratorFlag == obj.osprayUseGridAcceleratorFlag);
+        }
+        break;
+    case ID_osprayPreIntegrationFlag:
+        {  // new scope
+        retval = (osprayPreIntegrationFlag == obj.osprayPreIntegrationFlag);
+        }
+        break;
+    case ID_ospraySingleShadeFlag:
+        {  // new scope
+        retval = (ospraySingleShadeFlag == obj.ospraySingleShadeFlag);
+        }
+        break;
+    case ID_osprayOneSidedLightingFlag:
+        {  // new scope
+        retval = (osprayOneSidedLightingFlag == obj.osprayOneSidedLightingFlag);
+        }
+        break;
+    case ID_osprayAoTransparencyEnabledFlag:
+        {  // new scope
+        retval = (osprayAoTransparencyEnabledFlag == obj.osprayAoTransparencyEnabledFlag);
+        }
+        break;
+    case ID_ospraySpp:
+        {  // new scope
+        retval = (ospraySpp == obj.ospraySpp);
+        }
+        break;
+    case ID_osprayAoSamples:
+        {  // new scope
+        retval = (osprayAoSamples == obj.osprayAoSamples);
+        }
+        break;
+    case ID_osprayAoDistance:
+        {  // new scope
+        retval = (osprayAoDistance == obj.osprayAoDistance);
+        }
+        break;
+    case ID_osprayMinContribution:
+        {  // new scope
+        retval = (osprayMinContribution == obj.osprayMinContribution);
+        }
+        break;
     case ID_legendFlag:
         {  // new scope
         retval = (legendFlag == obj.legendFlag);
@@ -2138,6 +2468,9 @@ VolumeAttributes::FieldsEqual(int index_, const AttributeGroup *rhs) const
 //    Allen Harvey, Thurs Nov 3 7:21:13 EST 2011
 //    Added checks for not doing resampling
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Added RayCastingOSPRay option for volume rendering
+//
 // ****************************************************************************
 
 bool
@@ -2157,6 +2490,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
 
     if (rendererType == VolumeAttributes::RayCasting ||
         rendererType == VolumeAttributes::RayCastingSLIVR ||
+        rendererType == VolumeAttributes::RayCastingOSPRay ||
         rendererType == VolumeAttributes::RayCastingIntegration)
     {
         // Trilinear requires ghost zone while Rasterization and KernelBased do not
@@ -2185,6 +2519,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
         // modes does not require a reexecute.
         if(obj.rendererType == VolumeAttributes::RayCasting ||
            obj.rendererType == VolumeAttributes::RayCastingSLIVR ||
+           obj.rendererType == VolumeAttributes::RayCastingOSPRay ||
            obj.rendererType == VolumeAttributes::RayCastingIntegration)
         {
             return true;
diff --git a/plots/Volume/VolumeAttributes.code b/plots/Volume/VolumeAttributes.code
index 8873455ad1..e8ecb65a5c 100644
--- a/plots/Volume/VolumeAttributes.code
+++ b/plots/Volume/VolumeAttributes.code
@@ -52,6 +52,9 @@ Definition:
 //    Allen Harvey, Thurs Nov 3 7:21:13 EST 2011
 //    Added checks for not doing resampling
 //
+//    Qi WU, Sat Jun 10 22:21:27 MST 2018
+//    Added RayCastingOSPRay option for volume rendering
+//
 // ****************************************************************************
 
 bool
@@ -71,6 +74,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
 
     if (rendererType == VolumeAttributes::RayCasting ||
         rendererType == VolumeAttributes::RayCastingSLIVR ||
+        rendererType == VolumeAttributes::RayCastingOSPRay ||
         rendererType == VolumeAttributes::RayCastingIntegration)
     {
         // Trilinear requires ghost zone while Rasterization and KernelBased do not
@@ -99,6 +103,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
         // modes does not require a reexecute.
         if(obj.rendererType == VolumeAttributes::RayCasting ||
            obj.rendererType == VolumeAttributes::RayCastingSLIVR ||
+           obj.rendererType == VolumeAttributes::RayCastingOSPRay ||
            obj.rendererType == VolumeAttributes::RayCastingIntegration)
         {
             return true;
@@ -664,3 +669,7 @@ Target: xml2cmake
 Condition: VISIT_SLIVR
 Definitions: -DVISIT_SLIVR
 
+Target: xml2cmake
+Condition: VISIT_OSPRAY
+Definitions: -DVISIT_OSPRAY
+
diff --git a/plots/Volume/VolumeAttributes.h b/plots/Volume/VolumeAttributes.h
index ac9aa85353..3567f46879 100644
--- a/plots/Volume/VolumeAttributes.h
+++ b/plots/Volume/VolumeAttributes.h
@@ -67,7 +67,8 @@ public:
         Default,
         RayCasting,
         RayCastingIntegration,
-        RayCastingSLIVR
+        RayCastingSLIVR,
+        RayCastingOSPRay
     };
     enum GradientType
     {
@@ -142,6 +143,16 @@ public:
     void SelectMaterialProperties();
 
     // Property setting methods
+    void SetOsprayShadowsEnabledFlag(bool osprayShadowsEnabledFlag_);
+    void SetOsprayUseGridAcceleratorFlag(bool osprayUseGridAcceleratorFlag_);
+    void SetOsprayPreIntegrationFlag(bool osprayPreIntegrationFlag_);
+    void SetOspraySingleShadeFlag(bool ospraySingleShadeFlag_);
+    void SetOsprayOneSidedLightingFlag(bool osprayOneSidedLightingFlag_);
+    void SetOsprayAoTransparencyEnabledFlag(bool osprayAoTransparencyEnabledFlag_);
+    void SetOspraySpp(int ospraySpp_);
+    void SetOsprayAoSamples(int osprayAoSamples_);
+    void SetOsprayAoDistance(double osprayAoDistance_);
+    void SetOsprayMinContribution(double osprayMinContribution_);
     void SetLegendFlag(bool legendFlag_);
     void SetLightingFlag(bool lightingFlag_);
     void SetColorControlPoints(const ColorControlPointList &colorControlPoints_);
@@ -176,6 +187,16 @@ public:
     void SetMaterialProperties(const double *materialProperties_);
 
     // Property getting methods
+    bool                           GetOsprayShadowsEnabledFlag() const;
+    bool                           GetOsprayUseGridAcceleratorFlag() const;
+    bool                           GetOsprayPreIntegrationFlag() const;
+    bool                           GetOspraySingleShadeFlag() const;
+    bool                           GetOsprayOneSidedLightingFlag() const;
+    bool                           GetOsprayAoTransparencyEnabledFlag() const;
+    int                            GetOspraySpp() const;
+    int                            GetOsprayAoSamples() const;
+    double                         GetOsprayAoDistance() const;
+    double                         GetOsprayMinContribution() const;
     bool                           GetLegendFlag() const;
     bool                           GetLightingFlag() const;
     const ColorControlPointList    &GetColorControlPoints() const;
@@ -276,7 +297,17 @@ public:
 
     // IDs that can be used to identify fields in case statements
     enum {
-        ID_legendFlag = 0,
+        ID_osprayShadowsEnabledFlag = 0,
+        ID_osprayUseGridAcceleratorFlag,
+        ID_osprayPreIntegrationFlag,
+        ID_ospraySingleShadeFlag,
+        ID_osprayOneSidedLightingFlag,
+        ID_osprayAoTransparencyEnabledFlag,
+        ID_ospraySpp,
+        ID_osprayAoSamples,
+        ID_osprayAoDistance,
+        ID_osprayMinContribution,
+        ID_legendFlag,
         ID_lightingFlag,
         ID_colorControlPoints,
         ID_opacityAttenuation,
@@ -312,6 +343,16 @@ public:
     };
 
 private:
+    bool                     osprayShadowsEnabledFlag;
+    bool                     osprayUseGridAcceleratorFlag;
+    bool                     osprayPreIntegrationFlag;
+    bool                     ospraySingleShadeFlag;
+    bool                     osprayOneSidedLightingFlag;
+    bool                     osprayAoTransparencyEnabledFlag;
+    int                      ospraySpp;
+    int                      osprayAoSamples;
+    double                   osprayAoDistance;
+    double                   osprayMinContribution;
     bool                     legendFlag;
     bool                     lightingFlag;
     ColorControlPointList    colorControlPoints;
@@ -349,6 +390,6 @@ private:
     static const char *TypeMapFormatString;
     static const private_tmfs_t TmfsStruct;
 };
-#define VOLUMEATTRIBUTES_TMFS "bbafiabissUbfbfbfbfbiiiidiifibdD"
+#define VOLUMEATTRIBUTES_TMFS "bbbbbbiiddbbafiabissUbfbfbfbfbiiiidiifibdD"
 
 #endif
diff --git a/plots/Volume/VolumeAttributes.java b/plots/Volume/VolumeAttributes.java
index 129f5a16d6..310f19b10d 100644
--- a/plots/Volume/VolumeAttributes.java
+++ b/plots/Volume/VolumeAttributes.java
@@ -61,13 +61,14 @@ import llnl.visit.GaussianControlPointList;
 
 public class VolumeAttributes extends AttributeSubject implements Plugin
 {
-    private static int VolumeAttributes_numAdditionalAtts = 32;
+    private static int VolumeAttributes_numAdditionalAtts = 42;
 
     // Enum values
     public final static int RENDERER_DEFAULT = 0;
     public final static int RENDERER_RAYCASTING = 1;
     public final static int RENDERER_RAYCASTINGINTEGRATION = 2;
     public final static int RENDERER_RAYCASTINGSLIVR = 3;
+    public final static int RENDERER_RAYCASTINGOSPRAY = 4;
 
     public final static int GRADIENTTYPE_CENTEREDDIFFERENCES = 0;
     public final static int GRADIENTTYPE_SOBELOPERATOR = 1;
@@ -101,6 +102,16 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
     {
         super(VolumeAttributes_numAdditionalAtts);
 
+        osprayShadowsEnabledFlag = false;
+        osprayUseGridAcceleratorFlag = false;
+        osprayPreIntegrationFlag = false;
+        ospraySingleShadeFlag = false;
+        osprayOneSidedLightingFlag = false;
+        osprayAoTransparencyEnabledFlag = false;
+        ospraySpp = 1;
+        osprayAoSamples = 0;
+        osprayAoDistance = 100000;
+        osprayMinContribution = 0.001;
         legendFlag = true;
         lightingFlag = true;
         colorControlPoints = new ColorControlPointList();
@@ -145,6 +156,16 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
     {
         super(VolumeAttributes_numAdditionalAtts + nMoreFields);
 
+        osprayShadowsEnabledFlag = false;
+        osprayUseGridAcceleratorFlag = false;
+        osprayPreIntegrationFlag = false;
+        ospraySingleShadeFlag = false;
+        osprayOneSidedLightingFlag = false;
+        osprayAoTransparencyEnabledFlag = false;
+        ospraySpp = 1;
+        osprayAoSamples = 0;
+        osprayAoDistance = 100000;
+        osprayMinContribution = 0.001;
         legendFlag = true;
         lightingFlag = true;
         colorControlPoints = new ColorControlPointList();
@@ -191,6 +212,16 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
 
         int i;
 
+        osprayShadowsEnabledFlag = obj.osprayShadowsEnabledFlag;
+        osprayUseGridAcceleratorFlag = obj.osprayUseGridAcceleratorFlag;
+        osprayPreIntegrationFlag = obj.osprayPreIntegrationFlag;
+        ospraySingleShadeFlag = obj.ospraySingleShadeFlag;
+        osprayOneSidedLightingFlag = obj.osprayOneSidedLightingFlag;
+        osprayAoTransparencyEnabledFlag = obj.osprayAoTransparencyEnabledFlag;
+        ospraySpp = obj.ospraySpp;
+        osprayAoSamples = obj.osprayAoSamples;
+        osprayAoDistance = obj.osprayAoDistance;
+        osprayMinContribution = obj.osprayMinContribution;
         legendFlag = obj.legendFlag;
         lightingFlag = obj.lightingFlag;
         colorControlPoints = new ColorControlPointList(obj.colorControlPoints);
@@ -258,7 +289,17 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
             materialProperties_equal = (materialProperties[i] == obj.materialProperties[i]);
 
         // Create the return value
-        return ((legendFlag == obj.legendFlag) &&
+        return ((osprayShadowsEnabledFlag == obj.osprayShadowsEnabledFlag) &&
+                (osprayUseGridAcceleratorFlag == obj.osprayUseGridAcceleratorFlag) &&
+                (osprayPreIntegrationFlag == obj.osprayPreIntegrationFlag) &&
+                (ospraySingleShadeFlag == obj.ospraySingleShadeFlag) &&
+                (osprayOneSidedLightingFlag == obj.osprayOneSidedLightingFlag) &&
+                (osprayAoTransparencyEnabledFlag == obj.osprayAoTransparencyEnabledFlag) &&
+                (ospraySpp == obj.ospraySpp) &&
+                (osprayAoSamples == obj.osprayAoSamples) &&
+                (osprayAoDistance == obj.osprayAoDistance) &&
+                (osprayMinContribution == obj.osprayMinContribution) &&
+                (legendFlag == obj.legendFlag) &&
                 (lightingFlag == obj.lightingFlag) &&
                 (colorControlPoints.equals(obj.colorControlPoints)) &&
                 (opacityAttenuation == obj.opacityAttenuation) &&
@@ -296,191 +337,251 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
     public String GetVersion() { return "1.1"; }
 
     // Property setting methods
+    public void SetOsprayShadowsEnabledFlag(boolean osprayShadowsEnabledFlag_)
+    {
+        osprayShadowsEnabledFlag = osprayShadowsEnabledFlag_;
+        Select(0);
+    }
+
+    public void SetOsprayUseGridAcceleratorFlag(boolean osprayUseGridAcceleratorFlag_)
+    {
+        osprayUseGridAcceleratorFlag = osprayUseGridAcceleratorFlag_;
+        Select(1);
+    }
+
+    public void SetOsprayPreIntegrationFlag(boolean osprayPreIntegrationFlag_)
+    {
+        osprayPreIntegrationFlag = osprayPreIntegrationFlag_;
+        Select(2);
+    }
+
+    public void SetOspraySingleShadeFlag(boolean ospraySingleShadeFlag_)
+    {
+        ospraySingleShadeFlag = ospraySingleShadeFlag_;
+        Select(3);
+    }
+
+    public void SetOsprayOneSidedLightingFlag(boolean osprayOneSidedLightingFlag_)
+    {
+        osprayOneSidedLightingFlag = osprayOneSidedLightingFlag_;
+        Select(4);
+    }
+
+    public void SetOsprayAoTransparencyEnabledFlag(boolean osprayAoTransparencyEnabledFlag_)
+    {
+        osprayAoTransparencyEnabledFlag = osprayAoTransparencyEnabledFlag_;
+        Select(5);
+    }
+
+    public void SetOspraySpp(int ospraySpp_)
+    {
+        ospraySpp = ospraySpp_;
+        Select(6);
+    }
+
+    public void SetOsprayAoSamples(int osprayAoSamples_)
+    {
+        osprayAoSamples = osprayAoSamples_;
+        Select(7);
+    }
+
+    public void SetOsprayAoDistance(double osprayAoDistance_)
+    {
+        osprayAoDistance = osprayAoDistance_;
+        Select(8);
+    }
+
+    public void SetOsprayMinContribution(double osprayMinContribution_)
+    {
+        osprayMinContribution = osprayMinContribution_;
+        Select(9);
+    }
+
     public void SetLegendFlag(boolean legendFlag_)
     {
         legendFlag = legendFlag_;
-        Select(0);
+        Select(10);
     }
 
     public void SetLightingFlag(boolean lightingFlag_)
     {
         lightingFlag = lightingFlag_;
-        Select(1);
+        Select(11);
     }
 
     public void SetColorControlPoints(ColorControlPointList colorControlPoints_)
     {
         colorControlPoints = colorControlPoints_;
-        Select(2);
+        Select(12);
     }
 
     public void SetOpacityAttenuation(float opacityAttenuation_)
     {
         opacityAttenuation = opacityAttenuation_;
-        Select(3);
+        Select(13);
     }
 
     public void SetOpacityMode(int opacityMode_)
     {
         opacityMode = opacityMode_;
-        Select(4);
+        Select(14);
     }
 
     public void SetOpacityControlPoints(GaussianControlPointList opacityControlPoints_)
     {
         opacityControlPoints = opacityControlPoints_;
-        Select(5);
+        Select(15);
     }
 
     public void SetResampleFlag(boolean resampleFlag_)
     {
         resampleFlag = resampleFlag_;
-        Select(6);
+        Select(16);
     }
 
     public void SetResampleTarget(int resampleTarget_)
     {
         resampleTarget = resampleTarget_;
-        Select(7);
+        Select(17);
     }
 
     public void SetOpacityVariable(String opacityVariable_)
     {
         opacityVariable = opacityVariable_;
-        Select(8);
+        Select(18);
     }
 
     public void SetCompactVariable(String compactVariable_)
     {
         compactVariable = compactVariable_;
-        Select(9);
+        Select(19);
     }
 
     public void SetFreeformOpacity(byte[] freeformOpacity_)
     {
         for(int i = 0; i < 256; ++i)
              freeformOpacity[i] = freeformOpacity_[i];
-        Select(10);
+        Select(20);
     }
 
     public void SetUseColorVarMin(boolean useColorVarMin_)
     {
         useColorVarMin = useColorVarMin_;
-        Select(11);
+        Select(21);
     }
 
     public void SetColorVarMin(float colorVarMin_)
     {
         colorVarMin = colorVarMin_;
-        Select(12);
+        Select(22);
     }
 
     public void SetUseColorVarMax(boolean useColorVarMax_)
     {
         useColorVarMax = useColorVarMax_;
-        Select(13);
+        Select(23);
     }
 
     public void SetColorVarMax(float colorVarMax_)
     {
         colorVarMax = colorVarMax_;
-        Select(14);
+        Select(24);
     }
 
     public void SetUseOpacityVarMin(boolean useOpacityVarMin_)
     {
         useOpacityVarMin = useOpacityVarMin_;
-        Select(15);
+        Select(25);
     }
 
     public void SetOpacityVarMin(float opacityVarMin_)
     {
         opacityVarMin = opacityVarMin_;
-        Select(16);
+        Select(26);
     }
 
     public void SetUseOpacityVarMax(boolean useOpacityVarMax_)
     {
         useOpacityVarMax = useOpacityVarMax_;
-        Select(17);
+        Select(27);
     }
 
     public void SetOpacityVarMax(float opacityVarMax_)
     {
         opacityVarMax = opacityVarMax_;
-        Select(18);
+        Select(28);
     }
 
     public void SetSmoothData(boolean smoothData_)
     {
         smoothData = smoothData_;
-        Select(19);
+        Select(29);
     }
 
     public void SetSamplesPerRay(int samplesPerRay_)
     {
         samplesPerRay = samplesPerRay_;
-        Select(20);
+        Select(30);
     }
 
     public void SetRendererType(int rendererType_)
     {
         rendererType = rendererType_;
-        Select(21);
+        Select(31);
     }
 
     public void SetGradientType(int gradientType_)
     {
         gradientType = gradientType_;
-        Select(22);
+        Select(32);
     }
 
     public void SetScaling(int scaling_)
     {
         scaling = scaling_;
-        Select(23);
+        Select(33);
     }
 
     public void SetSkewFactor(double skewFactor_)
     {
         skewFactor = skewFactor_;
-        Select(24);
+        Select(34);
     }
 
     public void SetLimitsMode(int limitsMode_)
     {
         limitsMode = limitsMode_;
-        Select(25);
+        Select(35);
     }
 
     public void SetSampling(int sampling_)
     {
         sampling = sampling_;
-        Select(26);
+        Select(36);
     }
 
     public void SetRendererSamples(float rendererSamples_)
     {
         rendererSamples = rendererSamples_;
-        Select(27);
+        Select(37);
     }
 
     public void SetLowGradientLightingReduction(int lowGradientLightingReduction_)
     {
         lowGradientLightingReduction = lowGradientLightingReduction_;
-        Select(28);
+        Select(38);
     }
 
     public void SetLowGradientLightingClampFlag(boolean lowGradientLightingClampFlag_)
     {
         lowGradientLightingClampFlag = lowGradientLightingClampFlag_;
-        Select(29);
+        Select(39);
     }
 
     public void SetLowGradientLightingClampValue(double lowGradientLightingClampValue_)
     {
         lowGradientLightingClampValue = lowGradientLightingClampValue_;
-        Select(30);
+        Select(40);
     }
 
     public void SetMaterialProperties(double[] materialProperties_)
@@ -489,7 +590,7 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
         materialProperties[1] = materialProperties_[1];
         materialProperties[2] = materialProperties_[2];
         materialProperties[3] = materialProperties_[3];
-        Select(31);
+        Select(41);
     }
 
     public void SetMaterialProperties(double e0, double e1, double e2, double e3)
@@ -498,10 +599,20 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
         materialProperties[1] = e1;
         materialProperties[2] = e2;
         materialProperties[3] = e3;
-        Select(31);
+        Select(41);
     }
 
     // Property getting methods
+    public boolean                  GetOsprayShadowsEnabledFlag() { return osprayShadowsEnabledFlag; }
+    public boolean                  GetOsprayUseGridAcceleratorFlag() { return osprayUseGridAcceleratorFlag; }
+    public boolean                  GetOsprayPreIntegrationFlag() { return osprayPreIntegrationFlag; }
+    public boolean                  GetOspraySingleShadeFlag() { return ospraySingleShadeFlag; }
+    public boolean                  GetOsprayOneSidedLightingFlag() { return osprayOneSidedLightingFlag; }
+    public boolean                  GetOsprayAoTransparencyEnabledFlag() { return osprayAoTransparencyEnabledFlag; }
+    public int                      GetOspraySpp() { return ospraySpp; }
+    public int                      GetOsprayAoSamples() { return osprayAoSamples; }
+    public double                   GetOsprayAoDistance() { return osprayAoDistance; }
+    public double                   GetOsprayMinContribution() { return osprayMinContribution; }
     public boolean                  GetLegendFlag() { return legendFlag; }
     public boolean                  GetLightingFlag() { return lightingFlag; }
     public ColorControlPointList    GetColorControlPoints() { return colorControlPoints; }
@@ -539,68 +650,88 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
     public void WriteAtts(CommunicationBuffer buf)
     {
         if(WriteSelect(0, buf))
-            buf.WriteBool(legendFlag);
+            buf.WriteBool(osprayShadowsEnabledFlag);
         if(WriteSelect(1, buf))
-            buf.WriteBool(lightingFlag);
+            buf.WriteBool(osprayUseGridAcceleratorFlag);
         if(WriteSelect(2, buf))
-            colorControlPoints.Write(buf);
+            buf.WriteBool(osprayPreIntegrationFlag);
         if(WriteSelect(3, buf))
-            buf.WriteFloat(opacityAttenuation);
+            buf.WriteBool(ospraySingleShadeFlag);
         if(WriteSelect(4, buf))
-            buf.WriteInt(opacityMode);
+            buf.WriteBool(osprayOneSidedLightingFlag);
         if(WriteSelect(5, buf))
-            opacityControlPoints.Write(buf);
+            buf.WriteBool(osprayAoTransparencyEnabledFlag);
         if(WriteSelect(6, buf))
-            buf.WriteBool(resampleFlag);
+            buf.WriteInt(ospraySpp);
         if(WriteSelect(7, buf))
-            buf.WriteInt(resampleTarget);
+            buf.WriteInt(osprayAoSamples);
         if(WriteSelect(8, buf))
-            buf.WriteString(opacityVariable);
+            buf.WriteDouble(osprayAoDistance);
         if(WriteSelect(9, buf))
-            buf.WriteString(compactVariable);
+            buf.WriteDouble(osprayMinContribution);
         if(WriteSelect(10, buf))
-            buf.WriteByteArray(freeformOpacity, true);
+            buf.WriteBool(legendFlag);
         if(WriteSelect(11, buf))
-            buf.WriteBool(useColorVarMin);
+            buf.WriteBool(lightingFlag);
         if(WriteSelect(12, buf))
-            buf.WriteFloat(colorVarMin);
+            colorControlPoints.Write(buf);
         if(WriteSelect(13, buf))
-            buf.WriteBool(useColorVarMax);
+            buf.WriteFloat(opacityAttenuation);
         if(WriteSelect(14, buf))
-            buf.WriteFloat(colorVarMax);
+            buf.WriteInt(opacityMode);
         if(WriteSelect(15, buf))
-            buf.WriteBool(useOpacityVarMin);
+            opacityControlPoints.Write(buf);
         if(WriteSelect(16, buf))
-            buf.WriteFloat(opacityVarMin);
+            buf.WriteBool(resampleFlag);
         if(WriteSelect(17, buf))
-            buf.WriteBool(useOpacityVarMax);
+            buf.WriteInt(resampleTarget);
         if(WriteSelect(18, buf))
-            buf.WriteFloat(opacityVarMax);
+            buf.WriteString(opacityVariable);
         if(WriteSelect(19, buf))
-            buf.WriteBool(smoothData);
+            buf.WriteString(compactVariable);
         if(WriteSelect(20, buf))
-            buf.WriteInt(samplesPerRay);
+            buf.WriteByteArray(freeformOpacity, true);
         if(WriteSelect(21, buf))
-            buf.WriteInt(rendererType);
+            buf.WriteBool(useColorVarMin);
         if(WriteSelect(22, buf))
-            buf.WriteInt(gradientType);
+            buf.WriteFloat(colorVarMin);
         if(WriteSelect(23, buf))
-            buf.WriteInt(scaling);
+            buf.WriteBool(useColorVarMax);
         if(WriteSelect(24, buf))
-            buf.WriteDouble(skewFactor);
+            buf.WriteFloat(colorVarMax);
         if(WriteSelect(25, buf))
-            buf.WriteInt(limitsMode);
+            buf.WriteBool(useOpacityVarMin);
         if(WriteSelect(26, buf))
-            buf.WriteInt(sampling);
+            buf.WriteFloat(opacityVarMin);
         if(WriteSelect(27, buf))
-            buf.WriteFloat(rendererSamples);
+            buf.WriteBool(useOpacityVarMax);
         if(WriteSelect(28, buf))
-            buf.WriteInt(lowGradientLightingReduction);
+            buf.WriteFloat(opacityVarMax);
         if(WriteSelect(29, buf))
-            buf.WriteBool(lowGradientLightingClampFlag);
+            buf.WriteBool(smoothData);
         if(WriteSelect(30, buf))
-            buf.WriteDouble(lowGradientLightingClampValue);
+            buf.WriteInt(samplesPerRay);
         if(WriteSelect(31, buf))
+            buf.WriteInt(rendererType);
+        if(WriteSelect(32, buf))
+            buf.WriteInt(gradientType);
+        if(WriteSelect(33, buf))
+            buf.WriteInt(scaling);
+        if(WriteSelect(34, buf))
+            buf.WriteDouble(skewFactor);
+        if(WriteSelect(35, buf))
+            buf.WriteInt(limitsMode);
+        if(WriteSelect(36, buf))
+            buf.WriteInt(sampling);
+        if(WriteSelect(37, buf))
+            buf.WriteFloat(rendererSamples);
+        if(WriteSelect(38, buf))
+            buf.WriteInt(lowGradientLightingReduction);
+        if(WriteSelect(39, buf))
+            buf.WriteBool(lowGradientLightingClampFlag);
+        if(WriteSelect(40, buf))
+            buf.WriteDouble(lowGradientLightingClampValue);
+        if(WriteSelect(41, buf))
             buf.WriteDoubleArray(materialProperties);
     }
 
@@ -609,101 +740,131 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
         switch(index)
         {
         case 0:
-            SetLegendFlag(buf.ReadBool());
+            SetOsprayShadowsEnabledFlag(buf.ReadBool());
             break;
         case 1:
-            SetLightingFlag(buf.ReadBool());
+            SetOsprayUseGridAcceleratorFlag(buf.ReadBool());
             break;
         case 2:
-            colorControlPoints.Read(buf);
-            Select(2);
+            SetOsprayPreIntegrationFlag(buf.ReadBool());
             break;
         case 3:
-            SetOpacityAttenuation(buf.ReadFloat());
+            SetOspraySingleShadeFlag(buf.ReadBool());
             break;
         case 4:
-            SetOpacityMode(buf.ReadInt());
+            SetOsprayOneSidedLightingFlag(buf.ReadBool());
             break;
         case 5:
-            opacityControlPoints.Read(buf);
-            Select(5);
+            SetOsprayAoTransparencyEnabledFlag(buf.ReadBool());
             break;
         case 6:
-            SetResampleFlag(buf.ReadBool());
+            SetOspraySpp(buf.ReadInt());
             break;
         case 7:
-            SetResampleTarget(buf.ReadInt());
+            SetOsprayAoSamples(buf.ReadInt());
             break;
         case 8:
-            SetOpacityVariable(buf.ReadString());
+            SetOsprayAoDistance(buf.ReadDouble());
             break;
         case 9:
-            SetCompactVariable(buf.ReadString());
+            SetOsprayMinContribution(buf.ReadDouble());
             break;
         case 10:
-            SetFreeformOpacity(buf.ReadByteArray());
+            SetLegendFlag(buf.ReadBool());
             break;
         case 11:
-            SetUseColorVarMin(buf.ReadBool());
+            SetLightingFlag(buf.ReadBool());
             break;
         case 12:
-            SetColorVarMin(buf.ReadFloat());
+            colorControlPoints.Read(buf);
+            Select(12);
             break;
         case 13:
-            SetUseColorVarMax(buf.ReadBool());
+            SetOpacityAttenuation(buf.ReadFloat());
             break;
         case 14:
-            SetColorVarMax(buf.ReadFloat());
+            SetOpacityMode(buf.ReadInt());
             break;
         case 15:
-            SetUseOpacityVarMin(buf.ReadBool());
+            opacityControlPoints.Read(buf);
+            Select(15);
             break;
         case 16:
-            SetOpacityVarMin(buf.ReadFloat());
+            SetResampleFlag(buf.ReadBool());
             break;
         case 17:
-            SetUseOpacityVarMax(buf.ReadBool());
+            SetResampleTarget(buf.ReadInt());
             break;
         case 18:
-            SetOpacityVarMax(buf.ReadFloat());
+            SetOpacityVariable(buf.ReadString());
             break;
         case 19:
-            SetSmoothData(buf.ReadBool());
+            SetCompactVariable(buf.ReadString());
             break;
         case 20:
-            SetSamplesPerRay(buf.ReadInt());
+            SetFreeformOpacity(buf.ReadByteArray());
             break;
         case 21:
-            SetRendererType(buf.ReadInt());
+            SetUseColorVarMin(buf.ReadBool());
             break;
         case 22:
-            SetGradientType(buf.ReadInt());
+            SetColorVarMin(buf.ReadFloat());
             break;
         case 23:
-            SetScaling(buf.ReadInt());
+            SetUseColorVarMax(buf.ReadBool());
             break;
         case 24:
-            SetSkewFactor(buf.ReadDouble());
+            SetColorVarMax(buf.ReadFloat());
             break;
         case 25:
-            SetLimitsMode(buf.ReadInt());
+            SetUseOpacityVarMin(buf.ReadBool());
             break;
         case 26:
-            SetSampling(buf.ReadInt());
+            SetOpacityVarMin(buf.ReadFloat());
             break;
         case 27:
-            SetRendererSamples(buf.ReadFloat());
+            SetUseOpacityVarMax(buf.ReadBool());
             break;
         case 28:
-            SetLowGradientLightingReduction(buf.ReadInt());
+            SetOpacityVarMax(buf.ReadFloat());
             break;
         case 29:
-            SetLowGradientLightingClampFlag(buf.ReadBool());
+            SetSmoothData(buf.ReadBool());
             break;
         case 30:
-            SetLowGradientLightingClampValue(buf.ReadDouble());
+            SetSamplesPerRay(buf.ReadInt());
             break;
         case 31:
+            SetRendererType(buf.ReadInt());
+            break;
+        case 32:
+            SetGradientType(buf.ReadInt());
+            break;
+        case 33:
+            SetScaling(buf.ReadInt());
+            break;
+        case 34:
+            SetSkewFactor(buf.ReadDouble());
+            break;
+        case 35:
+            SetLimitsMode(buf.ReadInt());
+            break;
+        case 36:
+            SetSampling(buf.ReadInt());
+            break;
+        case 37:
+            SetRendererSamples(buf.ReadFloat());
+            break;
+        case 38:
+            SetLowGradientLightingReduction(buf.ReadInt());
+            break;
+        case 39:
+            SetLowGradientLightingClampFlag(buf.ReadBool());
+            break;
+        case 40:
+            SetLowGradientLightingClampValue(buf.ReadDouble());
+            break;
+        case 41:
             SetMaterialProperties(buf.ReadDoubleArray());
             break;
         }
@@ -712,6 +873,16 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
     public String toString(String indent)
     {
         String str = new String();
+        str = str + boolToString("osprayShadowsEnabledFlag", osprayShadowsEnabledFlag, indent) + "\n";
+        str = str + boolToString("osprayUseGridAcceleratorFlag", osprayUseGridAcceleratorFlag, indent) + "\n";
+        str = str + boolToString("osprayPreIntegrationFlag", osprayPreIntegrationFlag, indent) + "\n";
+        str = str + boolToString("ospraySingleShadeFlag", ospraySingleShadeFlag, indent) + "\n";
+        str = str + boolToString("osprayOneSidedLightingFlag", osprayOneSidedLightingFlag, indent) + "\n";
+        str = str + boolToString("osprayAoTransparencyEnabledFlag", osprayAoTransparencyEnabledFlag, indent) + "\n";
+        str = str + intToString("ospraySpp", ospraySpp, indent) + "\n";
+        str = str + intToString("osprayAoSamples", osprayAoSamples, indent) + "\n";
+        str = str + doubleToString("osprayAoDistance", osprayAoDistance, indent) + "\n";
+        str = str + doubleToString("osprayMinContribution", osprayMinContribution, indent) + "\n";
         str = str + boolToString("legendFlag", legendFlag, indent) + "\n";
         str = str + boolToString("lightingFlag", lightingFlag, indent) + "\n";
         str = str + indent + "colorControlPoints = {\n" + colorControlPoints.toString(indent + "    ") + indent + "}\n";
@@ -749,6 +920,8 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
             str = str + "RENDERER_RAYCASTINGINTEGRATION";
         if(rendererType == RENDERER_RAYCASTINGSLIVR)
             str = str + "RENDERER_RAYCASTINGSLIVR";
+        if(rendererType == RENDERER_RAYCASTINGOSPRAY)
+            str = str + "RENDERER_RAYCASTINGOSPRAY";
         str = str + "\n";
         str = str + indent + "gradientType = ";
         if(gradientType == GRADIENTTYPE_CENTEREDDIFFERENCES)
@@ -806,6 +979,16 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
 
 
     // Attributes
+    private boolean                  osprayShadowsEnabledFlag;
+    private boolean                  osprayUseGridAcceleratorFlag;
+    private boolean                  osprayPreIntegrationFlag;
+    private boolean                  ospraySingleShadeFlag;
+    private boolean                  osprayOneSidedLightingFlag;
+    private boolean                  osprayAoTransparencyEnabledFlag;
+    private int                      ospraySpp;
+    private int                      osprayAoSamples;
+    private double                   osprayAoDistance;
+    private double                   osprayMinContribution;
     private boolean                  legendFlag;
     private boolean                  lightingFlag;
     private ColorControlPointList    colorControlPoints;
diff --git a/plots/Volume/avtVolumeFilter.C b/plots/Volume/avtVolumeFilter.C
index 23a1e585db..f9b746c14b 100644
--- a/plots/Volume/avtVolumeFilter.C
+++ b/plots/Volume/avtVolumeFilter.C
@@ -79,6 +79,13 @@
 #include <avtSLIVRRayTracer.h>
 #endif
 
+#ifdef VISIT_OSPRAY
+# define VISIT_OSPRAY_CONTEXT_ONLY /*dont have to include helper funcitons*/
+# include <avtOSPRayCommon.h>
+# undef VISIT_OSPRAY_CONTEXT_ONLY
+# include <avtOSPRayRayTracer.h>
+#endif
+
 //
 // Function Prototypes
 //
@@ -103,6 +110,9 @@ static void CreateViewInfoFromViewAttributes(avtViewInfo &,
 avtVolumeFilter::avtVolumeFilter()
 {
     primaryVariable = NULL;
+#ifdef VISIT_OSPRAY
+    ospray = NULL;
+#endif
 }
 
 
@@ -126,6 +136,11 @@ avtVolumeFilter::~avtVolumeFilter()
         delete [] primaryVariable;
         primaryVariable = NULL;
     }
+#ifdef VISIT_OSPRAY
+    if (ospray != NULL) {
+      delete (OSPVisItContext*)ospray;
+    }
+#endif
 }
 
 
@@ -225,10 +240,14 @@ avtVolumeFilter::Execute(void)
     int t1 = visitTimer->StartTimer();
 
     // Get the local histogram for this rank.
+    // const std::string variableName_ =
+    //  (atts.GetScaling() == VolumeAttributes::Linear) ?
+    //  primaryVariable : "_expr_" + std::string(primaryVariable);
+    // std::cout << "primaryVariable = " << primaryVariable << std::endl;
     std::vector<VISIT_LONG_LONG> numvals_in(numValsInHist, 0);
-    if( avtDatasetExaminer::CalculateHistogram(ds, primaryVariable,
-                                               minmax[0], minmax[1],
-                                               numvals_in) )
+    if(avtDatasetExaminer::CalculateHistogram(ds, primaryVariable,
+                                              minmax[0], minmax[1],
+                                              numvals_in))
         
     {
       debug1 << "CalculateHistogram failed for "
@@ -237,8 +256,8 @@ avtVolumeFilter::Execute(void)
 
     // Get the global histograms acrosss all ranks.
     std::vector<VISIT_LONG_LONG> numvals_out(numValsInHist, 0);
-    SumLongLongArrayAcrossAllProcessors( &(numvals_in[0]),
-                                         &(numvals_out[0]), numValsInHist);
+    SumLongLongArrayAcrossAllProcessors(&(numvals_in[0]),
+                                        &(numvals_out[0]), numValsInHist);
     
     VISIT_LONG_LONG maxVal = 0;
     for (i = 0 ; i < numValsInHist ; i++)
@@ -292,20 +311,36 @@ avtVolumeFilter::CreateOpacityMap(double range[2])
     if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR)
     {
         // Set the opacity map. This modifies the opacities though.
-        om.SetTable(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0, atts.GetRendererSamples());
-        om.SetTableFloat(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0, atts.GetRendererSamples());
+        om.SetTable(vtf, 256, atts.GetOpacityAttenuation() * 2.0 - 1.0,
+                    atts.GetRendererSamples());
+        om.SetTableFloat(vtf, 256, atts.GetOpacityAttenuation() * 2.0 - 1.0,
+                         atts.GetRendererSamples());
     }
     else
 #endif
     {
-        if ((atts.GetRendererType() == VolumeAttributes::RayCasting) && (atts.GetSampling() == VolumeAttributes::Trilinear))
-            om.SetTable(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0, atts.GetRendererSamples());
+#ifdef VISIT_OSPRAY
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay)
+    {
+        om.SetTable(vtf, 256, atts.GetOpacityAttenuation() * 2.0 - 1.0, 
+                    atts.GetRendererSamples());
+        om.SetTableFloatNOC(vtf, 256,
+                            atts.GetOpacityAttenuation() * 2.0 - 1.0); 
+    }
+    else
+#endif
+    {
+        if ((atts.GetRendererType() == VolumeAttributes::RayCasting) && 
+            (atts.GetSampling() == VolumeAttributes::Trilinear))
+            om.SetTable(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0,
+                        atts.GetRendererSamples());
         else
         {
             // Set the opacity map just using the transfer function.
             om.SetTable(vtf, 256, atts.GetOpacityAttenuation());
         }
     }
+    }
 
     double actualRange[2];
     bool artificialMin = atts.GetUseColorVarMin();
@@ -345,7 +380,7 @@ avtVolumeFilter::CreateOpacityMap(double range[2])
     }
     om.SetMin(range[0]);
     om.SetMax(range[1]);
-    om.computeVisibleRange();
+    om.ComputeVisibleRange();
 
     if (atts.GetRendererType() == VolumeAttributes::RayCastingIntegration)
     {
@@ -370,11 +405,13 @@ avtVolumeFilter::CreateOpacityMap(double range[2])
     return om;
 }
 
-extern bool GetLogicalBounds(avtDataObject_p input,int &width,int &height, int &depth);
+extern bool GetLogicalBounds(avtDataObject_p input,
+                             int &width,int &height, int &depth);
+
+#if defined(VISIT_SLIVR) || defined(VISIT_OSPRAY)
 
-#ifdef VISIT_SLIVR
 // ****************************************************************************
-//  Method: avtVolumeFilter::RenderImageRaycastingSLIVR
+//  Method: avtVolumeFilter::RenderImageRayCasting
 //
 //  Purpose:
 //      Do SW rendering with SLIVR.
@@ -389,8 +426,8 @@ extern bool GetLogicalBounds(avtDataObject_p input,int &width,int &height, int &
 // ****************************************************************************
 
 avtImage_p
-avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
-                             const WindowAttributes &window)
+avtVolumeFilter::RenderImageRayCasting(avtImage_p opaque_image,
+                                 const WindowAttributes &window)
 {
     //
     // We need to create a dummy pipeline with the volume renderer that we
@@ -401,7 +438,23 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     //
     // Set up the volume renderer.
     //
-    avtSLIVRRayTracer *software = new avtSLIVRRayTracer;
+    avtRayTracerBase *software = nullptr;
+#ifdef VISIT_SLIVR
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) {        
+        software = new avtSLIVRRayTracer;
+    }
+    else
+#endif
+    {
+#ifdef VISIT_OSPRAY
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay) {
+        software = new avtOSPRayRayTracer;
+        if (ospray == NULL) { ospray = new OSPVisItContext; }
+        ((avtOSPRayRayTracer*)software)->SetOSPRay
+                                           ((OSPVisItContext*)ospray);
+    }
+#endif
+    }
     software->SetInput(termsrc.GetOutput());
     software->InsertOpaqueImage(opaque_image);
 
@@ -410,7 +463,7 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     //
     double range[2] = {0., 0.};
     avtOpacityMap om(CreateOpacityMap(range));
-    om.computeVisibleRange();
+    om.ComputeVisibleRange();
 
     avtFlatLighting fl;
     avtLightingModel *lm = &fl;
@@ -418,9 +471,9 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     avtCompositeRF *compositeRF = new avtCompositeRF(lm, &om, &om);
     software->SetTransferFn(&om);
 
-    debug5 << "Min visible scalar range:" << om.GetMinVisibleScalar() << "  Max visible scalar range: "  <<  om.GetMaxVisibleScalar() << std::endl;
-
-
+    debug5 << "Min visible scalar range: " << om.GetMinVisibleScalar() << " "
+           << "Max visible scalar range: " << om.GetMaxVisibleScalar()
+           << std::endl;
 
     //
     // Determine which variables to use and tell the ray function.
@@ -437,7 +490,8 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     const char *gradvar = atts.GetOpacityVariable().c_str();
     if (strcmp(gradvar, "default") == 0)
         gradvar = primaryVariable;
-    // This name is explicitly sent to the avtGradientExpression in avtVolumePlot.
+    // This name is explicitly sent to the avtGradientExpression in
+    // avtVolumePlot.
     SNPRINTF(gradName, 128, "_%s_gradient", gradvar);
 
     for (int i = 0 ; i < vl.nvars ; i++)
@@ -454,10 +508,10 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
         {
             opacIndex = count;
         }
-       // if (vl.varnames[i] == gradName)
-       // {
-       //     gradIndex = count;
-       // }
+        // if (vl.varnames[i] == gradName)
+        // {
+        //     gradIndex = count;
+        // }
         count += vl.varsizes[i];
     }
 
@@ -494,16 +548,12 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
         }
     }
 
-
     //
     // Unsure about this one??? RayFunction seems important
     //
     software->SetRayFunction(compositeRF);
     software->SetSamplesPerRay(atts.GetSamplesPerRay());
-
-    debug5 << "Sampling rate: "  << atts.GetRendererSamples() << std::endl;
-
-
+    debug5 << "Sampling rate: " << atts.GetRendererSamples() << std::endl;
 
     //
     // Set camera parameters
@@ -521,66 +571,90 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     {
         double viewDirection[3];
         int numSlices;
-
-        viewDirection[0] = (view.GetViewNormal()[0] > 0)? view.GetViewNormal()[0]: -view.GetViewNormal()[0];
-        viewDirection[1] = (view.GetViewNormal()[1] > 0)? view.GetViewNormal()[1]: -view.GetViewNormal()[1];
-        viewDirection[2] = (view.GetViewNormal()[2] > 0)? view.GetViewNormal()[2]: -view.GetViewNormal()[2];
-
-        numSlices = (width_*viewDirection[0] + height_*viewDirection[1] + depth_*viewDirection[2]) * atts.GetRendererSamples();
-
+        viewDirection[0] = (view.GetViewNormal()[0] > 0)?
+            view.GetViewNormal()[0]:
+            -view.GetViewNormal()[0];
+        viewDirection[1] = (view.GetViewNormal()[1] > 0)?
+            view.GetViewNormal()[1]:
+            -view.GetViewNormal()[1];
+        viewDirection[2] = (view.GetViewNormal()[2] > 0)?
+            view.GetViewNormal()[2]: 
+            -view.GetViewNormal()[2];
+        numSlices = (width_ * viewDirection[0] +
+                     height_* viewDirection[1] + 
+                     depth_ * viewDirection[2]) * atts.GetRendererSamples();
         software->SetSamplesPerRay(numSlices);
-        debug5 << "RayCastingSLIVR - slices: "<< numSlices << " : " << width_ << " ,  " << height_  << " , " << depth_ << endl;
     }
-
     software->SetView(vi);
 
-    double view_dir[3];
-    view_dir[0] = vi.focus[0] - vi.camera[0];
-    view_dir[1] = vi.focus[1] - vi.camera[1];
-    view_dir[2] = vi.focus[2] - vi.camera[2];
-    double mag = sqrt(view_dir[0]*view_dir[0] + view_dir[1]*view_dir[1]
-                      + view_dir[2]*view_dir[2]);
+    double viewDirection[3];
+    viewDirection[0] = vi.focus[0] - vi.camera[0];
+    viewDirection[1] = vi.focus[1] - vi.camera[1];
+    viewDirection[2] = vi.focus[2] - vi.camera[2];
+    double mag = sqrt(viewDirection[0]*viewDirection[0] + viewDirection[1]*viewDirection[1]
+                      + viewDirection[2]*viewDirection[2]);
     if (mag != 0.) // only 0 if focus and camera are the same
     {
-        view_dir[0] /= mag;
-        view_dir[1] /= mag;
-        view_dir[2] /= mag;
+        viewDirection[0] /= mag;
+        viewDirection[1] /= mag;
+        viewDirection[2] /= mag;
     }
-    software->SetViewDirection(view_dir);
 
     //
     // Set up lighting and material properties
     //
-    if (atts.GetLightingFlag())
-        software->SetLighting(true);
-    else
-        software->SetLighting(false);
-
-    double tempLightDir[3];
-    tempLightDir[0] = ((window.GetLights()).GetLight(0)).GetDirection()[0];
-    tempLightDir[1] = ((window.GetLights()).GetLight(0)).GetDirection()[1];
-    tempLightDir[2] = ((window.GetLights()).GetLight(0)).GetDirection()[2];
-    software->SetLightDirection(tempLightDir);
-
     double *matProp = atts.GetMaterialProperties();
     double materialPropArray[4];
     materialPropArray[0] = matProp[0];
     materialPropArray[1] = matProp[1];
     materialPropArray[2] = matProp[2];
     materialPropArray[3] = matProp[3];
-    software->SetMatProperties(materialPropArray);
-
-
+    
+#ifdef VISIT_SLIVR
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) {
+      double tempLightDir[3];
+      tempLightDir[0] = ((window.GetLights()).GetLight(0)).GetDirection()[0];
+      tempLightDir[1] = ((window.GetLights()).GetLight(0)).GetDirection()[1];
+      tempLightDir[2] = ((window.GetLights()).GetLight(0)).GetDirection()[2];      
+      avtSLIVRRayTracer* s = (avtSLIVRRayTracer*)software;
+      s->SetViewDirection(viewDirection);
+      s->SetLighting(atts.GetLightingFlag());
+      s->SetLightDirection(tempLightDir);
+      s->SetMatProperties(materialPropArray);
+    } else
+#endif
+    {
+#ifdef VISIT_OSPRAY
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay) {
+      avtOSPRayRayTracer* s = (avtOSPRayRayTracer*)software;
+      s->SetActiveVariable(primaryVariable);
+      s->SetLightInfo(window.GetLights());
+      s->SetMatProperties(materialPropArray);
+      s->SetViewDirection(viewDirection);
+      s->SetLighting(atts.GetLightingFlag());
+      s->SetSamplingRate(atts.GetRendererSamples());
+      s->SetShadowsEnabled(atts.GetOsprayShadowsEnabledFlag());
+      s->SetUseGridAccelerator(atts.GetOsprayUseGridAcceleratorFlag());
+      s->SetPreIntegration(atts.GetOsprayPreIntegrationFlag());
+      s->SetSingleShade(atts.GetOspraySingleShadeFlag());
+      s->SetOneSidedLighting(atts.GetOsprayOneSidedLightingFlag());
+      s->SetAoTransparencyEnabled(atts.GetOsprayAoTransparencyEnabledFlag());
+      s->SetSpp(atts.GetOspraySpp());
+      s->SetAoSamples(atts.GetOsprayAoSamples());
+      s->SetAoDistance(atts.GetOsprayAoDistance());
+      s->SetMinContribution(atts.GetOsprayMinContribution());
+    }
+#endif
+    }
 
     //
     // Set the volume renderer's background color and mode from the
     // window attributes.
     //
-    //software->SetBackgroundMode(window.GetBackgroundMode());
     software->SetBackgroundColor(window.GetBackground());
+    //software->SetBackgroundMode(window.GetBackgroundMode());
     //software->SetGradientBackgroundColors(window.GetGradBG1(), window.GetGradBG2());
 
-
     //
     // Do the funny business to force an update. ... and called avtDataObject
     //
@@ -592,7 +666,6 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     //
     delete software;
     avtRay::SetArbitrator(NULL);
-
     delete compositeRF;
 
     //
@@ -715,9 +788,10 @@ avtImage_p
 avtVolumeFilter::RenderImage(avtImage_p opaque_image,
                              const WindowAttributes &window)
 {
-#ifdef VISIT_SLIVR
-    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR){
-        return RenderImageRaycastingSLIVR(opaque_image,window);
+#if defined(VISIT_SLIVR) || defined(VISIT_SLIVR)
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+        atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay){
+        return RenderImageRayCasting(opaque_image,window);
     }
 #endif
 
@@ -1247,7 +1321,8 @@ avtVolumeFilter::ModifyContract(avtContract_p contract)
     {
         if (((atts.GetRendererType() == VolumeAttributes::RayCasting) &&
             (atts.GetSampling() == VolumeAttributes::Trilinear)) ||
-            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR))
+            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) ||
+            (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay))
             ds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
         newcontract = new avtContract(contract, ds);
         primaryVariable = new char[strlen(var)+1];
@@ -1272,7 +1347,8 @@ avtVolumeFilter::ModifyContract(avtContract_p contract)
 
         if (((atts.GetRendererType() == VolumeAttributes::RayCasting) &&
             (atts.GetSampling() == VolumeAttributes::Trilinear)) ||
-            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR))
+            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) ||
+            (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay))
             nds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
         newcontract = new avtContract(contract, nds);
         primaryVariable = new char[exprName.size()+1];
@@ -1289,7 +1365,8 @@ avtVolumeFilter::ModifyContract(avtContract_p contract)
         nds->AddSecondaryVariable(var);
         if (((atts.GetRendererType() == VolumeAttributes::RayCasting) &&
             (atts.GetSampling() == VolumeAttributes::Trilinear)) ||
-            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR))
+            (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) ||
+            (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay))
             nds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
         newcontract = new avtContract(contract, nds);
         primaryVariable = new char[strlen(exprName.c_str())+1];
diff --git a/plots/Volume/avtVolumeFilter.h b/plots/Volume/avtVolumeFilter.h
index d60df439ed..675a8121bb 100644
--- a/plots/Volume/avtVolumeFilter.h
+++ b/plots/Volume/avtVolumeFilter.h
@@ -44,11 +44,11 @@
 #define AVT_VOLUME_FILTER_H
 
 #include <avtDatasetToDatasetFilter.h>
-#include <avtOpacityMap.h>
 
 #include <VolumeAttributes.h>
 
 #include <avtImage.h>
+#include <avtOpacityMap.h>
 
 class     WindowAttributes;
 
@@ -75,6 +75,9 @@ class     WindowAttributes;
 //    Jeremy Meredith, Thu Feb 15 11:44:28 EST 2007
 //    Added support for rectilinear grids with an inherent transform.
 //
+//    Qi WU, Wed Jun 20 2018
+//    Added support for ospray volume rendering filter
+//
 // ****************************************************************************
 
 class avtVolumeFilter : public avtDatasetToDatasetFilter
@@ -89,15 +92,22 @@ class avtVolumeFilter : public avtDatasetToDatasetFilter
                                   { return "Volume rendering"; };
 
     avtImage_p               RenderImage(avtImage_p, const WindowAttributes &);
-#ifdef VISIT_SLIVR
-    avtImage_p               RenderImageRaycastingSLIVR(avtImage_p opaque_image, const WindowAttributes &);
+    
+#if defined(VISIT_SLIVR) || defined(VISIT_OSPRAY)
+    avtImage_p               RenderImageRayCasting(avtImage_p,
+                                                   const WindowAttributes &);
 #endif
+
     int                      GetNumberOfStages(const WindowAttributes &);
 
   protected:
     VolumeAttributes         atts;
     char                    *primaryVariable;
 
+#ifdef VISIT_OSPRAY /* handler for ospray volume rendering filter*/
+    void                    *ospray;
+#endif
+
     avtOpacityMap            CreateOpacityMap(double range[2]);
 
     virtual void             Execute(void);
diff --git a/plots/Volume/avtVolumePlot.C b/plots/Volume/avtVolumePlot.C
index ecdf4b192e..6ef3990c6a 100644
--- a/plots/Volume/avtVolumePlot.C
+++ b/plots/Volume/avtVolumePlot.C
@@ -233,7 +233,8 @@ avtVolumePlot::PlotIsImageBased(void)
 {
     return (atts.GetRendererType() == VolumeAttributes::RayCasting ||
             atts.GetRendererType() == VolumeAttributes::RayCastingIntegration ||
-            atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR);
+            atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+            atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay);
 }
 
 
@@ -689,7 +690,8 @@ avtVolumePlot::ApplyRenderingTransformation(avtDataObject_p input)
 
     if (atts.GetRendererType() == VolumeAttributes::RayCasting ||
         atts.GetRendererType() == VolumeAttributes::RayCastingIntegration ||
-        atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR)
+        atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+        atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay)
     {
 #ifdef ENGINE
         // gradient calc for raycasting integration not needed, but
diff --git a/sim/V2/runtime/CMakeLists.txt b/sim/V2/runtime/CMakeLists.txt
index 9c87f8f898..7b4b0c6fb6 100644
--- a/sim/V2/runtime/CMakeLists.txt
+++ b/sim/V2/runtime/CMakeLists.txt
@@ -172,8 +172,8 @@ VISIT_INSTALL_TARGETS(simV2runtime_ser)
 
 IF(VISIT_PARALLEL)
     ADD_PARALLEL_LIBRARY(simV2runtime_par ${LIBSIM_RUNTIME_SOURCES} ${LIBSIM_STATIC_SOURCES})
-#    TARGET_LINK_LIBRARIES(simV2runtime_par engine_par vtksys vtkpng vtkmetaio vtkDICOMParser vtkImagingSources vtkglew vtkCommonSystem vtkCommonColor vtkCommonComputationalGeometry vtkFiltersStatistics vtkalglib vtklz4 vtkImagingFourier ${LIBSIM_RUNTIME_VIEWER_LIBS_PAR})
-    TARGET_LINK_LIBRARIES(simV2runtime_par engine_par ${VTK_LIBRARIES} ${LIBSIM_RUNTIME_VIEWER_LIBS_PAR})
+
+    TARGET_LINK_LIBRARIES(simV2runtime_par engine_par ${LIBSIM_RUNTIME_VIEWER_LIBS_PAR})
     IF(NOT APPLE)
         SET_TARGET_PROPERTIES(simV2runtime_par PROPERTIES INSTALL_RPATH "$ORIGIN")
     ENDIF(NOT APPLE)
diff --git a/svn_bin/bv_support/bv_embree.sh b/svn_bin/bv_support/bv_embree.sh
new file mode 100644
index 0000000000..3793e836f8
--- /dev/null
+++ b/svn_bin/bv_support/bv_embree.sh
@@ -0,0 +1,171 @@
+function bv_embree_initialize
+{
+    export DO_EMBREE="no"
+    export USE_SYSTEM_EMBREE="no"
+    add_extra_commandline_args "embree" "alt-embree-dir" 1 "Use alternative directory for embree"
+}
+
+function bv_embree_enable
+{
+    DO_EMBREE="yes"
+}
+
+function bv_embree_disable
+{
+    DO_EMBREE="no"
+}
+
+function bv_embree_alt_embree_dir
+{
+    echo "Using alternate embree directory"
+    bv_embree_enable
+    USE_SYSTEM_EMBREE="yes"
+    EMBREE_INSTALL_DIR="$1"
+}
+
+function bv_embree_depends_on
+{
+    echo ""
+}
+
+function bv_embree_initialize_vars
+{
+    info "initializing embree vars"
+    if [[ "$DO_EMBREE" == "yes" ]] ; then
+        if [[ "$USE_SYSTEM_EMBREE" == "no" ]]; then
+            EMBREE_INSTALL_DIR=$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH
+        fi
+    fi
+}
+
+function bv_embree_info
+{
+    export EMBREE_VERSION=${EMBREE_VERSION:-"3.2.0"}
+    if [[ "$OPSYS" == "Darwin" ]] ; then
+        export EMBREE_FILE=${EMBREE_FILE:-"embree-${EMBREE_VERSION}.x86_64.macosx.tar.gz"}
+        export EMBREE_INSTALL_DIR_NAME=embree-$EMBREE_VERSION.x86_64.macosx
+    else
+        export EMBREE_FILE=${EMBREE_FILE:-"embree-${EMBREE_VERSION}.x86_64.linux.tar.gz"}
+        export EMBREE_INSTALL_DIR_NAME=embree-$EMBREE_VERSION.x86_64.linux
+    fi
+    export EMBREE_COMPATIBILITY_VERSION=${EMBREE_COMPATIBILITY_VERSION:-"${EMBREE_VERSION}"}
+    export EMBREE_BUILD_DIR=${EMBREE_BUILD_DIR:-"${EMBREE_VERSION}"}
+    export EMBREE_URL=${EMBREE_URL:-"https://github.com/embree/embree/releases/download/v${EMBREE_VERSION}/"}
+
+    export EMBREE_MD5_CHECKSUM=""
+    export EMBREE_SHA256_CHECKSUM=""
+}
+
+function bv_embree_print
+{
+    printf "%s%s\n" "EMBREE_FILE=" "${EMBREE_FILE}"
+    printf "%s%s\n" "EMBREE_VERSION=" "${EMBREE_VERSION}"
+    printf "%s%s\n" "EMBREE_COMPATIBILITY_VERSION=" "${EMBREE_COMPATIBILITY_VERSION}"
+    printf "%s%s\n" "EMBREE_BUILD_DIR=" "${EMBREE_BUILD_DIR}"
+}
+
+function bv_embree_host_profile
+{
+    if [[ "$DO_EMBREE" == "yes" ]] ; then
+        echo >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        echo "## EMBREE" >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        if [[ "$USE_SYSTEM_EMBREE" == "no" ]]; then
+            echo "VISIT_OPTION_DEFAULT(VISIT_EMBREE_ROOT \${VISITHOME}/embree/$EMBREE_VERSION/\${VISITARCH})" >> $HOSTCONF
+        else
+            echo "VISIT_OPTION_DEFAULT(VISIT_EMBREE_ROOT ${EMBREE_INSTALL_DIR})" >> $HOSTCONF
+        fi
+    fi
+}
+
+function bv_embree_print_usage
+{
+    #embree does not have an option, it is only dependent on embree.
+    printf "%-15s %s [%s]\n" "--embree" "Build embree" "$DO_EMBREE"
+}
+
+function bv_embree_ensure
+{
+    if [[ "$DO_EMBREE" == "yes" && "$USE_SYSTEM_EMBREE" == "no" ]] ; then
+        ensure_built_or_ready "embree" $EMBREE_VERSION $EMBREE_BUILD_DIR $EMBREE_FILE $EMBREE_URL
+        if [[ $? != 0 ]] ; then
+            ANY_ERRORS="yes"
+            DO_EMBREE="no"
+            error "Unable to build embree.  ${EMBREE_FILE} not found."
+        fi
+    elif [[ "$USE_SYSTEM_EMBREE" == "yes" ]] ; then
+        if [[ ! -d $EMBREE_INSTALL_DIR/include/embree3 ]]; then
+            error "Unable to find embree v3.+ in the alternative path, perhaps a wrong embree version is provided."
+        fi
+    fi
+}
+
+function bv_embree_dry_run
+{
+    if [[ "$DO_EMBREE" == "yes" ]] ; then
+        echo "Dry run option not set for embree."
+    fi
+}
+
+# ***************************************************************************
+# build_embree
+#
+# Modifications:
+#
+# ***************************************************************************
+
+function build_embree
+{
+    # Unzip the EMBREE tarball and copy it to the VisIt installation.
+    info "Installing prebuilt embree"    
+    tar zxvf $EMBREE_FILE
+    rm $EMBREE_INSTALL_DIR_NAME/lib/libtbb*
+    mkdir -p $VISITDIR/embree/$EMBREE_VERSION/$VISITARCH || error "Cannot create embree install directory"
+    cp -R $EMBREE_INSTALL_DIR_NAME/* $VISITDIR/embree/$EMBREE_VERSION/$VISITARCH || error "Cannot copy to embree install directory"
+    if [[ "$DO_GROUP" == "yes" ]] ; then
+        chmod -R ug+w,a+rX "$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH"
+        chgrp -R ${GROUP} "$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH"
+    fi
+    cd "$START_DIR"
+    info "Done with embree"
+    return 0
+}
+
+function bv_embree_is_enabled
+{
+    if [[ $DO_EMBREE == "yes" ]]; then
+        return 1    
+    fi
+    return 0
+}
+
+function bv_embree_is_installed
+{
+    if [[ "$USE_SYSTEM_EMBREE" == "yes" ]]; then   
+        return 1
+    fi
+
+    check_if_installed "embree" $EMBREE_VERSION
+    if [[ $? == 0 ]] ; then
+        return 1
+    fi
+    return 0
+}
+
+function bv_embree_build
+{
+    if [[ "$DO_EMBREE" == "yes" && "$USE_SYSTEM_EMBREE" == "no" ]] ; then
+        check_if_installed "embree" $EMBREE_VERSION
+        if [[ $? == 0 ]] ; then
+            info "Skipping build of embree"
+        else
+            build_embree
+            if [[ $? != 0 ]] ; then
+                error "Unable to build or install embree.  Bailing out."
+            fi
+            info "Done building embree"
+        fi
+    fi
+}
+
diff --git a/svn_bin/bv_support/bv_ispc.sh b/svn_bin/bv_support/bv_ispc.sh
new file mode 100644
index 0000000000..cf27b75d5b
--- /dev/null
+++ b/svn_bin/bv_support/bv_ispc.sh
@@ -0,0 +1,167 @@
+function bv_ispc_initialize
+{
+    export DO_ISPC="no"
+    export USE_SYSTEM_ISPC="no"
+    add_extra_commandline_args "ispc" "alt-ispc-dir" 1 "Use alternative directory for ispc"
+}
+
+function bv_ispc_enable
+{
+    DO_ISPC="yes"
+}
+
+function bv_ispc_disable
+{
+    DO_ISPC="no"
+}
+
+function bv_ispc_alt_ispc_dir
+{
+    echo "Using alternate ispc directory"
+    bv_ispc_enable
+    USE_SYSTEM_ISPC="yes"
+    ISPC_INSTALL_DIR="$1"
+}
+
+function bv_ispc_depends_on
+{
+    echo ""
+}
+
+function bv_ispc_initialize_vars
+{
+    info "initializing ispc vars"
+    if [[ "$DO_ISPC" == "yes" ]] ; then
+        if [[ "$USE_SYSTEM_ISPC" == "no" ]]; then
+            ISPC_INSTALL_DIR=$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH
+        fi
+    fi
+}
+
+function bv_ispc_info
+{
+    export ISPC_VERSION=${ISPC_VERSION:-"1.9.2"}
+    if [[ "$OPSYS" == "Darwin" ]] ; then
+        export ISPC_FILE=${ISPC_FILE:-"ispc-v${ISPC_VERSION}-osx.tar.gz"}
+        export ISPC_URL=${ISPC_URL:-"http://sdvis.org/ospray/download/dependencies/osx/"}
+        export ISPC_INSTALL_DIR_NAME=ispc-v$ISPC_VERSION-osx
+    else
+        export ISPC_FILE=${ISPC_FILE:-"ispc-v${ISPC_VERSION}-linux.tar.gz"}
+        export ISPC_URL=${ISPC_URL:-"http://sdvis.org/ospray/download/dependencies/linux/"}
+        export ISPC_INSTALL_DIR_NAME=ispc-v$ISPC_VERSION-linux
+    fi
+    export ISPC_COMPATIBILITY_VERSION=${ISPC_COMPATIBILITY_VERSION:-"${ISPC_VERSION}"}
+    export ISPC_BUILD_DIR=${ISPC_BUILD_DIR:-"${ISPC_VERSION}"}
+
+    export ISPC_MD5_CHECKSUM=""
+    export ISPC_SHA256_CHECKSUM=""
+}
+
+function bv_ispc_print
+{
+    printf "%s%s\n" "ISPC_FILE=" "${ISPC_FILE}"
+    printf "%s%s\n" "ISPC_VERSION=" "${ISPC_VERSION}"
+    printf "%s%s\n" "ISPC_COMPATIBILITY_VERSION=" "${ISPC_COMPATIBILITY_VERSION}"
+    printf "%s%s\n" "ISPC_BUILD_DIR=" "${ISPC_BUILD_DIR}"
+}
+
+function bv_ispc_host_profile
+{
+    if [[ "$DO_ISPC" == "yes" ]]; then
+        echo >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        echo "## ISPC" >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        if [[ "$USE_SYSTEM_ISPC" == "no" ]]; then
+            echo "VISIT_OPTION_DEFAULT(VISIT_ISPC_ROOT \${VISITHOME}/ispc/$ISPC_VERSION/\${VISITARCH})" >> $HOSTCONF
+        else
+            echo "VISIT_OPTION_DEFAULT(VISIT_ISPC_ROOT ${ISPC_INSTALL_DIR})" >> $HOSTCONF
+        fi
+    fi
+}
+
+function bv_ispc_print_usage
+{
+    #ispc does not have an option, it is only dependent on ispc.
+    printf "%-15s %s [%s]\n" "--ispc" "Build ISPC" "$DO_ISPC"
+}
+
+function bv_ispc_ensure
+{
+    if [[ "$DO_ISPC" == "yes" && "$USE_SYSTEM_ISPC" == "no" ]] ; then
+        ensure_built_or_ready "ispc" $ISPC_VERSION $ISPC_BUILD_DIR $ISPC_FILE $ISPC_URL
+        if [[ $? != 0 ]] ; then
+            ANY_ERRORS="yes"
+            DO_ISPC="no"
+            error "Unable to build ISPC.  ${ISPC_FILE} not found."
+        fi
+    fi
+}
+
+function bv_ispc_dry_run
+{
+    if [[ "$DO_ISPC" == "yes" ]] ; then
+        echo "Dry run option not set for ISPC."
+    fi
+}
+
+# ***************************************************************************
+# build_ispc
+#
+# Modifications:
+#
+# ***************************************************************************
+
+function build_ispc
+{
+    # Unzip the ISPC tarball and copy it to the VisIt installation.
+    info "Installing prebuilt ISPC"    
+    tar zxvf $ISPC_FILE
+    mkdir -p $VISITDIR/ispc/$ISPC_VERSION/$VISITARCH || error "Cannot create ispc install directory"
+    cp -R $ISPC_INSTALL_DIR_NAME/* $VISITDIR/ispc/$ISPC_VERSION/$VISITARCH || error "Cannot copy to ispc install directory"
+    if [[ "$DO_GROUP" == "yes" ]] ; then
+        chmod -R ug+w,a+rX "$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH"
+        chgrp -R ${GROUP} "$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH"
+    fi
+    cd "$START_DIR"
+    info "Done with ISPC"
+    return 0
+}
+
+function bv_ispc_is_enabled
+{
+    if [[ $DO_ISPC == "yes" ]]; then
+        return 1    
+    fi
+    return 0
+}
+
+function bv_ispc_is_installed
+{
+    if [[ "$USE_SYSTEM_ISPC" == "yes" ]]; then   
+        return 1
+    fi
+
+    check_if_installed "ispc" $ISPC_VERSION
+    if [[ $? == 0 ]] ; then
+        return 1
+    fi
+    return 0
+}
+
+function bv_ispc_build
+{
+    if [[ "$DO_ISPC" == "yes" && "$USE_SYSTEM_ISPC" == "no" ]] ; then
+        check_if_installed "ispc" $ISPC_VERSION
+        if [[ $? == 0 ]] ; then
+            info "Skipping build of ISPC"
+        else
+            build_ispc
+            if [[ $? != 0 ]] ; then
+                error "Unable to build or install ISPC.  Bailing out."
+            fi
+            info "Done building ISPC"
+        fi
+    fi
+}
+
diff --git a/svn_bin/bv_support/bv_ospray.sh b/svn_bin/bv_support/bv_ospray.sh
index 0db31d3517..de5dbf93b3 100644
--- a/svn_bin/bv_support/bv_ospray.sh
+++ b/svn_bin/bv_support/bv_ospray.sh
@@ -1,6 +1,11 @@
+# Module automatically read in from construct_build_visit
+# Insert header and comments
 function bv_ospray_initialize
 {
     export DO_OSPRAY="no"
+    export USE_SYSTEM_OSPRAY="no"
+    export OSPRAY_CONFIG_DIR=""
+    add_extra_commandline_args "ospray" "alt-ospray-dir" 1 "Use alternative directory for ospray"
 }
 
 function bv_ospray_enable
@@ -13,26 +18,64 @@ function bv_ospray_disable
     DO_OSPRAY="no"
 }
 
+function bv_ospray_alt_ospray_dir
+{
+    echo "Using alternate ospray directory"
+    bv_ospray_enable
+    USE_SYSTEM_OSPRAY="ospray"
+    OSPRAY_CONFIG_DIR="$1"
+}
+
+function bv_ospray_check_openmp
+{
+    _OPENMP=$(echo | cpp -fopenmp -dM | grep -i open)
+    if [[ "$_OPENMP" == "#define _OPENMP"* ]]; then
+        return 0
+    fi
+    return -1
+}
+
 function bv_ospray_depends_on
 {
-    depends_on=""
+    depends_on="cmake ispc embree"
+
+    if [[ "$DO_TBB" == "yes" ]]; then
+        depends_on="${depends_on} tbb"
+    else
+        bv_ospray_check_openmp
+        if [[ $? == -1 ]]; then
+            depends_on="${depends_on} tbb"
+        fi
+    fi
 
     echo ${depends_on}
 }
 
 function bv_ospray_info
 {
+    # versions
     export OSPRAY_VERSION=${OSPRAY_VERSION:-"1.6.1"}
-    export OSPRAY_FILE=${OSPRAY_FILE:-"ospray-${OSPRAY_VERSION}.x86_64.linux.tar.gz"}
-    export OSPRAY_BUILD_DIR=${OSPRAY_BUILD_DIR:-"ospray-${OSPRAY_VERSION}.x86_64.linux"}
-    export OSPRAY_URL=${OSPRAY_URL:-"https://github.com/ospray/ospray/releases/download/v${OSPRAY_VERSION}/"}
+    export OSPRAY_VISIT_MODULE_VERSION=${OSPRAY_VISIT_MODULE_VERSION:-"1.6.x"}
+    
+    # ospray source
+    export OSPRAY_TARBALL=${OSPRAY_TARBALL:-"ospray-${OSPRAY_VERSION}.tar.gz"}
+    export OSPRAY_BUILD_DIR=${OSPRAY_BUILD_DIR:-"ospray-${OSPRAY_VERSION}"}
+    export OSPRAY_DOWNLOAD_URL=${OSPRAY_DOWNLOAD_URL:-"https://github.com/wilsonCernWq/module_visit/releases/download/v1.6.x"}
+
+    # ospray module
+    export OSPRAY_VISIT_MODULE_TARBALL=${OSPRAY_VISIT_MODULE_TARBALL:-"module_visit-${OSPRAY_VISIT_MODULE_VERSION}.zip"}
+    export OSPRAY_VISIT_MODULE_UNTAR_DIR=${OSPRAY_VISIT_MODULE_UNTAR_DIR:-"module_visit-${OSPRAY_VISIT_MODULE_VERSION}"}
+    export OSPRAY_VISIT_MODULE_BUILD_DIR=${OSPRAY_VISIT_MODULE_BUILD_DIR:-"${OSPRAY_BUILD_DIR}/modules/module_visit"}
+    export OSPRAY_VISIT_MODULE_DOWNLOAD_URL=${OSPRAY_VISIT_MODULE_DOWNLOAD_URL:-"https://github.com/wilsonCernWq/module_visit/releases/download/v1.6.x"}
+    
+    # checksum
     export OSPRAY_MD5_CHECKSUM=""
     export OSPRAY_SHA256_CHECKSUM=""
 }
 
 function bv_ospray_print
 {
-    print "%s%s\n" "OSPRAY_FILE=" "${OSPRAY_FILE}"
+    print "%s%s\n" "OSPRAY_TARBALL=" "${OSPRAY_TARBALL}"
     print "%s%s\n" "OSPRAY_VERSION=" "${OSPRAY_VERSION}"
     print "%s%s\n" "OSPRAY_TARGET=" "${OSPRAY_TARGET}"
     print "%s%s\n" "OSPRAY_BUILD_DIR=" "${OSPRAY_BUILD_DIR}"
@@ -45,13 +88,23 @@ function bv_ospray_print_usage
 
 function bv_ospray_host_profile
 {
-    if [[ "$DO_OSPRAY" == "yes" ]] ; then
+    if [[ "$DO_OSPRAY" == "yes" ]]; then
         echo >> $HOSTCONF
         echo "##" >> $HOSTCONF
         echo "## OSPRay" >> $HOSTCONF
         echo "##" >> $HOSTCONF
         echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY ON TYPE BOOL)" >> $HOSTCONF
-        echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY_DIR \${VISITHOME}/ospray/$OSPRAY_VERSION/\${VISITARCH})" >> $HOSTCONF
+        if [[ "$USE_SYSTEM_OSPRAY" == "no" ]]; then
+            if [[ -d $OSPRAY_INSTALL_DIR/lib ]]; then
+                echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY_DIR \${VISITHOME}/ospray/$OSPRAY_VERSION/\${VISITARCH}/lib/cmake/ospray-${OSPRAY_VERSION})" >> $HOSTCONF
+            elif [[ -d $OSPRAY_INSTALL_DIR/lib64 ]]; then
+                echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY_DIR \${VISITHOME}/ospray/$OSPRAY_VERSION/\${VISITARCH}/lib64/cmake/ospray-${OSPRAY_VERSION})" >> $HOSTCONF
+            else
+                error "No library path for OSPRay has been found."
+            fi
+        else
+            echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY_DIR ${OSPRAY_CONFIG_DIR})" >> $HOSTCONF
+        fi
     fi
 }
 
@@ -65,26 +118,44 @@ function bv_ospray_is_enabled
 
 function bv_ospray_ensure
 {
-    if [[ "$DO_OSPRAY" == "yes" ]]; then
+    if [[ "$DO_OSPRAY" == "yes" && "$USE_SYSTEM_OSPRAY" == "no" ]]; then
         ensure_built_or_ready "ospray" \
             $OSPRAY_VERSION \
             $OSPRAY_BUILD_DIR \
-            $OSPRAY_FILE \
-            $OSPRAY_URL
+            $OSPRAY_TARBALL \
+            $OSPRAY_DOWNLOAD_URL 
         if [[ $? != 0 ]] ; then
             return 1
         fi
+        ensure_built_or_ready "ospray-visit-module" \
+            $OSPRAY_VISIT_MODULE_VERSION \
+            $OSPRAY_VISIT_MODULE_BUILD_DIR \
+            $OSPRAY_VISIT_MODULE_TARBALL \
+            $OSPRAY_VISIT_MODULE_DOWNLOAD_URL
+        if [[ $? != 0 ]] ; then
+            return 1
+        fi       
     fi
 }
 
 function bv_ospray_initialize_vars
 {
     info "initializing ospray vars"
-    if [[ "$DO_OSPRAY" == "yes" ]] ; then
-        OSPRAY_INSTALL_DIR="${VISITDIR}/ospray/${OSPRAY_VERSION}/${VISITARCH}"
+    if [[ "$DO_OSPRAY" == "yes" ]]; then
+        if [[ "$USE_SYSTEM_OSPRAY" == "no" ]]; then
+            OSPRAY_INSTALL_DIR="${VISITDIR}/ospray/${OSPRAY_VERSION}/${VISITARCH}"
+        else
+            OSPRAY_INSTALL_DIR="${OSPRAY_CONFIG_DIR}/../../../"
+        fi
+
+        # Qi's Note: Are those variables necessary ?
         OSPRAY_INCLUDE_DIR="${OSPRAY_INSTALL_DIR}/include"
-        OSPRAY_LIB_DIR="${OSPRAY_INSTALL_DIR}/lib"
-        OSPRAY_LIB="${OSPRAY_LIB_DIR}/libospray.so"
+        if [[ -d $OSPRAY_INSTALL_DIR/lib64 ]]; then
+            OSPRAY_LIB_DIR="${OSPRAY_INSTALL_DIR}/lib64"
+        else
+            OSPRAY_LIB_DIR="${OSPRAY_INSTALL_DIR}/lib"
+        fi        
+        OSPRAY_LIB="${OSPRAY_LIB_DIR}/libospray.so"            
 
         VTK_USE_OSPRAY="yes"
     fi
@@ -99,6 +170,10 @@ function bv_ospray_dry_run
 
 function bv_ospray_is_installed
 {
+    if [[ "$USE_SYSTEM_OSPRAY" == "yes" ]]; then   
+        return 1
+    fi
+
     check_if_installed "ospray" $OSPRAY_VERSION
     if [[ $? == 0 ]] ; then
         return 1
@@ -106,28 +181,90 @@ function bv_ospray_is_installed
     return 0
 }
 
+function build_ospray_in_source
+{
+    # set compiler if the user hasn't explicitly set CC and CXX
+    if [ -z $CC ]; then
+        echo "***NOTE: using compiler $C_COMPILER/$CXX_COMPILER!"
+        export CC=$C_COMPILER
+        export CXX=$CXX_COMPILER
+    fi
+
+    #### Build OSPRay ####
+    mkdir -p build
+    cd build
+
+    # Clean out build directory to be sure we are doing a fresh build
+    rm -rf *
+
+    # set release and RPM settings
+    info "Configure OSPRay . . . "
+    CMAKE_INSTALL=${CMAKE_INSTALL:-"$VISITDIR/cmake/${CMAKE_VERSION}/$VISITARCH/bin"}
+
+    CMAKE_VARS=""
+    CMAKE_VARS=${CMAKE_VARS}" -D CMAKE_INSTALL_PREFIX=${OSPRAY_INSTALL_DIR} "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_BUILD_ISA=ALL "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_MODULE_VISIT=ON "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_MODULE_MPI=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_MODULE_MPI_APPS=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_APPS_EXAMPLEVIEWER=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_APPS_BENCHMARK=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_SG_CHOMBO=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_SG_OPENIMAGEIO=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_SG_VTK=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_ZIP_MODE=OFF "
+    CMAKE_VARS=${CMAKE_VARS}" -D embree_DIR=${EMBREE_INSTALL_DIR} "
+    CMAKE_VARS=${CMAKE_VARS}" -D ISPC_EXECUTABLE=${ISPC_INSTALL_DIR}/ispc "
+    if [[ "${TBB_INSTALL_DIR}" == "" ]]; then
+        bv_ospray_check_openmp
+        if [[ $? == 0 ]]; then
+            CMAKE_VARS=${CMAKE_VARS}" -D OSPRAY_TASKING_SYSTEM=OpenMP "
+        else
+            error "OSPRay cannot find neither TBB nor OpenMP."
+        fi
+    else
+        CMAKE_VARS=${CMAKE_VARS}" -D TBB_ROOT=${TBB_INSTALL_DIR} "
+    fi
+    ${CMAKE_INSTALL}/cmake ${CMAKE_VARS} \
+        .. || error "OSPRay did not configure correctly.  Giving up."
+
+    #
+    # Now build OSPRay
+    #
+    info "Building OSPRay (~10 minute)"
+    env DYLD_LIBRARY_PATH=`pwd`/bin $MAKE $MAKE_OPT_FLAGS || \
+        error "OSPRay did not build correctly.  Giving up."
+
+    info "Installing OSPRay . . . "
+    $MAKE install || error "OSPRay did not install correctly."
+}
+
 function build_ospray
 {
-    prepare_build_dir $OSPRAY_BUILD_DIR $OSPRAY_FILE
+    # prepare directories
+    prepare_build_dir $OSPRAY_BUILD_DIR $OSPRAY_TARBALL
     untarred_ospray=$?
-    if [[ $untarred_ospray == -1 ]] ; then
+    if [[ $untarred_ospray == -1 ]]; then
         warn "Unable to prepare OSPRay build directory. Giving up!"
         return 1
     fi
-
-    cd $OSPRAY_BUILD_DIR || error "Couldn't cd to OSPRay build dir."
-    info "Installing OSPRay . . ."
-    echo mkdir -p ${OSPRAY_INSTALL_DIR}
-    mkdir -p ${OSPRAY_INSTALL_DIR}
-    echo cp -a include lib ${OSPRAY_INSTALL_DIR}
-    cp -a include lib ${OSPRAY_INSTALL_DIR}
-
-    if [[  $? != 0 ]] ; then
-        warn "OSPRay install failed. Giving up"
+    prepare_build_dir $OSPRAY_VISIT_MODULE_BUILD_DIR $OSPRAY_VISIT_MODULE_TARBALL
+    untarred_ospray_visit_module=$?
+    if [[ $untarred_ospray_visit_module == -1 ]]; then
+        warn "Unable to prepare OSPRay build directory. Giving up!"
         return 1
+    elif [[ $untarred_ospray_visit_module == 1 ]]; then
+        rm -fr $OSPRAY_VISIT_MODULE_BUILD_DIR
+        mv $OSPRAY_VISIT_MODULE_UNTAR_DIR $OSPRAY_VISIT_MODULE_BUILD_DIR \
+            || error "Couldn't find module_visit for OSPRay"
     fi
-    
-    if [[ "$DO_GROUP" == "yes" ]] ; then
+
+    # build and install
+    cd $OSPRAY_BUILD_DIR || error "Couldn't cd to OSPRay build dir."
+    build_ospray_in_source
+
+    # others
+    if [[ "$DO_GROUP" == "yes" ]]; then
         chmod -R ug+w,a+rX "$VISITDIR/ospray"
         chgrp -R ${GROUP} "$VISITDIR/ospray"
     fi
@@ -139,17 +276,16 @@ function build_ospray
 function bv_ospray_build
 {
     cd "$START_DIR"
-    if [[ "$DO_OSPRAY" == "yes" ]]; then
+    if [[ "$DO_OSPRAY" == "yes" && "$USE_SYSTEM_OSPRAY" == "no" ]]; then
         check_if_installed "ospray" $OSPRAY_VERSION
         if [[ $? == 0 ]] ; then
             info "Skipping OSPRay build. OSPRay is already installed."
         else
-            info "Building OSPRay (~1 minute)"
             build_ospray
-            if [[ $? != 0 ]] ; then
+            if [[ $? != 0 ]]; then
                 error "Unable to build or install OSPRay. Bailing out."
             fi
-            info "Done building OSPRay"
         fi
     fi
 }
+
diff --git a/svn_bin/bv_support/bv_tbb.sh b/svn_bin/bv_support/bv_tbb.sh
index e353018811..f01809add5 100644
--- a/svn_bin/bv_support/bv_tbb.sh
+++ b/svn_bin/bv_support/bv_tbb.sh
@@ -1,6 +1,8 @@
 function bv_tbb_initialize
 {
     export DO_TBB="no"
+    export USE_SYSTEM_TBB="no"
+    add_extra_commandline_args "tbb" "alt-tbb-dir" 1 "Use alternative directory for tbb"
 }
 
 function bv_tbb_enable
@@ -13,9 +15,32 @@ function bv_tbb_disable
     DO_TBB="no"
 }
 
+function bv_tbb_alt_tbb_dir
+{
+    echo "Using alternate TBB directory"
+    bv_tbb_enable
+    USE_SYSTEM_TBB="yes"
+    TBB_INSTALL_DIR="$1"
+}
+
 function bv_tbb_depends_on
 {
-    echo ""
+    if [[ "$USE_SYSTEM_TBB" == "yes" ]] ; then
+        echo ""
+    else
+        echo ""
+    fi
+}
+
+function bv_tbb_initialize_vars
+{
+    info "initializing TBB vars"
+    if [[ "$DO_TBB" == "yes" ]] ; then
+        if [[ "$USE_SYSTEM_TBB" == "no" ]]; then
+            TBB_INSTALL_DIR=$VISITDIR/tbb/$TBB_VERSION/$VISITARCH
+        fi
+    fi
+    export TBB_ROOT="${TBB_INSTALL_DIR}"
 }
 
 function bv_tbb_info
@@ -47,8 +72,11 @@ function bv_tbb_host_profile
         echo "##" >> $HOSTCONF
         echo "## TBB" >> $HOSTCONF
         echo "##" >> $HOSTCONF
-        echo "VISIT_OPTION_DEFAULT(TBB_ROOT \${VISITHOME}/tbb/\${VISITARCH}/$TBB_VERSION)" \
-            >> $HOSTCONF
+        if [[ "$USE_SYSTEM_TBB" == "no" ]]; then
+            echo "VISIT_OPTION_DEFAULT(TBB_ROOT \${VISITHOME}/tbb/$TBB_VERSION/\${VISITARCH})" >> $HOSTCONF
+        else
+            echo "VISIT_OPTION_DEFAULT(TBB_ROOT ${TBB_INSTALL_DIR})" >> $HOSTCONF
+        fi
     fi
 }
 
@@ -60,7 +88,7 @@ function bv_tbb_print_usage
 
 function bv_tbb_ensure
 {
-    if [[ "$DO_TBB" == "yes" ]] ; then
+    if [[ "$DO_TBB" == "yes" && "$USE_SYSTEM_TBB" == "no" ]] ; then
         ensure_built_or_ready "tbb" $TBB_VERSION $TBB_BUILD_DIR $TBB_FILE
         if [[ $? != 0 ]] ; then
             ANY_ERRORS="yes"
@@ -89,14 +117,13 @@ function build_tbb
     # Unzip the TBB tarball and copy it to the VisIt installation.
     info "Installing prebuilt TBB"
     tar zxvf $TBB_FILE
-    mkdir $VISITDIR/tbb
-    mkdir $VISITDIR/tbb/$VISITARCH
-    cp -R $TBB_VERSION "$VISITDIR/tbb/$VISITARCH"
-    rm -rf $TBB_VERSION
+    mkdir -p $VISITDIR/tbb/$TBB_VERSION/$VISITARCH || error "Cannot make tbb install directory"
+    cp -R $TBB_VERSION/* $VISITDIR/tbb/$TBB_VERSION/$VISITARCH || error "Cannot copy to tbb install directory"
 
+    # others
     if [[ "$DO_GROUP" == "yes" ]] ; then
-        chmod -R ug+w,a+rX "$VISITDIR/tbb/$VISITARCH"
-        chgrp -R ${GROUP} "$VISITDIR/tbb/$VISITARCH"
+        chmod -R ug+w,a+rX "$VISITDIR/tbb/$TBB_VERSION/$VISITARCH"
+        chgrp -R ${GROUP} "$VISITDIR/tbb/$TBB_VERSION/$VISITARCH"
     fi
     cd "$START_DIR"
     info "Done with TBB"
@@ -113,7 +140,11 @@ function bv_tbb_is_enabled
 
 function bv_tbb_is_installed
 {
-    check_if_installed "tbb"
+    if [[ "$USE_SYSTEM_TBB" == "yes" ]]; then   
+        return 1
+    fi
+
+    check_if_installed "tbb" $TBB_VERSION
     if [[ $? == 0 ]] ; then
         return 1
     fi
@@ -122,8 +153,8 @@ function bv_tbb_is_installed
 
 function bv_tbb_build
 {
-    if [[ "$DO_TBB" == "yes" ]] ; then
-        check_if_installed "tbb"
+    if [[ "$DO_TBB" == "yes" && "$USE_SYSTEM_TBB" == "no" ]] ; then
+        check_if_installed "tbb" $TBB_VERSION
         if [[ $? == 0 ]] ; then
             info "Skipping build of TBB"
         else
diff --git a/svn_bin/bv_support/bv_vtk.sh b/svn_bin/bv_support/bv_vtk.sh
index 0516822c9c..4160290ce4 100644
--- a/svn_bin/bv_support/bv_vtk.sh
+++ b/svn_bin/bv_support/bv_vtk.sh
@@ -51,7 +51,7 @@ function bv_vtk_depends_on
     fi
 
     if [[ "$DO_OSPRAY" == "yes" ]]; then
-        depends_on="${depends_on} ospray"
+        depends_on="${depends_on} embree ospray"
     fi
 
     # Only depend on Qt if we're not doing server-only builds.
@@ -803,6 +803,7 @@ function build_vtk
     if [[ "$DO_OSPRAY" == "yes" ]] ; then
         vopts="${vopts} -DModule_vtkRenderingOSPRay:BOOL=ON"
         vopts="${vopts} -DOSPRAY_INSTALL_DIR=${OSPRAY_INSTALL_DIR}"
+        vopts="${vopts} -Dembree_DIR=${EMBREE_INSTALL_DIR}"
     fi
 
     CMAKE_BIN="${CMAKE_INSTALL}/cmake"
diff --git a/svn_bin/bv_support/modules.xml b/svn_bin/bv_support/modules.xml
index f662420992..8af931c196 100644
--- a/svn_bin/bv_support/modules.xml
+++ b/svn_bin/bv_support/modules.xml
@@ -20,6 +20,7 @@
             <lib name="conduit"/>
             <lib name="cgns"/>
             <lib name="eavl"/>
+            <lib name="embree"/>
             <lib name="fastbit"/>
             <lib name="fastquery"/>
             <lib name="gdal"/>
@@ -28,6 +29,7 @@
             <lib name="hdf4"/>
             <lib name="hdf5"/>
             <lib name="icet"/>
+            <lib name="ispc"/>
             <lib name="llvm"/>
 <!--        <lib name="mdsplus"/>    Removed for now by Allen Sanderson-->
             <lib name="mesagl"/>
@@ -39,10 +41,10 @@
             <lib name="nektarpp"/>
             <lib name="netcdf"/>
             <lib name="openexr"/>
-            <lib name="pidx"/>
             <lib name="openssl"/>
             <lib name="osmesa"/>
             <lib name="ospray"/>
+            <lib name="pidx"/>
             <lib name="pyside"/>
             <lib name="silo"/>
             <lib name="szip"/>
@@ -73,11 +75,13 @@
             <lib name="cfitsio"/>
             <lib name="conduit"/>
             <lib name="cgns"/>
+            <lib name="embree"/>
             <lib name="gdal"/>
             <lib name="fastbit"/>
             <lib name="fastquery"/>
             <lib name="hdf5"/>
             <lib name="h5part"/>
+            <lib name="ispc"/>
             <lib name="mpich"/>
             <lib name="mxml"/>
             <lib name="netcdf"/>
@@ -89,6 +93,7 @@
             <lib name="pyside"/>
             <lib name="silo"/>
             <lib name="szip"/>
+            <lib name="tbb"/>
             <lib name="uintah"/>
             <lib name="visus"/>
             <lib name="xdmf"/>
@@ -169,6 +174,9 @@
         -->
         <group name="nonio" comment="Build non I/O libraries" enabled="no">
             <lib name="icet"/>
+            <lib name="embree"/>
+            <lib name="ispc"/>
+            <lib name="tbb"/>
             <lib name="ospray"/>
         </group>
 
