commit 139ee8404dea214331003d576fb749ca8ce8ac49
Author: WU Qi <wilson.over.cloud@gmail.com>
Date:   Mon Jul 16 10:50:32 2018 -0600

    commit for ospray

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7b2855250..d51341495 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1197,8 +1197,27 @@ ELSE(VISIT_THREAD)
     MESSAGE(STATUS "Threading for VisIt: OFF")
 ENDIF(VISIT_THREAD)
 
+# modified by Qi
 IF(VISIT_OSPRAY)
+    # setup variables 
+    SET(OSPRAY_USE_EXTERNAL_EMBREE ON)
+    SET(ospray_DIR ${VISIT_OSPRAY_DIR})
+    SET(embree_DIR ${VISIT_EMBREE_ROOT})
+    SET(ISPC_EXECUTABLE ${VISIT_ISPC_ROOT})
+    FIND_PACKAGE(ospray REQUIRED)
+    # additional module library
+    SET(OSPRAY_LIBRARIES
+      ${OSPRAY_LIBRARIES}
+      ${LIBRARY_PATH_PREFIX}ospray_module_visit${LIBRARY_SUFFIX}
+      ${LIBRARY_PATH_PREFIX}visit_image_composite${LIBRARY_SUFFIX}
+      )
+    # include ospray
     ADD_DEFINITIONS(-DVISIT_OSPRAY)
+    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIR})
+    LINK_DIRECTORIES(${VISIT_OSPRAY_DIR}/../..)
+    # debug
+    MESSAGE(STATUS "OSPRAY_INCLUDE_DIR: " ${OSPRAY_INCLUDE_DIR})
+    MESSAGE(STATUS "OSPRAY_LIBRARIES: " ${OSPRAY_LIBRARIES})
     MESSAGE(STATUS "OSPRAY for VisIt: ON")
 ELSE(VISIT_OSPRAY)
     MESSAGE(STATUS "OSPRAY for VisIt: OFF")
diff --git a/avt/Filters/CMakeLists.txt b/avt/Filters/CMakeLists.txt
index b8a6c495b..3f5099771 100644
--- a/avt/Filters/CMakeLists.txt
+++ b/avt/Filters/CMakeLists.txt
@@ -73,6 +73,9 @@
 #****************************************************************************/
 
 SET(AVTFILTERS_SOURCES
+avtSLIVROSPRayFilter.C
+avtSLIVRImgMetaData.C
+avtSLIVRImgCommunicator.C
 avtActualExtentsFilter.C
 avtCondenseDatasetFilter.C
 avtContourFilter.C
@@ -87,7 +90,6 @@ avtGhostZoneAndFacelistFilter.C
 avtGhostZoneFilter.C
 avtImageCommunicator.C
 avtImageCompositer.C
-avtImgCommunicator.C
 avtLinearTransformFilter.C
 avtLineoutFilter.C
 avtLineScanFilter.C
@@ -156,17 +158,27 @@ ${VTKM_INCLUDE_DIR}
 ${VTK_INCLUDE_DIRS}
 )
 
+IF (VISIT_OSPRAY) 
+    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIR})
+ENDIF ()
+
 # Add link directories
 LINK_DIRECTORIES(${LIBRARY_OUTPUT_DIRECTORY} ${EAVL_LIBRARY_DIR} ${VTK_LIBRARY_DIRS} ${MESA_LIBRARY_DIR} ${GLEW_LIBRARY_DIR})
 
 #********************************* SERIAL ************************************
 ADD_LIBRARY(avtfilters_ser ${AVTFILTERS_SOURCES})
-TARGET_LINK_LIBRARIES(avtfilters_ser visitcommon lightweight_visit_vtk visit_vtk avtmath avtview avtpipeline_ser avtdatabase_ser avtdbatts ${EAVL_LIB} ${VTKM_LIB} vtkFiltersModeling)
+TARGET_LINK_LIBRARIES(avtfilters_ser visitcommon lightweight_visit_vtk visit_vtk avtmath avtview avtpipeline_ser avtdatabase_ser avtdbatts ${EAVL_LIB} ${VISIT_VTKM_LIB} vtkFiltersModeling)
+IF (VISIT_OSPRAY) 
+    TARGET_LINK_LIBRARIES(avtfilters_ser ${OSPRAY_LIBRARIES})
+ENDIF (VISIT_OSPRAY) 
 VISIT_INSTALL_TARGETS(avtfilters_ser)
 
 #********************************* PARALLEL **********************************
 IF(VISIT_PARALLEL)
     ADD_PARALLEL_LIBRARY(avtfilters_par ${AVTFILTERS_SOURCES})
-    TARGET_LINK_LIBRARIES(avtfilters_par visitcommon lightweight_visit_vtk visit_vtk avtmath avtview avtpipeline_par avtdatabase_par avtdbatts ${EAVL_LIB} ${VTKM_LIB} vtkFiltersModeling)
+    TARGET_LINK_LIBRARIES(avtfilters_par visitcommon lightweight_visit_vtk visit_vtk avtmath avtview avtpipeline_par avtdatabase_par avtdbatts ${EAVL_LIB} ${VISIT_VTKM_LIB} vtkFiltersModeling)
+    IF (VISIT_OSPRAY) 
+        TARGET_LINK_LIBRARIES(avtfilters_par ${OSPRAY_LIBRARIES})
+    ENDIF (VISIT_OSPRAY)
     VISIT_INSTALL_TARGETS(avtfilters_par)
 ENDIF(VISIT_PARALLEL)
diff --git a/avt/Filters/avtMassVoxelExtractor.C b/avt/Filters/avtMassVoxelExtractor.C
index 22581b490..0a306c107 100644
--- a/avt/Filters/avtMassVoxelExtractor.C
+++ b/avt/Filters/avtMassVoxelExtractor.C
@@ -42,11 +42,15 @@
 
 #include <avtMassVoxelExtractor.h>
 
-#include <float.h>
-
 #include <avtAccessor.h>
 #include <avtCellList.h>
 #include <avtVolume.h>
+#include <avtSLIVRImgMetaData.h>
+
+#include <avtMemory.h>
+#include <avtCallback.h>
+#include <DebugStream.h>
+#include <TimingsManager.h>
 
 #include <vtkDataArray.h>
 #include <vtkCamera.h>
@@ -57,23 +61,85 @@
 #include <vtkTemplateAliasMacro.h>
 #include <vtkUnsignedCharArray.h>
 
-#include <DebugStream.h>
-
-#include <stdio.h>
 #include <stdlib.h>
+#include <stdio.h>
+#include <float.h>
 #include <time.h>
-
+#include <math.h>
+#include <algorithm>
 #include <iostream>
 #include <fstream>
-#include <string>
 #include <sstream>
-#include <algorithm>
+#include <string>
 #include <limits>
-#include <math.h>
 
-#if defined (_MSC_VER) && (_MSC_VER < 1800) && !defined(round)
-inline double round(double x) {return (x-floor(x)) > 0.5 ? ceil(x) : floor(x);}
-#endif
+// ****************************************************************************
+//  Method: Dot
+//
+//  Purpose:
+//      Dot product for vectors
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 14, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+float Dot (float vecA[3], float vecB[3])
+{
+    return ((vecA[0] * vecB[0]) + (vecA[1] * vecB[1]) + (vecA[2] * vecB[2]));
+}
+
+
+// ****************************************************************************
+//  Method: Normalize
+//
+//  Purpose:
+//      Normalize vector
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 14, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void Normalize(float vec[3])
+{
+    float inverse_sqrt_sum_squared = sqrt(vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2]);
+    if (inverse_sqrt_sum_squared != 0)
+	inverse_sqrt_sum_squared = 1.0/inverse_sqrt_sum_squared;
+    for (int i=0;i<3; i++)
+	vec[i] = vec[i]*inverse_sqrt_sum_squared;
+}
+
+
+// ****************************************************************************
+//  Method: Reflect
+//
+//  Purpose:
+//      Reflect vector
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 14, 2016
+//
+//  Modifications:
+//
+// ****************************************************************************
+
+void Reflect(float vec[3], float normal[3], float refl[3])
+{
+    // Vnew = -2*(V dot N)*N + V
+    // out = incidentVec - 2.f * Dot(incidentVec, normal) * normal;
+    float vDotN = Dot(vec,normal);
+    for (int i=0; i<3; i++)
+    {
+        refl[i] = -2.0 * vDotN * normal[i] + vec[i];
+    }
+    Normalize(refl);
+}
+
 
 // ****************************************************************************
 //  Method: avtMassVoxelExtractor constructor
@@ -106,16 +172,21 @@ inline double round(double x) {return (x-floor(x)) > 0.5 ? ceil(x) : floor(x);}
 //    Kathleen Biagas, Fri Jul 13 09:23:55 PDT 2012
 //    Use double instead of float.
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for volume rendering using OSPRay (RayCasting:OSPRay)
+//
 // ****************************************************************************
 
-avtMassVoxelExtractor::avtMassVoxelExtractor(int w, int h, int d,
-                                             avtVolume *vol, avtCellList *cl)
+avtMassVoxelExtractor::avtMassVoxelExtractor
+(int w, int h, int d, avtVolume *vol, avtCellList *cl)
     : avtExtractor(w, h, d, vol, cl)
 {
     fullImgWidth = w;
     fullImgHeight = h;
+    
+    debug5 << "fullImgWidth: "  << fullImgWidth  << " "
+	   << "fullImgHeight: " << fullImgHeight << std::endl;
 
-    debug5 << "fullImgWidth: " << fullImgWidth << "    fullImgHeight: " << fullImgHeight << std::endl;
     gridsAreInWorldSpace = false;
     pretendGridsAreInWorldSpace = false;
 
@@ -125,10 +196,8 @@ avtMassVoxelExtractor::avtMassVoxelExtractor(int w, int h, int d,
     aspect = 1;
     view_to_world_transform = vtkMatrix4x4::New();
     world_to_view_transform = vtkMatrix4x4::New();
-
-    modelViewProj = vtkMatrix4x4::New();
-    invModelViewProj = vtkMatrix4x4::New();
-
+    model_to_screen_transform = vtkMatrix4x4::New();
+    screen_to_model_transform = vtkMatrix4x4::New();
 
     X = NULL;
     Y = NULL;
@@ -136,26 +205,38 @@ avtMassVoxelExtractor::avtMassVoxelExtractor(int w, int h, int d,
     divisors_X = NULL;
     divisors_Y = NULL;
     divisors_Z = NULL;
-
+    
     prop_buffer   = new double[3*depth];
     ind_buffer    = new int[3*depth];
     valid_sample  = new bool[depth];
+
+    // patch screen position
+    imgDims[0] = imgDims[1] = 0;             // size of the patch
+    imgLowerLeft[0]  = imgLowerLeft[1]  = 0; // coordinates in the whole image
+    imgUpperRight[0] = imgUpperRight[1] = 0; //
+
+    // lighting
     lighting = false;
-    lightPosition[0] = lightPosition[1] = lightPosition[2] = 0.0;   lightPosition[3] = 1.0;
-    materialProperties[0] = 0.4; materialProperties[1] = 0.75; materialProperties[3] = 0.0; materialProperties[3] = 15.0;
+    lightPosition[0] = lightPosition[1] = lightPosition[2] = 0.0;
+    lightPosition[3] = 1.0;
+    materialProperties[0] = 0.4; 
+    materialProperties[1] = 0.75;
+    materialProperties[2] = 0.0; 
+    materialProperties[3] = 15.0;
     gradient[0] = gradient[1] = gradient[2] = 0;
 
     proc = patch = 0;
     patchDrawn = 0;
-    imgDims[0] = imgDims[1] = 0;                // size of the patch
-    imgLowerLeft[0] = imgLowerLeft[1] = 0;      // coordinates in the whole image
-    imgUpperRight[0] = imgUpperRight[1] = 0;    //
-    eyeSpaceDepth = -1;
+
+    eyesSpaceDepth = -1;
     clipSpaceDepth = -1;
-    imgArray = NULL;                            // the image data
 
+    imgArray = NULL;                            // the image data
     depthBuffer = NULL;
     rgbColorBuffer = NULL;
+
+    // ospray renderer
+    ospray = NULL;
 }
 
 
@@ -180,6 +261,9 @@ avtMassVoxelExtractor::avtMassVoxelExtractor(int w, int h, int d,
 //    Hank Childs, Wed Dec 24 11:22:43 PST 2008
 //    Remove reference to ProportionSpaceToZBufferSpace data member.
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for volume rendering using OSPRay (RayCasting:OSPRay)
+//
 // ****************************************************************************
 
 avtMassVoxelExtractor::~avtMassVoxelExtractor()
@@ -187,26 +271,29 @@ avtMassVoxelExtractor::~avtMassVoxelExtractor()
     view_to_world_transform->Delete();
     world_to_view_transform->Delete();
 
+    model_to_screen_transform->Delete();
+    screen_to_model_transform->Delete();
+
     if (prop_buffer != NULL)
-    delete [] prop_buffer;
+	delete [] prop_buffer;
     if (ind_buffer != NULL)
-    delete [] ind_buffer;
+	delete [] ind_buffer;
     if (valid_sample != NULL)
-    delete [] valid_sample;
+	delete [] valid_sample;
     if (X != NULL)
-        delete [] X;
+	delete [] X;
     if (Y != NULL)
-        delete [] Y;
+	delete [] Y;
     if (Z != NULL)
-        delete [] Z;
+	delete [] Z;
     if (divisors_X != NULL)
-        delete [] divisors_X;
+	delete [] divisors_X;
     if (divisors_Y != NULL)
-        delete [] divisors_Y;
+	delete [] divisors_Y;
     if (divisors_Z != NULL)
-        delete [] divisors_Z;
+	delete [] divisors_Z;
     if (imgArray != NULL)
-        delete []imgArray;
+	delete []imgArray;
 
     imgArray = NULL;
 }
@@ -230,8 +317,9 @@ avtMassVoxelExtractor::~avtMassVoxelExtractor()
 template <class T> static void
 AssignEight(double *vals, int *index, int s, int m, T *array)
 {
-    for (int i = 0 ; i < 8 ; i++)
+    for (int i = 0 ; i < 8 ; i++) {
         vals[i] = (double) array[s*index[i]+m];
+    }
 }
 
 static void
@@ -239,39 +327,40 @@ AssignEight(int vartype, double *vals, int *index, int s, int m, void *array)
 {
     switch (vartype)
     {
-      case VTK_CHAR:
+    case VTK_CHAR:
         AssignEight(vals, index, s, m, (char *) array);
         break;
-      case VTK_UNSIGNED_CHAR:
+    case VTK_UNSIGNED_CHAR:
         AssignEight(vals, index, s, m, (unsigned char *) array);
         break;
-      case VTK_SHORT:
+    case VTK_SHORT:
         AssignEight(vals, index, s, m, (short *) array);
         break;
-      case VTK_UNSIGNED_SHORT:
+    case VTK_UNSIGNED_SHORT:
         AssignEight(vals, index, s, m, (unsigned short *) array);
         break;
-      case VTK_INT:
+    case VTK_INT:
         AssignEight(vals, index, s, m, (int *) array);
         break;
-      case VTK_UNSIGNED_INT:
+    case VTK_UNSIGNED_INT:
         AssignEight(vals, index, s, m, (unsigned int *) array);
         break;
-      case VTK_UNSIGNED_LONG:
+    case VTK_UNSIGNED_LONG:
         AssignEight(vals, index, s, m, (long *) array);
         break;
-      case VTK_FLOAT:
+    case VTK_FLOAT:
         AssignEight(vals, index, s, m, (float *) array);
         break;
-      case VTK_DOUBLE:
+    case VTK_DOUBLE:
         AssignEight(vals, index, s, m, (double *) array);
         break;
-      case VTK_ID_TYPE:
+    case VTK_ID_TYPE:
         AssignEight(vals, index, s, m, (vtkIdType *) array);
         break;
     }
 }
 
+
 // ****************************************************************************
 //  Function:  ConvertToDouble
 //
@@ -292,25 +381,25 @@ ConvertToDouble(int vartype, int index, int s, int m, void *array)
 {
     switch (vartype)
     {
-      case VTK_CHAR:
+    case VTK_CHAR:
         return (double) ((char*)array)[s*index+m];
-      case VTK_UNSIGNED_CHAR:
+    case VTK_UNSIGNED_CHAR:
         return (double) ((unsigned char*)array)[s*index+m];
-      case VTK_SHORT:
+    case VTK_SHORT:
         return (double) ((short*)array)[s*index+m];
-      case VTK_UNSIGNED_SHORT:
+    case VTK_UNSIGNED_SHORT:
         return (double) ((unsigned short*)array)[s*index+m];
-      case VTK_INT:
+    case VTK_INT:
         return (double) ((int*)array)[s*index+m];
-      case VTK_UNSIGNED_INT:
+    case VTK_UNSIGNED_INT:
         return (double) ((unsigned int*)array)[s*index+m];
-      case VTK_UNSIGNED_LONG:
+    case VTK_UNSIGNED_LONG:
         return (double) ((unsigned long*)array)[s*index+m];
-      case VTK_FLOAT:
+    case VTK_FLOAT:
         return (double) ((float*)array)[s*index+m];
-      case VTK_DOUBLE:
+    case VTK_DOUBLE:
         return ((double*)array)[s*index+m];
-      case VTK_ID_TYPE:
+    case VTK_ID_TYPE:
         return (double) ((vtkIdType*)array)[s*index+m];
     }
 
@@ -335,19 +424,22 @@ ConvertToDouble(int vartype, int index, int s, int m, void *array)
 //    Hank Childs, Fri Jun  1 16:40:10 PDT 2007
 //    Added support for non-scalars.
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for volume rendering using OSPRay (RayCasting:OSPRay)
+//
 // ****************************************************************************
 
 void
-avtMassVoxelExtractor::Extract(vtkRectilinearGrid *rgrid,
-                std::vector<std::string> &varnames, std::vector<int> &varsizes)
+avtMassVoxelExtractor::Extract
+(vtkRectilinearGrid *rgrid, std::vector<std::string> &varnames, std::vector<int> &varsizes)
 {
     if (gridsAreInWorldSpace || pretendGridsAreInWorldSpace)
-        if (rayCastingSLIVR)
-            ExtractWorldSpaceGridRCSLIVR(rgrid, varnames, varsizes);
-        else
-          ExtractWorldSpaceGrid(rgrid, varnames, varsizes);
+	if (rayCastingSLIVR)
+	    ExtractWorldSpaceGridRCSLIVR(rgrid, varnames, varsizes);
+	else
+	    ExtractWorldSpaceGrid(rgrid, varnames, varsizes);
     else
-        ExtractImageSpaceGrid(rgrid, varnames, varsizes);
+	ExtractImageSpaceGrid(rgrid, varnames, varsizes);
 }
 
 
@@ -425,7 +517,8 @@ avtMassVoxelExtractor::SetGridsAreInWorldSpace(bool val, const avtViewInfo &v,
     view.SetCameraFromView(cam);
     cam->GetClippingRange(cur_clip_range);
     vtkMatrix4x4 *mat = cam->GetCompositeProjectionTransformMatrix(aspect,
-                                         cur_clip_range[0], cur_clip_range[1]);
+								   cur_clip_range[0], 
+								   cur_clip_range[1]);
 
     if (xform)
     {
@@ -473,7 +566,8 @@ avtMassVoxelExtractor::SetGridsAreInWorldSpace(bool val, const avtViewInfo &v,
 
 void
 avtMassVoxelExtractor::ExtractWorldSpaceGrid(vtkRectilinearGrid *rgrid,
-                 std::vector<std::string> &varnames, std::vector<int> &varsize)
+					     std::vector<std::string> &varnames, 
+					     std::vector<int> &varsize)
 {
     //
     // Some of our sampling routines need a chance to pre-process the data.
@@ -596,7 +690,8 @@ avtMassVoxelExtractor::RegisterGrid(vtkRectilinearGrid *rgrid,
         delete [] Z;
 
     // dims is the size of each of the small 3D patches e.g. 52x16x16 (or grid)
-    // X, Y & Z store the "real" coordinates each point in the grid (the above grid) e.g. 0.61075, 0.19536, 0.01936 for 0,0,0
+    // X, Y & Z store the "real" coordinates each point in the grid (the above grid)
+    // e.g. 0.61075, 0.19536, 0.01936 for 0,0,0
     X = new double[dims[0]];
     for (size_t i = 0 ; i < (size_t)dims[0] ; i++)
         X[i] = rgrid->GetXCoordinates()->GetTuple1(i);
@@ -714,8 +809,8 @@ avtMassVoxelExtractor::RegisterGrid(vtkRectilinearGrid *rgrid,
 // ****************************************************************************
 
 void
-avtMassVoxelExtractor::GetSegment(int w, int h, double *origin, double *terminus)
-    const
+avtMassVoxelExtractor::GetSegment
+(int w, int h, double *origin, double *terminus) const
 {
     double view[4];
 
@@ -742,35 +837,34 @@ avtMassVoxelExtractor::GetSegment(int w, int h, double *origin, double *terminus
         origin[2] /= origin[3];
     }
 
-
     view[0] = (w - width/2.)/(width/2.);
     if (pretendGridsAreInWorldSpace)
-        view[0] *= -1;
+	view[0] *= -1;
     view[1] = (h - height/2.)/(height/2.);
     view[2] = cur_clip_range[1];
     view[3] = 1.;
     view_to_world_transform->MultiplyPoint(view, terminus);
     if (terminus[3] != 0.)
     {
-        terminus[0] /= terminus[3];
-        terminus[1] /= terminus[3];
-        terminus[2] /= terminus[3];
+	terminus[0] /= terminus[3];
+	terminus[1] /= terminus[3];
+	terminus[2] /= terminus[3];
     }
 
     if (jitter)
     {
-        int reliable_random_number = (13*w*h + 14*w*w + 79*h*h + 247*w + 779*h)%513;
-        double jitter = (1.0/depth) * ((reliable_random_number-256) / (256.0));
-        double dir[3];
-        dir[0] = (terminus[0] - origin[0])*jitter;
-        dir[1] = (terminus[1] - origin[1])*jitter;
-        dir[2] = (terminus[2] - origin[2])*jitter;
-        origin[0] += dir[0];
-        origin[1] += dir[1];
-        origin[2] += dir[2];
-        terminus[0] += dir[0];
-        terminus[1] += dir[1];
-        terminus[2] += dir[2];
+	int reliable_random_number = (13*w*h + 14*w*w + 79*h*h + 247*w + 779*h)%513;
+	double jitter = (1.0/depth) * ((reliable_random_number-256) / (256.0));
+	double dir[3];
+	dir[0] = (terminus[0] - origin[0])*jitter;
+	dir[1] = (terminus[1] - origin[1])*jitter;
+	dir[2] = (terminus[2] - origin[2])*jitter;
+	origin[0] += dir[0];
+	origin[1] += dir[1];
+	origin[2] += dir[2];
+	terminus[0] += dir[0];
+	terminus[1] += dir[1];
+	terminus[2] += dir[2];
     }
 }
 
@@ -931,9 +1025,10 @@ avtMassVoxelExtractor::GridOnPlusSideOfPlane(const double *origin,
         // We can substitute in D to get
         // A*(pt[0]-origin[0]) + B*(pt[1]-origin[1]) + C*(pt[2-origin[2]) ?>= 0
         //
-        double val  = normal[0]*(pt[0] - origin[0])
-                   + normal[1]*(pt[1] - origin[1])
-                   + normal[2]*(pt[2] - origin[2]);
+        double val  = 
+	    normal[0]*(pt[0] - origin[0]) +
+	    normal[1]*(pt[1] - origin[1]) +
+	    normal[2]*(pt[2] - origin[2]);
 
         // Note: If we're only pretending that grids are in world space -- i.e.
         // we're resampling, not raycasting an image -- then flipping across
@@ -981,11 +1076,18 @@ avtMassVoxelExtractor::GridOnPlusSideOfPlane(const double *origin,
 
 bool
 avtMassVoxelExtractor::FindSegmentIntersections(const double *origin, 
-                                  const double *terminus, int &start, int &end)
+						const double *terminus, 
+						int &start, int &end)
 {
     double  t, x, y, z;
 
-    //debug5 << "x,y: " << w << ", " << h << "  origin: " << origin[0] << ", " << origin[1] << ", " << origin[2] << "   " << terminus[0] << ", " << terminus[1] << ", " << terminus[2] << "   first/last: " << first << " / " << last << endl;
+    // debug5 << "x,y: " << w << ", " << h;
+    // debug5 << " origin: "  
+    // 	      << origin[0] << ", " 
+    // 	      << origin[1] << ", " 
+    // 	      << origin[2] << "   ";
+    // debug5 << terminus[0] << ", " << terminus[1] << ", " << terminus[2];
+    // debug5 << "   first/last: " << first << " / " << last << endl;
 
     int num_hits = 0;
     double hits[6]; // Should always be 2 or 0.
@@ -998,17 +1100,17 @@ avtMassVoxelExtractor::FindSegmentIntersections(const double *origin,
     double z_max = Z[dims[2]-1];
 
     if (x_min <= origin[0] && origin[0] <= x_max &&
-        y_min <= origin[1] && origin[1] <= y_max &&
-        z_min <= origin[2] && origin[2] <= z_max)
+	y_min <= origin[1] && origin[1] <= y_max &&
+	z_min <= origin[2] && origin[2] <= z_max)
     {
-        hits[num_hits++] = 0.0;
+	hits[num_hits++] = 0.0;
     }
 
     if (x_min <= terminus[0] && terminus[0] <= x_max &&
-        y_min <= terminus[1] && terminus[1] <= y_max &&
-        z_min <= terminus[2] && terminus[2] <= z_max)
+	y_min <= terminus[1] && terminus[1] <= y_max &&
+	z_min <= terminus[2] && terminus[2] <= z_max)
     {
-        hits[num_hits++] = 1.0;
+	hits[num_hits++] = 1.0;
     }
 
     //
@@ -1017,29 +1119,29 @@ avtMassVoxelExtractor::FindSegmentIntersections(const double *origin,
     //
     if (terminus[0] != origin[0])
     {
-        //
-        // See if we hit the X-min face.
-        //
-        t = (x_min - origin[0]) / (terminus[0] - origin[0]);
-        y = origin[1] + t*(terminus[1] - origin[1]);
-        z = origin[2] + t*(terminus[2] - origin[2]);
-        if (y_min <= y && y <= y_max && z_min <= z && z <= z_max &&
-            t > 0. && t < 1.)
-        {
-            hits[num_hits++] = t;
-        }
-
-        //
-        // See if we hit the X-max face.
-        //
-        t = (x_max - origin[0]) / (terminus[0] - origin[0]);
-        y = origin[1] + t*(terminus[1] - origin[1]);
-        z = origin[2] + t*(terminus[2] - origin[2]);
-        if (y_min <= y && y <= y_max && z_min <= z && z <= z_max &&
-            t > 0. && t < 1.)
-        {
-            hits[num_hits++] = t;
-        }
+	//
+	// See if we hit the X-min face.
+	//
+	t = (x_min - origin[0]) / (terminus[0] - origin[0]);
+	y = origin[1] + t*(terminus[1] - origin[1]);
+	z = origin[2] + t*(terminus[2] - origin[2]);
+	if (y_min <= y && y <= y_max && z_min <= z && z <= z_max &&
+	    t > 0. && t < 1.)
+	{
+	    hits[num_hits++] = t;
+	}
+
+	//
+	// See if we hit the X-max face.
+	//
+	t = (x_max - origin[0]) / (terminus[0] - origin[0]);
+	y = origin[1] + t*(terminus[1] - origin[1]);
+	z = origin[2] + t*(terminus[2] - origin[2]);
+	if (y_min <= y && y <= y_max && z_min <= z && z <= z_max &&
+	    t > 0. && t < 1.)
+	{
+	    hits[num_hits++] = t;
+	}
     }
 
     //
@@ -1048,29 +1150,29 @@ avtMassVoxelExtractor::FindSegmentIntersections(const double *origin,
     //
     if (terminus[1] != origin[1])
     {
-        //
-        // See if we hit the Y-min face.
-        //
-        t = (y_min - origin[1]) / (terminus[1] - origin[1]);
-        x = origin[0] + t*(terminus[0] - origin[0]);
-        z = origin[2] + t*(terminus[2] - origin[2]);
-        if (x_min <= x && x <= x_max && z_min <= z && z <= z_max &&
-            t > 0. && t < 1.)
-        {
-            hits[num_hits++] = t;
-        }
-
-        //
-        // See if we hit the Y-max face.
-        //
-        t = (y_max - origin[1]) / (terminus[1] - origin[1]);
-        x = origin[0] + t*(terminus[0] - origin[0]);
-        z = origin[2] + t*(terminus[2] - origin[2]);
-        if (x_min <= x && x <= x_max && z_min <= z && z <= z_max &&
-            t > 0. && t < 1.)
-        {
-            hits[num_hits++] = t;
-        }
+	//
+	// See if we hit the Y-min face.
+	//
+	t = (y_min - origin[1]) / (terminus[1] - origin[1]);
+	x = origin[0] + t*(terminus[0] - origin[0]);
+	z = origin[2] + t*(terminus[2] - origin[2]);
+	if (x_min <= x && x <= x_max && z_min <= z && z <= z_max &&
+	    t > 0. && t < 1.)
+	{
+	    hits[num_hits++] = t;
+	}
+
+	//
+	// See if we hit the Y-max face.
+	//
+	t = (y_max - origin[1]) / (terminus[1] - origin[1]);
+	x = origin[0] + t*(terminus[0] - origin[0]);
+	z = origin[2] + t*(terminus[2] - origin[2]);
+	if (x_min <= x && x <= x_max && z_min <= z && z <= z_max &&
+	    t > 0. && t < 1.)
+	{
+	    hits[num_hits++] = t;
+	}
     }
 
     //
@@ -1079,33 +1181,33 @@ avtMassVoxelExtractor::FindSegmentIntersections(const double *origin,
     //
     if (terminus[2] != origin[2])
     {
-        //
-        // See if we hit the Z-min face.
-        //
-        t = (z_min - origin[2]) / (terminus[2] - origin[2]);
-        x = origin[0] + t*(terminus[0] - origin[0]);
-        y = origin[1] + t*(terminus[1] - origin[1]);
-        if (x_min <= x && x <= x_max && y_min <= y && y <= y_max &&
-            t > 0. && t < 1.)
-        {
-            hits[num_hits++] = t;
-        }
-
-        //
-        // See if we hit the Z-max face.
-        //
-        t = (z_max - origin[2]) / (terminus[2] - origin[2]);
-        x = origin[0] + t*(terminus[0] - origin[0]);
-        y = origin[1] + t*(terminus[1] - origin[1]);
-        if (x_min <= x && x <= x_max && y_min <= y && y <= y_max &&
-            t > 0. && t < 1.)
-        {
-            hits[num_hits++] = t;
-        }
+	//
+	// See if we hit the Z-min face.
+	//
+	t = (z_min - origin[2]) / (terminus[2] - origin[2]);
+	x = origin[0] + t*(terminus[0] - origin[0]);
+	y = origin[1] + t*(terminus[1] - origin[1]);
+	if (x_min <= x && x <= x_max && y_min <= y && y <= y_max &&
+	    t > 0. && t < 1.)
+	{
+	    hits[num_hits++] = t;
+	}
+
+	//
+	// See if we hit the Z-max face.
+	//
+	t = (z_max - origin[2]) / (terminus[2] - origin[2]);
+	x = origin[0] + t*(terminus[0] - origin[0]);
+	y = origin[1] + t*(terminus[1] - origin[1]);
+	if (x_min <= x && x <= x_max && y_min <= y && y <= y_max &&
+	    t > 0. && t < 1.)
+	{
+	    hits[num_hits++] = t;
+	}
     }
 
     if (num_hits == 0)
-        return false;
+	return false;
 
     //
     // We are expecting exactly two hits.  If we don't get that, then
@@ -1113,25 +1215,25 @@ avtMassVoxelExtractor::FindSegmentIntersections(const double *origin,
     //
     if (num_hits != 2)
     {
-        start = 0;
-        end = depth-1;
-        return true;
+	start = 0;
+	end = depth-1;
+	return true;
     }
 
     if (hits[0] > hits[1])
     {
-        double t = hits[0];
-        hits[0] = hits[1];
-        hits[1] = t;
+	double t = hits[0];
+	hits[0] = hits[1];
+	hits[1] = t;
     }
 
     if (hits[0] < 0 && hits[1] < 0)
-        // Dataset on back side of camera -- no intersection.
-        return false;
+	// Dataset on back side of camera -- no intersection.
+	return false;
 
     if (hits[0] > 1. && hits[1] > 1.)
-        // Dataset past far clipping plane -- no intersection.
-        return false;
+	// Dataset past far clipping plane -- no intersection.
+	return false;
 
     // This is the correct calculation whether we are using orthographic or
     // perspective projection ... because with perspective we are using
@@ -1139,16 +1241,16 @@ avtMassVoxelExtractor::FindSegmentIntersections(const double *origin,
     start = (int) floor(depth*hits[0]);
     end   = (int) ceil(depth*hits[1]);
     if (start < 0)
-        start = 0;
+	start = 0;
     if (end > depth)
-        end = depth;
+	end = depth;
 
     return true;
 }
 
 
 // ****************************************************************************
-//  Method: avtMassVoxelExtractor::getIndexandDistFromCenter
+//  Method: avtMassVoxelExtractor::GetIndexandDistFromCenter
 //
 //  Purpose:
 //      Compute distance
@@ -1161,30 +1263,31 @@ avtMassVoxelExtractor::FindSegmentIntersections(const double *origin,
 // ****************************************************************************
 
 void
-avtMassVoxelExtractor::getIndexandDistFromCenter(float dist, int index,    int &index_before, int &index_after,    float &dist_before, float &dist_after)
+avtMassVoxelExtractor::GetIndexandDistFromCenter
+(float dist, int index, 
+ int &index_before, int &index_after, 
+ float &dist_before, float &dist_after)
 {
     float center = 0.5;
     if (dist < center)
     {
-        index_before = index-1;
-        index_after = index;
-        dist_before = dist + center;
-        dist_after = 1.0 - dist_before;
+	index_before = index-1;
+	index_after = index;
+	dist_before = dist + center;
+	dist_after = 1.0 - dist_before;
     }
     else
     {
-        index_before = index;
-        index_after = index+1;
-        dist_before = dist - center;
-        dist_after = 1.0 - dist_before;
+	index_before = index;
+	index_after = index+1;
+	dist_before = dist - center;
+	dist_after = 1.0 - dist_before;
     }
 }
 
 
-
-
 // ****************************************************************************
-//  Method: avtImgCommunicator::computeIndices
+//  Method: avtSLIVRImgCommunicator::ComputeIndices
 //
 //  Purpose:
 //      computing indices
@@ -1198,7 +1301,7 @@ avtMassVoxelExtractor::getIndexandDistFromCenter(float dist, int index,    int &
 // ****************************************************************************
 
 void
-avtMassVoxelExtractor::computeIndices(int dims[3], int indices[6], int returnIndices[8])
+avtMassVoxelExtractor::ComputeIndices(int dims[3], int indices[6], int returnIndices[8])
 {
     returnIndices[0] = (indices[4])*((dims[0]-1)*(dims[1]-1)) + (indices[2])*(dims[0]-1) + (indices[0]);
     returnIndices[1] = (indices[4])*((dims[0]-1)*(dims[1]-1)) + (indices[2])*(dims[0]-1) + (indices[1]);
@@ -1214,7 +1317,7 @@ avtMassVoxelExtractor::computeIndices(int dims[3], int indices[6], int returnInd
 }
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::computeIndicesVert
+//  Method: avtSLIVRImgCommunicator::ComputeIndicesVert
 //
 //  Purpose:
 //      Compute indices for vertices
@@ -1227,7 +1330,7 @@ avtMassVoxelExtractor::computeIndices(int dims[3], int indices[6], int returnInd
 // ****************************************************************************
 
 void
-avtMassVoxelExtractor::computeIndicesVert(int dims[3], int indices[6], int returnIndices[8])
+avtMassVoxelExtractor::ComputeIndicesVert(int dims[3], int indices[6], int returnIndices[8])
 {
     returnIndices[0] = (indices[4])*((dims[0])*(dims[1])) + (indices[2])*(dims[0]) + (indices[0]);
     returnIndices[1] = (indices[4])*((dims[0])*(dims[1])) + (indices[2])*(dims[0]) + (indices[1]);
@@ -1244,7 +1347,7 @@ avtMassVoxelExtractor::computeIndicesVert(int dims[3], int indices[6], int retur
 
 
 // ****************************************************************************
-//  Method: avtImgCommunicator::trilinearInterpolate
+//  Method: avtSLIVRImgCommunicator::TrilinearInterpolate
 //
 //  Purpose:
 //      Trilinear interpolation
@@ -1257,7 +1360,8 @@ avtMassVoxelExtractor::computeIndicesVert(int dims[3], int indices[6], int retur
 // ****************************************************************************
 
 double
-avtMassVoxelExtractor::trilinearInterpolate(double vals[8], float distRight, float distTop, float distBack)
+avtMassVoxelExtractor::TrilinearInterpolate
+(double vals[8], float distRight, float distTop, float distBack)
 {
     float dist_from_right = 1.0 - distRight;
     float dist_from_left = distRight;
@@ -1268,15 +1372,15 @@ avtMassVoxelExtractor::trilinearInterpolate(double vals[8], float distRight, flo
     float dist_from_back = 1.0 - distBack;
     float dist_from_front = distBack;
 
-    double val =    dist_from_right     * dist_from_top         * dist_from_back * vals[0] +
-                    dist_from_left      * dist_from_top         * dist_from_back * vals[1] +
-                    dist_from_right     * dist_from_bottom      * dist_from_back * vals[2] +
-                    dist_from_left      * dist_from_bottom      * dist_from_back * vals[3] +
-
-                    dist_from_right     * dist_from_top         * dist_from_front * vals[4] +
-                    dist_from_left      * dist_from_top         * dist_from_front * vals[5] +
-                    dist_from_right     * dist_from_bottom      * dist_from_front * vals[6] +
-                    dist_from_left      * dist_from_bottom      * dist_from_front * vals[7];
+    double val =   
+	dist_from_right     * dist_from_top         * dist_from_back * vals[0] +
+	dist_from_left      * dist_from_top         * dist_from_back * vals[1] +
+	dist_from_right     * dist_from_bottom      * dist_from_back * vals[2] +
+	dist_from_left      * dist_from_bottom      * dist_from_back * vals[3] +
+	dist_from_right     * dist_from_top         * dist_from_front * vals[4] +
+	dist_from_left      * dist_from_top         * dist_from_front * vals[5] +
+	dist_from_right     * dist_from_bottom      * dist_from_front * vals[6] +
+	dist_from_left      * dist_from_bottom      * dist_from_front * vals[7];
     return val;
 }
 
@@ -1310,192 +1414,192 @@ avtMassVoxelExtractor::SampleVariable(int first, int last, int w, int h)
     double dest_rgb[4] = {0.0,0.0,0.0, 0.0};     // to store the computed color
     for (int i = first ; i < last ; i++)
     {
-        const int *ind = ind_buffer + 3*i;
-        const double *prop = prop_buffer + 3*i;
-
-        int index = 0;
-        if (calc_cell_index)
-            index = ind[2]*((dims[0]-1)*(dims[1]-1)) + ind[1]*(dims[0]-1) + ind[0];
-
-        if (ghosts != NULL)
-        {
-            if (ghosts[index] != 0)
-               valid_sample[i] = false;
-        }
-
-        if (!valid_sample[i] && inrun)
-        {
-            ray->SetSamples(i-count, i-1, tmpSampleList);
-            inrun = false;
-            count = 0;
-        }
-
-
-        //
-        // Trilinear SETUP
-        int indices[6];
-        float dist_from_left, dist_from_right,  dist_from_top,dist_from_bottom,  dist_from_front, dist_from_back;
-        float x_left, y_bottom, z_front;
-
-        if (trilinearInterpolation)
-        {
-            int index_left, index_right,            index_top, index_bottom,         index_front, index_back;
-
-            int newInd[3];
-            newInd[0] = ind[0];
-            newInd[1] = ind[1];
-            newInd[2] = ind[2];
-
-            float x_right = prop[0];        x_left   = 1. - x_right;
-            float y_top   = prop[1];        y_bottom = 1. - y_top;
-            float z_back  = prop[2];        z_front  = 1. - z_back;
-
-            // get the index and distance from the center of the neighbouring cells
-            getIndexandDistFromCenter(x_right, newInd[0], index_left, index_right,   dist_from_left, dist_from_right);
-            getIndexandDistFromCenter(y_top,   newInd[1], index_bottom,index_top,    dist_from_bottom,dist_from_top);
-            getIndexandDistFromCenter(z_back,  newInd[2], index_front, index_back,   dist_from_front, dist_from_back);
-
-
-            indices[4] = index_front;       indices[5] = index_back;
-            indices[2] = index_bottom;      indices[3] = index_top;
-            indices[0] = index_left;        indices[1] = index_right;
-
-
-            if (indices[0] < 0 || indices[0]>dims[0]-2)
-                valid_sample[i] = false;
-
-            if (indices[1] < 0 || indices[1]>dims[0]-2)
-                valid_sample[i] = false;
-
-
-            if (indices[2] < 0 || indices[2]>dims[1]-2)
-                valid_sample[i] = false;
-
-            if (indices[3] < 0 || indices[3]>dims[1]-2)
-                valid_sample[i] = false;
-
-
-            if (indices[4] < 0 || indices[4]>dims[2]-2)
-                valid_sample[i] = false;
-
-            if (indices[5] < 0 || indices[5]>dims[2]-2)
-                valid_sample[i] = false;
-        }
-
-        if (!valid_sample[i])
-            continue;
-
-        //
-        // Trilinear RUN
-        if (trilinearInterpolation)
-        {
-            //
-            // Cell centered data
-            //
-            if (ncell_arrays > 0){
-                int indexT[8];
-                computeIndices(dims, indices, indexT);
-
-                for (int l = 0 ; l < ncell_arrays ; l++)            // ncell_arrays: usually 1
-                {
-
-                    void  *cell_array = cell_arrays[l];
-                    double values[8];
-                    for (int m = 0 ; m < cell_size[l] ; m++){       // cell_size[l] usually 1
-                        AssignEight(cell_vartypes[l], values, indexT, cell_size[l], m, cell_array);
-                        double scalarValue = trilinearInterpolate(values, dist_from_left, dist_from_bottom, dist_from_front);
-
-                        tmpSampleList[count][cell_index[l]+m] = scalarValue;
-                    }
-                }
-            }
-
-            //
-            // Node centered data
-            //
-            if (npt_arrays > 0)
-            {
-                int indexT[8];
-                computeIndicesVert(dims, indices, indexT);
-
-                for (int l = 0 ; l < npt_arrays ; l++)
-                {
-                    void  *pt_array = pt_arrays[l];
-                    double values[8];
-                    for (int m = 0 ; m < pt_size[l] ; m++)
-                    {
-                        AssignEight(pt_vartypes[l], values, indexT, pt_size[l], m, pt_array);
-                        double scalarValue = trilinearInterpolate(values, x_left, y_bottom, z_front);
-
-                        tmpSampleList[count][pt_index[l]+m] = scalarValue;
-                    }
-                }
-            }
-        }
-        else
-        {
-            if (ncell_arrays > 0)
-            {
-                for (int l = 0 ; l < ncell_arrays ; l++)
-                {
-                    for (int m = 0 ; m < cell_size[l] ; m++)
-                        tmpSampleList[count][cell_index[l]+m] =
-                                         ConvertToDouble(cell_vartypes[l], index,
-                                                      cell_size[l], m, cell_arrays[l]);
-                }
-            }
-
-            if (npt_arrays > 0)
-            {
-                int index[8];
-                index[0] = (ind[2])  *dims[0]*dims[1] + (ind[1])  *dims[0] + (ind[0]);
-                index[1] = (ind[2])  *dims[0]*dims[1] + (ind[1])  *dims[0] + (ind[0]+1);
-                index[2] = (ind[2])  *dims[0]*dims[1] + (ind[1]+1)*dims[0] + (ind[0]);
-                index[3] = (ind[2])  *dims[0]*dims[1] + (ind[1]+1)*dims[0] + (ind[0]+1);
-                index[4] = (ind[2]+1)*dims[0]*dims[1] + (ind[1])  *dims[0] + (ind[0]);
-                index[5] = (ind[2]+1)*dims[0]*dims[1] + (ind[1])  *dims[0] + (ind[0]+1);
-                index[6] = (ind[2]+1)*dims[0]*dims[1] + (ind[1]+1)*dims[0] + (ind[0]);
-                index[7] = (ind[2]+1)*dims[0]*dims[1] + (ind[1]+1)*dims[0] + (ind[0]+1);
-
-                double x_right = prop[0];
-                double x_left = 1. - prop[0];
-                double y_top = prop[1];
-                double y_bottom = 1. - prop[1];
-                double z_back = prop[2];
-                double z_front = 1. - prop[2];
-                for (int l = 0 ; l < npt_arrays ; l++)
-                {
-                    void  *pt_array = pt_arrays[l];
-                    int    s = pt_size[l];
-                    for (int m = 0 ; m < s ; m++)
-                    {
-                        double vals[8];
-                        AssignEight(pt_vartypes[l], vals, index, s, m, pt_array);
-                        double val =
-                          x_left*y_bottom*z_front*vals[0] +
-                          x_right*y_bottom*z_front*vals[1] +
-                          x_left*y_top*z_front*vals[2] +
-                          x_right*y_top*z_front*vals[3] +
-                          x_left*y_bottom*z_back*vals[4] +
-                          x_right*y_bottom*z_back*vals[5] +
-                          x_left*y_top*z_back*vals[6] +
-                          x_right*y_top*z_back*vals[7];
-
-                        tmpSampleList[count][pt_index[l]+m] = val;
-                    }
-                }
-            }
-        }
-
-        inrun = true;
-        count++;
+	const int *ind = ind_buffer + 3*i;
+	const double *prop = prop_buffer + 3*i;
+	
+	int index = 0;
+	if (calc_cell_index)
+	    index = ind[2]*((dims[0]-1)*(dims[1]-1)) + ind[1]*(dims[0]-1) + ind[0];
+
+	if (ghosts != NULL)
+	{
+	    if (ghosts[index] != 0)
+		valid_sample[i] = false;
+	}
+
+	if (!valid_sample[i] && inrun)
+	{
+	    ray->SetSamples(i-count, i-1, tmpSampleList);
+	    inrun = false;
+	    count = 0;
+	}
+
+
+	//
+	// Trilinear SETUP
+	int indices[6];
+	float dist_from_left, dist_from_right,  dist_from_top,dist_from_bottom,  dist_from_front, dist_from_back;
+	float x_left, y_bottom, z_front;
+
+	if (trilinearInterpolation)
+	{
+	    int index_left, index_right,            index_top, index_bottom,         index_front, index_back;
+
+	    int newInd[3];
+	    newInd[0] = ind[0];
+	    newInd[1] = ind[1];
+	    newInd[2] = ind[2];
+
+	    float x_right = prop[0];        x_left   = 1. - x_right;
+	    float y_top   = prop[1];        y_bottom = 1. - y_top;
+	    float z_back  = prop[2];        z_front  = 1. - z_back;
+
+	    // get the index and distance from the center of the neighbouring cells
+	    GetIndexandDistFromCenter(x_right, newInd[0], index_left, index_right,   dist_from_left, dist_from_right);
+	    GetIndexandDistFromCenter(y_top,   newInd[1], index_bottom,index_top,    dist_from_bottom,dist_from_top);
+	    GetIndexandDistFromCenter(z_back,  newInd[2], index_front, index_back,   dist_from_front, dist_from_back);
+
+
+	    indices[4] = index_front;       indices[5] = index_back;
+	    indices[2] = index_bottom;      indices[3] = index_top;
+	    indices[0] = index_left;        indices[1] = index_right;
+
+
+	    if (indices[0] < 0 || indices[0]>dims[0]-2)
+		valid_sample[i] = false;
+
+	    if (indices[1] < 0 || indices[1]>dims[0]-2)
+		valid_sample[i] = false;
+
+
+	    if (indices[2] < 0 || indices[2]>dims[1]-2)
+		valid_sample[i] = false;
+
+	    if (indices[3] < 0 || indices[3]>dims[1]-2)
+		valid_sample[i] = false;
+
+
+	    if (indices[4] < 0 || indices[4]>dims[2]-2)
+		valid_sample[i] = false;
+
+	    if (indices[5] < 0 || indices[5]>dims[2]-2)
+		valid_sample[i] = false;
+	}
+
+	if (!valid_sample[i])
+	    continue;
+
+	//
+	// Trilinear RUN
+	if (trilinearInterpolation)
+	{
+	    //
+	    // Cell centered data
+	    //
+	    if (ncell_arrays > 0){
+		int indexT[8];
+		ComputeIndices(dims, indices, indexT);
+
+		for (int l = 0 ; l < ncell_arrays ; l++)            // ncell_arrays: usually 1
+		{
+
+		    void  *cell_array = cell_arrays[l];
+		    double values[8];
+		    for (int m = 0 ; m < cell_size[l] ; m++){       // cell_size[l] usually 1
+			AssignEight(cell_vartypes[l], values, indexT, cell_size[l], m, cell_array);
+			double scalarValue = TrilinearInterpolate(values, dist_from_left, dist_from_bottom, dist_from_front);
+
+			tmpSampleList[count][cell_index[l]+m] = scalarValue;
+		    }
+		}
+	    }
+
+	    //
+	    // Node centered data
+	    //
+	    if (npt_arrays > 0)
+	    {
+		int indexT[8];
+		ComputeIndicesVert(dims, indices, indexT);
+
+		for (int l = 0 ; l < npt_arrays ; l++)
+		{
+		    void  *pt_array = pt_arrays[l];
+		    double values[8];
+		    for (int m = 0 ; m < pt_size[l] ; m++)
+		    {
+			AssignEight(pt_vartypes[l], values, indexT, pt_size[l], m, pt_array);
+			double scalarValue = TrilinearInterpolate(values, x_left, y_bottom, z_front);
+
+			tmpSampleList[count][pt_index[l]+m] = scalarValue;
+		    }
+		}
+	    }
+	}
+	else
+	{
+	    if (ncell_arrays > 0)
+	    {
+		for (int l = 0 ; l < ncell_arrays ; l++)
+		{
+		    for (int m = 0 ; m < cell_size[l] ; m++)
+			tmpSampleList[count][cell_index[l]+m] =
+			    ConvertToDouble(cell_vartypes[l], index,
+					    cell_size[l], m, cell_arrays[l]);
+		}
+	    }
+
+	    if (npt_arrays > 0)
+	    {
+		int index[8];
+		index[0] = (ind[2])  *dims[0]*dims[1] + (ind[1])  *dims[0] + (ind[0]);
+		index[1] = (ind[2])  *dims[0]*dims[1] + (ind[1])  *dims[0] + (ind[0]+1);
+		index[2] = (ind[2])  *dims[0]*dims[1] + (ind[1]+1)*dims[0] + (ind[0]);
+		index[3] = (ind[2])  *dims[0]*dims[1] + (ind[1]+1)*dims[0] + (ind[0]+1);
+		index[4] = (ind[2]+1)*dims[0]*dims[1] + (ind[1])  *dims[0] + (ind[0]);
+		index[5] = (ind[2]+1)*dims[0]*dims[1] + (ind[1])  *dims[0] + (ind[0]+1);
+		index[6] = (ind[2]+1)*dims[0]*dims[1] + (ind[1]+1)*dims[0] + (ind[0]);
+		index[7] = (ind[2]+1)*dims[0]*dims[1] + (ind[1]+1)*dims[0] + (ind[0]+1);
+
+		double x_right = prop[0];
+		double x_left = 1. - prop[0];
+		double y_top = prop[1];
+		double y_bottom = 1. - prop[1];
+		double z_back = prop[2];
+		double z_front = 1. - prop[2];
+		for (int l = 0 ; l < npt_arrays ; l++)
+		{
+		    void  *pt_array = pt_arrays[l];
+		    int    s = pt_size[l];
+		    for (int m = 0 ; m < s ; m++)
+		    {
+			double vals[8];
+			AssignEight(pt_vartypes[l], vals, index, s, m, pt_array);
+			double val =
+			    x_left*y_bottom*z_front*vals[0] +
+			    x_right*y_bottom*z_front*vals[1] +
+			    x_left*y_top*z_front*vals[2] +
+			    x_right*y_top*z_front*vals[3] +
+			    x_left*y_bottom*z_back*vals[4] +
+			    x_right*y_bottom*z_back*vals[5] +
+			    x_left*y_top*z_back*vals[6] +
+			    x_right*y_top*z_back*vals[7];
+
+			tmpSampleList[count][pt_index[l]+m] = val;
+		    }
+		}
+	    }
+	}
+
+	inrun = true;
+	count++;
     }
 
     //
     // Make sure we get runs at the end.
     //
     if (inrun)
-        ray->SetSamples(last-count, last-1, tmpSampleList);
+	ray->SetSamples(last-count, last-1, tmpSampleList);
 }
 
 // ****************************************************************************
@@ -1516,19 +1620,19 @@ avtMassVoxelExtractor::SampleVariable(int first, int last, int w, int h)
 static inline int FindMatch(const double *A, const double &a, const int &nA)
 {
     if ((a < A[0]) || (a > A[nA-1]))
-        return -1;
+	return -1;
 
     int low = 0;
     int hi  = nA-1;
     while ((hi - low) > 1)
     {
-        int guess = (hi+low)/2;
-        if (A[guess] == a)
-            return guess;
-        if (a < A[guess])
-            hi = guess;
-        else
-            low = guess;
+	int guess = (hi+low)/2;
+	if (A[guess] == a)
+	    return guess;
+	if (a < A[guess])
+	    hi = guess;
+	else
+	    low = guess;
     }
 
     return low;
@@ -1552,18 +1656,18 @@ static inline int FindMatch(const double *A, const double &a, const int &nA)
 
 template <class T> inline int
 FindIndex(const double &pt, const int &last_hit, const int &n,
-          T *vals)
+	  T *vals)
 {
     for (int i = last_hit ; i < n-1 ; ++i)
     {
-        if (pt >= (double)vals[i] && (pt <= (double)vals[i+1]))
-            return i;
+	if (pt >= (double)vals[i] && (pt <= (double)vals[i+1]))
+	    return i;
     }
 
     for (int i = 0 ; i < last_hit ; ++i)
     {
-        if (pt >= (double)vals[i] && (pt <= (double)vals[i+1]))
-            return i;
+	if (pt >= (double)vals[i] && (pt <= (double)vals[i+1]))
+	    return i;
     }
 
     return -1;
@@ -1571,13 +1675,15 @@ FindIndex(const double &pt, const int &last_hit, const int &n,
 
 inline int
 FindIndex(vtkDataArray *coordArray,const double &pt, const int &last_hit,
-          const int &n)
+	  const int &n)
 {
     switch(coordArray->GetDataType())
     {
-        vtkTemplateAliasMacro(return FindIndex(pt, last_hit, n,
-            static_cast<VTK_TT *>(coordArray->GetVoidPointer(0))));
-        default:    return -1;
+	vtkTemplateAliasMacro
+	    (return FindIndex(pt, last_hit, n,
+			      static_cast<VTK_TT *>
+			      (coordArray->GetVoidPointer(0))));
+    default:    return -1;
     }
 }
 
@@ -1606,10 +1712,11 @@ FindRange(vtkDataArray *coordArray, int ind, double c, double &min, double &max)
 {
     switch(coordArray->GetDataType())
     {
-        vtkTemplateAliasMacro(FindRange(ind, c, min, max,
-            static_cast<VTK_TT *>(coordArray->GetVoidPointer(0))));
-        default:
-            EXCEPTION1(VisItException, "Unknown Coordinate type");
+	vtkTemplateAliasMacro
+	    (FindRange(ind, c, min, max,
+		       static_cast<VTK_TT *>(coordArray->GetVoidPointer(0))));
+    default:
+	EXCEPTION1(VisItException, "Unknown Coordinate type");
     }
 }
 
@@ -1659,7 +1766,8 @@ FindRange(vtkDataArray *coordArray, int ind, double c, double &min, double &max)
 
 void
 avtMassVoxelExtractor::ExtractImageSpaceGrid(vtkRectilinearGrid *rgrid,
-                std::vector<std::string> &varnames, std::vector<int> &varsizes)
+					     std::vector<std::string> &varnames,
+					     std::vector<int> &varsizes)
 {
     int  i, j, k, l, m;
 
@@ -1673,33 +1781,33 @@ avtMassVoxelExtractor::ExtractImageSpaceGrid(vtkRectilinearGrid *rgrid,
     int last_y_hit = 0;
     int last_z_hit = 0;
 
-    vtkUnsignedCharArray *ghosts = (vtkUnsignedCharArray *)rgrid->GetCellData()
-                                                   ->GetArray("avtGhostZones");
+    vtkUnsignedCharArray *ghosts = 
+	(vtkUnsignedCharArray *)rgrid->GetCellData()->GetArray("avtGhostZones");
     std::vector<void *>  cell_arrays;
     std::vector<int>     cell_vartypes;
     std::vector<int>     cell_size;
     std::vector<int>     cell_index;
     for (i = 0 ; i < rgrid->GetCellData()->GetNumberOfArrays() ; i++)
     {
-        vtkDataArray *arr = rgrid->GetCellData()->GetArray(i);
-        const char *name = arr->GetName();
-        int idx = -1;
-        for (j = 0 ; j < (int)varnames.size() ; j++)
-        {
-            if (varnames[j] == name)
-            {
-                idx = 0;
-                for (k = 0 ; k < j ; k++)
-                    idx += varsizes[k];
-                break;
-            }
-        }
-        if (idx < 0)
-            continue;
-        cell_index.push_back(idx);
-        cell_size.push_back(arr->GetNumberOfComponents());
-        cell_vartypes.push_back(arr->GetDataType());
-        cell_arrays.push_back(arr->GetVoidPointer(0));
+	vtkDataArray *arr = rgrid->GetCellData()->GetArray(i);
+	const char *name = arr->GetName();
+	int idx = -1;
+	for (j = 0 ; j < (int)varnames.size() ; j++)
+	{
+	    if (varnames[j] == name)
+	    {
+		idx = 0;
+		for (k = 0 ; k < j ; k++)
+		    idx += varsizes[k];
+		break;
+	    }
+	}
+	if (idx < 0)
+	    continue;
+	cell_index.push_back(idx);
+	cell_size.push_back(arr->GetNumberOfComponents());
+	cell_vartypes.push_back(arr->GetDataType());
+	cell_arrays.push_back(arr->GetVoidPointer(0));
     }
 
     std::vector<void *>  pt_arrays;
@@ -1708,25 +1816,25 @@ avtMassVoxelExtractor::ExtractImageSpaceGrid(vtkRectilinearGrid *rgrid,
     std::vector<int>     pt_index;
     for (i = 0 ; i < rgrid->GetPointData()->GetNumberOfArrays() ; i++)
     {
-        vtkDataArray *arr = rgrid->GetPointData()->GetArray(i);
-        const char *name = arr->GetName();
-        int idx = -1;
-        for (j = 0 ; j < (int)varnames.size() ; j++)
-        {
-            if (varnames[j] == name)
-            {
-                idx = 0;
-                for (k = 0 ; k < j ; k++)
-                    idx += varsizes[k];
-                break;
-            }
-        }
-        if (idx < 0)
-            continue;
-        pt_index.push_back(idx);
-        pt_size.push_back(arr->GetNumberOfComponents());
-        pt_vartypes.push_back(arr->GetDataType());
-        pt_arrays.push_back(arr->GetVoidPointer(0));
+	vtkDataArray *arr = rgrid->GetPointData()->GetArray(i);
+	const char *name = arr->GetName();
+	int idx = -1;
+	for (j = 0 ; j < (int)varnames.size() ; j++)
+	{
+	    if (varnames[j] == name)
+	    {
+		idx = 0;
+		for (k = 0 ; k < j ; k++)
+		    idx += varsizes[k];
+		break;
+	    }
+	}
+	if (idx < 0)
+	    continue;
+	pt_index.push_back(idx);
+	pt_size.push_back(arr->GetNumberOfComponents());
+	pt_vartypes.push_back(arr->GetDataType());
+	pt_arrays.push_back(arr->GetVoidPointer(0));
     }
 
     vtkDataArray *xarray = rgrid->GetXCoordinates();
@@ -1742,131 +1850,131 @@ avtMassVoxelExtractor::ExtractImageSpaceGrid(vtkRectilinearGrid *rgrid,
 
     for (j = startY ; j <= stopY ; j++)
     {
-        double yc = YFromIndex(j);
-        int yind = FindIndex(yarray, yc, last_y_hit, nY);
-        if (yind == -1)
-            continue;
-        last_y_hit = yind;
-
-        double y_bottom  = 0.;
-        double y_top = 1.;
-        if (pt_arrays.size() > 0)
-        {
-            FindRange(yarray, yind, yc, y_bottom, y_top);
-        }
-        for (i = startX ; i <= stopX ; i++)
-        {
-            double xc = XFromIndex(i);
-            int xind = FindIndex(xarray, xc, last_x_hit, nX);
-            if (xind == -1)
-                continue;
-            last_x_hit = xind;
-
-            double x_left  = 0.;
-            double x_right = 1.;
-            if (pt_arrays.size() > 0)
-            {
-                FindRange(xarray, xind, xc, x_left, x_right);
-            }
-
-            last_z_hit = 0;
-            int count = 0;
-            int firstZ = -1;
-            int lastZ  = stopZ;
-            for (k = startZ ; k <= stopZ ; k++)
-            {
-                double zc = ZFromIndex(k);
-                int zind = FindIndex(zarray, zc, last_z_hit, nZ);
-                if (zind == -1)
-                {
-                    if (firstZ == -1)
-                        continue;
-                    else
-                    {
-                        lastZ = k-1;
-                        break;
-                    }
-                }
-                if ((count == 0) && (firstZ == -1))
-                    firstZ = k;
-                last_z_hit = zind;
-
-                //
-                // Don't sample from ghost zones.
-                //
-                if (ghosts != NULL)
-                {
-                    int index = zind*((nX-1)*(nY-1)) + yind*(nX-1) + xind;
-                    if (ghosts->GetValue(index) != 0)
-                    {
-                        if (count > 0)
-                        {
-                            avtRay *ray = volume->GetRay(i, j);
-                            ray->SetSamples(firstZ, k-1, tmpSampleList);
-                        }
-                        firstZ = -1;
-                        count = 0;
-                        continue;
-                    }
-                }
-
-                double z_front  = 0.;
-                double z_back = 1.;
-                if (pt_arrays.size() > 0)
-                {
-                    FindRange(zarray, zind, zc, z_front, z_back);
-                }
-
-                for (l = 0 ; l < (int)cell_arrays.size() ; l++)
-                {
-                    int index = zind*((nX-1)*(nY-1)) + yind*(nX-1) + xind;
-                    for (m = 0 ; m < cell_size[l] ; m++)
-                        tmpSampleList[count][cell_index[l]+m] =
-                                  ConvertToDouble(cell_vartypes[l],index,
-                                              cell_size[l], m, cell_arrays[l]);
-                }
-                if (pt_arrays.size() > 0)
-                {
-                    int index[8];
-                    index[0] = (zind)*nX*nY + (yind)*nX + (xind);
-                    index[1] = (zind)*nX*nY + (yind)*nX + (xind+1);
-                    index[2] = (zind)*nX*nY + (yind+1)*nX + (xind);
-                    index[3] = (zind)*nX*nY + (yind+1)*nX + (xind+1);
-                    index[4] = (zind+1)*nX*nY + (yind)*nX + (xind);
-                    index[5] = (zind+1)*nX*nY + (yind)*nX + (xind+1);
-                    index[6] = (zind+1)*nX*nY + (yind+1)*nX + (xind);
-                    index[7] = (zind+1)*nX*nY + (yind+1)*nX + (xind+1);
-                    for (l = 0 ; l < (int)pt_arrays.size() ; l++)
-                    {
-                        void  *pt_array = pt_arrays[l];
-                        int    s        = pt_size[l];
-                        for (m = 0 ; m < s ; m++)
-                        {
-                            double vals[8];
-                            AssignEight(pt_vartypes[l], vals, index,
-                                        s, m, pt_array);
-                            double val =
-                                  x_left*y_bottom*z_front*vals[0] +
-                                  x_right*y_bottom*z_front*vals[1] +
-                                  x_left*y_top*z_front*vals[2] +
-                                  x_right*y_top*z_front*vals[3] +
-                                  x_left*y_bottom*z_back*vals[4] +
-                                  x_right*y_bottom*z_back*vals[5] +
-                                  x_left*y_top*z_back*vals[6] +
-                                  x_right*y_top*z_back*vals[7];
-                            tmpSampleList[count][pt_index[l]+m] = val;
-                        }
-                    }
-                }
-                count++;
-            }
-
-            if (count > 0)
-            {
-                avtRay *ray = volume->GetRay(i, j);
-                ray->SetSamples(firstZ, lastZ, tmpSampleList);
-            }
-        }
+	double yc = YFromIndex(j);
+	int yind = FindIndex(yarray, yc, last_y_hit, nY);
+	if (yind == -1)
+	    continue;
+	last_y_hit = yind;
+
+	double y_bottom  = 0.;
+	double y_top = 1.;
+	if (pt_arrays.size() > 0)
+	{
+	    FindRange(yarray, yind, yc, y_bottom, y_top);
+	}
+	for (i = startX ; i <= stopX ; i++)
+	{
+	    double xc = XFromIndex(i);
+	    int xind = FindIndex(xarray, xc, last_x_hit, nX);
+	    if (xind == -1)
+		continue;
+	    last_x_hit = xind;
+
+	    double x_left  = 0.;
+	    double x_right = 1.;
+	    if (pt_arrays.size() > 0)
+	    {
+		FindRange(xarray, xind, xc, x_left, x_right);
+	    }
+
+	    last_z_hit = 0;
+	    int count = 0;
+	    int firstZ = -1;
+	    int lastZ  = stopZ;
+	    for (k = startZ ; k <= stopZ ; k++)
+	    {
+		double zc = ZFromIndex(k);
+		int zind = FindIndex(zarray, zc, last_z_hit, nZ);
+		if (zind == -1)
+		{
+		    if (firstZ == -1)
+			continue;
+		    else
+		    {
+			lastZ = k-1;
+			break;
+		    }
+		}
+		if ((count == 0) && (firstZ == -1))
+		    firstZ = k;
+		last_z_hit = zind;
+
+		//
+		// Don't sample from ghost zones.
+		//
+		if (ghosts != NULL)
+		{
+		    int index = zind*((nX-1)*(nY-1)) + yind*(nX-1) + xind;
+		    if (ghosts->GetValue(index) != 0)
+		    {
+			if (count > 0)
+			{
+			    avtRay *ray = volume->GetRay(i, j);
+			    ray->SetSamples(firstZ, k-1, tmpSampleList);
+			}
+			firstZ = -1;
+			count = 0;
+			continue;
+		    }
+		}
+
+		double z_front  = 0.;
+		double z_back = 1.;
+		if (pt_arrays.size() > 0)
+		{
+		    FindRange(zarray, zind, zc, z_front, z_back);
+		}
+
+		for (l = 0 ; l < (int)cell_arrays.size() ; l++)
+		{
+		    int index = zind*((nX-1)*(nY-1)) + yind*(nX-1) + xind;
+		    for (m = 0 ; m < cell_size[l] ; m++)
+			tmpSampleList[count][cell_index[l]+m] =
+			    ConvertToDouble(cell_vartypes[l],index,
+					    cell_size[l], m, cell_arrays[l]);
+		}
+		if (pt_arrays.size() > 0)
+		{
+		    int index[8];
+		    index[0] = (zind)*nX*nY + (yind)*nX + (xind);
+		    index[1] = (zind)*nX*nY + (yind)*nX + (xind+1);
+		    index[2] = (zind)*nX*nY + (yind+1)*nX + (xind);
+		    index[3] = (zind)*nX*nY + (yind+1)*nX + (xind+1);
+		    index[4] = (zind+1)*nX*nY + (yind)*nX + (xind);
+		    index[5] = (zind+1)*nX*nY + (yind)*nX + (xind+1);
+		    index[6] = (zind+1)*nX*nY + (yind+1)*nX + (xind);
+		    index[7] = (zind+1)*nX*nY + (yind+1)*nX + (xind+1);
+		    for (l = 0 ; l < (int)pt_arrays.size() ; l++)
+		    {
+			void  *pt_array = pt_arrays[l];
+			int    s        = pt_size[l];
+			for (m = 0 ; m < s ; m++)
+			{
+			    double vals[8];
+			    AssignEight(pt_vartypes[l], vals, index,
+					s, m, pt_array);
+			    double val =
+				x_left*y_bottom*z_front*vals[0] +
+				x_right*y_bottom*z_front*vals[1] +
+				x_left*y_top*z_front*vals[2] +
+				x_right*y_top*z_front*vals[3] +
+				x_left*y_bottom*z_back*vals[4] +
+				x_right*y_bottom*z_back*vals[5] +
+				x_left*y_top*z_back*vals[6] +
+				x_right*y_top*z_back*vals[7];
+			    tmpSampleList[count][pt_index[l]+m] = val;
+			}
+		    }
+		}
+		count++;
+	    }
+
+	    if (count > 0)
+	    {
+		avtRay *ray = volume->GetRay(i, j);
+		ray->SetSamples(firstZ, lastZ, tmpSampleList);
+	    }
+	}
     }
 }
 
@@ -1897,24 +2005,24 @@ avtMassVoxelExtractor::ExtractImageSpaceGrid(vtkRectilinearGrid *rgrid,
 // ****************************************************************************
 
 void
-avtMassVoxelExtractor::SampleAlongSegment(const double *origin,
-                                          const double *terminus, int w, int h)
+avtMassVoxelExtractor::SampleAlongSegment
+(const double *origin, const double *terminus, int w, int h)
 {
     int first = 0;
     int last = 0;
-    bool hasIntersections = FindSegmentIntersections(origin, terminus,
-                                                     first, last);
+    bool hasIntersections = 
+	FindSegmentIntersections(origin, terminus, first, last);
 
-    if (!hasIntersections)
-        return;
+    if (!hasIntersections) { return; }
 
     //
     // Determine if there is intersection with buffer
-    bool rcSLIVRBufferMerge = false;
-    double _worldOpaqueCoordinates[3];
-    bool intesecting = false;
-    int intersect = -1;
-    float posAlongVector = 0;
+    //
+    // bool rcSLIVRBufferMerge = false;
+    double worldOpaqueCoordinates[3];
+    bool intersecting = false;
+    int  intersect = -1;
+    float propAlongVector = 0.0f;
 
     bool foundHit = false;
     int curX = -1;
@@ -1931,216 +2039,242 @@ avtMassVoxelExtractor::SampleAlongSegment(const double *origin,
     double pt[3];
     bool hasSamples = false;
 
-
-
     if (rayCastingSLIVR)
     {
-        int screenX = bufferExtents[1] - bufferExtents[0];
-        int screenY = bufferExtents[3] - bufferExtents[2];
-
-        int _index = h*screenX + w;
-
-        if (depthBuffer[_index] != 1)  // There is some other things to blend with at this location ...
-        {
-            float normalizedDepth = depthBuffer[_index]*2 - 1;  // switching from (0 - 1) to (-1 - 1)
-
-            //debug5 << "normalizedDepth: " <<normalizedDepth << "  renderingDepthsExtents[0]: " << renderingDepthsExtents[0] << "   renderingDepthsExtents[1]:" << renderingDepthsExtents[1] << std::endl;
-            if ( (normalizedDepth >= renderingDepthsExtents[0]) && (normalizedDepth <= renderingDepthsExtents[1]) )  // ... and it's within this patch
-            {
-                rcSLIVRBufferMerge = true;
-                unProject(w,h, depthBuffer[_index], _worldOpaqueCoordinates, fullImgWidth, fullImgHeight);
-                //debug5 << "Location: " << w << ", " << h << std::endl;
-
-                double start[3];
-                start[0] = terminus[0];
-                start[1] = terminus[1];
-                start[2] = terminus[2];
-                if (xGoingUp)
-                    start[0] = origin[0];
+	int screenX = bufferExtents[1] - bufferExtents[0];
+	int screenY = bufferExtents[3] - bufferExtents[2];
+	int screenIndex = h * screenX + w;
+	if (screenIndex < 0 || screenIndex >= screenX * screenY) { return; }
+
+	if (depthBuffer[screenIndex] != 1)  	    
+	{
+	    // There is some other things to blend with at this location ...
+            // -- switching from (0 - 1) to (-1 - 1)
+	    float normalizedDepth = depthBuffer[screenIndex]*2 - 1;  
+
+	    debug5 << "normalizedDepth: " << normalizedDepth << " "
+	    	   << "renderingDepthsExtents[0]: " 
+		   << renderingDepthsExtents[0] << " " 
+	    	   << "renderingDepthsExtents[1]: " 
+		   << renderingDepthsExtents[1] << std::endl;
+
+	    // ... and it's within this patch
+	    if ((normalizedDepth >= renderingDepthsExtents[0]) && 
+		(normalizedDepth <= renderingDepthsExtents[1]))  
+	    {
+		//rcSLIVRBufferMerge = true;
+
+		// unProject(w,h, depthBuffer[screenIndex], worldOpaqueCoordinates, 
+		// 	     fullImgWidth, fullImgHeight);
+
+		slivr::ProjectScreenToWorld(w, h, depthBuffer[screenIndex],
+					    fullImgWidth, fullImgHeight, 
+					    panPercentage, imageZoom, 
+					    screen_to_model_transform,
+					    worldOpaqueCoordinates);
+
+		//debug5 << "Location: " << w << ", " << h << std::endl;
+		// double start[3];
+		// start[0] = terminus[0];
+		// start[1] = terminus[1];
+		// start[2] = terminus[2];
+		// if (xGoingUp)
+		//     start[0] = origin[0];
+		// if (yGoingUp)
+		//     start[1] = origin[1];
+		// if (zGoingUp)
+		//     start[1] = origin[2];
+
+		double start[3] = {
+		    xGoingUp ? origin[0] : terminus[0],
+		    yGoingUp ? origin[1] : terminus[1],
+		    zGoingUp ? origin[2] : terminus[2]
+		};
+
+		float distOriginTerminus_Squared = 
+		    (origin[0]-terminus[0])*(origin[0]-terminus[0]) +
+		    (origin[1]-terminus[1])*(origin[1]-terminus[1]) + 
+		    (origin[2]-terminus[2])*(origin[2]-terminus[2]);
+		float distCoordStart_Squared = 
+		    (worldOpaqueCoordinates[0]-start[0])*(worldOpaqueCoordinates[0]-start[0]) +
+		    (worldOpaqueCoordinates[1]-start[1])*(worldOpaqueCoordinates[1]-start[1]) + 
+		    (worldOpaqueCoordinates[2]-start[2])*(worldOpaqueCoordinates[2]-start[2]);
+
+		// lies along the vector
+		if (distCoordStart_Squared < distOriginTerminus_Squared)    
+		{
+		    intersecting = true;
+		    propAlongVector = 
+			(float)sqrt(distCoordStart_Squared)/sqrt(distOriginTerminus_Squared);
+		}
+	    }
+	}
+    }
 
-                if (yGoingUp)
-                    start[1] = origin[1];
+    for (int i = first ; i < last ; i++)
+    {
+	int *ind = ind_buffer + 3*i;       // index of the cell
+	double *dProp = prop_buffer + 3*i; // percentage within the cell
+	valid_sample[i] = false;
+
+	double proportion = ((double)i)/((double)depth);
+	pt[0] = origin[0] + proportion*x_dist; // current point position
+	pt[1] = origin[1] + proportion*y_dist;
+	pt[2] = origin[2] + proportion*z_dist;
+
+	ind[0] = -1;
+	ind[1] = -1;
+	ind[2] = -1;
+
+	if (!foundHit)
+	{
+	    //
+	    // We haven't found any hits previously.  Exhaustively search
+	    // through arrays and try to find a hit.
+	    //
+	    ind[0] = FindMatch(X, pt[0], dims[0]);
+	    if (ind[0] >= 0)
+		dProp[0] = (pt[0] - X[ind[0]]) * divisors_X[ind[0]];
+	    ind[1] = FindMatch(Y, pt[1], dims[1]);
+	    if (ind[1] >= 0)
+		dProp[1] = (pt[1] - Y[ind[1]]) * divisors_Y[ind[1]];
+	    ind[2] = FindMatch(Z, pt[2], dims[2]);
+	    if (ind[2] >= 0)
+		dProp[2] = (pt[2] - Z[ind[2]]) * divisors_Z[ind[2]];
+	}
+	else
+	{
+	    //
+	    // We have found a hit before.  Try to locate the next sample
+	    // based on what we already found.
+	    //
+	    if (xGoingUp)
+	    {
+		for ( ; curX < dims[0]-1 ; curX++)
+		{
+		    if (pt[0] >= X[curX] && pt[0] <= X[curX+1])
+		    {
+			dProp[0] = (pt[0] - X[curX]) * divisors_X[curX];
+			ind[0] = curX;
+			break;
+		    }
+		}
+	    }
+	    else
+	    {
+		for ( ; curX >= 0 ; curX--)
+		{
+		    if (pt[0] >= X[curX] && pt[0] <= X[curX+1])
+		    {
+			dProp[0] = (pt[0] - X[curX]) * divisors_X[curX];
+			ind[0] = curX;
+			break;
+		    }
+		}
+	    }
+	    if (yGoingUp)
+	    {
+		for ( ; curY < dims[1]-1 ; curY++)
+		{
+		    if (pt[1] >= Y[curY] && pt[1] <= Y[curY+1])
+		    {
+			dProp[1] = (pt[1] - Y[curY]) * divisors_Y[curY];
+			ind[1] = curY;
+			break;
+		    }
+		}
+	    }
+	    else
+	    {
+		for ( ; curY >= 0 ; curY--)
+		{
+		    if (pt[1] >= Y[curY] && pt[1] <= Y[curY+1])
+		    {
+			dProp[1] = (pt[1] - Y[curY]) * divisors_Y[curY];
+			ind[1] = curY;
+			break;
+		    }
+		}
+	    }
+	    if (zGoingUp)
+	    {
+		for ( ; curZ < dims[2]-1 ; curZ++)
+		{
+		    if (pt[2] >= Z[curZ] && pt[2] <= Z[curZ+1])
+		    {
+			dProp[2] = (pt[2] - Z[curZ]) * divisors_Z[curZ];
+			ind[2] = curZ;
+			break;
+		    }
+		}
+	    }
+	    else
+	    {
+		for ( ; curZ >= 0 ; curZ--)
+		{
+		    if (pt[2] >= Z[curZ] && pt[2] <= Z[curZ+1])
+		    {
+			dProp[2] = (pt[2] - Z[curZ]) * divisors_Z[curZ];
+			ind[2] = curZ;
+			break;
+		    }
+		}
+	    }
+	}
+
+	bool intersectedDataset = !(ind[0] < 0 || ind[1] < 0 || ind[2] < 0);
+	if (!intersectedDataset)
+	{
+	    if (!foundHit)
+	    {
+		// We still haven't found the start.  Keep looking.
+		continue;
+	    }
+	    else
+	    {
+		// This is the true terminus.
+		last = i;
+		break;
+	    }
+	}
+	else  // Did intersect data set.
+	{
+	    if (!foundHit)
+	    {
+		// This is the first true sample.  "The true start"
+		first = i;
+	    }
+	}
+
+	valid_sample[i] = true;
+	foundHit = true;
+	hasSamples = true;
+
+	curX = ind[0];
+	curY = ind[1];
+	curZ = ind[2];
+    }
 
-                if (zGoingUp)
-                    start[1] = origin[2];
+    debug5 << "First: " << first << "  last: " << last << std::endl;
+    if (intersecting){
+	intersect = floor(propAlongVector * (last-first) + first);
+	debug5 << "intersect: " << intersect
+	       << " first: " << first << " last: " << last << std::endl;
+    }
 
-                float distOriginTerminus_Squared = (origin[0]-terminus[0])*(origin[0]-terminus[0]) + (origin[1]-terminus[1])*(origin[1]-terminus[1]) + (origin[2]-terminus[2])*(origin[2]-terminus[2]);
-                float distCoordStart_Squared = (_worldOpaqueCoordinates[0]-start[0])*(_worldOpaqueCoordinates[0]-start[0]) + (_worldOpaqueCoordinates[1]-start[1])*(_worldOpaqueCoordinates[1]-start[1]) + (_worldOpaqueCoordinates[2]-start[2])*(_worldOpaqueCoordinates[2]-start[2]);
-
-
-                if (distCoordStart_Squared < distOriginTerminus_Squared)     // lies along the vector
-                {
-                    intesecting = true;
-                    posAlongVector = sqrt(distCoordStart_Squared)/sqrt(distOriginTerminus_Squared);
-                }
-            }
-        }
-    }
-
-
-
-
-    for (int i = first ; i < last ; i++)
-    {
-        int *ind = ind_buffer + 3*i;
-        double *dProp = prop_buffer + 3*i;
-        valid_sample[i] = false;
-
-        double proportion = ((double)i)/((double)depth);
-        pt[0] = origin[0] + proportion*x_dist;
-        pt[1] = origin[1] + proportion*y_dist;
-        pt[2] = origin[2] + proportion*z_dist;
-
-        ind[0] = -1;
-        ind[1] = -1;
-        ind[2] = -1;
-
-        if (!foundHit)
-        {
-            //
-            // We haven't found any hits previously.  Exhaustively search
-            // through arrays and try to find a hit.
-            //
-            ind[0] = FindMatch(X, pt[0], dims[0]);
-            if (ind[0] >= 0)
-                dProp[0] = (pt[0] - X[ind[0]]) * divisors_X[ind[0]];
-            ind[1] = FindMatch(Y, pt[1], dims[1]);
-            if (ind[1] >= 0)
-                dProp[1] = (pt[1] - Y[ind[1]]) * divisors_Y[ind[1]];
-            ind[2] = FindMatch(Z, pt[2], dims[2]);
-            if (ind[2] >= 0)
-                dProp[2] = (pt[2] - Z[ind[2]]) * divisors_Z[ind[2]];
-        }
-        else
-        {
-            //
-            // We have found a hit before.  Try to locate the next sample
-            // based on what we already found.
-            //
-            if (xGoingUp)
-            {
-                for ( ; curX < dims[0]-1 ; curX++)
-                {
-                    if (pt[0] >= X[curX] && pt[0] <= X[curX+1])
-                    {
-                        dProp[0] = (pt[0] - X[curX]) * divisors_X[curX];
-                        ind[0] = curX;
-                        break;
-                    }
-                }
-            }
-            else
-            {
-                for ( ; curX >= 0 ; curX--)
-                {
-                    if (pt[0] >= X[curX] && pt[0] <= X[curX+1])
-                    {
-                        dProp[0] = (pt[0] - X[curX]) * divisors_X[curX];
-                        ind[0] = curX;
-                        break;
-                    }
-                }
-            }
-            if (yGoingUp)
-            {
-                for ( ; curY < dims[1]-1 ; curY++)
-                {
-                    if (pt[1] >= Y[curY] && pt[1] <= Y[curY+1])
-                    {
-                        dProp[1] = (pt[1] - Y[curY]) * divisors_Y[curY];
-                        ind[1] = curY;
-                        break;
-                    }
-                }
-            }
-            else
-            {
-                for ( ; curY >= 0 ; curY--)
-                {
-                    if (pt[1] >= Y[curY] && pt[1] <= Y[curY+1])
-                    {
-                        dProp[1] = (pt[1] - Y[curY]) * divisors_Y[curY];
-                        ind[1] = curY;
-                        break;
-                    }
-                }
-            }
-            if (zGoingUp)
-            {
-                for ( ; curZ < dims[2]-1 ; curZ++)
-                {
-                    if (pt[2] >= Z[curZ] && pt[2] <= Z[curZ+1])
-                    {
-                        dProp[2] = (pt[2] - Z[curZ]) * divisors_Z[curZ];
-                        ind[2] = curZ;
-                        break;
-                    }
-                }
-            }
-            else
-            {
-                for ( ; curZ >= 0 ; curZ--)
-                {
-                    if (pt[2] >= Z[curZ] && pt[2] <= Z[curZ+1])
-                    {
-                        dProp[2] = (pt[2] - Z[curZ]) * divisors_Z[curZ];
-                        ind[2] = curZ;
-                        break;
-                    }
-                }
-            }
-        }
-
-        bool intersectedDataset = !(ind[0] < 0 || ind[1] < 0 || ind[2] < 0);
-        if (!intersectedDataset)
-        {
-            if (!foundHit)
-            {
-                // We still haven't found the start.  Keep looking.
-                continue;
-            }
-            else
-            {
-                // This is the true terminus.
-                last = i;
-                break;
-            }
-        }
-        else  // Did intersect data set.
-        {
-            if (!foundHit)
-            {
-                // This is the first true sample.  "The true start"
-                first = i;
-            }
-        }
-
-        valid_sample[i] = true;
-        foundHit = true;
-        hasSamples = true;
-
-        curX = ind[0];
-        curY = ind[1];
-        curZ = ind[2];
-    }
-
-    //debug5 << "First: " << first << "  last: " << last << std::endl;
-
-    if (intesecting){
-        intersect = posAlongVector * (last-first) + first;
-        debug5 << "intersect: " << intersect << "   First: " << first << "  last: " << last << std::endl;
-    }
-
-    if (hasSamples)
-        if (rayCastingSLIVR)
-            SampleVariableRCSLIVR(first, last, intersect, w, h);
-        else
-            SampleVariable(first, last, w, h);
-}
+    if (hasSamples) {
+	if (rayCastingSLIVR) {
+	    SampleVariableRCSLIVR(first, last, intersect, w, h);
+	}
+	else {
+	    SampleVariable(first, last, w, h);
+	}
+    }
+}
 
 
 // ****************************************************************************
-//  Method: avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR
+//  Method: avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIR
 //
 //  Purpose:
 //      Compute region that patch covers
@@ -2150,191 +2284,391 @@ avtMassVoxelExtractor::SampleAlongSegment(const double *origin,
 //
 //  Modifications:
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for volume rendering using OSPRay (RayCasting:OSPRay)
+//
 // ****************************************************************************
 
 void
-avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR(vtkRectilinearGrid *rgrid,
-                 std::vector<std::string> &varnames, std::vector<int> &varsize)
+avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR
+(vtkRectilinearGrid *rgrid, 
+ std::vector<std::string> &varnames, 
+ std::vector<int> &varsize)
 {
+    int timing_ExtractWorldSpaceGridRCSLIVR = visitTimer->StartTimer();
+    //=======================================================================//
+    // Initialization
+    //=======================================================================//
+    // Flag to indicate if the patch is drawn
     patchDrawn = 0;
-    debug5 << "materialProperties:" << materialProperties[0] << ", " << materialProperties[1] << ", " << materialProperties[2] << ", " << materialProperties[3] << std::endl;
-
-    //
+    
+    //=======================================================================//
+    // Register data and early skipping
+    //=======================================================================//
+    int timing_register_data = visitTimer->StartTimer();
     // Some of our sampling routines need a chance to pre-process the data.
     // Register the grid here so we can do that.
-    //
-    RegisterGrid(rgrid, varnames, varsize);   // stores the values in a structure so that it can be used
-
-    //
+    // Stores the values in a structure so that it can be used
+    RegisterGrid(rgrid, varnames, varsize);
     // Determine what range we are dealing with on this iteration.
-    //
     int w_min = restrictedMinWidth;
-    int w_max = restrictedMaxWidth+1;
+    int w_max = restrictedMaxWidth + 1;
     int h_min = restrictedMinHeight;
-    int h_max = restrictedMaxHeight+1;
-
+    int h_max = restrictedMaxHeight + 1;
     imgWidth = imgHeight = 0;
-
-
-    //
     // Let's find out if this range can even intersect the dataset.
     // If not, just skip it.
+    if (!FrustumIntersectsGrid(w_min, w_max, h_min, h_max)) { return; }
+    // Timing
+    visitTimer->StopTimer(timing_register_data, 
+			  "avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR "
+			  "Register Data (VisIt preparation)");
+
+    //=======================================================================//
+    // obtain data pointers & ghost region information
+    //=======================================================================//
+    int timing_get_metadata = visitTimer->StartTimer();
+    // Calculate patch dimensions for point array and cell array
+    //   This is to check if the patch is a cell data or a point data
+    //   I have to assume cell dataset has a higher priority
+    void* volumePointer = NULL;
+    int   volumeDataType;
+    int nX = 0, nY = 0, nZ = 0;
+    if (ncell_arrays > 0) {
+	ospout << "[avtMassVoxelExtractor] Cell Dataset " << std::endl;
+	nX = dims[0] - 1;
+	nY = dims[1] - 1;
+	nZ = dims[2] - 1;
+	volumePointer = cell_arrays[ncell_arrays-1];
+	volumeDataType = cell_vartypes[ncell_arrays-1];
+    }
+    else if (npt_arrays > 0) {
+	ospout << "[avtMassVoxelExtractor] Point Dataset " << std::endl;
+	nX = dims[0];
+	nY = dims[1];
+	nZ = dims[2];
+	volumePointer = pt_arrays[npt_arrays-1];
+	volumeDataType = pt_vartypes[npt_arrays-1];	
+    } else {
+	std::cerr << "WARNING: Empty dataset " << std::endl;
+    }
+    ospout << "[avtMassVoxelExtractor] patch dimension "
+	   << nX << " " << nY << " " << nZ << std::endl;
+    // Calculate ghost region boundaries
+    //   ghost_boundaries is an array to indicate if the patch contains
+    //   any ghost regions in six different directions
+    // Here I assume the patch is larger than 3-cube
+    // If not then you might want to dig into this code and see if
+    // there will be any special boundary cases
     //
-    if (!FrustumIntersectsGrid(w_min, w_max, h_min, h_max))
-       return;
-
-    //
-    // Determine the screen size of the patch being processed
-    //
-    xMin = yMin = std::numeric_limits<int>::max();
-    xMax = yMax = std::numeric_limits<int>::min();
-
-    float coordinates[8][3];
-    coordinates[0][0] = X[0];           coordinates[0][1] = Y[0];           coordinates[0][2] = Z[0];
-    coordinates[1][0] = X[dims[0]-1];   coordinates[1][1] = Y[0];           coordinates[1][2] = Z[0];
-    coordinates[2][0] = X[dims[0]-1];   coordinates[2][1] = Y[dims[1]-1];   coordinates[2][2] = Z[0];
-    coordinates[3][0] = X[0];           coordinates[3][1] = Y[dims[1]-1];   coordinates[3][2] = Z[0];
-
-    coordinates[4][0] = X[0];           coordinates[4][1] = Y[0];           coordinates[4][2] = Z[dims[2]-1];
-    coordinates[5][0] = X[dims[0]-1];   coordinates[5][1] = Y[0];           coordinates[5][2] = Z[dims[2]-1];
-    coordinates[6][0] = X[dims[0]-1];   coordinates[6][1] = Y[dims[1]-1];   coordinates[6][2] = Z[dims[2]-1];
-    coordinates[7][0] = X[0];           coordinates[7][1] = Y[dims[1]-1];   coordinates[7][2] = Z[dims[2]-1];
-
-    //debug5 << "Extents - Min: " << X[0] << ", " << Y[0] << ", " << Z[0] << "   Max: " << X[dims[0]-1] << ", " << Y[dims[1]-1] << ", " << Z[dims[2]-1] << "    ";
-
-
+    // debug5 << "VAR: ghost value " << (int)ghosts[0] << std::endl;
     //
-    // Compute z order for blending patches
-    double _center[3];
-    _center[0] = (X[0] + X[dims[0]-1])/2.0;
-    _center[1] = (Y[0] + Y[dims[1]-1])/2.0;
-    _center[2] = (Z[0] + Z[dims[2]-1])/2.0;
-    double __depth = sqrt( (_center[0]-view.camera[0])*(_center[0]-view.camera[0]) +  (_center[1]-view.camera[1])*(_center[1]-view.camera[1]) + (_center[2]-view.camera[2])*(_center[2]-view.camera[2]) );
-    eyeSpaceDepth = __depth;
-
-
-
-    double _clipSpaceZ = 0;
-    double _world[3];
-    for (int i=0; i<8; i++)
+    bool ghost_bound[6] = {false};
+    if (ghosts != NULL)
     {
-        int pos2D[2];
-        float tempZ;
-
-        _world[0] = coordinates[i][0];
-        _world[1] = coordinates[i][1];
-        _world[2] = coordinates[i][2];
-
-        tempZ = project(_world, pos2D, fullImgWidth, fullImgHeight);
-
-        // Clamp values
-        pos2D[0] = std::min( std::max(pos2D[0], 0), w_max-1);
-        pos2D[0] = std::min( std::max(pos2D[0], 0), w_max-1);
-        pos2D[1] = std::min( std::max(pos2D[1], 0), h_max-1);
-        pos2D[1] = std::min( std::max(pos2D[1], 0), h_max-1);
-
-        // Get min max
-        xMin = std::min(xMin, pos2D[0]);
-        xMax = std::max(xMax, pos2D[0]);
-        yMin = std::min(yMin, pos2D[1]);
-        yMax = std::max(yMax, pos2D[1]);
-
-
-        if (i == 0)
-        {
-            _clipSpaceZ = tempZ;
-            renderingDepthsExtents[0] = tempZ;
-            renderingDepthsExtents[1] = tempZ;
-        }
-        else
-        {
-            if ( _clipSpaceZ > tempZ )
-                _clipSpaceZ = tempZ;
-
-            if (renderingDepthsExtents[0] > tempZ)      // min z
-                renderingDepthsExtents[0] = tempZ;
-
-            if (renderingDepthsExtents[1] < tempZ)      // max z
-                renderingDepthsExtents[1] = tempZ;
-        };
+	int gnX = 0, gnY = 0, gnZ = 0;
+	gnX = dims[0] - 1;
+	gnY = dims[1] - 1;
+        gnZ = dims[2] - 1;
+
+	// debug the meaning of the ghost zoom
+	// for (int z = 0; z < gnZ; ++z) {
+	//     for (int y = 0; y < gnY; ++y) {
+	// 	for (int x = 0; x < gnX; ++x) {
+	// 	    std::cout << (int)ghosts[z*gnY*gnX+y*gnX+x] << " ";
+	// 	}
+	// 	std::cout << std::endl;
+	//     }
+	//     std::cout << std::endl << std::endl;
+	// }
+	
+	for (int y = 1; y < (gnY-1); ++y) {
+	    for (int z = 1; z < (gnZ-1); ++z) {
+		if (!ghost_bound[0]) {
+		    if (ghosts[z*gnY*gnX+y*gnX        ] != 0)
+		    { ghost_bound[0] = true; }
+		}
+		if (!ghost_bound[3]) {
+		    if (ghosts[z*gnY*gnX+y*gnX+(gnX-1)] != 0)
+		    { ghost_bound[3] = true; }
+		}
+		if (ghost_bound[0] && ghost_bound[3]) { break; }
+	    }
+	}
+	for (int x = 1; x < (gnX-1); ++x) {
+	    for (int z = 1; z < (gnZ-1); ++z) {
+		if (!ghost_bound[1]) {
+		    if (ghosts[z*gnY*gnX            +x] != 0)
+		    { ghost_bound[1] = true; }
+		}
+		if (!ghost_bound[4]) {
+		    if (ghosts[z*gnY*gnX+(gnY-1)*gnX+x] != 0)
+		    { ghost_bound[4] = true; }
+		}
+		if (ghost_bound[1] && ghost_bound[4]) { break; }
+	    }
+	}
+	for (int x = 1; x < (gnX-1); ++x) {
+	    for (int y = 1; y < (gnY-1); ++y) {
+		if (!ghost_bound[2]) {
+		    if (ghosts[                y*gnX+x] != 0) 
+		    { ghost_bound[2] = true; }
+		}
+		if (!ghost_bound[5]) {
+		    if (ghosts[(gnZ-1)*gnY*gnX+y*gnX+x] != 0)
+		    { ghost_bound[5] = true; }
+		}
+		if (ghost_bound[2] && ghost_bound[5]) { break; }
+	    }
+	}
     }
-
-    renderingAreaExtents[0] = xMin;
-    renderingAreaExtents[1] = xMax;
-    renderingAreaExtents[2] = yMin;
-    renderingAreaExtents[3] = yMax;
-
-    clipSpaceDepth = _clipSpaceZ;
-
+    // Data bounding box
+    double volumeCube[6] = {
+	X[0], X[nX-1],
+	Y[0], Y[nY-1],
+	Z[0], Z[nZ-1]
+    };
+    // Timing
+    visitTimer->StopTimer(timing_get_metadata , 
+			  "avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR "
+			  "Compute metadata & ghost boundary (Pre-OSPRay preparation)");
+
+    //=======================================================================//
+    // Determine the screen size of the patch being processed
+    //=======================================================================//
+    int timing_get_screen_projection = visitTimer->StartTimer();
+    int patchScreenExtents[4];
+    slivr::ProjectWorldToScreenCube(volumeCube, w_max, h_max, 
+				    panPercentage, imageZoom,
+				    model_to_screen_transform, 
+				    patchScreenExtents, 
+				    renderingDepthsExtents);
+    xMin = patchScreenExtents[0];
+    xMax = patchScreenExtents[1];
+    yMin = patchScreenExtents[2];
+    yMax = patchScreenExtents[3];
+
+    ospout << "[avtMassVoxelExtractor] patch ghost bounds:"
+	   << "   " << ghost_bound[0] << " " << ghost_bound[3] 
+	   << " | " << ghost_bound[1] << " " << ghost_bound[4] 
+	   << " | " << ghost_bound[2] << " " << ghost_bound[5]
+	   << std::endl;   
+    
+    // calculate patch depth
+    double patch_center[3];
+    patch_center[0] = (volumeCube[0] + volumeCube[1])/2.0;
+    patch_center[1] = (volumeCube[2] + volumeCube[3])/2.0;
+    patch_center[2] = (volumeCube[4] + volumeCube[5])/2.0;        
+    double patch_depth = // use the norm of patch center as patch depth
+	std::sqrt((patch_center[0]-view.camera[0])*
+		  (patch_center[0]-view.camera[0])+
+		  (patch_center[1]-view.camera[1])*
+		  (patch_center[1]-view.camera[1])+
+		  (patch_center[2]-view.camera[2])*
+		  (patch_center[2]-view.camera[2]));
+    eyesSpaceDepth = patch_depth;
+    clipSpaceDepth = renderingDepthsExtents[0];
+    // Timing
+    visitTimer->StopTimer(timing_get_screen_projection, 
+			  "avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR "
+			  "Get screen size of the patch (Pre-OSPRay preparation)");
+
+    //=======================================================================//
+    // create framebuffer
+    //=======================================================================//
+    int timing_create_imgarray = visitTimer->StartTimer();
+    // assign data to the class
+    //xMax+=1; yMax+=1;
+    ospout << "[avtMassVoxelExtractor] patch extents " 
+	   << xMin << " " << xMax << " "
+	   << yMin << " " << yMax << std::endl;
+    if (xMin < fullImageExtents[0]) { xMin = fullImageExtents[0]; }
+    if (yMin < fullImageExtents[2]) { yMin = fullImageExtents[2]; }    
+    if (xMax > fullImageExtents[1]) { xMax = fullImageExtents[1]; }
+    if (yMax > fullImageExtents[3]) { yMax = fullImageExtents[3]; }
     imgWidth  = xMax-xMin;
     imgHeight = yMax-yMin;
 
+    // Initialize memory (framebuffer)
+    if (avtCallback::UseOSPRay()) {
+	// framebuffer
+	imgArray = new float[((imgWidth)*4) * imgHeight];   
+    } else {
+        // framebuffer initialized
+	imgArray = new float[((imgWidth)*4) * imgHeight](); 
+    };
+    // Timing
+    visitTimer->StopTimer(timing_create_imgarray, 
+			  "avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR "
+			  "Create ImgArray (Pre-OSPRay preparation)");
+
+    //=======================================================================//
+    // Render using OSPRay
+    //=======================================================================//
+    int timing_using_ospray = visitTimer->StartTimer();
+    if (avtCallback::UseOSPRay()) {
+	int timing_setup_ospray = visitTimer->StartTimer();
+	// shift grid and make it cel centered for cell data
+	double volumePBox[6] = {
+	    // for cell centered data, we put the voxel on its left boundary
+	    X[0], Y[0], Z[0], 
+	    X[nX-1], Y[nY-1], Z[nZ-1]
+	};
+	// compute boundingbox and clipping plane for ospray
+	double volumeBBox[6];
+	if (ncell_arrays > 0) {
+	    volumeBBox[0] = ghost_bound[0] ? (X[0]+X[1])/2. : volumePBox[0];
+	    volumeBBox[1] = ghost_bound[1] ? (Y[0]+Y[1])/2. : volumePBox[1];
+	    volumeBBox[2] = ghost_bound[2] ? (Z[0]+Z[1])/2. : volumePBox[2];
+	    volumeBBox[3] = 
+		ghost_bound[3] ? (X[nX-1]+X[nX-2])/2. : volumePBox[3];
+	    volumeBBox[4] = 
+		ghost_bound[4] ? (Y[nY-1]+Y[nY-2])/2. : volumePBox[4];
+	    volumeBBox[5] = 
+		ghost_bound[5] ? (Z[nZ-1]+Z[nZ-2])/2. : volumePBox[5];
+	}
+	else {
+	    volumeBBox[0] = ghost_bound[0] ? X[1] : volumePBox[0];
+	    volumeBBox[1] = ghost_bound[1] ? Y[1] : volumePBox[1];
+	    volumeBBox[2] = ghost_bound[2] ? Z[1] : volumePBox[2];
+	    volumeBBox[3] = ghost_bound[3] ? X[nX-2] : volumePBox[3];
+	    volumeBBox[4] = ghost_bound[4] ? Y[nY-2] : volumePBox[4];
+	    volumeBBox[5] = ghost_bound[5] ? Z[nZ-2] : volumePBox[5];
+	}
+	ospout << "[avtMassVoxelExtractor] patch data position:" 
+	       << " " << volumePBox[0]
+	       << " " << volumePBox[1]
+	       << " " << volumePBox[2]
+	       << " |"
+	       << " " << volumePBox[3]
+	       << " " << volumePBox[4]
+	       << " " << volumePBox[5]
+	       << std::endl;  
+	ospout << "[avtMassVoxelExtractor] patch data bbox:" 
+	       << " " << volumeBBox[0]
+	       << " " << volumeBBox[1]
+	       << " " << volumeBBox[2]
+	       << " |"
+	       << " " << volumeBBox[3]
+	       << " " << volumeBBox[4]
+	       << " " << volumeBBox[5]
+	       << std::endl; 
+	// Timing
+	visitTimer->StopTimer(timing_setup_ospray, 
+			      "avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR "
+			      "OSPRay bbox and clip (OSPRay preparation)");
+	
+	// Create volume and model
+	int timing_create_volume = visitTimer->StartTimer();
+	ospray->GetPatch(patch)->Set(volumeDataType, volumePointer,
+				     X, Y, Z, nX, nY, nZ, volumePBox, volumeBBox, 
+				     materialProperties, (float)rendererSampleRate,
+				     lighting);
+	visitTimer->StopTimer(timing_create_volume, 
+			      "avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR "
+			      "OSPRay Create Volume");
+
+	// Render Volume
+	int timing_render_volume = visitTimer->StartTimer();
+	if ((scalarRange[1] >= tFVisibleRange[0]) &&
+	    (scalarRange[0] <= tFVisibleRange[1]))
+	{
+	    ospray->Render(xMin, xMax, yMin, yMax,
+			   imgWidth, imgHeight, imgArray,
+			   ospray->GetPatch(patch));
+	    patchDrawn = 1;
+
+	}
+	visitTimer->StopTimer(timing_render_volume, 
+			      "avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR "
+			      "OSPRay Render Volume");	
+    }
+    // Timing
+    visitTimer->StopTimer(timing_using_ospray, 
+			  "avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR "
+			  "Using OSPRay");
 
-    //debug5 << "Initialize memory" << std::endl;
-
-    //
-    // Initialize memory
-    imgArray =  new float[((imgWidth)*4) * imgHeight]();   // image
-
-    //
+    //=======================================================================//
     // Send rays
-    imgDims[0] = imgWidth;       imgDims[1] = imgHeight;
-    imgLowerLeft[0] = xMin;      imgLowerLeft[1] = yMin;
-    imgUpperRight[0] = xMax;     imgUpperRight[1] = yMax;
-
-    //debug5 << "Send rays ~ screen:" << xMin << ", " << xMax << "    "  << yMin << ", " << yMax <<  "    " << renderingDepthsExtents[0] << ", " << renderingDepthsExtents[1] <<  "   Buffer extents: " << bufferExtents[0] << ", " << bufferExtents[1] << "   " << bufferExtents[2] << ", " << bufferExtents[3] << std::endl;
-
-    for (int _x = xMin ; _x < xMax ; _x++)
-        for (int _y = yMin ; _y < yMax ; _y++)
-        {
-            int index = (_y-yMin)*imgWidth + (_x-xMin);
-
-
-            if ( (scalarRange[1] < tFVisibleRange[0]) || (scalarRange[0] > tFVisibleRange[1]) )     // outside visible range
-            {
-                int fullIndex = ( (_y-bufferExtents[2]) * (bufferExtents[1]-bufferExtents[0]) + (_x-bufferExtents[0]) );
-
-                if ( depthBuffer[fullIndex] != 1)
-                {
-                    double clipDepth = depthBuffer[fullIndex]*2 - 1;
-
-                    if ( clipDepth >= renderingDepthsExtents[0] && clipDepth < renderingDepthsExtents[1])
-                    {
-                        patchDrawn = 1;
-
-                        imgArray[(_y-yMin)*(imgWidth*4) + (_x-xMin)*4 + 0] = rgbColorBuffer[fullIndex*3 + 0] / 255.0;
-                        imgArray[(_y-yMin)*(imgWidth*4) + (_x-xMin)*4 + 1] = rgbColorBuffer[fullIndex*3 + 1] / 255.0;
-                        imgArray[(_y-yMin)*(imgWidth*4) + (_x-xMin)*4 + 2] = rgbColorBuffer[fullIndex*3 + 2] / 255.0;
-                        imgArray[(_y-yMin)*(imgWidth*4) + (_x-xMin)*4 + 3] = 1.0;
-                    }
-                }
-            }
-            else
-            {
-                double _origin[3], _terminus[3];
-                double origin[4]  = {0,0,0,1};      // starting point where we start sampling
-                double terminus[4]= {0,0,0,1};      // ending point where we stop sampling
-
-                GetSegmentRCSLIVR(_x, _y, fullVolumeDepthExtents, _origin, _terminus);    // find the starting point & ending point of the ray
-
-                for (int i=0; i<3; i++){
-                    origin[i] = _origin[i];
-                    terminus[i] = _terminus[i];
-                }
-
-                SampleAlongSegment(origin, terminus, _x, _y);             // Go get the segments along this ray and store them in
-            }
-        }
+    //=======================================================================//
+    int timing_using_pascal = visitTimer->StartTimer();
+    imgDims[0] = imgWidth;
+    imgDims[1] = imgHeight;
+    imgLowerLeft[0] = xMin;
+    imgLowerLeft[1] = yMin;
+    imgUpperRight[0] = xMax; 
+    imgUpperRight[1] = yMax;
+
+    if (!avtCallback::UseOSPRay()) {
+	ospout << "[avtMassiveVoxelExtractor] "
+	       << "Using CPU version raytracer" << std::endl;
+    	for (int patchX = xMin; patchX < xMax ; patchX++) {
+	    for (int patchY = yMin; patchY < yMax ; patchY++) {
+
+		const int pIndex = (patchY-yMin)*imgWidth + (patchX-xMin);
+		const int fIndex = ((patchY-bufferExtents[2])*
+				    (bufferExtents[1]-bufferExtents[0])+
+				    (patchX-bufferExtents[0]));
+		// outside visible range
+		if ((scalarRange[1] < tFVisibleRange[0]) ||
+		    (scalarRange[0] > tFVisibleRange[1]))	
+		{
+		    if (depthBuffer[fIndex] != 1)
+		    {
+			const double clipDepth = depthBuffer[fIndex]*2 - 1;
+			if (clipDepth >= renderingDepthsExtents[0] && 
+			    clipDepth <= renderingDepthsExtents[1])
+			{
+			    patchDrawn = 1;
+			    const int imgID = pIndex * 4;
+			    imgArray[imgID + 0] = 
+				rgbColorBuffer[fIndex*3 + 0]/255.0;
+			    imgArray[imgID + 1] = 
+				rgbColorBuffer[fIndex*3 + 1]/255.0;
+			    imgArray[imgID + 2] = 
+				rgbColorBuffer[fIndex*3 + 2]/255.0;
+			    imgArray[imgID + 3] = 1.0;
+			}
+		    }
+		}
+		else
+		{
+		    // std::cout << "draw" << std::endl;
+		    patchDrawn = 1;		    
+		    // starting point where we start sampling
+		    double origin[4]   = {0,0,0,1};
+		    // ending point where we stop sampling 
+		    double terminus[4] = {0,0,0,1};
+		    // find the starting point & ending point of the ray
+		    GetSegmentRCSLIVR(patchX, patchY, fullVolumeDepthExtents,
+				      origin, terminus); 
+		    // Go get the segments along this ray and store them in
+		    SampleAlongSegment(origin, terminus, patchX, patchY);
+		}
+	    }
+	}
+    }
+    // Timing
+    visitTimer->StopTimer(timing_using_pascal, 
+			  "avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR "
+			  "Using Pascal (Post OSPRay)");
 
-    //
+    //=======================================================================//
     // Deallocate memory if not used
+    //=======================================================================//
     if (patchDrawn == 0)
-    {
-        if (imgArray != NULL)
-            delete []imgArray;
-
-        imgArray = NULL;
-    }
+    { 
+	if (imgArray != NULL) 
+	{ 
+	    delete []imgArray; imgArray = NULL; 
+	} 
+    } 
+    // else {
+    // 	WriteArrayToPPM("patch-after-render"+
+    // 			std::to_string(proc), imgArray, 
+    // 			imgWidth, imgHeight);
+    // }
+    visitTimer->StopTimer(timing_ExtractWorldSpaceGridRCSLIVR, "Calling avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR");
 }
 
 
@@ -2352,15 +2686,41 @@ avtMassVoxelExtractor::ExtractWorldSpaceGridRCSLIVR(vtkRectilinearGrid *rgrid,
 // ****************************************************************************
 
 void
-avtMassVoxelExtractor::GetSegmentRCSLIVR(int x, int y, double depthsExtents[2], double *_origin, double *_terminus)
+avtMassVoxelExtractor::GetSegmentRCSLIVR
+(int x, int y, double depthsExtents[2], double *origin, double *terminus)
 {
-    unProject(x,y, depthsExtents[0], _origin,   fullImgWidth, fullImgHeight);
-    unProject(x,y, depthsExtents[1], _terminus, fullImgWidth, fullImgHeight);
+    //unProject(x,y, depthsExtents[0], origin,   fullImgWidth, fullImgHeight);
+    //unProject(x,y, depthsExtents[1], terminus, fullImgWidth, fullImgHeight);
+
+    slivr::ProjectScreenToWorld(x, y, depthsExtents[0], 
+				fullImgWidth, fullImgHeight, 
+				panPercentage, imageZoom, 
+				screen_to_model_transform,
+				origin);
+    slivr::ProjectScreenToWorld(x, y, depthsExtents[1], 
+				fullImgWidth, fullImgHeight, 
+				panPercentage, imageZoom, 
+				screen_to_model_transform,
+				terminus);
+    // if (jitter)
+    // {
+    // 	int reliable_random_number = 
+    // 	    (13*x*y + 14*x*x + 79*y*y + 247*x + 779*y)%513;
+    // 	double jitter = (1.0/depth) * ((reliable_random_number-256) / (256.0));
+    // 	double dir[3];
+    // 	dir[0] = (terminus[0] - origin[0])*jitter;
+    // 	dir[1] = (terminus[1] - origin[1])*jitter;
+    // 	dir[2] = (terminus[2] - origin[2])*jitter;
+    // 	origin[0] += dir[0];
+    // 	origin[1] += dir[1];
+    // 	origin[2] += dir[2];
+    // 	terminus[0] += dir[0];
+    // 	terminus[1] += dir[1];
+    // 	terminus[2] += dir[2];
+    // }
 }
 
 
-
-
 // ****************************************************************************
 //  Method: avtMassVoxelExtractor::SampleVariableRCSLIVR
 //
@@ -2374,475 +2734,499 @@ avtMassVoxelExtractor::GetSegmentRCSLIVR(int x, int y, double depthsExtents[2],
 // ****************************************************************************
 
 void
-avtMassVoxelExtractor::SampleVariableRCSLIVR(int first, int last, int intersect, int x, int y)
+avtMassVoxelExtractor::SampleVariableRCSLIVR
+(int first, int last, int intersect, int x, int y)
 {
     int  count = 0;
     bool calc_cell_index = ((ncell_arrays > 0) || (ghosts != NULL));
 
-    double dest_rgb[4] = {0.0,0.0,0.0, 0.0};     // to store the computed color
-    for (int i = first ; i < last ; i++)
+    double dest_rgb[4] = {0.0,0.0,0.0,0.0};     // to store the computed color
+    for (int i = first; i < last ; i++)
     {
-        // If we intersect a value in the z buffer
-        if (i == intersect)
-        {
-            int fullIndex = (y * (bufferExtents[1]-bufferExtents[0]) + x) * 3.0;
-
-            float bufferColor[4];
-            bufferColor[0] = rgbColorBuffer[fullIndex + 0] / 255.0;
-            bufferColor[1] = rgbColorBuffer[fullIndex + 1] / 255.0;
-            bufferColor[2] = rgbColorBuffer[fullIndex + 2] / 255.0;
-            bufferColor[3] = 1.0;
-
-            for (int j=0; j<4; j++)
-                dest_rgb[j] = bufferColor[j] * (1.0 - dest_rgb[3]) + dest_rgb[j];
-
-            //debug5 << x << ", " << y << "   ~ First: " << first << "  i:  " << i << "   intersect: " << intersect << "  bufferColor: " << bufferColor[0] << ", " << bufferColor[1] << ", " << bufferColor[2] << "   dest_rgb: " << dest_rgb[0] << ", " << dest_rgb[1] << ", " << dest_rgb[2] << ", " << dest_rgb[3] << std::endl;
-            break;
-        }
-
-        const int *ind = ind_buffer + 3*i;
-        const double *prop = prop_buffer + 3*i;
-
-        int index = 0;
-        if (calc_cell_index)
-            index = ind[2]*((dims[0]-1)*(dims[1]-1)) + ind[1]*(dims[0]-1) + ind[0];
-
-        if (ghosts != NULL)
-        {
-            if (ghosts[index] != 0)
-               valid_sample[i] = false;
-        }
-
-        int index_left, index_right,            index_top, index_bottom,         index_front, index_back;
-        float dist_from_left, dist_from_right,  dist_from_top,dist_from_bottom,  dist_from_front, dist_from_back;
-
-        int newInd[3];
-        newInd[0] = ind[0];
-        newInd[1] = ind[1];
-        newInd[2] = ind[2];
-
-        float x_right = prop[0];        float x_left   = 1. - x_right;
-        float y_top   = prop[1];        float y_bottom = 1. - y_top;
-        float z_back  = prop[2];        float z_front  = 1. - z_back;
-
-        //std::cout << "x_right: " << x_right <<  "  x_left: " << x_left << "   y_top:" <<  y_top << "  y_bottom: " <<  "   z_back: " << z_back<< "  z_front: " <<  z_front << std::endl;
-        
-
-        // get the index and distance from the center of the neighbouring cells
-        getIndexandDistFromCenter(x_right, newInd[0], index_left, index_right,   dist_from_left, dist_from_right);
-        getIndexandDistFromCenter(y_top,   newInd[1], index_bottom,index_top,    dist_from_bottom,dist_from_top);
-        getIndexandDistFromCenter(z_back,  newInd[2], index_front, index_back,   dist_from_front, dist_from_back);
-
-        int indices[6];
-        indices[4] = index_front;       indices[5] = index_back;
-        indices[2] = index_bottom;      indices[3] = index_top;
-        indices[0] = index_left;        indices[1] = index_right;
-
-
-        if (indices[0] < 0 || indices[0]>dims[0]-2)
-            valid_sample[i] = false;
-
-        if (indices[1] < 0 || indices[1]>dims[0]-2)
-            valid_sample[i] = false;
-
-
-        if (indices[2] < 0 || indices[2]>dims[1]-2)
-            valid_sample[i] = false;
-
-        if (indices[3] < 0 || indices[3]>dims[1]-2)
-            valid_sample[i] = false;
-
-
-        if (indices[4] < 0 || indices[4]>dims[2]-2)
-            valid_sample[i] = false;
-
-        if (indices[5] < 0 || indices[5]>dims[2]-2)
-            valid_sample[i] = false;
-
-
-        if (!valid_sample[i])
-            continue;
-
-
-        //
-        // Cell centered data
-        //
-        if (ncell_arrays > 0)
-        {
-            int indexT[8];
-            computeIndices(dims, indices, indexT);
-
-            for (int l = 0 ; l < ncell_arrays ; l++)            // ncell_arrays: usually 1
-            {
-                void  *cell_array = cell_arrays[l];
-                double values[8];
-                for (int m = 0 ; m < cell_size[l] ; m++)        // cell_size[l] usually 1
-                {
-                    AssignEight(cell_vartypes[l], values, indexT, cell_size[l], m, cell_array);
-                    double scalarValue = trilinearInterpolate(values, dist_from_left, dist_from_bottom, dist_from_front);
-                    double source_rgb[4];
-                    int retVal = transferFn1D->QueryTF(scalarValue,source_rgb);
-
-                    if ( ((retVal == 0)||(source_rgb[3]==0)) || (source_rgb[0]==0 && source_rgb[1]==0 && source_rgb[2]==0) )
-                    {
-                        // no need to do anything more if there will be no color
-                    }
-                    else
-                    {
-                        //
-                        // Compute Lighting (if needed)
-                        //
-                        if (lighting == true)
-                        {
-                            double vals[6];
-
-                            // h = offset = 1/2 the distance between grids
-                            // grad = 1/2*h * ( f(x+h,y,z)-f(x-h,y,z)    f(x,y+h,z)-f(x,y-h,z)   f(x,y,z-h)-f(x,y,z-h)  )
-
-                            float distFromRight, distFromLeft, distFromTop, distFromBottom, distFromFront, distFromBack;
-                            int indexLeft, indexRight, indexTop, indexBottom, indexFront, indexBack;
-                            float gradientOffset = 0.25;
-
-                            double gradVals[8];
-                            int indexGrad[8], gradInd[3], gradIndices[6];
-                            float xRight, yTop, zBack;
-
-                            void  *cell_array = cell_arrays[0];
-
-                            //
-                            // X
-                            //
-                            for (int i=0; i<6; i++)
-                                gradIndices[i] = indices[i];
-
-                            //
-                            // find x-h
-                            //
-                            if (x_right - gradientOffset < 0.0){
-                                xRight = (x_right - gradientOffset)+1.0;
-                                gradInd[0] = ind[0]-1;
-                            }
-                            else{
-                                xRight = x_right - gradientOffset;
-                                gradInd[0] = ind[0];
-                            }
-
-                            getIndexandDistFromCenter(xRight, gradInd[0],  indexLeft, indexRight,  distFromLeft, distFromRight);
-                            gradIndices[0] = indexLeft;    gradIndices[1] = indexRight;
-                            computeIndices(dims, gradIndices, indexGrad);
-                            AssignEight(cell_vartypes[0], gradVals, indexGrad, 1, 0, cell_array);
-                            vals[0] = trilinearInterpolate(gradVals, distFromLeft, dist_from_bottom, dist_from_front);
-
-                            //
-                            // find x+h
-                            //
-                            if (x_right + gradientOffset > 1.0){
-                                xRight = (x_right + gradientOffset)-1.0;
-                                gradInd[0] = ind[0]+1;
-                            }else{
-                                xRight = x_right + gradientOffset;
-                                gradInd[0] = ind[0];
-                            }
-
-                            getIndexandDistFromCenter(xRight, gradInd[0],  indexLeft, indexRight,  distFromLeft, distFromRight);
-                            gradIndices[0] = indexLeft;    gradIndices[1] = indexRight;
-                            computeIndices(dims, gradIndices, indexGrad);
-                            AssignEight(cell_vartypes[0], gradVals, indexGrad, 1, 0, cell_array);
-                            vals[1] = trilinearInterpolate(gradVals, distFromLeft, dist_from_bottom, dist_from_front);
-
-
-
-                            //
-                            // Y
-                            //
-                            for (int i=0; i<6; i++)
-                                gradIndices[i] = indices[i];
-
-                            //
-                            // find y-h
-                            //
-                            if (y_top - gradientOffset < 0.0){
-                                yTop = (y_top - gradientOffset)+1.0;
-                                gradInd[1] = ind[1]-1;
-                            }
-                            else{
-                                yTop = y_top - gradientOffset;
-                                gradInd[1] = ind[1];
-                            }
-
-                            getIndexandDistFromCenter(yTop, gradInd[1],  indexBottom, indexTop,  distFromBottom, distFromTop);
-                            gradIndices[2] = indexBottom ;    gradIndices[3] = indexTop;
-                            computeIndices(dims, gradIndices, indexGrad);
-                            AssignEight(cell_vartypes[0], gradVals, indexGrad, 1, 0, cell_array);
-                            vals[2] = trilinearInterpolate(gradVals, dist_from_left, distFromBottom, dist_from_front);
-
-                            //
-                            // find y+h
-                            //
-                            yTop = y_top;
-                            if (y_top + gradientOffset > 1.0){
-                                yTop = (y_top + gradientOffset)-1.0;
-                                gradInd[1] = ind[1]+1;
-                            }else{
-                                yTop = y_top + gradientOffset;
-                                gradInd[1] = ind[1];
-                            }
-
-                            getIndexandDistFromCenter(yTop, gradInd[1],  indexBottom, indexTop,  distFromBottom, distFromTop);
-                            gradIndices[2] = indexBottom;    gradIndices[3] = indexTop;
-                            computeIndices(dims, gradIndices, indexGrad);
-                            AssignEight(cell_vartypes[0], gradVals, indexGrad, 1, 0, cell_array);
-                            vals[3] = trilinearInterpolate(gradVals, dist_from_left, distFromBottom, dist_from_front);
-
-
-                            //
-                            // Z
-                            //
-                            for (int i=0; i<6; i++)
-                                gradIndices[i] = indices[i];
-
-                            //
-                            // z-h
-                            //
-                            if (z_back - gradientOffset < 0.0){
-                                zBack = (z_back - gradientOffset)+1.0;
-                                gradInd[2] = ind[2]-1;
-                            }
-                            else{
-                                zBack = z_back - gradientOffset;
-                                gradInd[2] = ind[2];
-                            }
-
-                            getIndexandDistFromCenter(zBack, gradInd[2],  indexFront, indexBack,  distFromFront, distFromBack);
-                            gradIndices[4] = indexFront;    gradIndices[5] = indexBack;
-                            computeIndices(dims, gradIndices, indexGrad);
-                            AssignEight(cell_vartypes[0], gradVals, indexGrad, 1, 0, cell_array);
-                            vals[4] = trilinearInterpolate(gradVals, dist_from_left, dist_from_bottom, distFromFront);
-
-                            //
-                            // z+h
-                            //
-                            if (z_back + gradientOffset > 1.0){
-                                zBack = (z_back + gradientOffset)-1.0;
-                                gradInd[2] = ind[2]+1;
-                            }else{
-                                zBack = z_back + gradientOffset;
-                                gradInd[2] = ind[2];
-                            }
-
-                            getIndexandDistFromCenter(zBack, gradInd[2],  indexFront, indexBack,  distFromFront, distFromBack);
-                            gradIndices[4] = indexFront;    gradIndices[5] = indexBack;
-                            computeIndices(dims, gradIndices, indexGrad);
-                            AssignEight(cell_vartypes[0], gradVals, indexGrad, 1, 0, cell_array);
-                            vals[5] = trilinearInterpolate(gradVals, dist_from_left, dist_from_bottom, distFromFront);
-
-
-                            gradient[0] = (1.0/(2.0*gradientOffset)) * (vals[1] - vals[0]);
-                            gradient[1] = (1.0/(2.0*gradientOffset)) * (vals[3] - vals[2]);
-                            gradient[2] = (1.0/(2.0*gradientOffset)) * (vals[5] - vals[4]);
-
-                            normalize(gradient);
-                        }
-
-                        //
-                        // Compute the color
-                        //
-                        computePixelColor(source_rgb, dest_rgb, gradient);
-                    }
-
-                }
-            }
-        }
-
-        //
-        // Node centered data
-        //
-        if (npt_arrays > 0)
-        {
-            int indexT[8];
-            computeIndicesVert(dims, indices, indexT);
-
-            for (int l = 0 ; l < npt_arrays ; l++)
-            {
-                void  *pt_array = pt_arrays[l];
-                double values[8];
-                for (int m = 0 ; m < pt_size[l] ; m++)
-                {
-                    AssignEight(pt_vartypes[l], values, indexT, pt_size[l], m, pt_array);
-                    double scalarValue = trilinearInterpolate(values, x_left, y_bottom, z_front);
-                    double source_rgb[4];
-                    int retVal = transferFn1D->QueryTF(scalarValue,source_rgb);
-                    if ( ((retVal == 0)||(source_rgb[3]==0)) || (source_rgb[0]==0 && source_rgb[1]==0 && source_rgb[2]==0) )
-                    {
-                        // no need to do anything more if there will be no color
-                    }
-                    else
-                    {
-                        //
-                        // Compute Lighting (if needed)
-                        //
-                        if (lighting == true)
-                        {
-                            double vals[6];
-
-                            // h = offset = 1/2 the distance between grids
-                            // grad = 1/2*h * ( f(x+h,y,z)-f(x-h,y,z)    f(x,y+h,z)-f(x,y-h,z)   f(x,y,z-h)-f(x,y,z-h)  )
-
-                            float distFromRight, distFromLeft, distFromTop, distFromBottom, distFromFront, distFromBack;
-                            int indexLeft, indexRight, indexTop, indexBottom, indexFront, indexBack;
-                            float gradientOffset = 0.5;
-
-                            double gradVals[8];
-                            int indexGrad[8], gradInd[3], gradIndices[6];
-                            float xRight, yTop, zBack = 0;
-
-
-
-                            //
-                            // X
-                            //
-                            for (int i=0; i<6; i++)
-                                gradIndices[i] = indices[i];
-
-                            //
-                            // find x-h
-                            //
-                            if (x_right - gradientOffset < 0.0){
-                                xRight = (x_right - gradientOffset)+1.0;
-                                gradInd[0] = ind[0]-1;
-                            }
-                            else{
-                                xRight = x_right - gradientOffset;
-                                gradInd[0] = ind[0];
-                            }
-
-                            getIndexandDistFromCenter(xRight, gradInd[0],  indexLeft, indexRight,  distFromLeft, distFromRight);
-                            gradIndices[0] = indexLeft;    gradIndices[1] = indexRight;
-                            computeIndicesVert(dims, gradIndices, indexGrad);
-                            AssignEight(pt_vartypes[0], gradVals, indexGrad, 1, 0, pt_array);
-                            vals[0] = trilinearInterpolate(gradVals, x_left-gradientOffset, y_bottom, z_front);
-
-                            //
-                            // find x+h
-                            //
-                            if (x_right + gradientOffset > 1.0){
-                                xRight = (x_right + gradientOffset)-1.0;
-                                gradInd[0] = ind[0]+1;
-                            }else{
-                                xRight = x_right + gradientOffset;
-                                gradInd[0] = ind[0];
-                            }
-
-                            getIndexandDistFromCenter(xRight, gradInd[0],  indexLeft, indexRight,  distFromLeft, distFromRight);
-                            gradIndices[0] = indexLeft;    gradIndices[1] = indexRight;
-                            computeIndices(dims, gradIndices, indexGrad);
-                            AssignEight(pt_vartypes[0], gradVals, indexGrad, 1, 0, pt_array);
-                            vals[1] = trilinearInterpolate(gradVals, x_left+gradientOffset, y_bottom, z_front);
-
-
-
-                            //
-                            // Y
-                            //
-                            for (int i=0; i<6; i++)
-                                gradIndices[i] = indices[i];
-
-                            //
-                            // find y-h
-                            //
-                            if (y_top - gradientOffset < 0.0){
-                                yTop = (y_top - gradientOffset)+1.0;
-                                gradInd[1] = ind[1]-1;
-                            }
-                            else{
-                                yTop = y_top - gradientOffset;
-                                gradInd[1] = ind[1];
-                            }
-
-                            getIndexandDistFromCenter(yTop, gradInd[1],  indexBottom, indexTop,  distFromBottom, distFromTop);
-                            gradIndices[2] = indexBottom ;    gradIndices[3] = indexTop;
-                            computeIndices(dims, gradIndices, indexGrad);
-                            AssignEight(pt_vartypes[0], gradVals, indexGrad, 1, 0, pt_array);
-                            vals[2] = trilinearInterpolate(gradVals, x_left, y_bottom-gradientOffset, z_front);
-
-                            //
-                            // find y+h
-                            //
-                            yTop = y_top;
-                            if (y_top + gradientOffset > 1.0){
-                                yTop = (y_top + gradientOffset)-1.0;
-                                gradInd[1] = ind[1]+1;
-                            }else{
-                                yTop = y_top + gradientOffset;
-                                gradInd[1] = ind[1];
-                            }
-
-                            getIndexandDistFromCenter(yTop, gradInd[1],  indexBottom, indexTop,  distFromBottom, distFromTop);
-                            gradIndices[2] = indexBottom;    gradIndices[3] = indexTop;
-                            computeIndices(dims, gradIndices, indexGrad);
-                            AssignEight(pt_vartypes[0], gradVals, indexGrad, 1, 0, pt_array);
-                            vals[3] = trilinearInterpolate(gradVals, x_left, y_bottom+gradientOffset, z_front);
-
-
-                            //
-                            // Z
-                            //
-                            for (int i=0; i<6; i++)
-                                gradIndices[i] = indices[i];
-
-                            //
-                            // z-h
-
-                            if (z_back - gradientOffset < 0.0){
-                                zBack = (z_back - gradientOffset)+1.0;
-                                gradInd[2] = ind[2]-1;
-                            }
-                            else
-                            {
-                                zBack = z_back - gradientOffset;
-                                gradInd[2] = ind[2];
-                            }
-
-                            getIndexandDistFromCenter(zBack, gradInd[2],  indexFront, indexBack,  distFromFront, distFromBack);
-                            gradIndices[4] = indexFront;    gradIndices[5] = indexBack;
-                            computeIndices(dims, gradIndices, indexGrad);
-                            AssignEight(pt_vartypes[0], gradVals, indexGrad, 1, 0, pt_array);
-                            vals[4] = trilinearInterpolate(gradVals, x_left, y_bottom, z_front-gradientOffset);
-
-                            //
-                            // z+h
-                            //
-                            if (z_back + gradientOffset > 1.0){
-                                zBack = (z_back + gradientOffset)-1.0;
-                                gradInd[2] = ind[2]+1;
-                            }else{
-                                zBack = z_back + gradientOffset;
-                                gradInd[2] = ind[2];
-                            }
-
-                            getIndexandDistFromCenter(zBack, gradInd[2],  indexFront, indexBack,  distFromFront, distFromBack);
-                            gradIndices[4] = indexFront;    gradIndices[5] = indexBack;
-                            computeIndices(dims, gradIndices, indexGrad);
-                            AssignEight(pt_vartypes[0], gradVals, indexGrad, 1, 0, pt_array);
-                            vals[5] = trilinearInterpolate(gradVals, x_left, y_bottom, z_front+gradientOffset);
-
-
-                            gradient[0] = (1.0/(2.0*gradientOffset)) * (vals[1] - vals[0]);
-                            gradient[1] = (1.0/(2.0*gradientOffset)) * (vals[3] - vals[2]);
-                            gradient[2] = (1.0/(2.0*gradientOffset)) * (vals[5] - vals[4]);
-
-                            normalize(gradient);
-                        }
-
-                        //
-                        // Compute the color
-                        //
-                        computePixelColor(source_rgb, dest_rgb, gradient);
-                    }
-                }
-            }
-        }
-        count++;
+	// If we intersect a value in the z buffer
+	if (i == intersect)
+	{
+	    int fullIndex = (y * (bufferExtents[1]-bufferExtents[0]) + x) * 3.0;
+	    float bufferColor[4];
+	    bufferColor[0] = rgbColorBuffer[fullIndex + 0] / 255.0;
+	    bufferColor[1] = rgbColorBuffer[fullIndex + 1] / 255.0;
+	    bufferColor[2] = rgbColorBuffer[fullIndex + 2] / 255.0;
+	    bufferColor[3] = 1.0;
+	    for (int j=0; j<4; j++)
+	    { 
+		dest_rgb[j] = bufferColor[j] * (1.0 - dest_rgb[3]) + dest_rgb[j]; 
+	    }
+	    // debug5 << x << ", " << y 
+	    // 	   << " ~ First: " << first 
+	    // 	   << " i:  " << i 
+	    // 	   << " intersect: " << intersect 
+	    // 	   << " bufferColor: " 
+	    // 	   << bufferColor[0] << ", " 
+	    // 	   << bufferColor[1] << ", " 
+	    // 	   << bufferColor[2] 
+	    // 	   << " dest_rgb: " 
+	    // 	   << dest_rgb[0] << ", " 
+	    // 	   << dest_rgb[1] << ", " 
+	    // 	   << dest_rgb[2] << ", " 
+	    // 	   << dest_rgb[3] << std::endl;
+	    break;
+	}
+
+	const int *ind = ind_buffer + 3*i;
+	const double *prop = prop_buffer + 3*i;
+
+	int index = 0;
+	if (calc_cell_index) {
+	    index = 
+		ind[2]*((dims[0]-1)*(dims[1]-1)) + ind[1]*(dims[0]-1) + ind[0];
+	}
+
+	if (ghosts != NULL)
+	{
+	    if (ghosts[index] != 0)
+		valid_sample[i] = false;
+	}
+
+	int index_left, index_right,            index_top, index_bottom,         index_front, index_back;
+	float dist_from_left, dist_from_right,  dist_from_top,dist_from_bottom,  dist_from_front, dist_from_back;
+
+	int newInd[3];
+	newInd[0] = ind[0];
+	newInd[1] = ind[1];
+	newInd[2] = ind[2];
+
+	float x_right = prop[0];        float x_left   = 1. - x_right;
+	float y_top   = prop[1];        float y_bottom = 1. - y_top;
+	float z_back  = prop[2];        float z_front  = 1. - z_back;		
+
+	// get the index and distance from the center of the neighbouring cells
+	GetIndexandDistFromCenter(x_right, newInd[0], index_left,   index_right,
+				  dist_from_left, dist_from_right);
+	GetIndexandDistFromCenter(y_top,   newInd[1], index_bottom, index_top,
+				  dist_from_bottom,dist_from_top);
+	GetIndexandDistFromCenter(z_back,  newInd[2], index_front,  index_back,
+				  dist_from_front, dist_from_back);
+
+	int indices[6];
+	indices[4] = index_front;       indices[5] = index_back;
+	indices[2] = index_bottom;      indices[3] = index_top;
+	indices[0] = index_left;        indices[1] = index_right;
+
+	if (indices[0] < 0 || indices[0]>dims[0]-2)
+	    valid_sample[i] = false;
+
+	if (indices[1] < 0 || indices[1]>dims[0]-2)
+	    valid_sample[i] = false;
+
+	if (indices[2] < 0 || indices[2]>dims[1]-2)
+	    valid_sample[i] = false;
+
+	if (indices[3] < 0 || indices[3]>dims[1]-2)
+	    valid_sample[i] = false;
+
+	if (indices[4] < 0 || indices[4]>dims[2]-2)
+	    valid_sample[i] = false;
+
+	if (indices[5] < 0 || indices[5]>dims[2]-2)
+	    valid_sample[i] = false;
+
+	if (!valid_sample[i])
+	    continue;
+
+	//
+	// Cell centered data
+	//
+	if (ncell_arrays > 0)
+	{
+	    int indexT[8];
+	    ComputeIndices(dims, indices, indexT);
+
+	    // ncell_arrays: usually 1
+	    for (int l = 0 ; l < ncell_arrays ; l++)
+	    {
+		void  *cell_array = cell_arrays[l];
+		double values[8];
+
+		// cell_size[l] usually 1
+		for (int m = 0 ; m < cell_size[l] ; m++)
+		{
+		    AssignEight(cell_vartypes[l], values, indexT, 
+				cell_size[l], m, cell_array);
+		    double scalarValue = 
+			TrilinearInterpolate(values, 
+					     dist_from_left, 
+					     dist_from_bottom, 
+					     dist_from_front);
+		    double source_rgb[4];
+		    int retVal;
+
+		    retVal = transferFn1D->QueryTF(scalarValue,source_rgb);
+
+		    if (((retVal == 0) || (source_rgb[3]==0)) || 
+		    	(source_rgb[0]==0 && 
+		    	 source_rgb[1]==0 && 
+		    	 source_rgb[2]==0))
+		    {
+			// no need to do anything more if there will be no color
+		    }
+		    else
+		    {
+			//
+			// Compute Lighting (if needed)
+			//
+			if (lighting == true)
+			{
+			    double vals[6];
+
+			    // h = offset = 1/2 the distance between grids
+			    // grad = 1/2*h * ( f(x+h,y,z)-f(x-h,y,z)    f(x,y+h,z)-f(x,y-h,z)   f(x,y,z-h)-f(x,y,z-h)  )
+
+			    float distFromRight, distFromLeft, 
+				  distFromTop, distFromBottom, 
+				  distFromFront, distFromBack;
+			    int indexLeft, indexRight, indexTop, 
+				indexBottom, indexFront, indexBack;
+			    float gradientOffset = 0.25;
+
+			    double gradVals[8];
+			    int indexGrad[8], gradInd[3], gradIndices[6];
+			    float xRight, yTop, zBack;
+
+			    void  *cell_array = cell_arrays[0];
+
+			    //
+			    // X
+			    //
+			    for (int i=0; i<6; i++)
+				gradIndices[i] = indices[i];
+
+			    //
+			    // find x-h
+			    //
+			    if (x_right - gradientOffset < 0.0){
+				xRight = (x_right - gradientOffset)+1.0;
+				gradInd[0] = ind[0]-1;
+			    }
+			    else{
+				xRight = x_right - gradientOffset;
+				gradInd[0] = ind[0];
+			    }
+
+			    GetIndexandDistFromCenter(xRight, gradInd[0],  indexLeft, indexRight,  distFromLeft, distFromRight);
+			    gradIndices[0] = indexLeft;    gradIndices[1] = indexRight;
+			    ComputeIndices(dims, gradIndices, indexGrad);
+			    AssignEight(cell_vartypes[0], gradVals, indexGrad, 1, 0, cell_array);
+			    vals[0] = TrilinearInterpolate(gradVals, distFromLeft, dist_from_bottom, dist_from_front);
+
+			    //
+			    // find x+h
+			    //
+			    if (x_right + gradientOffset > 1.0){
+				xRight = (x_right + gradientOffset)-1.0;
+				gradInd[0] = ind[0]+1;
+			    }else{
+				xRight = x_right + gradientOffset;
+				gradInd[0] = ind[0];
+			    }
+
+			    GetIndexandDistFromCenter(xRight, gradInd[0],  indexLeft, indexRight,  distFromLeft, distFromRight);
+			    gradIndices[0] = indexLeft;    gradIndices[1] = indexRight;
+			    ComputeIndices(dims, gradIndices, indexGrad);
+			    AssignEight(cell_vartypes[0], gradVals, indexGrad, 1, 0, cell_array);
+			    vals[1] = TrilinearInterpolate(gradVals, distFromLeft, dist_from_bottom, dist_from_front);
+
+
+
+			    //
+			    // Y
+			    //
+			    for (int i=0; i<6; i++)
+				gradIndices[i] = indices[i];
+
+			    //
+			    // find y-h
+			    //
+			    if (y_top - gradientOffset < 0.0){
+				yTop = (y_top - gradientOffset)+1.0;
+				gradInd[1] = ind[1]-1;
+			    }
+			    else{
+				yTop = y_top - gradientOffset;
+				gradInd[1] = ind[1];
+			    }
+
+			    GetIndexandDistFromCenter(yTop, gradInd[1],  indexBottom, indexTop,  distFromBottom, distFromTop);
+			    gradIndices[2] = indexBottom ;    gradIndices[3] = indexTop;
+			    ComputeIndices(dims, gradIndices, indexGrad);
+			    AssignEight(cell_vartypes[0], gradVals, indexGrad, 1, 0, cell_array);
+			    vals[2] = TrilinearInterpolate(gradVals, dist_from_left, distFromBottom, dist_from_front);
+
+			    //
+			    // find y+h
+			    //
+			    yTop = y_top;
+			    if (y_top + gradientOffset > 1.0){
+				yTop = (y_top + gradientOffset)-1.0;
+				gradInd[1] = ind[1]+1;
+			    }else{
+				yTop = y_top + gradientOffset;
+				gradInd[1] = ind[1];
+			    }
+
+			    GetIndexandDistFromCenter(yTop, gradInd[1],  indexBottom, indexTop,  distFromBottom, distFromTop);
+			    gradIndices[2] = indexBottom;    gradIndices[3] = indexTop;
+			    ComputeIndices(dims, gradIndices, indexGrad);
+			    AssignEight(cell_vartypes[0], gradVals, indexGrad, 1, 0, cell_array);
+			    vals[3] = TrilinearInterpolate(gradVals, dist_from_left, distFromBottom, dist_from_front);
+
+
+			    //
+			    // Z
+			    //
+			    for (int i=0; i<6; i++)
+				gradIndices[i] = indices[i];
+
+			    //
+			    // z-h
+			    //
+			    if (z_back - gradientOffset < 0.0){
+				zBack = (z_back - gradientOffset)+1.0;
+				gradInd[2] = ind[2]-1;
+			    }
+			    else{
+				zBack = z_back - gradientOffset;
+				gradInd[2] = ind[2];
+			    }
+
+			    GetIndexandDistFromCenter(zBack, gradInd[2],  indexFront, indexBack,  distFromFront, distFromBack);
+			    gradIndices[4] = indexFront;    gradIndices[5] = indexBack;
+			    ComputeIndices(dims, gradIndices, indexGrad);
+			    AssignEight(cell_vartypes[0], gradVals, indexGrad, 1, 0, cell_array);
+			    vals[4] = TrilinearInterpolate(gradVals, dist_from_left, dist_from_bottom, distFromFront);
+
+			    //
+			    // z+h
+			    //
+			    if (z_back + gradientOffset > 1.0){
+				zBack = (z_back + gradientOffset)-1.0;
+				gradInd[2] = ind[2]+1;
+			    }else{
+				zBack = z_back + gradientOffset;
+				gradInd[2] = ind[2];
+			    }
+
+			    GetIndexandDistFromCenter(zBack, gradInd[2],  indexFront, indexBack,  distFromFront, distFromBack);
+			    gradIndices[4] = indexFront;    gradIndices[5] = indexBack;
+			    ComputeIndices(dims, gradIndices, indexGrad);
+			    AssignEight(cell_vartypes[0], gradVals, indexGrad, 1, 0, cell_array);
+			    vals[5] = TrilinearInterpolate(gradVals, dist_from_left, dist_from_bottom, distFromFront);
+
+
+			    gradient[0] = (1.0/(2.0*gradientOffset)) * (vals[1] - vals[0]);
+			    gradient[1] = (1.0/(2.0*gradientOffset)) * (vals[3] - vals[2]);
+			    gradient[2] = (1.0/(2.0*gradientOffset)) * (vals[5] - vals[4]);
+
+			    Normalize(gradient);
+			}
+
+			//
+			// Compute the color
+			//
+			ComputePixelColor(source_rgb, dest_rgb, gradient);
+		    }		    
+		}
+	    }
+	}
+
+	//
+	// Node centered data
+	//
+	if (npt_arrays > 0)
+	{
+	    int indexT[8];
+	    ComputeIndicesVert(dims, indices, indexT);
+
+	    for (int l = 0 ; l < npt_arrays ; l++)
+	    {
+		void  *pt_array = pt_arrays[l];
+		double values[8];
+		for (int m = 0 ; m < pt_size[l] ; m++)
+		{
+		    AssignEight(pt_vartypes[l], values, indexT, pt_size[l], m, pt_array);
+		    double scalarValue = TrilinearInterpolate(values, x_left, y_bottom, z_front);
+		    double source_rgb[4];
+		    int retVal = transferFn1D->QueryTF(scalarValue,source_rgb);
+		    if ( ((retVal == 0)||(source_rgb[3]==0)) || (source_rgb[0]==0 && source_rgb[1]==0 && source_rgb[2]==0) )
+		    {
+			// no need to do anything more if there will be no color
+		    }
+		    else
+		    {
+			//
+			// Compute Lighting (if needed)
+			//
+			if (lighting == true)
+			{
+			    double vals[6];
+
+			    // h = offset = 1/2 the distance between grids
+			    // grad = 1/2*h * ( f(x+h,y,z)-f(x-h,y,z)    f(x,y+h,z)-f(x,y-h,z)   f(x,y,z-h)-f(x,y,z-h)  )
+
+			    float distFromRight, distFromLeft, distFromTop, distFromBottom, distFromFront, distFromBack;
+			    int indexLeft, indexRight, indexTop, indexBottom, indexFront, indexBack;
+			    float gradientOffset = 0.5;
+
+			    double gradVals[8];
+			    int indexGrad[8], gradInd[3], gradIndices[6];
+			    float xRight, yTop, zBack = 0;
+
+
+
+			    //
+			    // X
+			    //
+			    for (int i=0; i<6; i++)
+				gradIndices[i] = indices[i];
+
+			    //
+			    // find x-h
+			    //
+			    if (x_right - gradientOffset < 0.0){
+				xRight = (x_right - gradientOffset)+1.0;
+				gradInd[0] = ind[0]-1;
+			    }
+			    else{
+				xRight = x_right - gradientOffset;
+				gradInd[0] = ind[0];
+			    }
+
+			    GetIndexandDistFromCenter(xRight, gradInd[0],  indexLeft, indexRight,  distFromLeft, distFromRight);
+			    gradIndices[0] = indexLeft;    gradIndices[1] = indexRight;
+			    ComputeIndicesVert(dims, gradIndices, indexGrad);
+			    AssignEight(pt_vartypes[0], gradVals, indexGrad, 1, 0, pt_array);
+			    vals[0] = TrilinearInterpolate(gradVals, x_left-gradientOffset, y_bottom, z_front);
+
+			    //
+			    // find x+h
+			    //
+			    if (x_right + gradientOffset > 1.0){
+				xRight = (x_right + gradientOffset)-1.0;
+				gradInd[0] = ind[0]+1;
+			    }else{
+				xRight = x_right + gradientOffset;
+				gradInd[0] = ind[0];
+			    }
+
+			    GetIndexandDistFromCenter(xRight, gradInd[0],  indexLeft, indexRight,  distFromLeft, distFromRight);
+			    gradIndices[0] = indexLeft;    gradIndices[1] = indexRight;
+			    ComputeIndices(dims, gradIndices, indexGrad);
+			    AssignEight(pt_vartypes[0], gradVals, indexGrad, 1, 0, pt_array);
+			    vals[1] = TrilinearInterpolate(gradVals, x_left+gradientOffset, y_bottom, z_front);
+
+
+
+			    //
+			    // Y
+			    //
+			    for (int i=0; i<6; i++)
+				gradIndices[i] = indices[i];
+
+			    //
+			    // find y-h
+			    //
+			    if (y_top - gradientOffset < 0.0){
+				yTop = (y_top - gradientOffset)+1.0;
+				gradInd[1] = ind[1]-1;
+			    }
+			    else{
+				yTop = y_top - gradientOffset;
+				gradInd[1] = ind[1];
+			    }
+
+			    GetIndexandDistFromCenter(yTop, gradInd[1],  indexBottom, indexTop,  distFromBottom, distFromTop);
+			    gradIndices[2] = indexBottom ;    gradIndices[3] = indexTop;
+			    ComputeIndices(dims, gradIndices, indexGrad);
+			    AssignEight(pt_vartypes[0], gradVals, indexGrad, 1, 0, pt_array);
+			    vals[2] = TrilinearInterpolate(gradVals, x_left, y_bottom-gradientOffset, z_front);
+
+			    //
+			    // find y+h
+			    //
+			    yTop = y_top;
+			    if (y_top + gradientOffset > 1.0){
+				yTop = (y_top + gradientOffset)-1.0;
+				gradInd[1] = ind[1]+1;
+			    }else{
+				yTop = y_top + gradientOffset;
+				gradInd[1] = ind[1];
+			    }
+
+			    GetIndexandDistFromCenter(yTop, gradInd[1],  indexBottom, indexTop,  distFromBottom, distFromTop);
+			    gradIndices[2] = indexBottom;    gradIndices[3] = indexTop;
+			    ComputeIndices(dims, gradIndices, indexGrad);
+			    AssignEight(pt_vartypes[0], gradVals, indexGrad, 1, 0, pt_array);
+			    vals[3] = TrilinearInterpolate(gradVals, x_left, y_bottom+gradientOffset, z_front);
+
+
+			    //
+			    // Z
+			    //
+			    for (int i=0; i<6; i++)
+				gradIndices[i] = indices[i];
+
+			    //
+			    // z-h
+
+			    if (z_back - gradientOffset < 0.0){
+				zBack = (z_back - gradientOffset)+1.0;
+				gradInd[2] = ind[2]-1;
+			    }
+			    else
+			    {
+				zBack = z_back - gradientOffset;
+				gradInd[2] = ind[2];
+			    }
+
+			    GetIndexandDistFromCenter(zBack, gradInd[2],  indexFront, indexBack,  distFromFront, distFromBack);
+			    gradIndices[4] = indexFront;    gradIndices[5] = indexBack;
+			    ComputeIndices(dims, gradIndices, indexGrad);
+			    AssignEight(pt_vartypes[0], gradVals, indexGrad, 1, 0, pt_array);
+			    vals[4] = TrilinearInterpolate(gradVals, x_left, y_bottom, z_front-gradientOffset);
+
+			    //
+			    // z+h
+			    //
+			    if (z_back + gradientOffset > 1.0){
+				zBack = (z_back + gradientOffset)-1.0;
+				gradInd[2] = ind[2]+1;
+			    }else{
+				zBack = z_back + gradientOffset;
+				gradInd[2] = ind[2];
+			    }
+
+			    GetIndexandDistFromCenter(zBack, gradInd[2],  indexFront, indexBack,  distFromFront, distFromBack);
+			    gradIndices[4] = indexFront;    gradIndices[5] = indexBack;
+			    ComputeIndices(dims, gradIndices, indexGrad);
+			    AssignEight(pt_vartypes[0], gradVals, indexGrad, 1, 0, pt_array);
+			    vals[5] = TrilinearInterpolate(gradVals, x_left, y_bottom, z_front+gradientOffset);
+
+
+			    gradient[0] = (1.0/(2.0*gradientOffset)) * (vals[1] - vals[0]);
+			    gradient[1] = (1.0/(2.0*gradientOffset)) * (vals[3] - vals[2]);
+			    gradient[2] = (1.0/(2.0*gradientOffset)) * (vals[5] - vals[4]);
+
+			    Normalize(gradient);
+			}
+
+			//
+			// Compute the color
+			//
+			ComputePixelColor(source_rgb, dest_rgb, gradient);
+		    }
+		}
+	    }
+	}
+	count++;
     }
 
     //
@@ -2855,149 +3239,7 @@ avtMassVoxelExtractor::SampleVariableRCSLIVR(int first, int last, int intersect,
 
 
 // ****************************************************************************
-//  Method: avtMassVoxelExtractor::normalize
-//
-//  Purpose:
-//      Normalize vector
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 14, 2016
-//
-//  Modifications:
-//
-// ****************************************************************************
-
-void
-avtMassVoxelExtractor::normalize(float vec[3])
-{
-    float inverse_sqrt_sum_squared = sqrt(vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2]);
-    if (inverse_sqrt_sum_squared != 0)
-        inverse_sqrt_sum_squared = 1.0/inverse_sqrt_sum_squared;
-
-    for (int i=0;i<3; i++)
-        vec[i] = vec[i]*inverse_sqrt_sum_squared;
-}
-
-// ****************************************************************************
-//  Method: avtMassVoxelExtractor::reflect
-//
-//  Purpose:
-//      Reflect vector
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 14, 2016
-//
-//  Modifications:
-//
-// ****************************************************************************
-
-void
-avtMassVoxelExtractor::reflect(float vec[3], float normal[3], float refl[3])
-{
-    //Vnew = -2*(V dot N)*N + V
-    //out = incidentVec - 2.f * Dot(incidentVec, normal) * normal;
-    float vDotN = dot(vec,normal);
-    for (int i=0; i<3; i++)
-        refl[i] = -2.0 * vDotN * normal[i] + vec[i];
-
-    normalize(refl);
-}
-
-
-// ****************************************************************************
-//  Method: avtMassVoxelExtractor::project
-//
-//  Purpose:
-//      Convert from world coordinates to screen coordinates
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 14, 2016
-//
-//  Modifications:
-//
-// ****************************************************************************
-
-double
-avtMassVoxelExtractor::project(double _worldCoordinates[3], int pos2D[2], int _screenWidth, int _screenHeight)
-{
-    double normDevCoord[4];
-    double worldCoordinates[4] = {0,0,0,1};
-    worldCoordinates[0] = _worldCoordinates[0];
-    worldCoordinates[1] = _worldCoordinates[1];
-    worldCoordinates[2] = _worldCoordinates[2];
-
-    // World to Clip space (-1 - 1)
-    modelViewProj->MultiplyPoint(worldCoordinates, normDevCoord);
-
-    if (normDevCoord[3] == 0)
-    {
-        debug5 << "avtMassVoxelExtractor::project division by 0 error!" << endl;
-        debug5 << "worldCoordinates: " << worldCoordinates[0] << ", " << worldCoordinates[1] << ", " << worldCoordinates[2] << "   " << normDevCoord[0] << ", " << normDevCoord[1] << ", " << normDevCoord[2] << endl;
-        debug5 << "Matrix: " << *modelViewProj << endl;
-    }
-
-    // NDC
-    normDevCoord[0] = normDevCoord[0]/normDevCoord[3];
-    normDevCoord[1] = normDevCoord[1]/normDevCoord[3];
-    normDevCoord[2] = normDevCoord[2]/normDevCoord[3];
-    normDevCoord[3] = normDevCoord[3]/normDevCoord[3];
-
-    // Screen coordinates
-    pos2D[0] = round( normDevCoord[0]*(_screenWidth/2.)  + (_screenWidth/2.)  );
-    pos2D[1] = round( normDevCoord[1]*(_screenHeight/2.) + (_screenHeight/2.) );
-
-
-    // Add panning
-    pos2D[0] += round(_screenWidth * panPercentage[0]);
-    pos2D[1] += round(_screenHeight * panPercentage[1]); 
-
-    return normDevCoord[2];
-}
-
-// ****************************************************************************
-//  Method: avtMassVoxelExtractor::unProject
-//
-//  Purpose:
-//      Convert from screen coordinates to world coordinates
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 14, 2016
-//
-//  Modifications:
-//
-// ****************************************************************************
-
-void
-avtMassVoxelExtractor::unProject(int _x, int _y, float _z, double _worldCoordinates[3], int _width, int _height)
-{
-    // remove panning
-    _x -= round(_width * panPercentage[0]);
-    _y -= round(_height * panPercentage[1]); 
-
-    double worldCoordinates[4] = {0,0,0,1};
-    double in[4] = {0,0,0,1};
-    in[0] = (_x - _width/2. )/(_width/2.);
-    in[1] = (_y - _height/2.)/(_height/2.);
-    in[2] = _z;
-
-    invModelViewProj->MultiplyPoint(in, worldCoordinates);
-
-    if (worldCoordinates[3] == 0)
-        debug5 << "avtMassVoxelExtractor::unProject division by 0 error!" << endl;
-
-    worldCoordinates[0] = worldCoordinates[0]/worldCoordinates[3];
-    worldCoordinates[1] = worldCoordinates[1]/worldCoordinates[3];
-    worldCoordinates[2] = worldCoordinates[2]/worldCoordinates[3];
-    worldCoordinates[3] = worldCoordinates[3]/worldCoordinates[3];
-
-    _worldCoordinates[0] = worldCoordinates[0];
-    _worldCoordinates[1] = worldCoordinates[1];
-    _worldCoordinates[2] = worldCoordinates[2];
-}
-
-
-// ****************************************************************************
-//  Method: avtMassVoxelExtractor::getImageDimensions
+//  Method: avtMassVoxelExtractor::GetImageDimensions
 //
 //  Purpose:
 //      Transfers the metadata of the patch
@@ -3010,16 +3252,18 @@ avtMassVoxelExtractor::unProject(int _x, int _y, float _z, double _worldCoordina
 // ****************************************************************************
 
 void
-avtMassVoxelExtractor::getImageDimensions(int &inUse, int dims[2], int screen_ll[2], int screen_ur[2], float &eyeDepth, float &clipDepth)
+avtMassVoxelExtractor::GetImageDimensions
+(int &inUse, int dims[2], int screen_ll[2], int screen_ur[2], 
+ float &eyesDepth, float &clipDepth)
 {
     inUse = patchDrawn;
-
-    dims[0] = imgDims[0];    dims[1] = imgDims[1];
-
-    screen_ll[0] = imgLowerLeft[0];     screen_ll[1] = imgLowerLeft[1];
-    screen_ur[0] = imgUpperRight[0];    screen_ur[1] = imgUpperRight[1];
-
-    eyeDepth = eyeSpaceDepth;
+    dims[0] = imgDims[0];   
+    dims[1] = imgDims[1];
+    screen_ll[0] = imgLowerLeft[0];     
+    screen_ll[1] = imgLowerLeft[1];
+    screen_ur[0] = imgUpperRight[0];    
+    screen_ur[1] = imgUpperRight[1];
+    eyesDepth = eyesSpaceDepth; // distance between eye and patch center
     clipDepth = clipSpaceDepth;
 }
 
@@ -3038,12 +3282,12 @@ avtMassVoxelExtractor::getImageDimensions(int &inUse, int dims[2], int screen_ll
 // ****************************************************************************
 
 void
-avtMassVoxelExtractor::getComputedImage(float *image)
+avtMassVoxelExtractor::GetComputedImage(float *image)
 {
-    memcpy(image, imgArray, imgDims[0]*4*imgDims[1]*sizeof(float));
-
-    if (imgArray != NULL)
-        delete []imgArray;
+    memcpy(image, imgArray, 4*imgDims[0]*imgDims[1]*sizeof(float));
+    if (imgArray != NULL) {
+	delete []imgArray;
+    }
     imgArray = NULL;
 }
 
@@ -3053,7 +3297,7 @@ avtMassVoxelExtractor::getComputedImage(float *image)
 //
 //  Purpose:
 //      Computes color
-//      By replicating avtPhong::AddLightingHeadlight
+// 		By replicating avtPhong::AddLightingHeadlight
 //
 //  Programmer: Pascal Grosset
 //  Creation:   June 10, 2013
@@ -3065,52 +3309,59 @@ avtMassVoxelExtractor::getComputedImage(float *image)
 // ****************************************************************************
 
 void
-avtMassVoxelExtractor::computePixelColor(double source_rgb[4], double dest_rgb[4], float _gradient[3])
+avtMassVoxelExtractor::ComputePixelColor(double source_rgb[4], double dest_rgb[4], float _gradient[3])
 {
     if (dest_rgb[3] >= 0.99)
     {
-        patchDrawn = 1;
-        return;
+	patchDrawn = 1;
+	return;
     }
 
     // Phong Shading
     if (lighting == true)
     {
-        float dir[3];           
-        dir[0] = -view_direction[0];
-        dir[1] = -view_direction[1];
-        dir[2] = -view_direction[2];
-
-        normalize(dir);
-
-        double temp_rgb[4];
-        temp_rgb[0] = source_rgb[0];
-        temp_rgb[1] = source_rgb[1];
-        temp_rgb[2] = source_rgb[2];
-        temp_rgb[3] = source_rgb[3];
-
-        // cos(angle) = a.b;  angle between normal and light
-        float normal_dot_light = dot(_gradient,dir);   // angle between light and normal;
-        if (normal_dot_light < 0)
-            normal_dot_light = -normal_dot_light;
-
-        debug5 << "normal_dot_light: " << normal_dot_light << "   _gradient: " << _gradient[0] << ", " << _gradient[1] << ", " << _gradient[2] << std::endl;
-        // Calculate color using phong shading
-        // I = (I  * ka) + [ (I_i  * kd * (L.N)) + (Ia_i * ks * (R.V)^ns) ]_for each light source i
-        for (int i=0; i<3; i++)
-        {
-            source_rgb[i] =  ( (materialProperties[0] + materialProperties[1] * normal_dot_light)           * source_rgb[i] ) +     // I  * ( ka + kd*abs(cos(angle)) )
-                               (materialProperties[2] * pow((double)normal_dot_light,materialProperties[3]) * source_rgb[3] )  ;    // I  * kd*abs(cos(angle))
-
-        }
+	float dir[3];           
+	dir[0] = -view_direction[0];
+	dir[1] = -view_direction[1];
+	dir[2] = -view_direction[2];
+
+	Normalize(dir);
+
+	double temp_rgb[4];
+	temp_rgb[0] = source_rgb[0];
+	temp_rgb[1] = source_rgb[1];
+	temp_rgb[2] = source_rgb[2];
+	temp_rgb[3] = source_rgb[3];
+
+	// cos(angle) = a.b;  angle between normal and light
+	float normal_dot_light = Dot(_gradient,dir);   // angle between light and normal;
+	if (normal_dot_light < 0)
+	    normal_dot_light = -normal_dot_light;
+
+	debug5 << "normal_dot_light: " << normal_dot_light 
+	       << "   _gradient: " 
+	       << _gradient[0] << ", " 
+	       << _gradient[1] << ", " 
+	       << _gradient[2] << std::endl;
+
+	// Calculate color using phong shading
+	// I = (I  * ka) + [ (I_i  * kd * (L.N)) + (Ia_i * ks * (R.V)^ns) ]
+	// for each light source i
+	for (int i=0; i<3; i++)
+	{
+            // I * (ka + kd*abs(cos(angle)))           
+	    source_rgb[i] = 
+	    	((materialProperties[0]+materialProperties[1]*normal_dot_light)*source_rgb[i])+ 
+	    	(materialProperties[2]*pow((double)normal_dot_light, materialProperties[3])*source_rgb[3]);
+	}
     }
     for (int i=0; i<4; i++)
     {
-        // front to back compositing
-        dest_rgb[i] = source_rgb[i] * (1.0 - dest_rgb[3]) + dest_rgb[i];
+	// front to back compositing
+	dest_rgb[i] = source_rgb[i] * (1.0 - dest_rgb[3]) + dest_rgb[i];
 
-        // // back to front
-        //  dest_rgb[i] = std::min( dest_rgb[i] * (1.0 - intermediate_rgb[3]) + intermediate_rgb[i], 1.0);
+	// // back to front
+	//	dest_rgb[i] = std::min( dest_rgb[i] * (1.0 - intermediate_rgb[3]) + intermediate_rgb[i], 1.0);
     }
 
 
diff --git a/avt/Filters/avtMassVoxelExtractor.h b/avt/Filters/avtMassVoxelExtractor.h
index 637eb7026..b37309c92 100644
--- a/avt/Filters/avtMassVoxelExtractor.h
+++ b/avt/Filters/avtMassVoxelExtractor.h
@@ -47,20 +47,20 @@
 
 #include <avtExtractor.h>
 #include <avtViewInfo.h>
-
 #include <avtOpacityMap.h>
-
+#include <avtSLIVROSPRayFilter.h>
 #include <DebugStream.h>
-class     vtkRectilinearGrid;
-class     vtkMatrix4x4;
 
 #include <vtkMatrix3x3.h>
 #include <vtkMatrix4x4.h>
 #include <vtkCamera.h>
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <algorithm>
-#include "imgMetaData.h"
+
+class     vtkRectilinearGrid;
+class     vtkMatrix4x4;
 
 // ****************************************************************************
 //  Class: avtMassVoxelExtractor
@@ -99,193 +99,228 @@ class     vtkMatrix4x4;
 //    Kathleen Biagas, Fri Jul 13 09:44:45 PDT 2012
 //    Use double internally instead of float.
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for volume rendering using OSPRay (RayCasting:OSPRay)
+//
 // ****************************************************************************
 
 class AVTFILTERS_API avtMassVoxelExtractor : public avtExtractor
 {
-  public:
-                     avtMassVoxelExtractor(int, int, int, avtVolume *,
-                                            avtCellList *);
-    virtual         ~avtMassVoxelExtractor();
-
-    void             Extract(vtkRectilinearGrid *,
-                             std::vector<std::string> &varnames,
-                             std::vector<int> &varsize);
-
-    void             SetGridsAreInWorldSpace(bool, const avtViewInfo &,double,
-                                             const double *);
-    void             SetVariableInformation(std::vector<std::string> &names,
-                                            std::vector<int> varsize);
-
-    void             SetTrilinear(bool t) {trilinearInterpolation = t;   };
-
-
-    //
-    // RC SLIVR Specific
-    //
-
-    void             SetRayCastingSLIVR(bool s) {rayCastingSLIVR = s; };
-
-    void             SetLighting(bool l) {lighting = l; };
-    void             SetLightDirection(double _lightDir[3]) { for (int i=0;i<3;i++) lightDirection[i]=_lightDir[i]; }
-    void             SetLightPosition(double _lightPos[4]) { for (int i=0;i<4;i++) lightPosition[i]=_lightPos[i]; }
-    void             SetMatProperties(double _matProp[4]) { for (int i=0;i<4;i++) materialProperties[i]=_matProp[i]; }
-                        
-    void             SetScalarRange(double _range[2]){ scalarRange[0]=_range[0]; scalarRange[1]=_range[1];}
-    void             SetTFVisibleRange(double _tfRange[2]){ tFVisibleRange[0]=_tfRange[0]; tFVisibleRange[1]=_tfRange[1];}
-
-    void             SetTransferFn(avtOpacityMap *_transferFn1D) { transferFn1D = _transferFn1D; };
-
-    void             SetViewDirection(double *vD){ for (int i=0; i<3; i++) viewDirection[i]=view_direction[i] = vD[i]; }
-    void             SetClipPlanes(double _camClip[2]){ clipPlanes[0]=_camClip[0]; clipPlanes[1]=_camClip[1]; }
-    void             SetPanPercentages(double _pan[2]){ panPercentage[0]=_pan[0]; panPercentage[1]=_pan[1]; }
-    void             SetDepthExtents(double _depthExtents[2]){ fullVolumeDepthExtents[0]=_depthExtents[0]; fullVolumeDepthExtents[1]=_depthExtents[1]; }
-    void             SetMVPMatrix(vtkMatrix4x4 *_mvp){ modelViewProj->DeepCopy(_mvp); vtkMatrix4x4::Invert(modelViewProj, invModelViewProj); }
-
-
-    // Getting the image
-    void             getImageDimensions(int &inUse, int dims[2], int screen_ll[2], int screen_ur[2], float &eyeDepth, float &clipDepth);
-    void             getComputedImage(float *image);
-    void             setProcIdPatchID(int _proc, int _patch){ proc = _proc; patch = _patch; }
-
-    // Set the background information
-    void             setDepthBuffer(float *_zBuffer, int size){ depthBuffer=_zBuffer; }
-    void             setRGBBuffer(unsigned char  *_colorBuffer, int width, int height){ rgbColorBuffer=_colorBuffer; };
-    void             setBufferExtents(int _extents[4]){ for (int i=0;i<4; i++) bufferExtents[i]=_extents[i]; }
-
-  protected:
-    bool             gridsAreInWorldSpace;
-    bool             pretendGridsAreInWorldSpace;
-    avtViewInfo      view;
-    double           aspect;
-    double           cur_clip_range[2];
-    vtkMatrix4x4    *view_to_world_transform;
-    vtkMatrix4x4    *world_to_view_transform;
-
-    bool            trilinearInterpolation;
-    bool            rayCastingSLIVR;
-
-    vtkMatrix4x4    *modelViewProj;
-    vtkMatrix4x4    *invModelViewProj;
-    double           clipPlanes[2];
-    double           panPercentage[2];
-    double           fullVolumeDepthExtents[2];
-    double           viewDirection[3];
-    double           view_direction[3];
-
-    double           *X;
-    double           *Y;
-    double           *Z;
-    unsigned char   *ghosts;
-    int              dims[3];
-    int              ncell_arrays;
-    void            *cell_arrays[AVT_VARIABLE_LIMIT];
-    int              cell_size[AVT_VARIABLE_LIMIT];
-    int              cell_index[AVT_VARIABLE_LIMIT];
-    int              cell_vartypes[AVT_VARIABLE_LIMIT];
-    int              npt_arrays;
-    void            *pt_arrays[AVT_VARIABLE_LIMIT];
-    int              pt_size[AVT_VARIABLE_LIMIT];
-    int              pt_index[AVT_VARIABLE_LIMIT];
-    int              pt_vartypes[AVT_VARIABLE_LIMIT];
-
-    double          *prop_buffer;
-    int             *ind_buffer;
-    bool            *valid_sample;
-
-    // We repeatedly divide by the term (X[i+1]-X[i]).  In the interest of
-    // performance, cache the term 1./(X[i+1]-X[i]) and use that for faster
-    // multiplication.  This sped up total performance by about 5%.
-    double           *divisors_X;
-    double           *divisors_Y;
-    double           *divisors_Z;
-
-    void             ExtractImageSpaceGrid(vtkRectilinearGrid *,
-                             std::vector<std::string> &varnames,
-                             std::vector<int> &varsize);
-    void             ExtractWorldSpaceGrid(vtkRectilinearGrid *,
-                             std::vector<std::string> &varnames,
-                             std::vector<int> &varsize);
-
-    void             RegisterGrid(vtkRectilinearGrid*,
-                                  std::vector<std::string>&,std::vector<int>&);
-    void             SampleAlongSegment(const double *, const double*, int, int);
-    void             SampleVariable(int, int, int, int);
-    bool             FrustumIntersectsGrid(int, int, int, int) const;
-    bool             FrustumIntersectsGridSLIVR(int, int, int, int) const;
-    void             GetSegment(int, int, double *, double *) const;
-    static void      FindPlaneNormal(const double *, const double *,
-                                     const double *, double *);
-    bool             GridOnPlusSideOfPlane(const double *, const double *) const;
-    bool             FindSegmentIntersections(const double *, const double *,
-                                              int &, int &);
-
-    // Trilinear and RC SLIVR
-    double           trilinearInterpolate(double vals[8], float distRight, float distTop, float distBack);
-    void             computeIndices(int dims[3], int indices[6], int returnIndices[8]);
-    void             computeIndicesVert(int dims[3], int indices[6], int returnIndices[8]);
-    void             getIndexandDistFromCenter(float dist, int index,    int &index_before, int &index_after,    float &dist_before, float &dist_after);
-
-    //
-    // RC SLIVR Specific
-    //
-
-    // Color computation
-    bool             lighting;
-    double           lightPosition[4];
-    float            lightDirection[3];
-    double           materialProperties[4];
-    avtOpacityMap    *transferFn1D;
-    float            gradient[3];
-    double           scalarRange[2];
-    double           tFVisibleRange[2];
-
-
-    // Background + other plots
-    float           *depthBuffer;           // depth buffer for the background and other plots
-    unsigned char   *rgbColorBuffer;        // bounding box + pseudo color + ...
-    int              bufferExtents[4];      // extents of the buffer( minX, maxX, minY, maxY)
-
-    // Rendering
-    int              renderingAreaExtents[4];
-    double           renderingDepthsExtents[2];
-
-
-    // Patch details for one image
-    int              patchDrawn;            // whether the patch is drawn or not
-
-    int              imgWidth, imgHeight;
-    int              imgDims[2];            // size of the patch
-
-    int              imgLowerLeft[2];       // coordinates in the whole image
-    int              imgUpperRight[2];      //
-
-    float            eyeSpaceDepth;         // for blending patches
-    float            clipSpaceDepth;        // clip space depth for blending with other visit stuff
-
-    float            *imgArray;             // the image data
-
-    int              proc;                  // id of the processor
-    int              patch;                 // id of the patch
-
-    int              fullImgWidth, fullImgHeight;
-    int              xMin, xMax, yMin, yMax;
-
-
-    // RC SLIVR Only
-    void             normalize(float vec[3]);
-    void             reflect(float vec[3], float normal[3], float refl[3]);
-    float            dot(float vecA[3], float vecB[3]){ return ((vecA[0]*vecB[0]) + (vecA[1]*vecB[1]) + (vecA[2]*vecB[2])); }
-    void             unProject(int _x, int _y, float _z, double _worldCoordinates[3], int _width, int _height);
-    double           project(double _worldCoordinates[3], int pos2D[2], int _width, int _height);
-
-    void             computePixelColor(double source_rgb[4], double dest_rgb[4], float _gradient[3]);
-
-    void             GetSegmentRCSLIVR(int x, int y, double depthsExtents[2], double *_origin, double *_terminus);
-    void             SampleVariableRCSLIVR(int first, int last, int intersect, int x, int y);
-    void             ExtractWorldSpaceGridRCSLIVR(vtkRectilinearGrid *,  // added for raycasting slivr
-                             std::vector<std::string> &varnames,
-                             std::vector<int> &varsize);
+public:
+		         avtMassVoxelExtractor(int, int, int, avtVolume *, avtCellList *);
+	virtual         ~avtMassVoxelExtractor();
+
+	void             Extract(vtkRectilinearGrid *,
+				 std::vector<std::string> &varnames,
+				 std::vector<int> &varsize);
+
+	void             SetGridsAreInWorldSpace
+	    (bool, const avtViewInfo &,double, const double *);
+	void             SetVariableInformation
+	    (std::vector<std::string> &names, std::vector<int> varsize);
+	void             SetTrilinear(bool t) { trilinearInterpolation = t; };
+
+	//
+	// RayCast SLIVR Specific
+	//
+	void             SetRayCastingSLIVR(bool s) { rayCastingSLIVR = s; };
+	void             SetLighting(bool l) { lighting = l; };
+	void             SetLightDirection(double lightDir[3])
+	{ for (int i=0;i<3;i++) { lightDirection[i] = lightDir[i]; } }
+	void             SetLightPosition(double lightPos[4]) 
+	{ for (int i=0;i<4;i++) { lightPosition[i] = lightPos[i]; } }
+	void             SetMatProperties(double matProp[4]) 
+	{ for (int i=0;i<4;i++) { materialProperties[i] = matProp[i]; } }
+	void             SetScalarRange(double range[2])
+	{ scalarRange[0] = range[0]; scalarRange[1] = range[1];}
+	void             SetTFVisibleRange(double tfRange[2])
+	{ tFVisibleRange[0] = tfRange[0]; tFVisibleRange[1] = tfRange[1]; }
+	void             SetTransferFn(avtOpacityMap *tf1D) 
+	{ transferFn1D = tf1D; };
+	void             SetViewDirection(double *_vD)
+	{ for (int i=0; i<3; i++) { viewDirection[i] = view_direction[i] = _vD[i]; } }
+	void             SetCameraPosition(double *_cp) 
+	{ std::copy(_cp, _cp + 3, cameraPosition); }
+	void             SetCameraUpVector(double *_cu) 
+	{ std::copy(_cu, _cu + 3, cameraUpVector); }
+	void             SetCameraAspect(double _a) { cameraAspect = _a; }
+	void             SetClipPlanes(double _camClip[2])
+	{ clipPlanes[0] = _camClip[0]; clipPlanes[1] = _camClip[1]; }
+	void             SetPanPercentages(double _pan[2])
+	{ panPercentage[0] = _pan[0]; panPercentage[1] = _pan[1]; }
+	void             SetImageZoom(double _zoom) { imageZoom = _zoom; }
+	void             SetDepthExtents(double _depthExtents[2])
+	{ 
+	    fullVolumeDepthExtents[0] = _depthExtents[0]; 
+	    fullVolumeDepthExtents[1] = _depthExtents[1]; 
+	}
+	void             SetMVPMatrix(vtkMatrix4x4 *_mvp)
+	{ 
+	    model_to_screen_transform->DeepCopy(_mvp); 
+	    vtkMatrix4x4::Invert(model_to_screen_transform, screen_to_model_transform); 
+	}
+
+	//
+	// Getting the image
+	//
+	void             GetImageDimensions
+	    (int &, int dims[2], int screen_ll[2], int screen_ur[2], float &, float &);
+	void             GetComputedImage(float *);
+	void             SetProcIdPatchID(int _proc, int _patch)
+	{ proc = _proc; patch = _patch; }
+
+	//
+	// Set the background information
+        //
+	void             SetDepthBuffer(float *_zBuffer, int size) { depthBuffer=_zBuffer; }
+	void             SetRGBBuffer(unsigned char  *_colorBuffer, int width, int height)
+	{ rgbColorBuffer=_colorBuffer; };
+	void             SetBufferExtents(int _extents[4])
+	{ for (int i=0;i<4; i++) bufferExtents[i]=_extents[i]; }
+	void             SetRendererSampleRate(double r) { rendererSampleRate = r; }
+	void             SetOSPRay(OSPVisItContext* o) { ospray = o; }
+	void             SetFullImageExtents(int extents[4]) 
+	{
+	    fullImageExtents[0] = extents[0];
+	    fullImageExtents[1] = extents[1];
+	    fullImageExtents[2] = extents[2];	
+	    fullImageExtents[3] = extents[3];
+	}
+
+protected:
+	int              fullImageExtents[4];
+	bool             gridsAreInWorldSpace;
+	bool             pretendGridsAreInWorldSpace;
+	avtViewInfo      view;
+	double           aspect;
+	double           cur_clip_range[2];
+	vtkMatrix4x4    *view_to_world_transform;
+	vtkMatrix4x4    *world_to_view_transform;
+
+	bool             trilinearInterpolation;
+	bool             rayCastingSLIVR;
+
+	vtkMatrix4x4    *model_to_screen_transform;
+	vtkMatrix4x4    *screen_to_model_transform;
+	double           clipPlanes[2];
+	double 		 panPercentage[2];
+	double           imageZoom;
+	double           fullVolumeDepthExtents[2];
+	double           viewDirection[3];  // -->
+	double           view_direction[3]; // they are redundant. One of them should be removed
+	double           cameraPosition[3]; // (Qi) camera location in world coordinate
+	double           cameraUpVector[3]; // (Qi) camera up vector direction
+	double           cameraAspect;
+	double          *X;
+	double          *Y;
+	double          *Z;
+	unsigned char   *ghosts;
+	int              dims[3];
+	int              ncell_arrays;
+	void            *cell_arrays[AVT_VARIABLE_LIMIT];
+	int              cell_size[AVT_VARIABLE_LIMIT];
+	int              cell_index[AVT_VARIABLE_LIMIT];
+	int              cell_vartypes[AVT_VARIABLE_LIMIT];
+	int              npt_arrays;
+	void            *pt_arrays[AVT_VARIABLE_LIMIT];
+	int              pt_size[AVT_VARIABLE_LIMIT];
+	int              pt_index[AVT_VARIABLE_LIMIT];
+	int              pt_vartypes[AVT_VARIABLE_LIMIT];
+
+	double          *prop_buffer;
+	int             *ind_buffer;
+	bool            *valid_sample;
+
+	// We repeatedly divide by the term (X[i+1]-X[i]).  In the interest of
+	// performance, cache the term 1./(X[i+1]-X[i]) and use that for faster
+	// multiplication.  This sped up total performance by about 5%.
+	double           *divisors_X;
+	double           *divisors_Y;
+	double           *divisors_Z;
+
+	void             ExtractImageSpaceGrid(vtkRectilinearGrid *,
+					       std::vector<std::string> &varnames,
+					       std::vector<int> &varsize);
+	void             ExtractWorldSpaceGrid(vtkRectilinearGrid *,
+					       std::vector<std::string> &varnames,
+					       std::vector<int> &varsize);
+
+	void             RegisterGrid(vtkRectilinearGrid*,
+				      std::vector<std::string>&,std::vector<int>&);
+	void             SampleAlongSegment(const double *, const double*, int, int);
+	void             SampleVariable(int, int, int, int);
+	bool             FrustumIntersectsGrid(int, int, int, int) const;
+	bool             FrustumIntersectsGridSLIVR(int, int, int, int) const;
+	void             GetSegment(int, int, double *, double *) const;
+	static void      FindPlaneNormal(const double *, const double *,
+					 const double *, double *);
+	bool             GridOnPlusSideOfPlane(const double *, const double *) const;
+	bool             FindSegmentIntersections(const double *, const double *,
+						  int &, int &);
+
+	// Trilinear and RC SLIVR
+	double           TrilinearInterpolate(double vals[8], float distRight, float distTop, float distBack);
+	void             ComputeIndices(int dims[3], int indices[6], int returnIndices[8]);
+	void             ComputeIndicesVert(int dims[3], int indices[6], int returnIndices[8]);
+	void             GetIndexandDistFromCenter(float dist, int index,   
+						   int &index_before, int &index_after,  
+						   float &dist_before, float &dist_after);
+
+	//
+	// OSPRay stuffs
+	//
+	OSPVisItContext      *ospray;
+	double           rendererSampleRate;
+
+	//
+	// RC SLIVR Specific
+	//
+	// Color computation
+	bool             lighting;
+	double           lightPosition[4];
+	float            lightDirection[3];
+	double           materialProperties[4];
+	avtOpacityMap   *transferFn1D;
+	float            gradient[3];
+	double           scalarRange[2];
+	double           tFVisibleRange[2];
+	//
+	// Background + other plots
+	float           *depthBuffer;           // depth buffer for the background and other plots
+	unsigned char   *rgbColorBuffer;        // bounding box + pseudo color + ...
+	int              bufferExtents[4];      // extents of the buffer(minX, maxX, minY, maxY)
+	//
+	// Rendering
+	// int              renderingAreaExtents[4];
+	double           renderingDepthsExtents[2];
+	//
+	// Patch details for one image
+	int              patchDrawn;            // whether the patch is drawn or not
+	int              imgWidth, imgHeight;
+	int              imgDims[2];            // size of the patch
+	int              imgLowerLeft[2];       // coordinates in the whole image
+	int              imgUpperRight[2];      //
+	float            eyesSpaceDepth;         // for blending patches
+	float            clipSpaceDepth;        // clip space depth for blending with other visit stuff
+	float           *imgArray;              // the image data
+	int              proc;                  // id of the processor
+	int              patch;                 // id of the patch
+	int              fullImgWidth, fullImgHeight;
+	int              xMin, xMax, yMin, yMax;
+	//
+	// RC SLIVR Only
+	void             ComputePixelColor(double source_rgb[4],
+					   double dest_rgb[4],
+					   float gradient[3]);
+	//
+	// added for raycasting slivr
+	void             GetSegmentRCSLIVR(int x, int y,
+					   double depthsExtents[2],
+					   double *, double *);
+	void             SampleVariableRCSLIVR(int first, int last, int intersect, int x, int y);
+	void             ExtractWorldSpaceGridRCSLIVR(vtkRectilinearGrid *, 
+						      std::vector<std::string> &varnames,
+						      std::vector<int> &varsize);
 };
 
 #endif
diff --git a/avt/Filters/avtRayTracer.C b/avt/Filters/avtRayTracer.C
index 6f034a1fb..32e2ae298 100644
--- a/avt/Filters/avtRayTracer.C
+++ b/avt/Filters/avtRayTracer.C
@@ -63,7 +63,11 @@
 #include <avtSamplePoints.h>
 #include <avtVolume.h>
 #include <avtWorldSpaceToImageSpaceTransform.h>
+#include <avtMemory.h>
+#include <avtCallback.h>
 
+#include <avtSLIVRImgMetaData.h>
+#include <avtSLIVRImgCommunicator.h>
 #ifdef PARALLEL
 #include <avtImageCommunicator.h>
 #include <avtSamplePointCommunicator.h>
@@ -79,8 +83,13 @@ inline double round(double x) {return (x-floor(x)) > 0.5 ? ceil(x) : floor(x);}
 
 using     std::vector;
 
-bool sortImgMetaDataByDepth(imgMetaData const& before, imgMetaData const& after){ return before.avg_z > after.avg_z; }
-bool sortImgMetaDataByEyeSpaceDepth(imgMetaData const& before, imgMetaData const& after){ return before.eye_z > after.eye_z; }
+bool sortImgMetaDataByDepth
+(slivr::ImgMetaData const& before, slivr::ImgMetaData const& after)
+{ return before.clip_z > after.clip_z; }
+bool sortImgMetaDataByEyeSpaceDepth
+(slivr::ImgMetaData const& before, slivr::ImgMetaData const& after)
+{ return before.eye_z > after.eye_z; }
+
 
 // ****************************************************************************
 //  Method: avtRayTracer constructor
@@ -98,6 +107,9 @@ bool sortImgMetaDataByEyeSpaceDepth(imgMetaData const& before, imgMetaData const
 //    Pascal Grosset, Fri Sep 20 2013
 //    Added ray casting slivr & trilinear interpolation
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for volume rendering using OSPRay
+//
 // ****************************************************************************
 
 avtRayTracer::avtRayTracer()
@@ -137,14 +149,21 @@ avtRayTracer::avtRayTracer()
 
     screen[0] = screen[1] = 400;
     samplesPerRay  = 40;
+    // flags
     kernelBasedSampling = false;
     trilinearInterpolation = false;
     rayCastingSLIVR = false;
     convexHullOnRCSLIVR = false;
-
+    // lighting properties
     lighting = false;
-    lightPosition[0] = lightPosition[1] = lightPosition[2] = 0.0;   lightPosition[3] = 1.0;
-    materialProperties[0] = 0.4; materialProperties[1] = 0.75; materialProperties[3] = 0.0; materialProperties[3] = 15.0;
+    lightPosition[0] = lightPosition[1] = lightPosition[2] = 0.0;
+    lightPosition[3] = 1.0;
+    materialProperties[0] = 0.4; 
+    materialProperties[1] = 0.75;
+    materialProperties[2] = 0.0;
+    materialProperties[3] = 15.0;
+    // ospray
+    ospray = NULL;
 }
 
 
@@ -313,201 +332,10 @@ avtRayTracer::GetNumberOfDivisions(int screenX, int screenY, int screenZ)
 
 
 // ****************************************************************************
-//  Function:
-//
-//  Purpose:
-//      Blend images
-//
-//  Programmer: August 14, 2016
-//  Creation:   Pascal Grosset
-//
-//  Modifications:
-//
-// ****************************************************************************
-
-void
-avtRayTracer::blendImages(float *src, int dimsSrc[2], int posSrc[2], float *dst, int dimsDst[2], int posDst[2])
-{
-    for (int _y=0; _y<dimsSrc[1]; _y++)
-        for (int _x=0; _x<dimsSrc[0]; _x++)
-        {
-            int startingX = posSrc[0];
-            int startingY = posSrc[1];
-
-            if ((startingX + _x) > (posDst[0]+dimsDst[0]))
-                continue;
-
-            if ((startingY + _y) > (posDst[1]+dimsDst[1]))
-                continue;
-
-            int subImgIndex = dimsSrc[0]*_y*4 + _x*4;                                     // index in the subimage
-            int bufferIndex = ( (startingY+_y - posDst[1])*dimsDst[0]*4  + (startingX+_x - posDst[0])*4 );    // index in the big buffer
-
-            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
-            dst[bufferIndex+0] = imgComm.clamp( (dst[bufferIndex+0] * (1.0 - src[subImgIndex+3])) + src[subImgIndex+0] );
-            dst[bufferIndex+1] = imgComm.clamp( (dst[bufferIndex+1] * (1.0 - src[subImgIndex+3])) + src[subImgIndex+1] );
-            dst[bufferIndex+2] = imgComm.clamp( (dst[bufferIndex+2] * (1.0 - src[subImgIndex+3])) + src[subImgIndex+2] );
-            dst[bufferIndex+3] = imgComm.clamp( (dst[bufferIndex+3] * (1.0 - src[subImgIndex+3])) + src[subImgIndex+3] );
-        }
-}
-
-
-
-// ****************************************************************************
-//  Method: avtRayTracer::unProject
-//
-//  Purpose:
-//      Convert from screen coordinates to world coordinates
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 14, 2016
-//
-//  Modifications:
-//
-// ****************************************************************************
-
-void
-avtRayTracer::unProject(int _x, int _y, float _z, double _worldCoordinates[3], int _width, int _height, vtkMatrix4x4 *invModelViewProj)
-{
-    // remove panning
-    _x -= round(_width * panPercentage[0]);
-    _y -= round(_height * panPercentage[1]); 
-
-    double worldCoordinates[4] = {0,0,0,1};
-    double in[4] = {0,0,0,1};
-    in[0] = (_x - _width/2. )/(_width/2.);
-    in[1] = (_y - _height/2.)/(_height/2.);
-    in[2] = _z;
-
-    invModelViewProj->MultiplyPoint(in, worldCoordinates);
-
-    if (worldCoordinates[3] == 0)
-        debug5 << "avtMassVoxelExtractor::unProject division by 0 error!" << endl;
-
-    worldCoordinates[0] = worldCoordinates[0]/worldCoordinates[3];
-    worldCoordinates[1] = worldCoordinates[1]/worldCoordinates[3];
-    worldCoordinates[2] = worldCoordinates[2]/worldCoordinates[3];
-    worldCoordinates[3] = worldCoordinates[3]/worldCoordinates[3];
-
-    _worldCoordinates[0] = worldCoordinates[0];
-    _worldCoordinates[1] = worldCoordinates[1];
-    _worldCoordinates[2] = worldCoordinates[2];
-}
-
-
-
-// ****************************************************************************
-//  Method: avtRayTracer::project
-//
-//  Purpose:
-//      Convert world coordinates to screen coordinates
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 14, 2016
-//
-//  Modifications:
-//
-// ****************************************************************************
-double
-avtRayTracer::project(double _worldCoordinates[3], int pos2D[2], int _width, int _height, vtkMatrix4x4 *modelViewProj)
-{
-    double normDevCoord[4];
-    double worldCoordinates[4] = {0,0,0,1};
-    worldCoordinates[0] = _worldCoordinates[0];
-    worldCoordinates[1] = _worldCoordinates[1];
-    worldCoordinates[2] = _worldCoordinates[2];
-
-    // World to Clip space (-1 - 1)
-    modelViewProj->MultiplyPoint(worldCoordinates, normDevCoord);
-
-    if (normDevCoord[3] == 0)
-    {
-        debug5 << "avtMassVoxelExtractor::project division by 0 error!" << endl;
-        debug5 << "worldCoordinates: " << worldCoordinates[0] << ", " << worldCoordinates[1] << ", " << worldCoordinates[2] << "   " << normDevCoord[0] << ", " << normDevCoord[1] << ", " << normDevCoord[2] << endl;
-        debug5 << "Matrix: " << *modelViewProj << endl;
-    }
-
-    normDevCoord[0] = normDevCoord[0]/normDevCoord[3];
-    normDevCoord[1] = normDevCoord[1]/normDevCoord[3];
-    normDevCoord[2] = normDevCoord[2]/normDevCoord[3];
-    normDevCoord[3] = normDevCoord[3]/normDevCoord[3];
-
-    pos2D[0] = round( normDevCoord[0]*(_width/2.)  + (_width/2.)  );
-    pos2D[1] = round( normDevCoord[1]*(_height/2.) + (_height/2.) );
-
-    pos2D[0] += round(_width * panPercentage[0]);
-    pos2D[1] += round(_height * panPercentage[1]);
-
-    return normDevCoord[2];
-}
-
-
-
-// ****************************************************************************
-//  Method: avtRayTracer::project3Dto2D
-//
-//  Purpose:
-//          Compute the extents of a volume
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 14, 2016
-//
-//  Modifications:
-//
-// ****************************************************************************
-void
-avtRayTracer::project3Dto2D(double _3Dextents[6], int width, int height, vtkMatrix4x4 *modelViewProj, int _2DExtents[4], double depthExtents[2])
-{
-    double _world[3];
-    int _xMin, _xMax, _yMin, _yMax;
-    double _zMin, _zMax;
-    _xMin = _yMin = std::numeric_limits<int>::max();
-    _xMax = _yMax = std::numeric_limits<int>::min();
-
-    _zMin = std::numeric_limits<double>::max();
-    _zMax = std::numeric_limits<double>::min();
-
-    float coordinates[8][3];
-    coordinates[0][0] = _3Dextents[0];   coordinates[0][1] = _3Dextents[2];   coordinates[0][2] = _3Dextents[4];
-    coordinates[1][0] = _3Dextents[1];   coordinates[1][1] = _3Dextents[2];   coordinates[1][2] = _3Dextents[4];
-    coordinates[2][0] = _3Dextents[1];   coordinates[2][1] = _3Dextents[3];   coordinates[2][2] = _3Dextents[4];
-    coordinates[3][0] = _3Dextents[0];   coordinates[3][1] = _3Dextents[3];   coordinates[3][2] = _3Dextents[4];
-
-    coordinates[4][0] = _3Dextents[0];   coordinates[4][1] = _3Dextents[2];   coordinates[4][2] = _3Dextents[5];
-    coordinates[5][0] = _3Dextents[1];   coordinates[5][1] = _3Dextents[2];   coordinates[5][2] = _3Dextents[5];
-    coordinates[6][0] = _3Dextents[1];   coordinates[6][1] = _3Dextents[3];   coordinates[6][2] = _3Dextents[5];
-    coordinates[7][0] = _3Dextents[0];   coordinates[7][1] = _3Dextents[3];   coordinates[7][2] = _3Dextents[5];
-
-    int pos2D[2];
-    double _z;
-    for (int i=0; i<8; i++)
-    {
-        _world[0] = coordinates[i][0];
-        _world[1] = coordinates[i][1];
-        _world[2] = coordinates[i][2];
-        _z = project(_world, pos2D, width, height, modelViewProj);
-
-        // Get min max
-        _2DExtents[0] = _xMin = std::min(_xMin, pos2D[0]);
-        _2DExtents[1] = _xMax = std::max(_xMax, pos2D[0]);
-        _2DExtents[2] = _yMin = std::min(_yMin, pos2D[1]);
-        _2DExtents[3] = _yMax = std::max(_yMax, pos2D[1]);
-
-        depthExtents[0] = _zMin = std::min(_zMin, _z);
-        depthExtents[1] = _zMax = std::max(_zMax, _z);
-    }
-
-
-    debug5 << "_2DExtents " << _2DExtents[0] << ", " << _2DExtents[1] << "   "  << _2DExtents[2] << ", "  << _2DExtents[3] << "     z: " << depthExtents[0] << ", " << depthExtents[1] << endl;
-}
-
-
-
-// ****************************************************************************
-//  Method: avtRayTracer::checkInBounds
+//  Method: avtRayTracer::CheckInBounds
 //
 //  Purpose:
-//       Checks whether a coordinate value (coord) falls into a volume (volBounds)
+//    Checks whether a coordinate value (coord) falls into a volume (volBounds)
 //
 //  Programmer:
 //  Creation:
@@ -516,7 +344,7 @@ avtRayTracer::project3Dto2D(double _3Dextents[6], int width, int height, vtkMatr
 //
 // ****************************************************************************
 bool
-avtRayTracer::checkInBounds(double volBounds[6], double coord[3])
+avtRayTracer::CheckInBounds(double volBounds[6], double coord[3])
 {
     if (coord[0] > volBounds[0] && coord[0] < volBounds[1])
         if (coord[1] > volBounds[2] && coord[1] < volBounds[3])
@@ -525,6 +353,7 @@ avtRayTracer::checkInBounds(double volBounds[6], double coord[3])
 
     return false;
 }
+
 // ****************************************************************************
 //  Method: avtRayTracer::Execute
 //
@@ -616,236 +445,351 @@ avtRayTracer::checkInBounds(double volBounds[6], double coord[3])
 //    Fix camera matrices multiplication order for ray casting SLIVR
 //    Also fixed panning for ray casting SLIVR
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for volume rendering using OSPRay
+//
 // ****************************************************************************
 
 void
 avtRayTracer::Execute(void)
 {
-    int  timingIndex = visitTimer->StartTimer();
-    bool parallelOn = (imgComm.GetNumProcs() == 1)?false:true;
-
+    //=======================================================================//
+    // Initialization and Debug
+    //=======================================================================//
+    // check memory in the beginning
+    ospout << "[avrRayTracer] entering execute" << std::endl;
+    slivr::CheckMemoryHere("[avtRayTracer] Execute", "ospout");    
+    // initialize current time
+    int timingIndex = visitTimer->StartTimer();
+
+    //=======================================================================//
+    // Start of original pipeline
+    //=======================================================================//
+    bool parallelOn = (imgComm.GetParSize() == 1) ? false : true;
     if (rayfoo == NULL)
     {
-        debug1 << "Never set ray function for ray tracer." << endl;
-        EXCEPTION0(ImproperUseException);
+	debug1 << "Never set ray function for ray tracer." << endl;
+	EXCEPTION0(ImproperUseException);
     }
 
     //
     // First we need to transform all of domains into camera space.
     //
+    ospout << "[avrRayTracer] compute camera" << std::endl;
     double aspect = 1.;
     if (screen[1] > 0)
     {
-        aspect = (double)screen[0] / (double)screen[1];
+	aspect = (double)screen[0] / (double)screen[1];
     }
-
     double scale[3] = {1,1,1};
     vtkMatrix4x4 *transform = vtkMatrix4x4::New();
-    avtWorldSpaceToImageSpaceTransform::CalculateTransform(view, transform,
-                                                           scale, aspect);
+    avtWorldSpaceToImageSpaceTransform::CalculateTransform
+	(view, transform, scale, aspect);
     double newNearPlane, newFarPlane, oldNearPlane, oldFarPlane;
     TightenClippingPlanes(view, transform, newNearPlane, newFarPlane);
     oldNearPlane = view.nearPlane;  oldFarPlane  = view.farPlane;
     view.nearPlane = newNearPlane;  view.farPlane  = newFarPlane;
     transform->Delete();
-
     avtWorldSpaceToImageSpaceTransform trans(view, aspect);
     trans.SetInput(GetInput());
 
-
     //
     // Extract all of the samples from the dataset.
     //
+    ospout << "[avrRayTracer] create extractor" << std::endl;
     avtSamplePointExtractor extractor(screen[0], screen[1], samplesPerRay);
     bool doKernel = kernelBasedSampling;
-    if (trans.GetOutput()->GetInfo().GetAttributes().GetTopologicalDimension() == 0)
-        doKernel = true;
-
+    if (trans.GetOutput()->
+	GetInfo().GetAttributes().GetTopologicalDimension() == 0) 
+    {
+	doKernel = true;
+    }
     extractor.SetKernelBasedSampling(doKernel);
     extractor.RegisterRayFunction(rayfoo);
     extractor.SetJittering(true);
-    extractor.SetInput(trans.GetOutput());
-
-
-    if (trilinearInterpolation)
-        extractor.SetTrilinear(true);
-
-
+    extractor.SetInput(trans.GetOutput());        
+    extractor.SetTrilinear(trilinearInterpolation); 
+	
     //
-    // Ray casting: SLIVR ~ Before Rendering
+    // Before Rendering
     //
     double dbounds[6];  // Extents of the volume in world coordinates
-    vtkMatrix4x4 *pvm = vtkMatrix4x4::New();
-
-    vtkImageData  *__opaqueImageVTK = NULL;
-    unsigned char *__opaqueImageData = NULL;
-    float         *__opaqueImageZB = NULL;
-
-    int fullImageExtents[4];
-
+    vtkMatrix4x4  *model_to_screen_transform = vtkMatrix4x4::New();
+    vtkMatrix4x4  *screen_to_model_transform = vtkMatrix4x4::New();
+    vtkMatrix4x4  *screen_to_camera_transform = vtkMatrix4x4::New();
+    vtkImageData  *opaqueImageVTK = NULL;
+    unsigned char *opaqueImageData = NULL;
+    float         *opaqueImageZB = NULL;
+    std::vector<float> opaqueImageDepth(screen[0] * screen[1], oldFarPlane);
+    int            fullImageExtents[4];
 
     //
     // Ray casting: SLIVR ~ Setup
     //
     if (rayCastingSLIVR)
     {
-        extractor.SetRayCastingSLIVR(true);
-
-        //
-        // Camera Settings
-        vtkCamera *sceneCam = vtkCamera::New();
-        sceneCam->SetPosition(view.camera[0],view.camera[1],view.camera[2]);
-        sceneCam->SetFocalPoint(view.focus[0],view.focus[1],view.focus[2]);
-        sceneCam->SetViewUp(view.viewUp[0],view.viewUp[1],view.viewUp[2]);
-        sceneCam->SetViewAngle(view.viewAngle);
-        sceneCam->SetClippingRange(oldNearPlane, oldFarPlane);
-        if (view.orthographic)
-            sceneCam->ParallelProjectionOn();
-        else
-            sceneCam->ParallelProjectionOff();
-        sceneCam->SetParallelScale(view.parallelScale);
-
-        debug5 << "RT View settings: " << endl;
-        debug5 << "camera: "       << view.camera[0]      << ", " << view.camera[1]     << ", " << view.camera[2] << std::endl;
-        debug5 << "focus: "     << view.focus[0]          << ", " << view.focus[1]      << ", " << view.focus[2] << std::endl;
-        debug5 << "viewUp: "    << view.viewUp[0]         << ", " << view.viewUp[1]     << ", " << view.viewUp[2] << std::endl;
-        debug5 << "viewAngle: "  << view.viewAngle  << std::endl;
-        debug5 << "eyeAngle: "  << view.eyeAngle  << std::endl;
-        debug5 << "parallelScale: "  << view.parallelScale  << std::endl;
-        debug5 << "setScale: "  << view.setScale  << std::endl;
-        debug5 << "nearPlane: " << view.nearPlane   << std::endl;
-        debug5 << "farPlane: " << view.farPlane     << std::endl;
-        debug5 << "imagePan[0]: " << view.imagePan[0]     << std::endl;     // this is a freaking fraction!!!
-        debug5 << "imagePan[1]: " << view.imagePan[1]     << std::endl;
-        debug5 << "imageZoom: " << view.imageZoom     << std::endl;
-        debug5 << "orthographic: " << view.orthographic     << std::endl;
-        debug5 << "shear[0]: " << view.shear[0]     << std::endl;
-        debug5 << "shear[1]: " << view.shear[1]     << std::endl;
-        debug5 << "shear[2]: " << view.shear[2]     << std::endl;
-        debug5 << "oldNearPlane: " << oldNearPlane  << std::endl;
-        debug5 << "oldFarPlane: " <<oldFarPlane     << std::endl;
-        debug5 << "aspect: " << aspect << std::endl << std::endl;
-
-        double _clip[2];
-        _clip[0]=oldNearPlane;  _clip[1]=oldFarPlane;
-
-        panPercentage[0] = view.imagePan[0] * view.imageZoom;
-        panPercentage[1] = view.imagePan[1] * view.imageZoom;
-
-
-        // Scaling
-        vtkMatrix4x4 *scaletrans = vtkMatrix4x4::New();
-        scaletrans->Identity();
-        scaletrans->SetElement(0, 0, scale[0]);
-        scaletrans->SetElement(1, 1, scale[1]);
-        scaletrans->SetElement(2, 2, scale[2]);
-
-        // Zoom and pan portions
-        vtkMatrix4x4 *imageZoomAndPan = vtkMatrix4x4::New();
-        imageZoomAndPan->Identity();
-        imageZoomAndPan->SetElement(0, 0, view.imageZoom);
-        imageZoomAndPan->SetElement(1, 1, view.imageZoom);
-        //imageZoomAndPan->SetElement(0, 3, 2*view.imagePan[0]*view.imageZoom);
-        //imageZoomAndPan->SetElement(1, 3, 2*view.imagePan[1]*view.imageZoom);
-
-        // View
-        vtkMatrix4x4 *tmp = vtkMatrix4x4::New();
-        vtkMatrix4x4 *vm = vtkMatrix4x4::New();
-        vtkMatrix4x4 *vmInit = sceneCam->GetModelViewTransformMatrix();
-
-        //
-        //? why we use zoom&pan * scale * vmInit here ?
-        // vmInit->Transpose();
-        // imageZoomAndPan->Transpose();
-        // vtkMatrix4x4::Multiply4x4(vmInit, scaletrans, tmp);
-        // vtkMatrix4x4::Multiply4x4(tmp, imageZoomAndPan, vm);
-        // vm->Transpose();
-        //
-        vtkMatrix4x4::Multiply4x4(vmInit, scaletrans, tmp);
-        vtkMatrix4x4::Multiply4x4(imageZoomAndPan, tmp, vm);
-
-        // Projection: http://www.codinglabs.net/article_world_view_projection_matrix.aspx
-        vtkMatrix4x4 *p = sceneCam->GetProjectionTransformMatrix(aspect,oldNearPlane, oldFarPlane);
-
-        // The Z buffer that is passed from visit is in clip scape with z limits of -1 and 1
-        // (http://www.codinglabs.net/article_world_view_projection_matrix.aspx). However, using VTK, the
-        // z limits are withing nearz and farz.
-        // (https://fossies.org/dox/VTK-7.0.0/classvtkCamera.html#a77e5d3a6e753ae4068f9a3d91267d0eb)
-        // So, the projection matrix from VTK is hijacked here and adjusted to be within -1 and 1 too
-        // Same as in avtWorldSpaceToImageSpaceTransform::CalculatePerspectiveTransform
-        if (!view.orthographic)
-        {
-            p = sceneCam->GetProjectionTransformMatrix(aspect,oldNearPlane, oldFarPlane);
-            p->SetElement(2, 2, -(oldFarPlane+oldNearPlane)   / (oldFarPlane-oldNearPlane));
-            p->SetElement(2, 3, -(2*oldFarPlane*oldNearPlane) / (oldFarPlane-oldNearPlane));
-        }
-        else
-        {
-            p = sceneCam->GetProjectionTransformMatrix(aspect,oldNearPlane, oldFarPlane);
-            p->SetElement(2, 2, -2.0 / (oldFarPlane-oldNearPlane));
-            p->SetElement(2, 3, -(oldFarPlane + oldNearPlane) / (oldFarPlane-oldNearPlane));
-        }
-
-
-        // pan
-        vtkMatrix4x4 *pantrans = vtkMatrix4x4::New();
-        pantrans->Identity();
-        pantrans->SetElement(0, 3, 2*view.imagePan[0]);
-        pantrans->SetElement(1, 3, 2*view.imagePan[1]);
-
-        vtkMatrix4x4::Multiply4x4(p,vm,pvm);
-
-        debug5 << "pvm: " << *pvm << std::endl;
-
-        //
-        // Cleanup
-        scaletrans->Delete();
-        imageZoomAndPan->Delete();
-        vmInit->Delete();
-        tmp->Delete();
-        vm->Delete();
-        p->Delete();
-
-        //
-        // Get the full image extents of the volume
-        double depthExtents[2];
-
-        GetSpatialExtents(dbounds);
-        project3Dto2D(dbounds, screen[0], screen[1], pvm,  fullImageExtents, depthExtents);
-
-        //debug5 << "Full data extents: " << dbounds[0] << ", " << dbounds[1] << "    " << dbounds[2] << ", " << dbounds[3] << "    " << dbounds[4] << ", " << dbounds[5] << std::endl;
-        //debug5 << "fullImageExtents: " << fullImageExtents[0] << ", " << fullImageExtents[1] << "     " << fullImageExtents[2] << ", " << fullImageExtents[3] << std::endl;
-
-        if (parallelOn == false)
-            extractor.SetRayCastingSLIVRParallel(true);
-
-        extractor.SetJittering(false);
-        extractor.SetLighting(lighting);
-        extractor.SetLightDirection(lightDirection);
-        extractor.SetMatProperties(materialProperties);
-        extractor.SetViewDirection(view_direction);
-        extractor.SetTransferFn(transferFn1D);
-        extractor.SetClipPlanes(_clip);
-        extractor.SetPanPercentages(panPercentage);
-        extractor.SetDepthExtents(depthExtents);
-        extractor.SetMVPMatrix(pvm);
-
-        //
-        // Capture background
-        __opaqueImageVTK = opaqueImage->GetImage().GetImageVTK();
-        __opaqueImageData = (unsigned char *)__opaqueImageVTK->GetScalarPointer(0, 0, 0);
-        __opaqueImageZB  = opaqueImage->GetImage().GetZBuffer();
-
-        //createColorPPM("/home/pascal/Desktop/background", __opaqueImageData, screen[0], screen[1]);
-        //writeOutputToFileByLine("/home/pascal/Desktop/debugImages/RCSLV_depth_1_", __opaqueImageZB, screen[0], screen[1]);
-        //writeDepthBufferToPPM("/home/pascal/Desktop/depthBuffer", __opaqueImageZB, screen[0], screen[1]);
-
-        extractor.setDepthBuffer(__opaqueImageZB, screen[0]*screen[1]);
-        extractor.setRGBBuffer(__opaqueImageData, screen[0], screen[1]);
-
-        int _bufExtents[4] = {0,0,0,0};
-        _bufExtents[1] = screen[0]; _bufExtents[3] = screen[1];
-        extractor.setBufferExtents(_bufExtents);
+	extractor.SetRayCastingSLIVR(true);
+	//
+	// Camera Settings
+	//
+	vtkCamera *sceneCam = vtkCamera::New();
+	sceneCam->SetPosition(view.camera[0],view.camera[1],view.camera[2]);
+	sceneCam->SetFocalPoint(view.focus[0],view.focus[1],view.focus[2]);
+	sceneCam->SetViewUp(view.viewUp[0],view.viewUp[1],view.viewUp[2]);
+	sceneCam->SetViewAngle(view.viewAngle);
+	sceneCam->SetClippingRange(oldNearPlane, oldFarPlane);
+	if (view.orthographic) { sceneCam->ParallelProjectionOn(); }
+	else { sceneCam->ParallelProjectionOff(); }
+	sceneCam->SetParallelScale(view.parallelScale);	
+	// Clip planes
+	double oldclip[2] = {oldNearPlane, oldFarPlane};
+	panPercentage[0] = view.imagePan[0];
+	panPercentage[1] = view.imagePan[1];
+	// Scaling
+	vtkMatrix4x4 *matScale = vtkMatrix4x4::New();
+	matScale->Identity(); 
+	if (avtCallback::UseOSPRay())
+	{ 
+	    // This is set in line 686 "ospray->SetScaling(scale)"
+	}
+	else 
+	{
+	    matScale->SetElement(0, 0, scale[0]); 
+	    matScale->SetElement(1, 1, scale[1]);
+	    matScale->SetElement(2, 2, scale[2]);
+	}
+	// Scale + Model + View Matrix
+	vtkMatrix4x4 *matViewModelScale = vtkMatrix4x4::New();
+	vtkMatrix4x4 *matViewModel = sceneCam->GetModelViewTransformMatrix();
+	vtkMatrix4x4::Multiply4x4(matViewModel, matScale, matViewModelScale);
+	// Zooming
+	vtkMatrix4x4 *matZoomViewModelScale = vtkMatrix4x4::New();
+	vtkMatrix4x4 *matZoom = vtkMatrix4x4::New();
+	matZoom->Identity(); 
+	matZoom->SetElement(0, 0, view.imageZoom); 
+	matZoom->SetElement(1, 1, view.imageZoom);
+	vtkMatrix4x4::Multiply4x4(matZoom, matViewModelScale, 
+				  matZoomViewModelScale);
+	// Projection:
+	//
+	// https://www.vtk.org/doc/release/6.1/html/classvtkCamera.html
+	// HASH: #a4d9a509bf60f1555a70ecdee758c2753
+	//
+	// The Z buffer that is passed from visit is in clip scape with z 
+	// limits of -1 and 1. However, using VTK 6.1.0, the z limits are 
+	// wired. So, the projection matrix from VTK is hijacked here and
+	// adjusted to be within -1 and 1 too
+	//
+	// Actually the correct way of using VTK GetProjectionTransformMatrix 
+	// is to set near and far plane as -1 and 1
+	//
+	vtkMatrix4x4 *matProj = 
+	    sceneCam->GetProjectionTransformMatrix(aspect, -1, 1);
+	double sceneSize[2];
+	if (!view.orthographic)
+	{
+	    sceneSize[0] = 2.0 * oldNearPlane / matProj->GetElement(0, 0);
+	    sceneSize[1] = 2.0 * oldNearPlane / matProj->GetElement(1, 1);
+	}
+	else
+	{
+	    sceneSize[0] = 2.0 / matProj->GetElement(0, 0);
+	    sceneSize[1] = 2.0 / matProj->GetElement(1, 1);
+	}
+	// Compute model_to_screen_transform matrix
+	vtkMatrix4x4::Multiply4x4(matProj,matZoomViewModelScale,
+				  model_to_screen_transform);
+	vtkMatrix4x4::Invert(model_to_screen_transform,
+			     screen_to_model_transform);
+	vtkMatrix4x4::Invert(matProj,
+			     screen_to_camera_transform);
+	// Debug
+	ospout << "[avrRayTracer] matZoom " << *matZoom << std::endl;
+	ospout << "[avrRayTracer] matViewModel " << *matViewModel << std::endl;
+	ospout << "[avrRayTracer] matScale " << *matScale << std::endl;
+	ospout << "[avrRayTracer] matProj " << *matProj << std::endl;
+	// Cleanup
+	matScale->Delete();
+	matViewModel->Delete();
+	matViewModelScale->Delete();
+	matZoom->Delete();
+	matZoomViewModelScale->Delete();
+	matProj->Delete();
+	// Get the full image extents of the volume
+	double depthExtents[2];
+	GetSpatialExtents(dbounds);
+	slivr::ProjectWorldToScreenCube(dbounds, screen[0], screen[1], 
+					panPercentage, view.imageZoom,
+					model_to_screen_transform,
+					fullImageExtents, depthExtents);
+	fullImageExtents[0] = std::max(fullImageExtents[0], 0);
+	fullImageExtents[2] = std::max(fullImageExtents[2], 0);
+	fullImageExtents[1] = std::min(1+fullImageExtents[1], screen[0]);
+	fullImageExtents[3] = std::min(1+fullImageExtents[3], screen[1]);
+	// Debug
+	ospout << "[avrRayTracer] View settings: " << endl
+	       << "  inheriant view direction: "
+	       << viewDirection[0] << " "
+	       << viewDirection[1] << " "
+	       << viewDirection[2] << std::endl
+	       << "  camera: "       
+	       << view.camera[0] << ", " 
+	       << view.camera[1] << ", " 
+	       << view.camera[2] << std::endl
+	       << "  focus: "    
+	       << view.focus[0] << ", " 
+	       << view.focus[1] << ", " 
+	       << view.focus[2] << std::endl
+	       << "  viewUp: "    
+	       << view.viewUp[0] << ", " 
+	       << view.viewUp[1] << ", " 
+	       << view.viewUp[2] << std::endl
+	       << "  viewAngle: " << view.viewAngle << std::endl
+	       << "  eyeAngle:  " << view.eyeAngle  << std::endl
+	       << "  parallelScale: " << view.parallelScale  << std::endl
+	       << "  setScale: " << view.setScale << std::endl
+	       << "  scale:    " 
+	       << scale[0] << " " 
+	       << scale[1] << " " 
+	       << scale[2] << " " 
+	       << std::endl
+	       << "  nearPlane: " << view.nearPlane << std::endl
+	       << "  farPlane:  " << view.farPlane  << std::endl
+	       << "  imagePan[0]: " << view.imagePan[0] << std::endl 
+	       << "  imagePan[1]: " << view.imagePan[1] << std::endl
+	       << "  imageZoom:   " << view.imageZoom   << std::endl
+	       << "  orthographic: " << view.orthographic << std::endl
+	       << "  shear[0]: " << view.shear[0] << std::endl
+	       << "  shear[1]: " << view.shear[1] << std::endl
+	       << "  shear[2]: " << view.shear[2] << std::endl
+	       << "  oldNearPlane: " << oldNearPlane << std::endl
+	       << "  oldFarPlane:  " << oldFarPlane  << std::endl
+	       << "  aspect: " << aspect << std::endl
+	       << "[avrRayTracer] sceneSize: " 
+	       << sceneSize[0] << " " 
+	       << sceneSize[1] << std::endl
+	       << "[avrRayTracer] screen: " 
+	       << screen[0] << " " << screen[1] << std::endl
+	       << "[avrRayTracer] data bounds: " << std::endl
+	       << "\t" << dbounds[0] << " " << dbounds[1] << std::endl
+	       << "\t" << dbounds[2] << " " << dbounds[3] << std::endl
+	       << "\t" << dbounds[4] << " " << dbounds[5] << std::endl
+	       << "[avrRayTracer] full image extents: " << std::endl
+	       << "\t" << fullImageExtents[0] << " "
+	       << "\t" << fullImageExtents[1] << std::endl
+	       << "\t" << fullImageExtents[2] << " "
+	       << "\t" << fullImageExtents[3] << std::endl;
+	ospout << "[avrRayTracer] model_to_screen_transform: " 
+	       << *model_to_screen_transform << std::endl;
+	ospout << "[avrRayTracer] screen_to_model_transform: " 
+	       << *screen_to_model_transform << std::endl;
+	ospout << "[avrRayTracer] screen_to_camera_transform: " 
+	       << *screen_to_camera_transform << std::endl;
+
+	//===================================================================//
+	// ospray stuffs
+	//===================================================================//
+	if (avtCallback::UseOSPRay()) {
+	    slivr::CheckMemoryHere("[avtRayTracer] Execute before ospray", 
+				   "ospout");
+	    // initialize ospray
+	    // -- multi-threading enabled
+	    ospray->InitOSP();
+	    // camera
+	    ospout << "[avrRayTracer] make ospray camera" << std::endl;
+	    if (!view.orthographic)
+	    {
+		ospray->camera.Init(OSPVisItCamera::PERSPECTIVE);
+	    }
+	    else 
+	    {
+		ospray->camera.Init(OSPVisItCamera::ORTHOGRAPHIC);
+	    }
+	    ospray->camera.Set(view.camera,
+			       view.focus, 
+			       view.viewUp, 
+			       viewDirection,
+			       sceneSize, 
+			       aspect, 
+			       view.viewAngle, 
+			       view.imageZoom,
+			       view.imagePan, 
+			       fullImageExtents, 
+			       screen);
+	    ospray->SetScaling(scale);
+	    // transfer function
+	    ospout  << "[avrRayTracer] make ospray transfer function" 
+		    << std::endl;
+	    ospray->transferfcn.Init();
+	    ospray->transferfcn.Set
+		((OSPVisItColor*)transferFn1D->GetTableFloat(), 
+		 transferFn1D->GetNumberOfTableEntries(),
+		 (float)transferFn1D->GetMin(),
+		 (float)transferFn1D->GetMax());
+	    // renderer
+	    ospout << "[avrRayTracer] make ospray renderer" << std::endl;
+	    ospray->renderer.Init();
+	    ospray->renderer.Set(materialProperties, viewDirection, lighting);
+	    ospray->SetDataBounds(dbounds);
+	    // check memory
+	    slivr::CheckMemoryHere("[avtRayTracer] Execute after ospray",
+				   "ospout");
+	}
+
+	// 
+	// Continuation of previous pipeline
+	//
+	extractor.SetJittering(false);
+	extractor.SetLighting(lighting);
+	extractor.SetLightDirection(lightDirection);
+	extractor.SetMatProperties(materialProperties);
+	extractor.SetViewDirection(viewDirection);
+	extractor.SetTransferFn(transferFn1D);
+	extractor.SetClipPlanes(oldclip);
+	extractor.SetPanPercentages(view.imagePan);
+	extractor.SetImageZoom(view.imageZoom);
+	extractor.SetRendererSampleRate(rendererSampleRate); 
+	extractor.SetDepthExtents(depthExtents);
+	extractor.SetMVPMatrix(model_to_screen_transform);
+	extractor.SetFullImageExtents(fullImageExtents);
+	// sending ospray
+	extractor.SetOSPRay(ospray);
+
+	//
+	// Capture background
+	//
+	opaqueImageVTK  = opaqueImage->GetImage().GetImageVTK();
+	opaqueImageData = 
+	    (unsigned char *)opaqueImageVTK->GetScalarPointer(0, 0, 0);
+	opaqueImageZB   = opaqueImage->GetImage().GetZBuffer();
+	int bufferScreenExtents[4] = {0,screen[0],0,screen[1]};
+	extractor.SetDepthBuffer(opaqueImageZB,   screen[0]*screen[1]);
+	extractor.SetRGBBuffer  (opaqueImageData, screen[0],screen[1]);
+	extractor.SetBufferExtents(bufferScreenExtents);
+	// Set the background to OSPRay
+	if (avtCallback::UseOSPRay()) 
+	{
+	    for (int y = 0; y < screen[1]; ++y) 		    
+	    {
+	    	for (int x = 0; x < screen[0]; ++x) 
+	    	{
+	    	    int index = x + y * screen[0];
+	    	    int    screenCoord[2] = {x, y};
+	    	    double screenDepth = opaqueImageZB[index] * 2 - 1;
+	    	    double worldCoord[3];
+	    	    slivr::ProjectScreenToCamera
+	    		(screenCoord, screenDepth, 
+	    		 screen[0], screen[1],
+	    		 screen_to_camera_transform, 
+	    		 worldCoord);
+		    opaqueImageDepth[index] = -worldCoord[2];
+	    	}
+	    }
+	    ospray->SetBgBuffer(opaqueImageDepth.data(), 
+	    			bufferScreenExtents);
+	}
+	// TODO We cannot delete camera here, why ?
+	//sceneCam->Delete();
     }
 
     //
@@ -856,656 +800,487 @@ avtRayTracer::Execute(void)
     //
     if (!kernelBasedSampling)
     {
-        trans.SetPassThruRectilinearGrids(true);
-        extractor.SetRectilinearGridsAreInWorldSpace(true, view, aspect);
+	trans.SetPassThruRectilinearGrids(true);
+	extractor.SetRectilinearGridsAreInWorldSpace(true, view, aspect);
     }
 
-
-    int timingVolToImg = 0;
-    if (rayCastingSLIVR == true && parallelOn)
-        timingVolToImg = visitTimer->StartTimer();
-
-    debug5 << "Raytracing setup done! " << std::endl;
+    // Qi debug
+    slivr::CheckMemoryHere("[avtRayTracer] Execute raytracing setup done",
+			   "ospout");
 
     // Execute raytracer
     avtDataObject_p samples = extractor.GetOutput();
 
-    debug5 << "Raytracing rendering done! " << std::endl;
-
     //
     // Ray casting: SLIVR ~ After Rendering
     //
     if (rayCastingSLIVR == true)
     {
-        debug5 << "Start compositing" << std::endl;
-
-        avtRayCompositer rc(rayfoo);                            // only required to force an update - Need to find a way to get rid of that!!!!
-        rc.SetInput(samples);
-        avtImage_p image  = rc.GetTypedOutput();
-        image->Update(GetGeneralContract());
-
-        //
-        // SERIAL : Single Processor
-        //
-        if (parallelOn == false)
-        {
-            debug5 << "Serial compositing!" << std::endl;
-
-            //
-            // Get the metadata for all patches
-            std::vector<imgMetaData> allImgMetaData;          // contains the metadata to composite the image
-            int numPatches = extractor.getImgPatchSize();     // get the number of patches
-
-            for (int i=0; i<numPatches; i++)
-            {
-                imgMetaData temp;
-                temp = extractor.getImgMetaPatch(i);
-                allImgMetaData.push_back(temp);
-            }
-
-            //debug5 << "Number of patches: " << numPatches << std::endl;
-
-
-            //
-            // Sort with the largest z first
-            std::sort(allImgMetaData.begin(), allImgMetaData.end(), &sortImgMetaDataByEyeSpaceDepth);
-
-
-            //
-            // Blend images
-            //
-            int renderedWidth = fullImageExtents[1] - fullImageExtents[0];
-            int renderedHeight = fullImageExtents[3] - fullImageExtents[2];
-            float *composedData = new float[renderedWidth * renderedHeight * 4]();
-
-            for (int i=0; i<numPatches; i++)
-            {
-                imgMetaData currentPatch = allImgMetaData[i];
-
-                imgData tempImgData;
-                tempImgData.imagePatch = NULL;
-                tempImgData.imagePatch = new float[currentPatch.dims[0] * currentPatch.dims[1] * 4];
-                extractor.getnDelImgData(currentPatch.patchNumber, tempImgData);
-
-                for (int _y=0; _y<currentPatch.dims[1]; _y++)
-                    for (int _x=0; _x<currentPatch.dims[0]; _x++)
-                    {
-                        int startingX = currentPatch.screen_ll[0];
-                        int startingY = currentPatch.screen_ll[1];
-
-                        if ((startingX + _x) > fullImageExtents[1])
-                            continue;
-
-                        if ((startingY + _y) > fullImageExtents[3])
-                            continue;
-
-                        int subImgIndex = (_y*currentPatch.dims[0] + _x) * 4;                                                           // index in the subimage
-                        int bufferIndex = ( (((startingY+_y)-fullImageExtents[2]) * renderedWidth)  +  ((startingX+_x)-fullImageExtents[0]) ) * 4;  // index in the big buffer
-
-                        if (composedData[bufferIndex+3] < 1.0)
-                        {
-                            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
-                            float alpha = (1.0 - tempImgData.imagePatch[subImgIndex+3]);
-                            composedData[bufferIndex+0] = imgComm.clamp( (composedData[bufferIndex+0] * alpha) + tempImgData.imagePatch[subImgIndex+0] );
-                            composedData[bufferIndex+1] = imgComm.clamp( (composedData[bufferIndex+1] * alpha) + tempImgData.imagePatch[subImgIndex+1] );
-                            composedData[bufferIndex+2] = imgComm.clamp( (composedData[bufferIndex+2] * alpha) + tempImgData.imagePatch[subImgIndex+2] );
-                            composedData[bufferIndex+3] = imgComm.clamp( (composedData[bufferIndex+3] * alpha) + tempImgData.imagePatch[subImgIndex+3] );
-                        }
-                    }
-
-                //
-                // Clean up data
-                if (tempImgData.imagePatch != NULL)
-                    delete []tempImgData.imagePatch;
-                tempImgData.imagePatch = NULL;
-            }
-            allImgMetaData.clear();
-
-
-            debug5 << "Serial compositing done!" << std::endl;
-
-            //
-            // Create image for visit to display
-            avtImage_p whole_image;
-            whole_image = new avtImage(this);
-
-            vtkImageData *img = avtImageRepresentation::NewImage(screen[0], screen[1]);
-            whole_image->GetImage() = img;
-
-            unsigned char *imgFinal = NULL;
-            imgFinal = new unsigned char[screen[0] * screen[1] * 3];
-            imgFinal = whole_image->GetImage().GetRGBBuffer();
-
-
-            //
-            // Blend in with bounding box and other visit plots
-            vtkMatrix4x4 *Inversepvm = vtkMatrix4x4::New();
-            vtkMatrix4x4::Invert(pvm,Inversepvm);
-
-            int compositedImageWidth = fullImageExtents[1] - fullImageExtents[0];
-            int compositedImageHeight = fullImageExtents[3] - fullImageExtents[2];
-
-            // Having to adjust the dataset bounds by a arbitrary magic number here. Needs to be sorted out at some point!
-            dbounds[5] = dbounds[5]-0.025;
-
-            //debug5 << "Place in image ~ screen " <<  screen[0] << ", " << screen[1] << "   compositedImageWidth: " << compositedImageWidth << "  compositedImageHeight: " << compositedImageHeight
-            //     << "  fullImageExtents: " << fullImageExtents[0] << ", " << fullImageExtents[1] << ", " << fullImageExtents[2] << ", " << fullImageExtents[3] << std::endl;
-            //writeArrayToPPM("/home/pascal/Desktop/debugImages/final_", composedData, compositedImageWidth, compositedImageHeight);
-
-
-            for (int _y=0; _y<screen[1]; _y++)
-                for (int _x=0; _x<screen[0]; _x++)
-                {
-
-                    int index = _y*screen[0] + _x;
-                    int indexComposited = (_y-fullImageExtents[2])*compositedImageWidth + (_x-fullImageExtents[0]);
-
-                    bool insideComposited = false;
-                    if (_x >= fullImageExtents[0] && _x < fullImageExtents[1])
-                         if (_y >= fullImageExtents[2] && _y < fullImageExtents[3])
-                            insideComposited = true;
-
-
-                    if ( insideComposited )
-                    {
-                        if (composedData[indexComposited*4 + 3] == 0)
-                        {
-                            // No data from rendering here!
-                            imgFinal[index*3 + 0] = __opaqueImageData[index*3 + 0];
-                            imgFinal[index*3 + 1] = __opaqueImageData[index*3 + 1];
-                            imgFinal[index*3 + 2] = __opaqueImageData[index*3 + 2];
-                        }
-                        else
-                        {
-                            if (__opaqueImageZB[index] != 1)
-                            {
-                                // Might need to do some blending
-                                double worldCoordinates[3];
-                                float _tempZ = __opaqueImageZB[index] * 2 - 1;
-                                unProject(_x, _y, _tempZ, worldCoordinates, screen[0], screen[1], Inversepvm);
-
-                                //debug5 << "x,y,z: " << _x << ", " << _y << ", " << _tempZ << "   wordld: " << worldCoordinates[0] << ", " << worldCoordinates[1] << ", " << worldCoordinates[2];
-                                if ( checkInBounds(dbounds, worldCoordinates) )
-                                {
-                                    // Completely inside bounding box
-                                    float alpha = composedData[indexComposited*4+3];
-                                    float oneMinusAlpha = (1.0 - composedData[indexComposited*4+3]);
-                                    imgFinal[index*3 + 0] = std::min( ( ((float)__opaqueImageData[index*3 + 0]/255.0) * oneMinusAlpha  +  composedData[indexComposited*4 + 0] ), 1.0) * 255;
-                                    imgFinal[index*3 + 1] = std::min( ( ((float)__opaqueImageData[index*3 + 1]/255.0) * oneMinusAlpha  +  composedData[indexComposited*4 + 1] ), 1.0) * 255;
-                                    imgFinal[index*3 + 2] = std::min( ( ((float)__opaqueImageData[index*3 + 2]/255.0) * oneMinusAlpha  +  composedData[indexComposited*4 + 2] ), 1.0) * 255;
-                                }
-                                else
-                                {
-                                    // Intersect inside with bounding box
-
-                                    double ray[3], tMin, tMax;
-                                    computeRay( view.camera, worldCoordinates, ray);
-                                    if ( intersect(dbounds, ray, view.camera, tMin, tMax) )
-                                    {
-                                        double tIntersect = std::min( (worldCoordinates[0]-view.camera[0])/ray[0],
-                                                            std::min( (worldCoordinates[1]-view.camera[1])/ray[1], (worldCoordinates[2]-view.camera[2])/ray[2] ) );
-
-                                        if (tMin <= tIntersect)
-                                        {
-                                            float alpha = composedData[indexComposited*4+3];
-                                            float oneMinusAlpha = (1.0 - composedData[indexComposited*4+3]);
-                                            imgFinal[index*3 + 0] = std::min( ( ((float)__opaqueImageData[index*3 + 0]/255.0) * oneMinusAlpha  +  composedData[indexComposited*4 + 0] ), 1.0) * 255;
-                                            imgFinal[index*3 + 1] = std::min( ( ((float)__opaqueImageData[index*3 + 1]/255.0) * oneMinusAlpha  +  composedData[indexComposited*4 + 1] ), 1.0) * 255;
-                                            imgFinal[index*3 + 2] = std::min( ( ((float)__opaqueImageData[index*3 + 2]/255.0) * oneMinusAlpha  +  composedData[indexComposited*4 + 2] ), 1.0) * 255;
-                                            // volume infront
-                                        }
-                                        else
-                                        {
-                                            // box infront
-                                            imgFinal[index*3 + 0] = __opaqueImageData[index*3 + 0];
-                                            imgFinal[index*3 + 1] = __opaqueImageData[index*3 + 1];
-                                            imgFinal[index*3 + 2] = __opaqueImageData[index*3 + 2];
-                                            //debug5 << "  intersection - box infront!" << endl;
-                                        }
-                                    }
-                                    else
-                                    {
-                                        imgFinal[index*3 + 0] = (  composedData[indexComposited*4 + 0] ) * 255;
-                                        imgFinal[index*3 + 1] = (  composedData[indexComposited*4 + 1] ) * 255;
-                                        imgFinal[index*3 + 2] = (  composedData[indexComposited*4 + 2] ) * 255;
-                                    }
-                                }
-                            }
-                            else
-                            {
-                                // Inside bounding box but only background - Good
-                                float alpha = composedData[indexComposited*4+3];
-                                float oneMinusAlpha = (1.0 - composedData[indexComposited*4+3]);
-                                imgFinal[index*3 + 0] = std::min( ( ((float)__opaqueImageData[index*3 + 0]/255.0) * oneMinusAlpha  +  composedData[indexComposited*4 + 0] ), 1.0) * 255;
-                                imgFinal[index*3 + 1] = std::min( ( ((float)__opaqueImageData[index*3 + 1]/255.0) * oneMinusAlpha  +  composedData[indexComposited*4 + 1] ), 1.0) * 255;
-                                imgFinal[index*3 + 2] = std::min( ( ((float)__opaqueImageData[index*3 + 2]/255.0) * oneMinusAlpha  +  composedData[indexComposited*4 + 2] ), 1.0) * 255;
-                            }
-                        }
-
-                    }
-                    else
-                    {
-                        // Outside bounding box: Use the background - Good
-                        imgFinal[index*3 + 0] = __opaqueImageData[index*3 + 0];
-                        imgFinal[index*3 + 1] = __opaqueImageData[index*3 + 1];
-                        imgFinal[index*3 + 2] = __opaqueImageData[index*3 + 2];
-                    }
-
-                }
-
-            img->Delete();
-            SetOutput(whole_image);
-
-            //
-            // Cleanup
-            delete []composedData;
-
-            return;
-        }
-
-        //
-        // Parallel
-        //
-
-        debug5 << "Parallel compositing" << std::endl;
-        int  timingCompositinig = visitTimer->StartTimer();
-
-        //
-        // Get the metadata for all patches
-        std::vector<imgMetaData> allImgMetaData;          // contains the metadata to composite the image
-        int numPatches = extractor.getImgPatchSize();     // get the number of patches
-
-        int imgExtents[4] = {0,0,0,0}; //minX, maxX,  minY, maxY
-        int imgSize[2];                 // x, y
-        float *composedData = NULL;
-        float *localPatchesDepth = NULL;
-
-
-        debug5 << "Number of patches: " << numPatches << std::endl;
-        for (int i=0; i<numPatches; i++)
-        {
-            imgMetaData temp;
-            temp = extractor.getImgMetaPatch(i);
-
-            imgExtents[0]=temp.screen_ll[0];   // minX
-            imgExtents[1]=temp.screen_ur[0];   // maxX
-
-            imgExtents[2]=temp.screen_ll[1];   // minY
-            imgExtents[3]=temp.screen_ur[1];   // maxY
-
-            imgSize[0] = imgExtents[1]-imgExtents[0];
-            imgSize[1] = imgExtents[3]-imgExtents[2];
-
-            debug5 << "i: " << i << " image (minX, maxX   minY , maxY): " << imgExtents[0] << ", " << imgExtents[1] << "    " << imgExtents[2] << ", " << imgExtents[3] <<
-                                "  size: " << imgSize[0] << " x " << imgSize[1] << std::endl;
-        }
-
-
-        //
-        // Compositing
-        //
-
-        // //
-        // // Serial Direct Send
-        //imgComm.serialDirectSend(1, localPatchesDepth, imgExtents, composedData, backgroundColor, screen[0], screen[1]);
-
-
-        //
-        // Parallel Direct Send
-        int tags[2] = {1081, 1681};
-        int tagGather = 2681;
-        int numMPIRanks = imgComm.GetNumProcs();
-        int *regions =  new int[numMPIRanks]();
-
-        imgComm.regionAllocation(numMPIRanks, regions);
-        debug5 << "regionAllocation done!" << std::endl;
+	// Only required to force an update 
+	// Need to find a way to get rid of that!!!!
+	avtRayCompositer rc(rayfoo);
+	rc.SetInput(samples);
+	avtImage_p image  = rc.GetTypedOutput();
+
+	// Start timing
+	int timingVolToImg = visitTimer->StartTimer(); 
+	
+	// Execute rendering
+        // This will call the execute function
+	image->Update(GetGeneralContract()); 
+
+	// Time rendering
+	visitTimer->StopTimer(timingVolToImg, "AllPatchRendering");
+
+	//
+	// Image Compositing
+	//
+	// Timing
+	int timingCompositinig = visitTimer->StartTimer();
+	int timingOnlyCompositinig = visitTimer->StartTimer();
+	int timingDetail;
+	// Initialization
+	float *compositedData = NULL;
+	int compositedW, compositedH;
+	int compositedExtents[4];
+	// Debug
+	int numPatches = extractor.GetImgPatchSize();
+	ospout << "[avtRayTracer] Total num of patches " 
+	       << numPatches << std::endl;
+	for (int i=0; i<numPatches; i++)
+	{
+	    slivr::ImgMetaData currImgMeta = extractor.GetImgMetaPatch(i);
+	    ospout << "[avtRayTracer] Rank " << PAR_Rank() << " "
+		   << "Idx " << i << " (" << currImgMeta.patchNumber << ") " 
+		   << " depth " << currImgMeta.eye_z << std::endl
+		   << "current patch size = " 
+		   << currImgMeta.dims[0] << ", " 
+		   << currImgMeta.dims[1] << std::endl
+		   << "current patch starting" 
+		   << " X = " << currImgMeta.screen_ll[0] 
+		   << " Y = " << currImgMeta.screen_ll[1] << std::endl
+		   << "current patch ending" 
+		   << " X = " << currImgMeta.screen_ur[0] 
+		   << " Y = " << currImgMeta.screen_ur[1] << std::endl;
+	}
+	//-------------------------------------------------------------------//
+	// IceT: If each rank has only one patch, we use IceT to composite
+	//-------------------------------------------------------------------//
+	if (imgComm.IceTValid() && extractor.GetImgPatchSize() == 1) 	
+	{
+	    //---------------------------------------------------------------//
+	    // Setup Local Tile
+	    slivr::ImgMetaData currMeta = extractor.GetImgMetaPatch(0);
+	    slivr::ImgData     currData;
+	    currData.imagePatch = NULL;
+	    extractor.GetAndDelImgData /* do shallow copy inside */
+		(currMeta.patchNumber, currData);
+	    //---------------------------------------------------------------//
+	    //---------------------------------------------------------------//
+	    // First Composition
+	    if (PAR_Size() > 1)
+	    { 
+		compositedW = fullImageExtents[1] - fullImageExtents[0];
+		compositedH = fullImageExtents[3] - fullImageExtents[2];
+		compositedExtents[0] = fullImageExtents[0];
+		compositedExtents[1] = fullImageExtents[1];
+		compositedExtents[2] = fullImageExtents[2];
+		compositedExtents[3] = fullImageExtents[3];
+		if (PAR_Rank() == 0) {
+		    compositedData = 
+			new float[4 * compositedW * compositedH]();
+		}
+		int currExtents[4] = 
+		    {std::max(currMeta.screen_ll[0]-fullImageExtents[0], 0), 
+		     std::min(currMeta.screen_ur[0]-fullImageExtents[0], 
+			      compositedW), 
+		     std::max(currMeta.screen_ll[1]-fullImageExtents[2], 0),
+		     std::min(currMeta.screen_ur[1]-fullImageExtents[2],
+			      compositedH)};
+		imgComm.IceTInit(compositedW, compositedH);
+		imgComm.IceTSetTile(currData.imagePatch, 
+				    currExtents,
+				    currMeta.eye_z);
+		imgComm.IceTComposite(compositedData);
+		if (currData.imagePatch != NULL) {
+		    delete[] currData.imagePatch;
+		    currData.imagePatch = NULL;
+		}
+	    } else {
+		compositedW = currMeta.dims[0];
+		compositedH = currMeta.dims[1];
+		compositedExtents[0] = fullImageExtents[0];
+		compositedExtents[1] = fullImageExtents[0] + compositedW;
+		compositedExtents[2] = fullImageExtents[2];
+		compositedExtents[3] = fullImageExtents[2] + compositedH;
+		compositedData = currData.imagePatch;
+		currData.imagePatch = NULL;
+	    }
+	    //---------------------------------------------------------------//
+	    //---------------------------------------------------------------//
+	    // Memory
+	    slivr::CheckMemoryHere("[avtRayTracer] Execute "
+				   "IceT Compositing Done", 
+				   "ospout");
+	    //---------------------------------------------------------------//
+	}
+	//-------------------------------------------------------------------//
+	// SERIAL: Image Composition
+	//-------------------------------------------------------------------//
+	else if (parallelOn == false)
+	{
+	    //---------------------------------------------------------------//
+	    // Get the Metadata for All Patches
+	    slivr::CheckSectionStart("avtRayTracer", "Execute", timingDetail,
+				     "Serial-Composite: Get the Metadata for "
+				     "All Patches");
+            // contains the metadata to composite the image
+	    std::vector<slivr::ImgMetaData> allPatchMeta;
+	    std::vector<slivr::ImgData>     allPatchData;
+	    // get the number of patches
+	    int numPatches = extractor.GetImgPatchSize();
+	    for (int i=0; i<numPatches; i++)
+	    {
+	    	allPatchMeta.push_back(extractor.GetImgMetaPatch(i));
+	    }
+	    slivr::CheckSectionStop("avtRayTracer", "Execute", timingDetail,
+				    "Serial-Composite: Get the Metadata for "
+				    "All Patches");
+	    //---------------------------------------------------------------//
+	    //---------------------------------------------------------------//
+	    // Sort with the Largest z First
+	    slivr::CheckSectionStart("avtRayTracer", "Execute", timingDetail,
+				     "Serial-Composite: Sort with the Largest "
+				     "z First");
+	    std::sort(allPatchMeta.begin(), allPatchMeta.end(), 
+	    	      &sortImgMetaDataByEyeSpaceDepth);
+	    slivr::CheckSectionStop("avtRayTracer", "Execute", timingDetail,
+				    "Serial-Composite: Sort with the Largest "
+				    "z First");
+	    //---------------------------------------------------------------//
+	    //---------------------------------------------------------------//
+	    // Blend Images
+	    slivr::CheckSectionStart("avtRayTracer", "Execute", timingDetail,
+				     "Serial-Composite: Blend Images");
+	    compositedW = fullImageExtents[1] - fullImageExtents[0];
+	    compositedH = fullImageExtents[3] - fullImageExtents[2];
+	    compositedExtents[0] = fullImageExtents[0];
+	    compositedExtents[1] = fullImageExtents[0] + compositedW;
+	    compositedExtents[2] = fullImageExtents[2];
+	    compositedExtents[3] = fullImageExtents[2] + compositedH;	    
+	    if (PAR_Rank() == 0) {
+		compositedData = new float[compositedW * compositedH * 4]();
+	    }
+	    for (int i=0; i<numPatches; i++)
+	    {
+	    	slivr::ImgMetaData currImgMeta = allPatchMeta[i];
+	    	slivr::ImgData     currImgData;
+	    	currImgData.imagePatch = NULL;
+	    	extractor.GetAndDelImgData /* do shallow copy inside */
+	    	    (currImgMeta.patchNumber, currImgData);
+		const float* currData = currImgData.imagePatch;
+		const int currExtents[4] = 
+		    {currImgMeta.screen_ll[0], currImgMeta.screen_ur[0], 
+		     currImgMeta.screen_ll[1], currImgMeta.screen_ur[1]};
+		avtSLIVRImgCommunicator::BlendBackToFront(currData,
+							  currExtents,
+							  compositedData, 
+							  compositedExtents);
+		// Clean up data
+		if (currImgData.imagePatch != NULL) {
+		    delete[] currImgData.imagePatch;
+		}
+		currImgData.imagePatch = NULL;
+	    }
+	    allPatchMeta.clear();
+	    allPatchData.clear();
+	    slivr::CheckSectionStop("avtRayTracer", "Execute", timingDetail,
+				    "Serial-Composite: Blend Images");
+	    //---------------------------------------------------------------//
+	    //---------------------------------------------------------------//
+	    // Memory
+	    slivr::CheckMemoryHere("[avtRayTracer] Execute "
+				   "Sequential Compositing Done", 
+				   "ospout");
+	    //---------------------------------------------------------------//
+	} 
+	//
+	// PARALLEL: Image Composition
+	//
+	else
+	{ 
+	    //---------------------------------------------------------------//
+	    // Parallel Direct Send
+	    slivr::CheckSectionStart("avtRayTracer", "Execute", timingDetail,
+				     "Parallel-Composite: "
+				     "Parallel Direct Send");
+	    int tags[2] = {1081, 1681};
+	    int tagGather = 2681;
+	    int *regions = NULL;
+	    imgComm.RegionAllocation(regions);
+	    int myRegionHeight =
+		imgComm.ParallelDirectSendManyPatches
+		(extractor.imgDataHashMap, extractor.imageMetaPatchVector,
+		 numPatches, regions, imgComm.GetParSize(), tags, 
+		 fullImageExtents);
+	    imgComm.gatherImages(regions, imgComm.GetParSize(), 
+				 imgComm.intermediateImage, 
+				 imgComm.intermediateImageExtents, 
+				 imgComm.intermediateImageExtents, 
+				 tagGather, fullImageExtents, myRegionHeight);
+
+	    slivr::CheckSectionStop("avtRayTracer", "Execute", timingDetail,
+				    "Parallel-Composite: "
+				    "Parallel Direct Send");
+	    //---------------------------------------------------------------//
+	    //---------------------------------------------------------------//
+	    // Some Cleanup
+	    slivr::CheckSectionStart("avtRayTracer", "Execute", timingDetail,
+				     "Parallel-Composite: Some Cleanup");
+	    if (regions != NULL)
+		delete [] regions;
+	    regions = NULL;
+	    if (imgComm.intermediateImage != NULL)
+		delete [] imgComm.intermediateImage;
+	    imgComm.intermediateImage = NULL;		
+	    imgComm.Barrier();
+	    slivr::CheckSectionStop("avtRayTracer", "Execute", timingDetail,
+				    "Parallel-Composite: Some Cleanup");
+	    //---------------------------------------------------------------//
+	    //---------------------------------------------------------------//
+	    // Setup for Final Composition
+	    compositedW = 
+		imgComm.finalImageExtents[1] -
+		imgComm.finalImageExtents[0];
+	    compositedH = 
+		imgComm.finalImageExtents[3] -
+		imgComm.finalImageExtents[2];
+	    compositedExtents[0] = imgComm.finalImageExtents[0];
+	    compositedExtents[1] = imgComm.finalImageExtents[1];
+	    compositedExtents[2] = imgComm.finalImageExtents[2];
+	    compositedExtents[3] = imgComm.finalImageExtents[3];
+	    if (PAR_Rank() == 0) {
+		compositedData = imgComm.GetFinalImageBuffer();
+	    }
+	    //---------------------------------------------------------------//
+	    //---------------------------------------------------------------//
+	    // Memory
+	    slivr::CheckMemoryHere("[avtRayTracer] Execute "
+				   "Parallel Compositing Done", 
+				   "ospout");
+	    //---------------------------------------------------------------//
+	}	
+	visitTimer->StopTimer(timingOnlyCompositinig, "Pure Compositing");
+
+	///////////////////////////////////////////////////////////////////
+	//
+	// Final Composition for Displaying
+	//
+	///////////////////////////////////////////////////////////////////
+	if (PAR_Rank() == 0) 
+	{
+	    // Blend
+	    avtImage_p finalImage = new avtImage(this);
+	    vtkImageData *finalVTKImage = 
+		avtImageRepresentation::NewImage(screen[0], screen[1]);
+	    finalImage->GetImage() = finalVTKImage;
+	    unsigned char *finalImageBuffer = 
+		finalImage->GetImage().GetRGBBuffer();
+	    slivr::CompositeBackground(screen,
+				       compositedExtents,
+				       compositedW,
+				       compositedH,
+				       compositedData,
+				       opaqueImageData,
+				       opaqueImageZB,
+				       finalImageBuffer);
+	    // Cleanup
+	    finalVTKImage->Delete();
+	    SetOutput(finalImage);
+	}
+	if (compositedData != NULL) { 
+	    delete [] compositedData;
+	}
+	compositedData = NULL; 
+	ospout << "[avtRayTracer] Raycasting SLIVR is Done !" << std::endl;
+	
+	//
+	// time compositing
+	//
+	visitTimer->StopTimer(timingCompositinig, "Compositing");
+	
+    } else {
 
-        // // 
-        // // Parallel Direct Send
-        //imgComm.parallelDirectSend(composedData, imgExtents, regions, numMPIRanks, tags, fullImageExtents);
-
-
-        debug5 << "Starting parallel compositing!" << std::endl;
-        int myRegionHeight = imgComm.parallelDirectSendManyPatches(extractor.imgDataHashMap, extractor.imageMetaPatchVector, numPatches, regions, numMPIRanks, tags, fullImageExtents);
-        imgComm.gatherImages(regions, numMPIRanks, imgComm.intermediateImage, imgComm.intermediateImageExtents, imgComm.intermediateImageExtents, tagGather, fullImageExtents, myRegionHeight);
-        debug5 << imgComm.GetMyId() << " gather done! " << std::endl;
-
-
-        //
-        // Some cleanup
-
-        if (regions != NULL)
-            delete []regions;
-        regions = NULL;
-
-        if (imgComm.intermediateImage != NULL)
-            delete []imgComm.intermediateImage;
-        imgComm.intermediateImage = NULL;
-        
-
-        imgComm.barrier();
-        debug5 << "Global compositing done!" << std::endl;
-        
-
-        //
-        // Blend with VisIt background at root!
-        //
-
-        if (PAR_Rank() == 0)
-        {
-            //
-            // Create image for visit to display
-            avtImage_p whole_image;
-            whole_image = new avtImage(this);
-
-            vtkImageData *img = avtImageRepresentation::NewImage(screen[0], screen[1]);
-            whole_image->GetImage() = img;
-
-            unsigned char *imgFinal = NULL;
-            imgFinal = new unsigned char[screen[0] * screen[1] * 3]();
-            imgFinal = whole_image->GetImage().GetRGBBuffer();
-
-
-            //
-            // Blend in with bounding box and other visit plots
-            vtkMatrix4x4 *Inversepvm = vtkMatrix4x4::New();
-            vtkMatrix4x4::Invert(pvm,Inversepvm);
-
-            int compositedImageWidth  = imgComm.finalImageExtents[1] - imgComm.finalImageExtents[0];
-            int compositedImageHeight = imgComm.finalImageExtents[3] - imgComm.finalImageExtents[2];
-
-            //debug5 << "Place in image ~ screen " <<  screen[0] << ", " << screen[1] << "   compositedImageWidth: " << compositedImageWidth << "  compositedImageHeight: " << compositedImageHeight
-            //     << "  fullImageExtents: " << fullImageExtents[0] << ", " << fullImageExtents[1] << ", " << fullImageExtents[2] << ", " << fullImageExtents[3] << std::endl;
-            //writeArrayToPPM("/home/pascal/Desktop/debugImages/final_", imgComm.imgBuffer, compositedImageWidth, compositedImageHeight);
-
-            // Having to adjust the dataset bounds by a arbitrary (magic) number here. Needs to be sorted out at some point!
-            //dbounds[5] = dbounds[5]-0.025;
-
-            debug5 << "dbounds: "   << dbounds[0] << ", " << dbounds[1] << "    " << dbounds[2] << ", " << dbounds[3] << "  " << dbounds[4] << ", "<< dbounds[5]  << std::endl;
-
-            dbounds[0] = dbounds[0]+0.00;
-            dbounds[1] = dbounds[1]-0.00;
-
-            dbounds[2] = dbounds[2]+0.00;
-            dbounds[3] = dbounds[3]-0.00;
-
-            dbounds[4] = dbounds[4]+0.00;
-            dbounds[5] = dbounds[5]-0.00;
-
-            
-
-
-            for (int _y=0; _y<screen[1]; _y++)
-                for (int _x=0; _x<screen[0]; _x++)
-                {
-                    int index = _y*screen[0] + _x;
-                    int indexComposited = (_y-imgComm.finalImageExtents[2])*compositedImageWidth + (_x-imgComm.finalImageExtents[0]);
-
-                    bool insideComposited = false;
-                    if (_x >= imgComm.finalImageExtents[0] && _x < imgComm.finalImageExtents[1])
-                         if (_y >= imgComm.finalImageExtents[2] && _y < imgComm.finalImageExtents[3])
-                            insideComposited = true;
-
-
-                    if ( insideComposited )
-                    {
-                        if (imgComm.imgBuffer[indexComposited*4 + 3] == 0)
-                        {
-                            // No data from rendering here! - Good
-                            imgFinal[index*3 + 0] = __opaqueImageData[index*3 + 0];
-                            imgFinal[index*3 + 1] = __opaqueImageData[index*3 + 1];
-                            imgFinal[index*3 + 2] = __opaqueImageData[index*3 + 2];
-                        }
-                        else
-                        {
-                            if (__opaqueImageZB[index] != 1)
-                            {
-                                // Might need to do some blending
-                                double worldCoordinates[3];
-                                float _tempZ = __opaqueImageZB[index] * 2 - 1;
-                                unProject(_x, _y, _tempZ, worldCoordinates, screen[0], screen[1], Inversepvm);
-
-                                //debug5 << "x,y,z: " << _x << ", " << _y << ", " << _tempZ << "   wordld: " << worldCoordinates[0] << ", " << worldCoordinates[1] << ", " << worldCoordinates[2];
-                                if ( checkInBounds(dbounds, worldCoordinates) )
-                                {
-                                    // Completely inside bounding box
-                                    float alpha = (1.0 - imgComm.imgBuffer[indexComposited*4+3]);
-                                    imgFinal[index*3 + 0] = std::min( ( ((float)__opaqueImageData[index*3 + 0]/255.0) * alpha  +  imgComm.imgBuffer[indexComposited*4 + 0] ),1.0) * 255;
-                                    imgFinal[index*3 + 1] = std::min( ( ((float)__opaqueImageData[index*3 + 1]/255.0) * alpha  +  imgComm.imgBuffer[indexComposited*4 + 1] ),1.0) * 255;
-                                    imgFinal[index*3 + 2] = std::min( ( ((float)__opaqueImageData[index*3 + 2]/255.0) * alpha  +  imgComm.imgBuffer[indexComposited*4 + 2] ),1.0) * 255;
-                                }
-                                else
-                                {
-                                    // Intersect inside with bounding box
-                                    double ray[3], tMin, tMax;
-                                    computeRay( view.camera, worldCoordinates, ray);
-                                    if ( intersect(dbounds, ray, view.camera, tMin, tMax) )
-                                    {
-                                        double tIntersect = std::min( (worldCoordinates[0]-view.camera[0])/ray[0],
-                                                            std::min( (worldCoordinates[1]-view.camera[1])/ray[1], 
-                                                                      (worldCoordinates[2]-view.camera[2])/ray[2] ) );
-
-                                        if (tMin <= tIntersect)
-                                        {
-                                            float alpha = (1.0 - imgComm.imgBuffer[indexComposited*4+3]);
-                                            imgFinal[index*3 + 0] = std::min( ( ((float)__opaqueImageData[index*3 + 0]/255.0) * alpha  +  imgComm.imgBuffer[indexComposited*4 + 0] ), 1.0) * 255;
-                                            imgFinal[index*3 + 1] = std::min( ( ((float)__opaqueImageData[index*3 + 1]/255.0) * alpha  +  imgComm.imgBuffer[indexComposited*4 + 1] ), 1.0) * 255;
-                                            imgFinal[index*3 + 2] = std::min( ( ((float)__opaqueImageData[index*3 + 2]/255.0) * alpha  +  imgComm.imgBuffer[indexComposited*4 + 2] ), 1.0) * 255;
-                                            // volume infront
-                                        }
-                                        else
-                                        {
-                                            // box infront
-                                            imgFinal[index*3 + 0] = __opaqueImageData[index*3 + 0];
-                                            imgFinal[index*3 + 1] = __opaqueImageData[index*3 + 1];
-                                            imgFinal[index*3 + 2] = __opaqueImageData[index*3 + 2];
-                                            //debug5 << "  intersection - box infront!" << endl;
-                                        }
-                                    }
-                                    else
-                                    {
-                                        float alpha = (1.0 - imgComm.imgBuffer[indexComposited*4+3]);
-                                        imgFinal[index*3 + 0] = std::min( ( ((float)__opaqueImageData[index*3 + 0]/255.0) * alpha  +  imgComm.imgBuffer[indexComposited*4 + 0] ), 1.0) * 255;
-                                        imgFinal[index*3 + 1] = std::min( ( ((float)__opaqueImageData[index*3 + 1]/255.0) * alpha  +  imgComm.imgBuffer[indexComposited*4 + 1] ), 1.0) * 255;
-                                        imgFinal[index*3 + 2] = std::min( ( ((float)__opaqueImageData[index*3 + 2]/255.0) * alpha  +  imgComm.imgBuffer[indexComposited*4 + 2] ), 1.0) * 255;
-                                    }
-                                }
-                            }
-                            else
-                            {
-                                //__opaqueImageZB[index] == 1 - Only data, no background : Good
-                                float alpha = (1.0 - imgComm.imgBuffer[indexComposited*4+3]);
-                                imgFinal[index*3 + 0] = std::min( ( ((float)__opaqueImageData[index*3 + 0]/255.0) * alpha  +  imgComm.imgBuffer[indexComposited*4 + 0] ), 1.0) * 255;
-                                imgFinal[index*3 + 1] = std::min( ( ((float)__opaqueImageData[index*3 + 1]/255.0) * alpha  +  imgComm.imgBuffer[indexComposited*4 + 1] ), 1.0) * 255;
-                                imgFinal[index*3 + 2] = std::min( ( ((float)__opaqueImageData[index*3 + 2]/255.0) * alpha  +  imgComm.imgBuffer[indexComposited*4 + 2] ), 1.0) * 255;
-                            }
-                        }
-
-                    }
-                    else
-                    {
-                        // Outside bounding box: Use the background : Good
-                        imgFinal[index*3 + 0] = __opaqueImageData[index*3 + 0];
-                        imgFinal[index*3 + 1] = __opaqueImageData[index*3 + 1];
-                        imgFinal[index*3 + 2] = __opaqueImageData[index*3 + 2];
-                    }
-
-                }
-
-            img->Delete();
-            SetOutput(whole_image);
-        }
-
-        debug5 << "RC SLIVR: Done!" << std::endl;
-
-
-        //
-        // Cleanup
-        if (composedData != NULL)
-            delete []composedData;
-
-        if (localPatchesDepth != NULL)
-            delete []localPatchesDepth;
-
-        pvm->Delete();
-
-
-        visitTimer->StopTimer(timingCompositinig, "Compositing");
-        visitTimer->DumpTimings();
-
-        visitTimer->StopTimer(timingIndex, "Ray Tracing");
-        visitTimer->DumpTimings();
-
-        return;
-    }
-
-
-  #ifdef PARALLEL
-    //
-    // Tell the sample point extractor that we would like to send cells
-    // instead of sample points when appropriate.
-    //
-    extractor.SendCellsMode(true);
+#ifdef PARALLEL
+	//
+	// Tell the sample point extractor that we would like to send cells
+	// instead of sample points when appropriate.
+	//
+	extractor.SendCellsMode(true);
+
+	//
+	// Communicate the samples to the other processors.
+	//
+	avtSamplePointCommunicator sampleCommunicator;
+	sampleCommunicator.SetInput(extractor.GetOutput());
+	sampleCommunicator.SetJittering(true);
+
+	samples = sampleCommunicator.GetOutput();
+#endif
 
-    //
-    // Communicate the samples to the other processors.
-    //
-    avtSamplePointCommunicator sampleCommunicator;
-    sampleCommunicator.SetInput(extractor.GetOutput());
-    sampleCommunicator.SetJittering(true);
+	//
+	// Perform compositing on the rays to get the final image.
+	//
+	avtRayCompositer rc(rayfoo);
+	rc.SetBackgroundColor(background);
+	rc.SetBackgroundMode(backgroundMode);
+	rc.SetGradientBackgroundColors(gradBG1, gradBG2);
+
+
+	if (*opaqueImage != NULL)
+	{
+	    rc.InsertOpaqueImage(opaqueImage);
+	    bool convertToWBuffer = !view.orthographic;
+	    if (convertToWBuffer)
+	    {
+		const int numpixels = screen[0]*screen[1];
+		float *opaqueImageZB  = opaqueImage->GetImage().GetZBuffer();
+		vtkImageData  *opaqueImageVTK = 
+		    opaqueImage->GetImage().GetImageVTK();
+		unsigned char *opaqueImageData = 
+		    (unsigned char*)opaqueImageVTK->GetScalarPointer(0, 0, 0);
+
+		for (int p = 0 ; p < numpixels ; p++)
+		{
+		    // The z value in clip space in the depth buifer is
+		    // between 0 and 1 while it is normal for that
+		    // value to be between -1 and 1 instead. 
+		    // This is corrected here.
+		    double val = 2*opaqueImageZB[p]-1.0;
+
+		    // Map to actual distance from camera.
+		    val = (-2*oldFarPlane*oldNearPlane)
+			/ ( (val*(oldFarPlane-oldNearPlane)) -
+			    (oldFarPlane+oldNearPlane) );
+
+		    // Now normalize based on near and far.
+		    val = (val - newNearPlane) / (newFarPlane-newNearPlane);
+		    opaqueImageZB[p] = val;
+		}
+	    }
+	    else 
+	    {
+                // orthographic and need to adjust for tightened clipping
+		// planes
+		float *opaqueImageZB  = opaqueImage->GetImage().GetZBuffer();
+		const int numpixels = screen[0]*screen[1];
+		for (int p = 0 ; p < numpixels ; p++)
+		{
+		    double val = oldNearPlane +
+			(oldFarPlane-oldNearPlane)*opaqueImageZB[p];
+		    opaqueImageZB[p] = (val-newNearPlane)
+			/ (newFarPlane-newNearPlane);
+		}
+	    }
+	}
+	rc.SetInput(samples);
+	avtImage_p image = rc.GetTypedOutput();
 
-    samples = sampleCommunicator.GetOutput();
-  #endif
+#ifdef PARALLEL
+	//
+	// Communicate the screen to the root processor.
+	//
+	avtImageCommunicator imageCommunicator;
+	avtDataObject_p dob;
+	CopyTo(dob, image);
+	imageCommunicator.SetInput(dob);
+	image = imageCommunicator.GetTypedOutput();
+#endif
 
-    //
-    // Perform compositing on the rays to get the final image.
-    //
-    avtRayCompositer rc(rayfoo);
-    rc.SetBackgroundColor(background);
-    rc.SetBackgroundMode(backgroundMode);
-    rc.SetGradientBackgroundColors(gradBG1, gradBG2);
+	//
+	// Update the pipeline several times, once for each tile.
+	// The tiles are important to make sure that we never need too much
+	// memory.
+	//
+	int numDivisions = 
+	    GetNumberOfDivisions(screen[0],screen[1],samplesPerRay);
+
+	int IStep = screen[0] / numDivisions;
+	int JStep = screen[1] / numDivisions;
+	avtImage_p whole_image;
+	if (PAR_Rank() == 0)
+	{
+	    whole_image = new avtImage(this);
+	    vtkImageData *img = avtImageRepresentation::NewImage(screen[0],
+								 screen[1]);
+	    whole_image->GetImage() = img;
+	    img->Delete();
+	}
+	for (int i = 0 ; i < numDivisions ; i++)
+	    for (int j = 0 ; j < numDivisions ; j++)
+	    {
+		int IStart = i*IStep;
+		int IEnd = (i == (numDivisions-1) ? screen[0] : (i+1)*IStep);
+		int JStart = j*JStep;
+		int JEnd = (j == (numDivisions-1) ? screen[1] : (j+1)*JStep);
 
+#ifdef PARALLEL
+		//
+		// Create an image partition that will be passed around between
+		// parallel modules in an effort to minimize communication.
+		//
+		avtImagePartition imagePartition(screen[0], screen[1]);
+		imagePartition.RestrictToTile(IStart, IEnd, JStart, JEnd);
+		sampleCommunicator.SetImagePartition(&imagePartition);
+		imageCommunicator.SetImagePartition(&imagePartition);
+#endif
+		extractor.RestrictToTile(IStart, IEnd, JStart, JEnd);
+		image->Update(GetGeneralContract());
+		if (PAR_Rank() == 0)
+		{
+		    unsigned char *whole_rgb =
+			whole_image->GetImage().GetRGBBuffer();
+		    unsigned char *tile = image->GetImage().GetRGBBuffer();
+
+		    for (int jj = JStart ; jj < JEnd ; jj++)
+			for (int ii = IStart ; ii < IEnd ; ii++)
+			{
+			    int index = screen[0]*jj + ii;
+			    int index2 = 
+				(IEnd-IStart)*(jj-JStart) + (ii-IStart);
+			    whole_rgb[3*index+0] = tile[3*index2+0];
+			    whole_rgb[3*index+1] = tile[3*index2+1];
+			    whole_rgb[3*index+2] = tile[3*index2+2];
+			}
+		}
+	    }
+	if (PAR_Rank() == 0)
+	    image->Copy(*whole_image);
+
+	//
+	// Make our output image look the same as the ray compositer's.
+	//
+	SetOutput(image);
 
-    if (*opaqueImage != NULL)
-    {
-        rc.InsertOpaqueImage(opaqueImage);
-        bool convertToWBuffer = !view.orthographic;
-        if (convertToWBuffer)
-        {
-            float *opaqueImageZB  = opaqueImage->GetImage().GetZBuffer();
-            const int numpixels = screen[0]*screen[1];
-
-            vtkImageData  *_opaqueImageVTK = opaqueImage->GetImage().GetImageVTK();
-            unsigned char *_opaqueImageData = (unsigned char *)_opaqueImageVTK->GetScalarPointer(0, 0, 0);
-
-            for (int p = 0 ; p < numpixels ; p++)
-            {
-                // The z value in clip space in the depth buifer is between 0 and 1 while it is normal for that
-                // value to be between -1 and 1 instead. This is corrected here.
-                double val = 2*opaqueImageZB[p]-1.0;
-
-                // Map to actual distance from camera.
-                val = (-2*oldFarPlane*oldNearPlane)
-                         / ( (val*(oldFarPlane-oldNearPlane)) -
-                             (oldFarPlane+oldNearPlane) );
-
-                // Now normalize based on near and far.
-                val = (val - newNearPlane) / (newFarPlane-newNearPlane);
-                opaqueImageZB[p] = val;
-            }
-        }
-        else // orthographic and need to adjust for tightened clipping planes
-        {
-            float *opaqueImageZB  = opaqueImage->GetImage().GetZBuffer();
-            const int numpixels = screen[0]*screen[1];
-            for (int p = 0 ; p < numpixels ; p++)
-            {
-                double val = oldNearPlane +
-                             (oldFarPlane-oldNearPlane)*opaqueImageZB[p];
-                opaqueImageZB[p] = (val-newNearPlane)
-                                 / (newFarPlane-newNearPlane);
-            }
-        }
     }
-    rc.SetInput(samples);
-    avtImage_p image = rc.GetTypedOutput();
 
-  #ifdef PARALLEL
     //
-    // Communicate the screen to the root processor.
+    // Clean up
     //
-    avtImageCommunicator imageCommunicator;
-    avtDataObject_p dob;
-    CopyTo(dob, image);
-    imageCommunicator.SetInput(dob);
-    image = imageCommunicator.GetTypedOutput();
-  #endif
-
+    screen_to_model_transform->Delete();
+    model_to_screen_transform->Delete();
+    screen_to_camera_transform->Delete();
+    
     //
-    // Update the pipeline several times, once for each tile.
-    // The tiles are important to make sure that we never need too much
-    // memory.
+    // Stop timer 
     //
-    int numDivisions = GetNumberOfDivisions(screen[0],screen[1],samplesPerRay);
-
-    int IStep = screen[0] / numDivisions;
-    int JStep = screen[1] / numDivisions;
-    avtImage_p whole_image;
-    if (PAR_Rank() == 0)
-    {
-        whole_image = new avtImage(this);
-        vtkImageData *img = avtImageRepresentation::NewImage(screen[0],
-                                                             screen[1]);
-        whole_image->GetImage() = img;
-        img->Delete();
-    }
-    for (int i = 0 ; i < numDivisions ; i++)
-        for (int j = 0 ; j < numDivisions ; j++)
-        {
-            int IStart = i*IStep;
-            int IEnd = (i == (numDivisions-1) ? screen[0] : (i+1)*IStep);
-            int JStart = j*JStep;
-            int JEnd = (j == (numDivisions-1) ? screen[1] : (j+1)*JStep);
-
-  #ifdef PARALLEL
-            //
-            // Create an image partition that will be passed around between
-            // parallel modules in an effort to minimize communication.
-            //
-            avtImagePartition imagePartition(screen[0], screen[1]);
-            imagePartition.RestrictToTile(IStart, IEnd, JStart, JEnd);
-            sampleCommunicator.SetImagePartition(&imagePartition);
-            imageCommunicator.SetImagePartition(&imagePartition);
-  #endif
-            extractor.RestrictToTile(IStart, IEnd, JStart, JEnd);
-            image->Update(GetGeneralContract());
-            if (PAR_Rank() == 0)
-            {
-                unsigned char *whole_rgb =
-                                        whole_image->GetImage().GetRGBBuffer();
-                unsigned char *tile = image->GetImage().GetRGBBuffer();
-
-                for (int jj = JStart ; jj < JEnd ; jj++)
-                    for (int ii = IStart ; ii < IEnd ; ii++)
-                    {
-                        int index = screen[0]*jj + ii;
-                        int index2 = (IEnd-IStart)*(jj-JStart) + (ii-IStart);
-                        whole_rgb[3*index+0] = tile[3*index2+0];
-                        whole_rgb[3*index+1] = tile[3*index2+1];
-                        whole_rgb[3*index+2] = tile[3*index2+2];
-                    }
-            }
-        }
-    if (PAR_Rank() == 0)
-        image->Copy(*whole_image);
+    visitTimer->StopTimer(timingIndex, "Ray Tracing");
 
     //
-    // Make our output image look the same as the ray compositer's.
+    // Write timing to file
+    // Postpone this
     //
-    SetOutput(image);
-
-    visitTimer->StopTimer(timingIndex, "Ray Tracing");
-    visitTimer->DumpTimings();
+    // visitTimer->DumpTimings();
 }
 
 
@@ -1526,8 +1301,8 @@ avtRayTracer::Execute(void)
 void
 avtRayTracer::SetView(const avtViewInfo &v)
 {
-    view = v;
-    modified = true;
+	view = v;
+	modified = true;
 }
 
 
@@ -1847,15 +1622,15 @@ avtRayTracer::TightenClippingPlanes(const avtViewInfo &view,
 //
 // ****************************************************************************
 void
-avtRayTracer::computeRay(double camera[3], double position[3], double ray[3])
+avtRayTracer::ComputeRay(double camera[3], double position[3], double ray[3])
 {
-    for (int i=0; i<3; i++)
-        ray[i] = position[i] - camera[i];
+	for (int i=0; i<3; i++)
+		ray[i] = position[i] - camera[i];
 
-    double mag = sqrt( ray[0]*ray[0] + ray[1]*ray[1] + ray[2]*ray[2] );
+	double mag = sqrt( ray[0]*ray[0] + ray[1]*ray[1] + ray[2]*ray[2] );
 
-    for (int i=0; i<3; i++)
-        ray[i] = ray[i]/mag;
+	for (int i=0; i<3; i++)
+		ray[i] = ray[i]/mag;
 }
 
 
@@ -1871,51 +1646,52 @@ avtRayTracer::computeRay(double camera[3], double position[3], double ray[3])
 //
 // ****************************************************************************
 bool
-avtRayTracer::intersect(double bounds[6], double ray[3], double cameraPos[3], double &tMin, double &tMax)
+avtRayTracer::Intersect(double bounds[6], double ray[3], double cameraPos[3],
+			double &tMin, double &tMax)
 {
-    double t1, t2, tXMin, tXMax, tYMin, tYMax, tZMin, tZMax;
-    double invRay[3];
+	double t1, t2, tXMin, tXMax, tYMin, tYMax, tZMin, tZMax;
+	double invRay[3];
 
-    for (int i=0; i<3; i++)
-        invRay[i] = 1.0 / ray[i];
+	for (int i=0; i<3; i++)
+		invRay[i] = 1.0 / ray[i];
 
-    // X
-    t1 = (bounds[0] - cameraPos[0]) * invRay[0];
-    t2 = (bounds[1] - cameraPos[0]) * invRay[0];
+	// X
+	t1 = (bounds[0] - cameraPos[0]) * invRay[0];
+	t2 = (bounds[1] - cameraPos[0]) * invRay[0];
 
-    tXMin = std::min(t1, t2);
-    tXMax = std::max(t1, t2);
+	tXMin = std::min(t1, t2);
+	tXMax = std::max(t1, t2);
 
 
-    // Y
-    t1 = (bounds[2] - cameraPos[1]) * invRay[1];
-    t2 = (bounds[3] - cameraPos[1]) * invRay[1];
+	// Y
+	t1 = (bounds[2] - cameraPos[1]) * invRay[1];
+	t2 = (bounds[3] - cameraPos[1]) * invRay[1];
 
-    tYMin = std::min(t1, t2);
-    tYMax = std::max(t1, t2);
+	tYMin = std::min(t1, t2);
+	tYMax = std::max(t1, t2);
 
 
-    // Z
-    t1 = (bounds[4] - cameraPos[2]) * invRay[2];
-    t2 = (bounds[5] - cameraPos[2]) * invRay[2];
+	// Z
+	t1 = (bounds[4] - cameraPos[2]) * invRay[2];
+	t2 = (bounds[5] - cameraPos[2]) * invRay[2];
 
-    tZMin = std::min(t1, t2);
-    tZMax = std::max(t1, t2);
+	tZMin = std::min(t1, t2);
+	tZMax = std::max(t1, t2);
 
 
-    // Comparing
-    if ((tXMin > tYMax) || (tYMin > tXMax))
-        return false;
+	// Comparing
+	if ((tXMin > tYMax) || (tYMin > tXMax))
+		return false;
 
-    tMin = t1 = std::max(tXMin, tYMin);
-    tMax = t2 = std::min(tXMax, tYMax);
+	tMin = t1 = std::max(tXMin, tYMin);
+	tMax = t2 = std::min(tXMax, tYMax);
 
 
-    if ((t1 > tZMax) || (tZMin > t2))
-        return false;
+	if ((t1 > tZMax) || (tZMin > t2))
+		return false;
 
-    tMin = std::max(t1, tZMin);
-    tMax = std::min(t2, tYMax);
+	tMin = std::max(t1, tZMin);
+	tMax = std::min(t2, tYMax);
 
-    return true;
+	return true;
 }
diff --git a/avt/Filters/avtRayTracer.h b/avt/Filters/avtRayTracer.h
index 1566ddfdf..0745a2a57 100644
--- a/avt/Filters/avtRayTracer.h
+++ b/avt/Filters/avtRayTracer.h
@@ -48,13 +48,15 @@
 #include <avtDatasetToImageFilter.h>
 #include <avtViewInfo.h>
 #include <avtOpacityMap.h>
+#include <avtSLIVROSPRayFilter.h>
+#include <avtSLIVRImgCommunicator.h>
 
-#include <avtImgCommunicator.h>
+#include <vtkCamera.h>
 
 #include <map>
 #include <limits>
+#include <vector>
 
-#include <vtkCamera.h>
 class   avtRayFunction;
 class   vtkMatrix4x4;
 
@@ -128,27 +130,37 @@ class AVTFILTERS_API avtRayTracer : public avtDatasetToImageFilter
                                                       const double [3]);
     int                   GetSamplesPerRay(void)  { return samplesPerRay; };
     const int            *GetScreen(void)         { return screen; };
+    void                  SetKernelBasedSampling(bool v)
+    { kernelBasedSampling = v; };
+    void                  SetLighting(bool l) { lighting = l; };
+    void                  SetLightPosition(double _lightPos[4])
+    { for (int i=0;i<4;i++) lightPosition[i] = _lightPos[i]; }
+    void                  SetLightDirection(double _lightDir[3]) 
+    { for (int i=0;i<3;i++) lightDirection[i] = _lightDir[i]; }
+    void                  SetMatProperties(double _matProp[4]) 
+    { for (int i=0;i<4;i++) materialProperties[i] = _matProp[i]; }
+    void                  SetTransferFn(avtOpacityMap *_transferFn1D) 
+    { transferFn1D = _transferFn1D; };
+    void                  SetViewDirection(double *vd)
+    { for (int i=0; i<3; i++) viewDirection[i] = vd[i]; }
+    void                  SetTrilinear(bool t) { trilinearInterpolation = t; };
+    void                  SetRayCastingSLIVR(bool _rayCastingSLIVR)
+    { rayCastingSLIVR = _rayCastingSLIVR; };
+    void                  SetRendererSampleRate(double r)
+    { rendererSampleRate = r; }
+
+    void                  SetOSPRay(OSPVisItContext *ptr) { ospray = ptr; }
+protected:
+    
+    // ospray integration
+    OSPVisItContext *ospray;
 
-    void                  blendImages(float *src, int dimsSrc[2], int posSrc[2], float *dst, int dimsDst[2], int posDst[2]);
-    void                  SetKernelBasedSampling(bool v) { kernelBasedSampling = v; };
-
-
-    void                  SetLighting(bool l) {lighting = l; };
-    void                  SetLightPosition(double _lightPos[4]) { for (int i=0;i<4;i++) lightPosition[i]=_lightPos[i]; }
-    void                  SetLightDirection(double _lightDir[3]) { for (int i=0;i<3;i++) lightDirection[i]=_lightDir[i]; }
-    void                  SetMatProperties(double _matProp[4]) { for (int i=0;i<4;i++) materialProperties[i]=_matProp[i]; }
-    void                  SetTransferFn(avtOpacityMap *_transferFn1D) {transferFn1D = _transferFn1D; };
-
-    void                  SetViewDirection(double *vd){ for (int i=0; i<3; i++) view_direction[i] = vd[i]; }
-    void                  SetTrilinear(bool t) {trilinearInterpolation = t; };
-    void                  SetRayCastingSLIVR(bool _rayCastingSLIVR){ rayCastingSLIVR = _rayCastingSLIVR; };
-
-  protected:
-    avtImgCommunicator    imgComm;
-    avtViewInfo           view;
+    avtSLIVRImgCommunicator imgComm;
+    avtViewInfo             view;
 
     int                   screen[2];
     int                   samplesPerRay;
+    double                rendererSampleRate;
     bool                  kernelBasedSampling;
     bool                  trilinearInterpolation;
     int                   backgroundMode;
@@ -162,10 +174,9 @@ class AVTFILTERS_API avtRayTracer : public avtDatasetToImageFilter
     
     double                lightDirection[3];
     double                materialProperties[4];
-    avtOpacityMap         *transferFn1D;
-    double                view_direction[3];
+    double                viewDirection[3];
     double                panPercentage[2];
-
+    avtOpacityMap        *transferFn1D;
 
     bool                  rayCastingSLIVR;
     bool                  convexHullOnRCSLIVR;
@@ -178,13 +189,14 @@ class AVTFILTERS_API avtRayTracer : public avtDatasetToImageFilter
     void                  TightenClippingPlanes(const avtViewInfo &view,
                                                 vtkMatrix4x4 *,
                                                 double &, double &);
-    void project3Dto2D(double _3Dextents[6], int width, int height, vtkMatrix4x4 *_mvp, int _2DExtents[4], double depthExtents[2]);
-    double project(double _worldCoordinates[3], int pos2D[2], int _width, int _height, vtkMatrix4x4 *_mvp);
-    void unProject(int _x, int _y, float _z, double _worldCoordinates[3], int _width, int _height, vtkMatrix4x4 *invModelViewProj);
-    bool checkInBounds(double volBounds[6], double coord[3]);
 
-    void computeRay(double camera[3], double position[3], double ray[3]);
-    bool intersect(double bounds[6], double ray[3], double cameraPos[3], double &tMin, double &tMax);
+    void                  ComputeRay(double camera[3], 
+				     double position[3], double ray[3]);
+    bool                  CheckInBounds(double volBounds[6], double coord[3]);
+    bool                  Intersect(double bounds[6], double ray[3], 
+				    double cameraPos[3], 
+				    double &tMin, double &tMax);
+
 };
 
 
diff --git a/avt/Filters/avtSLIVRImgCommunicator.C b/avt/Filters/avtSLIVRImgCommunicator.C
new file mode 100644
index 000000000..13050f0f3
--- /dev/null
+++ b/avt/Filters/avtSLIVRImgCommunicator.C
@@ -0,0 +1,1956 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// ************************************************************************ //
+//                        avtSLIVRImgCommunicator.C                         //
+// ************************************************************************ //
+
+#include <avtSLIVRImgCommunicator.h>
+#include <avtSLIVROSPRayFilter.h>
+#include <avtParallel.h>
+#include <ImproperUseException.h>
+
+#ifdef PARALLEL
+#  ifdef VISIT_ICET
+#    include <GL/ice-t.h>
+#    include <GL/ice-t_mpi.h>
+#  endif
+#endif
+
+#include <cmath>
+#include <ctime>
+#include <cstdio>
+#include <cstring>
+#include <cstdlib>
+#include <limits>
+#include <fstream>
+#include <algorithm>
+#include <set>
+
+#if defined (_MSC_VER) && (_MSC_VER < 1800) && !defined(round)
+inline double round(double x) {return (x-floor(x))>0.5?ceil(x):floor(x);}
+#endif
+
+enum blendDirection {FRONT_TO_BACK = 0, BACK_TO_FRONT = 1};
+
+// ***************************************************************************
+// Threaded Blending
+// ***************************************************************************
+
+bool CheckThreadedBlend_Communicator()
+{
+    bool use = true;
+    const char* env_use = std::getenv("SLIVR_NOT_USE_THREADED_BLEND");
+    if (env_use) { 
+	use = atoi(env_use) <= 0; 
+    }
+    if (!use) {
+	ospout << "[avtSLIVRImgCommunicator] "
+	       << "Not Using Multi-Threading for Blending"
+	       << std::endl;
+    } else {
+	ospout << "[avtSLIVRImgCommunicator] "
+	       << "Using Multi-Threading for Blending"
+	       << std::endl;
+    }
+    return use;
+}
+#ifdef VISIT_OSPRAY
+bool UseThreadedBlend_Communicator = CheckThreadedBlend_Communicator();
+#else
+bool UseThreadedBlend_Communicator = false;
+#endif
+
+// ***************************************************************************
+//  Class: avtSLIVRImgComm_IceT
+// ***************************************************************************
+
+class avtSLIVRImgComm_IceT : public avtSLIVRImgComm
+{
+public:
+    avtSLIVRImgComm_IceT(int mpiSize, int mpiRank);
+    ~avtSLIVRImgComm_IceT();
+    void Init(int, int);
+    void SetTile(const float*, const int*, const float&);
+    void Composite(float*&);
+    static bool Valid();
+};
+
+bool avtSLIVRImgComm_IceT::Valid() { 
+    return false;
+}
+
+avtSLIVRImgComm_IceT::avtSLIVRImgComm_IceT(int mpiSize, int mpiRank)
+    : avtSLIVRImgComm(mpiSize, mpiRank)
+{	
+}
+
+avtSLIVRImgComm_IceT::~avtSLIVRImgComm_IceT()
+{
+}
+
+void avtSLIVRImgComm_IceT::Init(int W, int H)
+{
+}
+
+void avtSLIVRImgComm_IceT::SetTile(const float* d, 
+				   const int*   e, 
+				   const float& z)
+{
+}
+
+void avtSLIVRImgComm_IceT::Composite(float*& output)
+{
+}
+
+// ***************************************************************************
+//  End Class: avtSLIVRImgComm_IceT
+// ***************************************************************************
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::avtSLIVRImgCommunicator
+//
+//  Purpose: Constructor
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+//    Qi WU, Wed Jun 20 2018
+//    Add support for volume rendering using OSPRay (RayCasting:OSPRay)
+//
+// ***************************************************************************
+
+avtSLIVRImgCommunicator::avtSLIVRImgCommunicator()
+{
+#ifdef PARALLEL
+    MPI_Comm_size(VISIT_MPI_COMM, &mpiSize);
+    MPI_Comm_rank(VISIT_MPI_COMM, &mpiRank);
+#else
+    mpiSize = 1;
+    mpiRank = 0;
+#endif
+    finalImage = NULL;
+    compositor = NULL;
+
+    /////////////////////////////////////////////////////////////
+    intermediateImageExtents[0] = intermediateImageExtents[1] = 0.0;
+    intermediateImageExtents[2] = intermediateImageExtents[3] = 0.0;
+    intermediateImageBBox[0] = intermediateImageBBox[1] = 0.0;
+    intermediateImageBBox[2] = intermediateImageBBox[3] = 0.0;
+
+    totalPatches = 0;
+    intermediateImage = NULL;
+    /////////////////////////////////////////////////////////////
+}
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::~avtSLIVRImgCommunicator
+//
+//  Purpose:
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+avtSLIVRImgCommunicator::~avtSLIVRImgCommunicator()
+{
+    //if (mpiRank == 0) { if (finalImage != NULL) { delete [] finalImage; } }
+}
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::Barrier
+//
+//  Purpose:
+//    Barrier, useful for debugging
+//
+//  Programmer: Pascal Grosset
+//  Creation: July 2013
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtSLIVRImgCommunicator::Barrier() {
+#ifdef PARALLEL
+    MPI_Barrier(MPI_COMM_WORLD);
+#endif
+}
+
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::ColorImage
+//
+//  Purpose:
+//       Fills a 4 channel image with a specific color
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void
+avtSLIVRImgCommunicator::ColorImage(float *&srcImage,
+				    const int widthSrc,
+				    const int heightSrc,
+				    const float color[4])
+{
+    for (int i = 0; i < heightSrc * widthSrc; ++i) {
+	const int srcIndex = 4 * i;
+	srcImage[srcIndex+0] = color[0];
+	srcImage[srcIndex+1] = color[1];
+	srcImage[srcIndex+2] = color[2];
+	srcImage[srcIndex+3] = color[3];
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::PlaceImage
+//
+//  Purpose:
+//      Puts srcImage into dstImage
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void
+avtSLIVRImgCommunicator::PlaceImage(const float *srcImage,
+				    const int srcExtents[4], 
+				    float *&dstImage,
+				    const int dstExtents[4])
+{
+    const int srcX = srcExtents[1] - srcExtents[0];
+    const int srcY = srcExtents[3] - srcExtents[2];
+    const int dstX = dstExtents[1] - dstExtents[0];
+    const int dstY = dstExtents[3] - dstExtents[2];
+    const int startingX = std::max(srcExtents[0], dstExtents[0]);
+    const int startingY = std::max(srcExtents[2], dstExtents[2]);
+    const int endingX = std::min(srcExtents[1], dstExtents[1]);
+    const int endingY = std::min(srcExtents[3], dstExtents[3]);
+    
+    for (int y = startingY; y < endingY; ++y) {
+	for (int x = startingX; x < endingX; ++x) {
+	    // index in the sub-image
+	    const int srcIndex = 
+		(srcX * (y-srcExtents[2]) + x-srcExtents[0]) * 4; 
+	    // index in the larger buffer
+	    const int dstIndex = 
+		(dstX * (y-dstExtents[2]) + x-dstExtents[0]) * 4;
+	    dstImage[dstIndex+0] = srcImage[srcIndex+0];
+	    dstImage[dstIndex+1] = srcImage[srcIndex+1];
+	    dstImage[dstIndex+2] = srcImage[srcIndex+2];
+	    dstImage[dstIndex+3] = srcImage[srcIndex+3];
+	}
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::BlendWithBackground
+//
+//  Purpose:
+//      Blends _image with the backgroundColor
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+//    Qi WU, Wed Jun 20 2018
+//    Add support for threaded blending using OSPRay
+//
+// **************************************************************************
+void
+avtSLIVRImgCommunicator::BlendWithBackground(float *&image,
+					     const int extents[4],
+					     const float bgColor[4])
+{
+    const int pixelSize = (extents[3]-extents[2]) * (extents[1]-extents[0]);
+    // estimated potential speedup: 2.240
+    for (int i = 0; i < pixelSize; ++i)
+    {
+        const int   idx = i * 4;
+        const float alpha = (1.0 - image[idx+3]);
+        image[idx+0] = bgColor[0] * alpha + image[idx+0];
+        image[idx+1] = bgColor[1] * alpha + image[idx+1];
+        image[idx+2] = bgColor[2] * alpha + image[idx+2];
+        image[idx+3] = bgColor[3] * alpha + image[idx+3];
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::BlendFrontToBack
+//
+//  Purpose:
+//      Blends tow patches in a front to back manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+//    Qi WU, Wed Jun 20 2018
+//    Add support for threaded blending using OSPRay
+//
+// **************************************************************************
+
+void
+avtSLIVRImgCommunicator::BlendFrontToBack(const float *srcImage,
+					  const int srcExtents[4],
+					  const int blendExtents[4], 
+					  float *&dstImage,
+					  const int dstExtents[4])
+{
+#ifdef VISIT_OSPRAY
+    if (UseThreadedBlend_Communicator) {
+	visit::BlendFrontToBack(blendExtents,
+				srcExtents,
+				srcImage,
+				dstExtents,
+				dstImage);
+    } else {
+#endif
+    // image sizes
+    const int srcX = srcExtents[1] - srcExtents[0];
+    const int srcY = srcExtents[3] - srcExtents[2];
+    const int dstX = dstExtents[1] - dstExtents[0];
+    const int dstY = dstExtents[3] - dstExtents[2];
+    // determin the region to blend
+    const int startX = 
+	std::max(std::max(blendExtents[0], srcExtents[0]), dstExtents[0]);
+    const int startY = 
+	std::max(std::max(blendExtents[2], srcExtents[2]), dstExtents[2]);
+    const int endX = 
+	std::min(std::min(blendExtents[1], srcExtents[1]), dstExtents[1]);
+    const int endY = 
+	std::min(std::min(blendExtents[3], srcExtents[3]), dstExtents[3]);
+    
+    for (int y = startY; y < endY; ++y) {
+	for (int x = startX; x < endX; ++x) {
+	    // get indices
+	    int srcIndex = (srcX * (y-srcExtents[2]) + x-srcExtents[0]) * 4;
+	    int dstIndex = (dstX * (y-dstExtents[2]) + x-dstExtents[0]) * 4;
+
+	    // front to back compositing
+	    if (dstImage[dstIndex + 3] < 1.0f) {
+		float trans = 1.0f - dstImage[dstIndex + 3];
+		dstImage[dstIndex+0] = 
+		    CLAMP(srcImage[srcIndex+0] * trans + dstImage[dstIndex+0],
+			  0.0f, 1.0f);
+		dstImage[dstIndex+1] = 
+		    CLAMP(srcImage[srcIndex+1] * trans + dstImage[dstIndex+1],
+			  0.0f, 1.0f);
+		dstImage[dstIndex+2] = 
+		    CLAMP(srcImage[srcIndex+2] * trans + dstImage[dstIndex+2],
+			  0.0f, 1.0f);
+		dstImage[dstIndex+3] = 
+		    CLAMP(srcImage[srcIndex+3] * trans + dstImage[dstIndex+3],
+			  0.0f, 1.0f);
+	    }
+	}
+    }
+#ifdef VISIT_OSPRAY
+    }
+#endif
+}
+
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::BlendBackToFront
+//
+//  Purpose:
+//      Blends tow patches in a back to front manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+//    Qi WU, Wed Jun 20 2018
+//    Add support for threaded blending using OSPRay
+//
+// **************************************************************************
+
+void
+avtSLIVRImgCommunicator::BlendBackToFront(const float *srcImage,
+					  const int srcExtents[4],
+					  const int blendExtents[4], 
+					  float *&dstImage,
+					  const int dstExtents[4])
+{
+#ifdef VISIT_OSPRAY
+    if (UseThreadedBlend_Communicator) {
+	visit::BlendBackToFront(blendExtents,
+	                        srcExtents,
+	                        srcImage,
+	                        dstExtents,
+	                        dstImage);
+    } else {
+#endif
+    // image sizes
+    const int srcX = srcExtents[1] - srcExtents[0];
+    const int srcY = srcExtents[3] - srcExtents[2];
+    const int dstX = dstExtents[1] - dstExtents[0];
+    const int dstY = dstExtents[3] - dstExtents[2];
+    // determin the region to blend
+    const int startX = 
+	std::max(std::max(blendExtents[0], srcExtents[0]), dstExtents[0]);
+    const int startY = 
+	std::max(std::max(blendExtents[2], srcExtents[2]), dstExtents[2]);
+    const int endX = 
+	std::min(std::min(blendExtents[1], srcExtents[1]), dstExtents[1]);
+    const int endY = 
+	std::min(std::min(blendExtents[3], srcExtents[3]), dstExtents[3]);
+    
+    for (int y = startY; y < endY; ++y) {
+	for (int x = startX; x < endX; ++x) {
+	    // get indices
+	    int srcIndex = (srcX * (y-srcExtents[2]) + x-srcExtents[0]) * 4;
+	    int dstIndex = (dstX * (y-dstExtents[2]) + x-dstExtents[0]) * 4;
+	    // back to front compositing	    
+	    float trans = 1.0f - srcImage[srcIndex + 3];
+	    dstImage[dstIndex+0] = 
+		CLAMP(dstImage[dstIndex+0] * trans + srcImage[srcIndex+0],
+		      0.0f, 1.0f);
+	    dstImage[dstIndex+1] = 
+		CLAMP(dstImage[dstIndex+1] * trans + srcImage[srcIndex+1],
+		      0.0f, 1.0f);
+	    dstImage[dstIndex+2] = 
+		CLAMP(dstImage[dstIndex+2] * trans + srcImage[srcIndex+2],
+		      0.0f, 1.0f);
+	    dstImage[dstIndex+3] = 
+		CLAMP(dstImage[dstIndex+3] * trans + srcImage[srcIndex+3],
+		      0.0f, 1.0f);
+	}
+    }
+#ifdef VISIT_OSPRAY
+    }
+#endif
+}
+
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::BlendFrontToBack
+//
+//  Purpose:
+//      Blends tow patches in a front to back manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+//    Qi WU, Wed Jun 20 2018
+//    Add support for threaded blending using OSPRay
+//
+// **************************************************************************
+void
+avtSLIVRImgCommunicator::BlendFrontToBack(const float * srcImage,
+					  const int srcExtents[4], 
+					  float *& dstImage,
+					  const int dstExtents[4])
+{
+    BlendFrontToBack(srcImage, srcExtents, srcExtents, dstImage, dstExtents);
+}
+
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::BlendBackToFront
+//
+//  Purpose:
+//      Blends tow patches in a back to front manner
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void
+avtSLIVRImgCommunicator::BlendBackToFront
+(const float * srcImage, const int srcExtents[4], 
+ float *& dstImage, const int dstExtents[4])
+{
+    BlendBackToFront(srcImage, srcExtents, srcExtents, dstImage, dstExtents);
+}
+
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::UpdateBoundingBox
+//
+//  Purpose:
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void
+avtSLIVRImgCommunicator::UpdateBoundingBox(int currentBoundingBox[4],
+					   const int imageExtents[4])
+{
+    if ((currentBoundingBox[0] == 0 && currentBoundingBox[1] == 0) && 
+	(currentBoundingBox[2] == 0 && currentBoundingBox[3] == 0))
+    {
+        currentBoundingBox[0]=imageExtents[0];
+        currentBoundingBox[1]=imageExtents[1];
+        currentBoundingBox[2]=imageExtents[2];
+        currentBoundingBox[3]=imageExtents[3];
+        return;
+    }
+
+    if (imageExtents[0] < currentBoundingBox[0])
+    { currentBoundingBox[0] = imageExtents[0]; }
+
+    if (imageExtents[2] < currentBoundingBox[2])
+    { currentBoundingBox[2] = imageExtents[2]; }
+
+    if (imageExtents[1] > currentBoundingBox[1])
+    { currentBoundingBox[1] = imageExtents[1]; }
+
+    if (imageExtents[3] > currentBoundingBox[3])
+    { currentBoundingBox[3] = imageExtents[3]; }
+}
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::IceT
+//
+//  Purpose:
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+//  Modifications:
+//
+// **************************************************************************
+
+bool 
+avtSLIVRImgCommunicator::IceTValid() { 
+    return avtSLIVRImgComm_IceT::Valid(); 
+}
+
+void 
+avtSLIVRImgCommunicator::IceTInit(int W, int H)
+{
+    if (!avtSLIVRImgComm_IceT::Valid()) {
+	debug1 << "ERROR: IceT compositor is not valid. "
+	       << "Probably IceT is not compiled with VisIt"
+	       << std::endl;
+	EXCEPTION1(VisItException, 
+		   "ERROR: IceT compositor is not valid. "
+		   "Probably IceT is not compiled with VisIt");
+	return;
+    }
+    compositor = new avtSLIVRImgComm_IceT(mpiSize, mpiRank);
+    compositor->Init(W, H);
+}
+
+void avtSLIVRImgCommunicator::IceTSetTile(const float* d, 
+					  const int*   e,
+	                                  const float& z)
+{
+    int timingDetail;
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStart("avtSLIVRImgCommunicator", 
+			     "IceTSetTile", timingDetail,
+			     "IceT Setup Image Tile");
+    //---------------------------------------------------------------------//
+    compositor->SetTile(d, e, z);
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStop("avtSLIVRImgCommunicator", 
+			    "IceTSetTile", timingDetail,
+			    "IceT Setup Image Tile");
+    //---------------------------------------------------------------------//
+}
+
+void avtSLIVRImgCommunicator::IceTComposite(float*& output)
+{
+    int timingDetail;
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStart("avtSLIVRImgCommunicator", 
+			     "IceTComposite", timingDetail,
+			     "IceT Image Composition");
+    //---------------------------------------------------------------------//
+    compositor->Composite(output);
+    if (compositor != NULL) { delete compositor; }
+    compositor = NULL;
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStop("avtSLIVRImgCommunicator", 
+			    "IceTComposite", timingDetail,
+			    "IceT Image Composition");
+    //---------------------------------------------------------------------//
+}
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::GatherDepthAtRoot
+//
+//  Purpose:
+//      Used by Serial Direct Send
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void
+avtSLIVRImgCommunicator::GatherDepthAtRoot(const int numlocalPatches,
+					   const float *localPatchesDepth,
+					   int &totalPatches,
+					   int *&patchCountPerRank,
+					   float *&allPatchesDepth)
+{
+#ifdef PARALLEL
+    // Get how many patches are coming from each MPI rank
+    totalPatches = 0;
+    int *patchesOffset = NULL;
+
+    if (mpiRank == 0) // root!
+    { patchCountPerRank = new int[mpiSize](); }
+
+    // reference
+    // https://www.mpich.org/static/docs/v3.1/www3/MPI_Gather.html
+    MPI_Gather(&numlocalPatches, /* send buffer */
+	       1, /* send count */
+	       MPI_INT, 
+	       patchCountPerRank, /* address of receive buffer (root) */
+	       1, /* number of elements for any single receive (root) */
+	       MPI_INT, 
+	       0, /* rank of receiving process (integer) */
+	       MPI_COMM_WORLD); /* communicator (handle) */
+
+    // gather number of patch group
+    if (mpiRank == 0)
+    {
+        patchesOffset = new int[mpiSize]();
+        patchesOffset[0] = 0; // a bit redundant
+
+        for (int i=0; i<mpiSize; i++)
+        {
+            totalPatches += patchCountPerRank[i];
+            if (i == 0)
+	    { patchesOffset[i] = 0; }
+            else
+	    {
+		patchesOffset[i] = 
+		    patchesOffset[i-1] + patchCountPerRank[i-1]; 
+	    }
+        }
+	
+	// allocate only at root
+        allPatchesDepth = new float[totalPatches];
+    }
+
+    // Gathers into specified locations from all processes in a group
+    MPI_Gatherv(localPatchesDepth, numlocalPatches, MPI_FLOAT, 
+		allPatchesDepth, /* receive all depth */
+		patchCountPerRank, patchesOffset, MPI_FLOAT, 
+		0, MPI_COMM_WORLD);
+
+    // Cleanup
+    if (mpiRank == 0 && patchesOffset != NULL)
+    { delete [] patchesOffset; }
+    patchesOffset = NULL;
+#endif
+}
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::SerialDirectSend
+//
+//  Purpose:
+//      A very simple compositing that we can fall back to if parallel direct
+//      send is buggy.
+//      Works with convex patches though
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+void
+avtSLIVRImgCommunicator::SerialDirectSend(int localNumPatches,
+					  float *localPatchesDepth, 
+					  int *extents,
+					  float *imgData,
+					  float bgColor[4],
+					  int width, int height)
+{
+#ifdef PARALLEL
+    //
+    // Message
+    //
+    debug5 << "-- Serial Direct Send --" << std::endl;
+
+    float *recvImage = NULL;
+    int tags[2] = {5781, 5782};
+    //
+    // Retrieve depth info through MPI
+    //
+    int    totalPatches; // total number of patches
+    int   *totalPatchCountsPerRank = NULL;
+    float *totalPatchDepths = NULL;
+    GatherDepthAtRoot(localNumPatches,
+		      localPatchesDepth,
+		      totalPatches, 
+		      totalPatchCountsPerRank,
+		      totalPatchDepths);
+    //
+    //
+    //
+    if (mpiRank == 0)
+    {
+        // Root
+        int srcSize[2] = {width, height};
+	int srcPos[2]  = {0, 0};
+	int dstSize[2], dstPos[2];
+
+        // Sort patches we will receive
+        std::multimap<float,int> sortedPatches;
+
+        int patchId = 0;
+        for (int i=0; i<mpiSize; i++) {
+            for (int j=0; j<totalPatchCountsPerRank[i]; j++) {
+                sortedPatches.insert
+		    (std::make_pair(totalPatchDepths[patchId++],i));
+            }
+	}
+
+        // Create space for buffers
+        int recvParams[4]; // minX, maxX, minY, maxY
+        int imgExtents[4] = {0,width,0,height};
+
+        recvImage = new float[width*height*4]();
+        finalImage = new float[width*height*4]();
+	
+        int localIndex = 0;
+
+        // Compositing
+        for (std::multimap<float,int>::iterator it = sortedPatches.begin(); 
+	     it != sortedPatches.end(); ++it)
+        {
+            int rank = (*it).second;
+            if (rank != mpiRank)
+            {
+		// recv image info
+                MPI_Recv(recvParams, 4, MPI_INT, rank, 
+			 tags[0], MPI_COMM_WORLD, MPI_STATUS_IGNORE); 
+		// recv image
+                MPI_Recv(recvImage, width*height*4, MPI_FLOAT, rank,
+			 tags[1],  MPI_COMM_WORLD, MPI_STATUS_IGNORE);
+                dstPos[0]  = dstPos[0];                     
+		dstPos[1]  = dstPos[1];
+                dstSize[0] = recvParams[2]-recvParams[0];   
+		dstSize[1] = recvParams[3]-recvParams[1];
+            }
+            else
+            {
+                // It's local
+                recvParams[0] = extents[ localIndex*4 + 0];
+                recvParams[1] = extents[ localIndex*4 + 1];
+                recvParams[2] = extents[ localIndex*4 + 2];
+                recvParams[3] = extents[ localIndex*4 + 3];
+                recvImage = &imgData[ localIndex*(width*height*4) ];
+                localIndex++;
+            }
+            BlendFrontToBack(recvImage, recvParams, finalImage, imgExtents);
+        }
+        BlendWithBackground(finalImage, imgExtents, bgColor);
+    }
+    else
+    {
+        // Sender
+        for (int i=0; i<localNumPatches; i++)
+        {
+            int imgSize = 
+		(extents[i*4 + 1] - extents[i*4 + 0]) *
+		(extents[i*4 + 3] - extents[i*4 + 2]) * 4;	    
+            if (imgSize > 0)
+            {
+                MPI_Send(&extents[i*4],
+			 4, MPI_INT, 0, tags[0], MPI_COMM_WORLD);
+                MPI_Send(&imgData[i*(width*height*4)], 
+			 imgSize, MPI_FLOAT, 0, tags[1], MPI_COMM_WORLD);
+            }
+        }
+    }
+
+    // Cleanup
+    if (totalPatchDepths != NULL)
+	delete []totalPatchDepths;
+
+    if (totalPatchCountsPerRank != NULL)
+        delete []totalPatchCountsPerRank;
+
+    if (recvImage != NULL)
+        delete []recvImage;
+
+    recvImage = NULL;
+    totalPatchCountsPerRank = NULL;
+    totalPatchDepths = NULL;
+#endif
+}
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::regionAllocation
+//
+//  Purpose:
+//      Arbitrarily allocates regions to MPI ranks
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void
+avtSLIVRImgCommunicator::RegionAllocation(int *& regions)
+{
+    regions = new int[mpiSize];
+    // Initial allocation: partition for section rank
+    for (int i=0; i<mpiSize; i++) { regions[i] = i; }
+}
+
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::parallelDirectSend
+//
+//  Purpose:
+//      Parallel Direct Send rendering that can blend convex patches from each
+//      MPI rank. However, since we are not guaranteed to have convex patches.
+//      It's not used.
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImgCommunicator::parallelDirectSend(float *imgData,
+					    int imgExtents[4],
+					    int region[],
+					    int numRegions,
+					    int tags[2],
+					    int fullImageExtents[4])
+{
+#ifdef PARALLEL
+    //
+    // Determine position in region (myPositionInRegion)
+    int width  = fullImageExtents[1]-fullImageExtents[0];
+    int height = fullImageExtents[3]-fullImageExtents[2];
+
+    //debug5 << "fullImageExtents: " << fullImageExtents[0] << ", " << fullImageExtents[1] << "   " << fullImageExtents[2] << ", " << fullImageExtents[3] << endl;
+
+    compositingDone = false;
+    int myPositionInRegion = -1;
+    bool inRegion = true;
+    std::vector<int> regionVector(region, region+numRegions);
+    std::vector<int>::iterator it = std::find(regionVector.begin(),
+					      regionVector.end(),
+					      mpiRank);
+
+    if (it == regionVector.end())
+    {
+        inRegion = false;
+        //debug5 << mpiRank << " ~ SHOULD NOT HAPPEN: Not found " << mpiRank <<  " !!!" << std::endl;
+    }
+    else
+        myPositionInRegion = it - regionVector.begin();
+
+    //
+    // Region boundaries
+    int regionHeight = height/numRegions;
+    int lastRegionHeight = height - regionHeight*(numRegions-1);
+
+    // Extents of my region
+    int myStartingHeight =
+	fullImageExtents[2] +
+	myPositionInRegion *
+	regionHeight;
+    int myEndingHeight = myStartingHeight + regionHeight;
+    if (myPositionInRegion == numRegions-1)
+        myEndingHeight = fullImageExtents[3];
+
+    int myRegionHeight = myEndingHeight-myStartingHeight;
+
+    // Size of one buffer
+    int sizeOneBuffer = std::max(regionHeight,lastRegionHeight) * width * 4;
+
+    //debug5 << "myPositionInRegion: " << myPositionInRegion << std::endl;
+    //debug5 << "My extents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
+    //debug5 << "myRegionHeight: " << myRegionHeight << "  lastRegionHeight: " << lastRegionHeight << " regionHeight: " << regionHeight << "  myStartingHeight: " << myStartingHeight << "  myEndingHeight: " << myEndingHeight << std::endl;
+
+
+    //
+    // MPI Async
+
+    // Recv
+    MPI_Request *recvMetaRq = new MPI_Request[ numRegions-1 ];
+    MPI_Request *recvImageRq = new MPI_Request[ numRegions-1 ];
+
+    MPI_Status *recvMetaSt = new MPI_Status[ numRegions-1 ];
+    MPI_Status *recvImageSt = new MPI_Status[ numRegions-1 ];
+
+    // Send
+    MPI_Request *sendMetaRq = new MPI_Request[ numRegions-1 ];
+    MPI_Request *sendImageRq = new MPI_Request[ numRegions-1 ];
+
+    MPI_Status *sendMetaSt = new MPI_Status[ numRegions-1 ];
+    MPI_Status *sendImageSt = new MPI_Status[ numRegions-1 ];
+
+
+    //
+    // Create Buffers
+
+    // Create buffer for receiving images
+    float *recvDataBuffer;
+    recvDataBuffer = new float[ sizeOneBuffer * numRegions];
+
+    // Create buffer for receiving messages
+    std::vector<int> msgBuffer;
+    msgBuffer.clear();
+    msgBuffer.resize(5 * numRegions);
+
+    // Create buffer for sending messages
+    int *sendExtents = new int[numRegions*5];
+
+    //
+    // Async Recv
+    if (inRegion)
+    {
+        int recvCount=0;
+        for (int i=0; i<numRegions; i++)
+        {
+            if ( regionVector[i] == mpiRank )
+                continue;
+
+            int src = regionVector[i];
+            MPI_Irecv(&msgBuffer[i*5],                              5, MPI_INT,   src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvCount] );
+            MPI_Irecv(&recvDataBuffer[i*sizeOneBuffer], sizeOneBuffer, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+            recvCount++;
+        }
+    }
+
+    //debug5 << "Async Recv setup done " << std::endl;
+
+    //
+    // Async Send
+    int sendCount = 0;
+    int sendingOffset;
+    for (int i=0; i<numRegions; i++)
+    {
+        int regionStart, regionEnd, imgSize, dest;
+        dest = regionVector[i];
+
+        if ( dest == mpiRank )
+            continue;
+
+        regionStart = i*regionHeight;
+        regionEnd = regionStart + regionHeight;
+        if (i == numRegions-1) // the last one in region
+            regionEnd = height;
+
+        int startingYExtents = fullImageExtents[2] + regionStart;
+        int endingYExtents = fullImageExtents[2] + regionEnd;
+
+        //debug5 << "startingYExtents: " << startingYExtents <<"   endingYExtents: " << endingYExtents <<  std::endl;
+
+        if (startingYExtents < imgExtents[2])
+            startingYExtents = imgExtents[2];
+
+        if (endingYExtents > imgExtents[3])
+            endingYExtents = imgExtents[3];
+
+        bool hasData = true;
+        if (endingYExtents - startingYExtents <= 0 || imgExtents[1]-imgExtents[0] <= 0)
+        {
+            hasData = false;
+
+            sendingOffset = 0;
+            imgSize = sendExtents[i*5 + 0] = sendExtents[i*5 + 1] = sendExtents[i*5 + 2] = sendExtents[i*5 + 3] =  sendExtents[i*5 + 4] = 0;
+        }
+        else
+        {
+            imgSize = (endingYExtents-startingYExtents) * (imgExtents[1]-imgExtents[0]) * 4;
+            sendingOffset = (startingYExtents-imgExtents[2]) * (imgExtents[1]-imgExtents[0]) * 4;
+
+            sendExtents[i*5 + 0] = imgExtents[0];
+            sendExtents[i*5 + 1] = imgExtents[1];
+            sendExtents[i*5 + 2] = startingYExtents;
+            sendExtents[i*5 + 3] = endingYExtents;
+            sendExtents[i*5 + 4] = 0;
+        }
+
+        //std::cout << mpiRank << " ~ i: " << i << "   regionVector[index]: " << regionVector[index] << "  extents: " <<  sendExtents[index*5 + 0] << ", " << sendExtents[index*5 + 1]  << ", " << sendExtents[index*5 + 2] << ", " << sendExtents[index*5 + 3] << "  sending ... " << std::endl;
+        MPI_Isend(&sendExtents[i*5],             5,   MPI_INT, dest, tags[0], MPI_COMM_WORLD, &sendMetaRq[sendCount]);
+        MPI_Isend(&imgData[sendingOffset], imgSize, MPI_FLOAT, dest, tags[1], MPI_COMM_WORLD, &sendImageRq[sendCount]);
+
+        //debug5 << "dest: " << dest <<"   sendExtents: " << sendExtents[i*5 +0] << ", " << sendExtents[i*5 +1] << "    " << sendExtents[i*5 +2] << ", " << sendExtents[i*5 +3] << std::endl << std::endl;
+
+        sendCount++;
+    }
+
+    //debug5 << "Async Recv" << std::endl;
+
+    //
+    // Create buffer for region
+    intermediateImageExtents[0] = fullImageExtents[0];  intermediateImageExtents[1] = fullImageExtents[1];
+    intermediateImageExtents[2] = myStartingHeight;     intermediateImageExtents[3] = myEndingHeight;
+
+    intermediateImage = new float[width * (myEndingHeight-myStartingHeight) * 4]();
+
+    int recvImageExtents[4];
+    float *recvImageData;
+
+    //
+    // Blend
+    int numBlends = 0;
+    int countBlend = 0;
+
+    intermediateImageBBox[0] = intermediateImageBBox[2] = 0;
+    intermediateImageBBox[1] = intermediateImageBBox[3] = 0;
+
+    if (inRegion)
+    {
+        for (int i=0; i<numRegions; i++)
+        {
+            int index = i;
+
+            //debug5 << "regionVector[" << i << "] " << regionVector[index] << std::endl;
+
+            if (regionVector[index] == mpiRank)
+            {
+                int startingYExtents = myStartingHeight;
+                int endingYExtents = myEndingHeight;
+
+                if (startingYExtents < imgExtents[2])
+                    startingYExtents = imgExtents[2];
+
+                if (endingYExtents > imgExtents[3])
+                    endingYExtents = imgExtents[3];
+
+
+                bool hasData = true;
+                if (endingYExtents - startingYExtents <= 0)
+                {
+                    hasData = false;
+                    endingYExtents = startingYExtents = 0;
+                }
+
+                if (hasData == true)
+                {
+                    int extentsSectionRecv[4];
+                    extentsSectionRecv[0] = imgExtents[0];
+                    extentsSectionRecv[1] = imgExtents[1];
+                    extentsSectionRecv[2] = startingYExtents;
+                    extentsSectionRecv[3] = endingYExtents;
+
+                    BlendFrontToBack(imgData, imgExtents, extentsSectionRecv, intermediateImage, intermediateImageExtents);
+
+                    UpdateBoundingBox(intermediateImageBBox, extentsSectionRecv);
+                    numBlends++;
+                }
+            }
+            else
+            {
+                MPI_Wait(&recvMetaRq[countBlend], &recvMetaSt[countBlend]);
+
+                for (int j=0; j<4; j++)
+                    recvImageExtents[j] = msgBuffer[index*5 + j];
+
+                bool hasData =  false;
+                if (recvImageExtents[1]-recvImageExtents[0] > 0 && recvImageExtents[3]-recvImageExtents[2] > 0)
+                {
+                    hasData = true;
+                    MPI_Wait(&recvImageRq[countBlend], &recvImageSt[countBlend]);
+                    recvImageData = &recvDataBuffer[index*sizeOneBuffer];
+                }
+
+                if (hasData)
+                {
+
+                    BlendFrontToBack(recvImageData, recvImageExtents, intermediateImage, intermediateImageExtents);
+
+                    UpdateBoundingBox(intermediateImageBBox, recvImageExtents);
+                    numBlends++;
+                }
+
+                countBlend++;
+            }
+        }
+    }
+    else
+        compositingDone = true;
+
+    //debug5 << "PDS blending done" << std::endl;
+
+    msgBuffer.clear();
+
+
+    if (recvDataBuffer != NULL)
+        delete []recvDataBuffer;
+    recvDataBuffer = NULL;
+
+
+    if (numBlends == 0)
+        intermediateImageBBox[0]=intermediateImageBBox[1]=intermediateImageBBox[2]=intermediateImageBBox[3] = 0;
+
+    delete []recvMetaRq;
+    delete []recvImageRq;
+    delete []recvMetaSt;
+    delete []recvImageSt;
+
+    delete []sendMetaRq;
+    delete []sendImageRq;
+    delete []sendMetaSt;
+    delete []sendImageSt;
+
+    recvMetaRq = NULL;
+    recvImageRq = NULL;
+    recvMetaSt = NULL;
+    recvImageSt = NULL;
+
+    sendMetaRq = NULL;
+    sendImageRq = NULL;
+    sendMetaSt = NULL;
+    sendImageSt = NULL;
+#endif
+}
+
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::findRegionsForPatch
+//
+//  Purpose:
+//      Needed by Parallel Direct Send to determine the regions a patch will overlap
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+int
+avtSLIVRImgCommunicator::findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to)
+{
+    from = to = 0;
+    if (patchExtents[1]-patchExtents[0] <=0 || patchExtents[3]-patchExtents[2] <=0)
+        return 0;
+
+    if ( patchExtents[0] > screenProjectedExtents[1])
+        return 0;
+
+    if ( patchExtents[1] < screenProjectedExtents[0])
+        return 0;
+
+    if ( patchExtents[2] > screenProjectedExtents[3])
+        return 0;
+
+    if ( patchExtents[3] < screenProjectedExtents[2])
+        return 0;
+
+
+    // find from
+    for (int i=numRegions-1; i>=0; i--)
+        if ( patchExtents[2] >= getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
+        {
+            from = i;
+            break;
+        }
+    
+
+    // find to
+    for (int i=numRegions-1; i>=0; i--)
+        if ( patchExtents[3] > getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
+        {
+            to = i;
+            break;
+        }
+
+    return ( std::max( (to - from) + 1, 0) );
+}
+
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::computeRegionExtents
+//
+//  Purpose:
+//      Compute extents for each region
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImgCommunicator::computeRegionExtents(int numRanks, int height)
+{
+    //debug5 << "computeRegionExtents height " << height << std::endl;
+
+    int regionHeight = round((float)height/numRanks);
+    regularRegionSize = regionHeight;
+    maxRegionHeight = 0;
+    regionRankExtents.resize(numRanks*3);
+    for (int i=0; i<numRanks; i++)
+    {
+	int startRegionExtents, endRegionExtents, _currentRegionHeight;
+
+	startRegionExtents = CLAMP(regionHeight * i, 0, height);
+	endRegionExtents = CLAMP(regionHeight * i + regionHeight, 0, height);
+
+	if ( i == numRanks -1 )
+	    if ( endRegionExtents < height )
+		endRegionExtents = height;
+
+	_currentRegionHeight = CLAMP(endRegionExtents-startRegionExtents, 0, height);
+	maxRegionHeight = std::max(maxRegionHeight, _currentRegionHeight);
+
+	regionRankExtents[i*3+0] = startRegionExtents;
+	regionRankExtents[i*3+1] = endRegionExtents;
+	regionRankExtents[i*3+2] = _currentRegionHeight;
+
+	debug5 << i << " : (start, end, region): " << startRegionExtents << ", " << endRegionExtents << ", " << _currentRegionHeight << std::endl;
+    }
+}
+
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::ParallelDirectSendManyPatches
+//
+//  Purpose:
+//      Parallel Direct Send rendering that can blend individual patches
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+
+int
+avtSLIVRImgCommunicator::ParallelDirectSendManyPatches
+    (const std::multimap<int, slivr::ImgData> &imgDataHashMap, 
+     const std::vector<slivr::ImgMetaData>    &imageMetaPatchVector, 
+     int numPatches,
+     int *region,
+     int numRegions, 
+     int tags[2],
+     int fullImageExtents[4])
+{
+    int myRegionHeight = 0;
+#ifdef PARALLEL
+
+    //
+    // Some Initializations
+    //
+    debug5 << "Parallel Direct Send" << endl;
+    int timingDetail;
+    for (int i=0; i<4; i++)
+    {
+	intermediateImageExtents[i] = 0;
+	intermediateImageBBox[i] = 0;
+    }
+
+
+    //
+    // Find My Position in Regions
+    //
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStart("avtSLIVRImgCommunicator", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Find My position in Regions");
+    //---------------------------------------------------------------------//
+    compositingDone = false;
+    int myPositionInRegion = -1;
+    bool inRegion = true;
+    std::vector<int> regionVector(region, region+numRegions);
+    const std::vector<int>::const_iterator it = 
+	std::find(regionVector.begin(),
+		  regionVector.end(), 
+		  mpiRank);
+    if (it == regionVector.end())
+    {
+	inRegion = false;
+	debug5 << mpiRank << " ~ SHOULD NOT HAPPEN!!!!: Not found " 
+	       << mpiRank <<  " !!!" << std::endl;
+    }
+    else 
+    {
+	myPositionInRegion = it - regionVector.begin();
+    }
+    int width =  fullImageExtents[1]-fullImageExtents[0];
+    int height = fullImageExtents[3]-fullImageExtents[2];
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStop("avtSLIVRImgCommunicator", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Find My position in Regions");
+    debug5 << mpiRank << " ~ myPositionInRegion: " 
+	   << myPositionInRegion << ", numRanks: " << mpiSize << std::endl;
+    debug5 << "width: " << width << ", height : " << height 
+	   << " | fullImageExtents: "
+	   << fullImageExtents[0] << ", " 
+	   << fullImageExtents[1] << ", " 
+	   << fullImageExtents[2] << ", "
+	   << fullImageExtents[3] << std::endl;
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Compute Region Boundaries
+    //
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStart("avtSLIVRImgCommunicator", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Compute Region Boundaries");
+    //---------------------------------------------------------------------//
+    computeRegionExtents(mpiSize, height); // ?
+    int myStartingHeight = getScreenRegionStart
+	(myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
+    int myEndingHeight   = getScreenRegionEnd
+	(myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
+    myRegionHeight = CLAMP((myEndingHeight-myStartingHeight), 0, height);
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStop("avtSLIVRImgCommunicator", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Compute Region Boundaries");
+    debug5 << "myStartingHeight: " << myStartingHeight << ", "
+	   << "myEndingHeight: "   << myEndingHeight   << ", "
+	   << "myRegionHeight: "   << myRegionHeight   << std::endl;
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Size of one buffer
+    //
+    int sizeOneBuffer = getMaxRegionHeight() * width * 4;
+
+
+    //
+    // Determine How Many Patches and Pixel to Send to Each Region
+    //
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStart("avtSLIVRImgCommunicator", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Determine How Many Patches and Pixel to Send "
+			     "to Each Region");
+    //---------------------------------------------------------------------//
+    std::vector<int> numPatchesPerRegion;
+    std::vector<int> areaPerRegion;
+    std::set<int> numOfRegions;
+    numPatchesPerRegion.resize(numRegions);
+    areaPerRegion.resize(numRegions);
+
+    // 2D array: extents for each partition
+    std::vector < std::vector<float> > extentsPerPartiton;
+    for (int i=0; i<numRegions; i++) { 
+	extentsPerPartiton.push_back(std::vector<float>()); 
+    }
+    debug5 << "Parallel Direct Send ~ numPatches " << numPatches << endl;
+    int totalSendBufferSize = 0;
+    for (int i=0; i<numPatches; i++)
+    {
+	int _patchExtents[4];
+	slivr::ImgMetaData temp;
+	temp = imageMetaPatchVector.at(i);
+	_patchExtents[0]=temp.screen_ll[0];   // minX
+	_patchExtents[1]=temp.screen_ur[0];   // maxX
+	_patchExtents[2]=temp.screen_ll[1];   // minY
+	_patchExtents[3]=temp.screen_ur[1];   // maxY
+	const std::multimap<int, slivr::ImgData>::const_iterator it = 
+	    imgDataHashMap.find( i );
+	int from, to;
+	int numRegionIntescection = findRegionsForPatch(_patchExtents, 
+							fullImageExtents,
+							numRegions, 
+							from, to);
+	if (numRegionIntescection <= 0) continue;
+	debug5 << "\nParallel Direct Send ~ patch " << i 
+	       << "  from:" << from << "  to:" << to 
+	       << "  numPatches: " << numPatches 
+	       << "   _patchExtents: " 
+	       << _patchExtents[0] << ", " 
+	       << _patchExtents[1] << ", " 
+	       << _patchExtents[2] << ", " 
+	       << _patchExtents[3] 
+	       << ", fullImageExtents[2]: " << fullImageExtents[2] 
+	       << ", numRegions: " <<  numRegions 
+	       << ", totalSendBufferSize: " << totalSendBufferSize << endl;
+	for (int j=from; j<=to; j++) numPatchesPerRegion[j]++;
+	for (int partition=from; partition<=to; partition++)
+	{
+	    int _extentsYStart = std::max( _patchExtents[2], getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) );
+	    int _extentsYEnd   = std::min( _patchExtents[3], getScreenRegionEnd(  partition, fullImageExtents[2], fullImageExtents[3]) );
+	    int _area = (_extentsYEnd-_extentsYStart)*(_patchExtents[1]-_patchExtents[0]);
+	    areaPerRegion[partition] += _area;
+	    totalSendBufferSize += _area;
+	    debug5 << "_patchExtents[2]: " << _patchExtents[2] << ", region start: " << getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) <<  ", _extentsYStart: " << _extentsYStart<< endl;
+	    debug5 << "_patchExtents[3]: " << _patchExtents[3] << ", region end: " << getScreenRegionEnd(partition, fullImageExtents[2], fullImageExtents[3]) << ", _extentsYEnd: " << _extentsYEnd << endl;
+	    debug5 << "_area " << _area << endl;
+	    extentsPerPartiton[partition].push_back(i);
+	    extentsPerPartiton[partition].push_back(_patchExtents[0]);
+	    extentsPerPartiton[partition].push_back(_patchExtents[1]);
+	    extentsPerPartiton[partition].push_back(_extentsYStart);
+	    extentsPerPartiton[partition].push_back(_extentsYEnd);
+	    extentsPerPartiton[partition].push_back(temp.eye_z);
+	    numOfRegions.insert(partition);
+	}
+    }
+    totalSendBufferSize *= 4;                           // to account for RGBA
+    int numRegionsWithData = numOfRegions.size();
+    debug5 << "\nParallel Direct Send ~ creating buffers" << endl;
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStop("avtSLIVRImgCommunicator", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Determine How Many Patches and Pixel to Send "
+			    "to Each Region");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Copy the Data for Each Region for Each Patch
+    //
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStart("avtSLIVRImgCommunicator", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Copy the Data for Each Region for Each Patch");
+    //---------------------------------------------------------------------//
+    // Create buffer
+    float *sendDataBuffer = new float[totalSendBufferSize];     // contains all the data arranged by region
+    int   *sendDataBufferSize = new int[numRegionsWithData]();
+    int   *sendDataBufferOffsets = new int[numRegionsWithData]();
+    int   *sendBuffer = new int[numRegions*2]();
+    int regionWithDataCount = 0;
+    int numRegionsToSend = 0;
+    // Populate the buffer with data
+    int dataSendBufferOffset = 0;
+    for (int i=0; i<numRegions; i++)
+    {
+	int _dataSize = 0;
+	debug5 << "Region: " << i << "  size: " << extentsPerPartiton[i].size() << std::endl;
+	for (int j=0; j<extentsPerPartiton[i].size(); j+=6)
+	{
+	    int _patchID = extentsPerPartiton[i][j + 0];
+	    const std::multimap<int, slivr::ImgData>::const_iterator it = imgDataHashMap.find( _patchID );
+
+	    int _width = (extentsPerPartiton[i][j+2] - extentsPerPartiton[i][j+1]);
+	    int _bufferSize = _width * (extentsPerPartiton[i][j+4] - extentsPerPartiton[i][j+3]) * 4;
+	    int _dataOffset = extentsPerPartiton[i][j+3] - imageMetaPatchVector[_patchID].screen_ll[1];
+
+	    memcpy(&sendDataBuffer[dataSendBufferOffset], &(((*it).second).imagePatch[_width * _dataOffset * 4]), _bufferSize*sizeof(float) );
+
+	    dataSendBufferOffset += _bufferSize;
+	    _dataSize += _bufferSize;
+	}
+
+	if (_dataSize != 0){
+	    sendDataBufferSize[regionWithDataCount] = _dataSize;
+
+	    regionWithDataCount ++;
+	    if (regionWithDataCount != numRegionsWithData)
+		sendDataBufferOffsets[regionWithDataCount] = sendDataBufferOffsets[regionWithDataCount-1] + sendDataBufferSize[regionWithDataCount-1];
+
+	    if (regionVector[i] != mpiRank)
+		numRegionsToSend++;
+	}
+
+	sendBuffer[i*2+0] = numPatchesPerRegion[i];
+	sendBuffer[i*2+1] = areaPerRegion[i];
+
+	debug5 << "Region: " << i << "  numPatchesPerRegion: " << sendBuffer[i*2+0] << ", sendBuffer[i*2+1]: " << sendBuffer[i*2+1] << std::endl;
+    }
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStop("avtSLIVRImgCommunicator", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Copy the Data for Each Region for Each Patch");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Exchange Information about Size to Recv
+    //
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStart("avtSLIVRImgCommunicator", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Exchange Information about Size to Recv");
+    //---------------------------------------------------------------------//
+    int *recvInfoATABuffer = new int[numRegions*2]();
+    MPI_Alltoall(sendBuffer, 2, MPI_INT,  recvInfoATABuffer, 2, MPI_INT, MPI_COMM_WORLD);
+    delete []sendBuffer;
+    sendBuffer = NULL;
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStop("avtSLIVRImgCommunicator", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Exchange Information about Size to Recv");
+    debug5 << "Parallel Direct Send ~ Exchange information about size to recv" << endl;
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Calculate Buffer Size Needed
+    //
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStart("avtSLIVRImgCommunicator", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Calculate Buffer Size Needed");
+    //---------------------------------------------------------------------//
+    int infoBufferSize = 0;
+    int dataBufferSize = 0;
+    int numRegionsToRecvFrom = 0;
+    for (int i=0; i<numRegions; i++)
+    {
+	infoBufferSize += recvInfoATABuffer[i*2 + 0];   // number of patches per region
+	dataBufferSize += recvInfoATABuffer[i*2 + 1];   // area per region
+	debug5 << "From: " << i << ", #patches: " << recvInfoATABuffer[i*2 + 0] << ", " << recvInfoATABuffer[i*2 + 1] << std::endl;
+	if (i == mpiRank) continue;
+	if (recvInfoATABuffer[i*2 + 0] != 0)
+	    numRegionsToRecvFrom++;
+    }
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStop("avtSLIVRImgCommunicator", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Calculate Buffer Size Needed");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Create Structure for MPI Async send/recv
+    //
+    // Send
+    MPI_Request *sendMetaRq = new MPI_Request[ numRegionsToSend ];
+    MPI_Status *sendMetaSt = new MPI_Status[ numRegionsToSend ];
+    MPI_Request *sendImageRq = new MPI_Request[ numRegionsToSend ];
+    MPI_Status *sendImageSt = new MPI_Status[ numRegionsToSend ];
+    // Recv
+    MPI_Request *recvMetaRq = NULL;
+    MPI_Status *recvMetaSt = NULL;
+    MPI_Request *recvImageRq = NULL;
+    MPI_Status *recvImageSt = NULL;
+    // counters
+    int recvInfoCount = 0;
+    int offsetMeta = 0;
+    int offsetData = 0;
+
+
+    //
+    // Create Recv Buffers
+    //
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStart("avtSLIVRImgCommunicator", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Create Recv Buffers");
+    //---------------------------------------------------------------------//
+    float *recvInfoBuffer = new float[infoBufferSize*6];  // 6 - passing 6 parameters for each patch
+    float *recvDataBuffer =  new float[dataBufferSize*4]; // 4 - to account for RGBA
+
+    debug5 << "infoBufferSize: " << infoBufferSize << ", dataBufferSize: " << dataBufferSize << std::endl;
+    if (myRegionHeight != 0)
+    {
+        // Recv
+        recvMetaRq = new MPI_Request[ numRegionsToRecvFrom ];
+        recvMetaSt = new MPI_Status[ numRegionsToRecvFrom ];
+
+        recvImageRq = new MPI_Request[ numRegionsToRecvFrom ];
+        recvImageSt = new MPI_Status[ numRegionsToRecvFrom ];
+
+        // Async Recv for info
+        for (int i=0; i<numRegions; i++)
+        {
+            if (recvInfoATABuffer[i*2 + 0] == 0)
+                continue;
+
+            if ( regionVector[i] == mpiRank )
+                continue;
+
+            int src = regionVector[i];
+            MPI_Irecv(&recvInfoBuffer[offsetMeta], recvInfoATABuffer[i*2 + 0]*6, MPI_FLOAT, src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvInfoCount] );
+            MPI_Irecv(&recvDataBuffer[offsetData], recvInfoATABuffer[i*2 + 1]*4, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvInfoCount] );
+
+            offsetMeta += recvInfoATABuffer[i*2 + 0]*6;
+            offsetData += recvInfoATABuffer[i*2 + 1]*4;
+            recvInfoCount++;
+        }
+        debug5 << "Async recv setup - numRegionsToRecvFrom: " << numRegionsToRecvFrom << "   recvInfoCount: " << recvInfoCount << endl;
+    }
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStop("avtSLIVRImgCommunicator", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Create Recv Buffers");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Async Send
+    //
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStart("avtSLIVRImgCommunicator", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Async Send");
+    //---------------------------------------------------------------------//
+    int offset = 0;
+    int sendCount = 0;
+    int mpiSendCount = 0;
+    for (int i=0; i<numRegions; i++)
+    {
+        if ( extentsPerPartiton[i].size() != 0 )
+	{
+            if ( regionVector[i] == mpiRank )
+            {
+                memcpy( &recvInfoBuffer[offsetMeta], &extentsPerPartiton[i][0], extentsPerPartiton[i].size()*sizeof(float) );
+                memcpy( &recvDataBuffer[offsetData], &sendDataBuffer[offset],   sendDataBufferSize[ sendCount ]*sizeof(float) );
+
+                offset += sendDataBufferSize[sendCount];
+                sendCount++;
+            }
+            else
+            {
+                MPI_Isend(&extentsPerPartiton[i][0],  extentsPerPartiton[i].size(),  MPI_FLOAT, region[i], tags[0], MPI_COMM_WORLD, &sendMetaRq[mpiSendCount]);
+                MPI_Isend(&sendDataBuffer[offset], sendDataBufferSize[ sendCount ], MPI_FLOAT, region[i], tags[1], MPI_COMM_WORLD, &sendImageRq[mpiSendCount]);
+
+                offset += sendDataBufferSize[sendCount];
+                sendCount++;
+                mpiSendCount++;
+            }
+        }
+    }
+
+    debug5 << "Asyn send setup done ~ numRegionsToSend: " << numRegionsToSend << "  mpiSendCount: " << mpiSendCount << endl;
+
+    if (myRegionHeight != 0)
+    {
+        debug5 << "MPI_Waitall ..." << std::endl;
+        MPI_Waitall(recvInfoCount, recvImageRq, recvImageSt);   // Means that we have reveived everything!
+
+        debug5 << "MAPI_WAITALL done!" << std::endl;
+
+        if (recvInfoATABuffer != NULL)
+            delete []recvInfoATABuffer;
+        recvInfoATABuffer = NULL;
+
+	debug5 << "Sorting..." << std::endl;
+
+	//
+	// Sort the data
+	std::multimap<float,int> patchData;
+	std::vector<int> patchOffset;
+	patchOffset.push_back(0);
+	for (int i=0; i<infoBufferSize; i++)
+	{
+	    patchData.insert( std::pair<float,int> (recvInfoBuffer[i*6 + 5],i));
+	    int _patchSize = (recvInfoBuffer[i*6 + 4]-recvInfoBuffer[i*6 + 3]) * (recvInfoBuffer[i*6 + 2]-recvInfoBuffer[i*6 + 1]) * 4;
+	    int _offset = patchOffset[i] + _patchSize;
+
+	    if (i != infoBufferSize-1)
+		patchOffset.push_back(_offset);
+	}
+
+	//
+	// Create buffer for current region
+	intermediateImageBBox[0] = intermediateImageExtents[0] = fullImageExtents[0];
+	intermediateImageBBox[1] = intermediateImageExtents[1] = fullImageExtents[1];
+	intermediateImageBBox[2] = intermediateImageExtents[2] = myStartingHeight;
+	intermediateImageBBox[3] = intermediateImageExtents[3] = myEndingHeight;
+	intermediateImage = new float[width * (myEndingHeight - myStartingHeight) * 4]();
+	debug5 << "intermediate image size " << width << ", " << (myEndingHeight - myStartingHeight) << std::endl;
+
+	//
+	// Blend
+	int numBlends = 0;
+	for (std::multimap<float,int>::iterator it=patchData.begin(); it!=patchData.end(); ++it)
+	{
+	    int _id = (*it).second;
+	    int _extents[4];
+	    _extents[0] = recvInfoBuffer[_id*6 + 1];
+	    _extents[1] = recvInfoBuffer[_id*6 + 2];
+	    _extents[2] = recvInfoBuffer[_id*6 + 3];
+	    _extents[3] = recvInfoBuffer[_id*6 + 4];
+	    BlendFrontToBack(&recvDataBuffer[patchOffset[_id]], _extents, _extents, intermediateImage, intermediateImageExtents);
+	    numBlends++;
+	}
+
+	if (numBlends == 0) {
+	    intermediateImageBBox[0]=intermediateImageBBox[1]=intermediateImageBBox[2]=intermediateImageBBox[3] = 0;
+	}
+    }
+
+    MPI_Waitall(numRegionsToSend, sendImageRq, sendImageSt);   // Means that we have sent everything!
+
+    if (myRegionHeight == 0) compositingDone = true;
+
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStop("avtSLIVRImgCommunicator", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Async Send");
+    //---------------------------------------------------------------------//
+
+
+    //
+    // Cleanup
+    //
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStart("avtSLIVRImgCommunicator", 
+			     "ParallelDirectSendManyPatches", timingDetail,
+			     "Cleanup");
+    //---------------------------------------------------------------------//
+    if (sendDataBuffer != NULL)
+	delete []sendDataBuffer;
+    sendDataBuffer = NULL;
+
+    if (sendDataBufferSize != NULL)
+	delete []sendDataBufferSize;
+    sendDataBufferSize = NULL;
+
+    if (sendDataBufferOffsets != NULL)
+	delete []sendDataBufferOffsets;
+    sendDataBufferOffsets = NULL;
+
+
+    if (sendMetaRq != NULL)
+	delete []sendMetaRq;
+
+    if (sendImageRq != NULL)
+	delete []sendImageRq;
+
+    if (sendMetaSt != NULL)
+	delete []sendMetaSt;
+
+    if (sendImageSt != NULL)
+	delete []sendImageSt;
+
+    sendMetaRq = NULL;
+    sendImageRq = NULL;
+    sendMetaSt = NULL;
+    sendImageSt = NULL;
+
+    if (myRegionHeight != 0)
+    {
+	if (recvInfoBuffer != NULL)
+	    delete []recvInfoBuffer;
+	recvInfoBuffer = NULL;
+
+	if (recvDataBuffer != NULL)
+	    delete []recvDataBuffer;
+	recvDataBuffer = NULL;
+
+	if (recvMetaRq != NULL)
+	    delete []recvMetaRq;
+
+	if (recvMetaSt != NULL)
+	    delete []recvMetaSt;
+
+	if (recvImageRq != NULL)
+	    delete []recvImageRq;
+
+	if (recvImageSt != NULL)
+	    delete []recvImageSt;
+
+	recvMetaRq = NULL;
+	recvImageRq = NULL;
+	recvMetaSt = NULL;
+	recvImageSt = NULL;
+    }
+    //---------------------------------------------------------------------//
+    slivr::CheckSectionStop("avtSLIVRImgCommunicator", 
+			    "ParallelDirectSendManyPatches", timingDetail,
+			    "Cleanup");
+    debug5 << "All Parallel Direct Send is Done" << std::endl;
+    //---------------------------------------------------------------------//
+#endif
+    return myRegionHeight;
+}
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::gatherImages
+//
+//  Purpose:
+//      Gather images from Parallel Direct Send
+//
+//  Programmer: Pascal Grosset
+//  Creation:   August 19, 2016
+//
+//  Modifications:
+//
+// **************************************************************************
+void
+avtSLIVRImgCommunicator::gatherImages(int regionGather[], int totalNumRanks, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight)
+{
+#ifdef PARALLEL
+    debug5 << "gatherImages starting... totalNumRanks: " << totalNumRanks << ", compositingDone: " << compositingDone
+	   << ", imgExtents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
+
+    for (int i=0; i<4; i++)
+	finalImageExtents[i] = finalBB[i] = 0;
+
+    if (mpiRank == 0)
+    {
+	int width =  fullImageExtents[1]-fullImageExtents[0];
+	int height = fullImageExtents[3]-fullImageExtents[2];
+
+	debug5 << "Gather Images at 0, final size: " << fullImageExtents[1]-fullImageExtents[0] << " x " << fullImageExtents[3]-fullImageExtents[2] << std::endl;
+
+	//
+	// Receive at root/display node!
+	finalImage = new float[width*height*4];
+	finalImageExtents[0] = fullImageExtents[0];
+	finalImageExtents[1] = fullImageExtents[1];
+	finalImageExtents[2] = fullImageExtents[2];
+	finalImageExtents[3] = fullImageExtents[3];
+
+	int numRegionsWithData = 0;
+	int numToRecv = 0;
+	for (int i=0; i<totalNumRanks; i++)
+	{
+	    if (getRegionSize(i) != 0)
+		numRegionsWithData++;
+	}
+	numToRecv = numRegionsWithData;
+
+	// remove itself from the recv
+	if (getRegionSize(mpiRank) != 0) 
+	    numToRecv--;
+
+
+	//
+	// Create buffers for async reciving
+	MPI_Request *recvImageRq = new MPI_Request[ numToRecv ];
+	MPI_Status  *recvImageSt = new MPI_Status[ numToRecv ];
+
+	int lastBufferSize    = getRegionSize(totalNumRanks-1) * width * 4;
+	int regularBufferSize = regularRegionSize * width * 4;
+
+	debug5 << "numToRecv: " << numToRecv << ", numRegionsWithData: " << numRegionsWithData << std::endl;
+	debug5 << "regularBufferSize: " << regularBufferSize << ", lastBufferSize: " << lastBufferSize << std::endl;
+
+	// Async Recv
+	int recvCount=0;
+	for (int i=0; i<numRegionsWithData; i++)
+	{
+	    int src = regionGather[i];
+
+	    if (src == mpiRank)
+		continue;
+
+	    if (i == totalNumRanks-1)
+	    {
+		if (lastBufferSize != 0)
+		{
+		    MPI_Irecv(&finalImage[i*regularBufferSize], lastBufferSize,     MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+		}
+	    }
+	    else
+		MPI_Irecv(&finalImage[i*regularBufferSize], regularBufferSize,  MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
+			
+
+	    debug5 << i << " ~ recvCount: " << recvCount << std::endl;
+	    recvCount++;
+	}
+
+	if (compositingDone == false)   // If root has data for the final image
+	    PlaceImage(inputImg, imgExtents, finalImage, finalImageExtents);
+
+	MPI_Waitall(numToRecv, recvImageRq, recvImageSt);
+	compositingDone = true;
+
+	delete []recvImageRq;
+	recvImageRq = NULL;
+	delete []recvImageSt;
+	recvImageSt = NULL;
+    }
+    else
+    {
+	if (compositingDone == false)   
+	{
+	    int imgSize = (imgExtents[1]-imgExtents[0]) * (imgExtents[3]-imgExtents[2]) * 4;
+	    debug5 << "imgSize: " << imgSize << std::endl;
+
+	    MPI_Send(inputImg, imgSize, MPI_FLOAT, 0, tag, MPI_COMM_WORLD);
+	    compositingDone = true;
+	}
+    }
+
+#endif
+}
+
+// ***************************************************************************
+//  Method: avtSLIVRImgCommunicator::getcompositedImage
+//
+//  Purpose:
+//      Returns the whole image if needed
+//
+//  Programmer: Pascal Grosset
+//  Creation: July 2013
+//
+//  Modifications:
+//
+// ***************************************************************************
+
+void avtSLIVRImgCommunicator::getcompositedImage
+(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage)
+{
+    for (int i=0; i< imgBufferHeight; i++) {
+        for (int j=0; j<imgBufferWidth; j++) {
+            int bufferIndex = (imgBufferWidth*4*i) + (j*4);
+            int wholeImgIndex = (imgBufferWidth*3*i) + (j*3);
+            wholeImage[wholeImgIndex+0] = (finalImage[bufferIndex+0] ) * 255;
+            wholeImage[wholeImgIndex+1] = (finalImage[bufferIndex+1] ) * 255;
+            wholeImage[wholeImgIndex+2] = (finalImage[bufferIndex+2] ) * 255;
+        }
+    }
+    if (finalImage != NULL)
+    { delete []finalImage; }
+    finalImage = NULL;
+}
diff --git a/avt/Filters/avtSLIVRImgCommunicator.h b/avt/Filters/avtSLIVRImgCommunicator.h
new file mode 100644
index 000000000..7df56c0ca
--- /dev/null
+++ b/avt/Filters/avtSLIVRImgCommunicator.h
@@ -0,0 +1,241 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+// *************************************************************************//
+//                          avtSLIVRImgCommunicator.h                       //
+// *************************************************************************//
+
+#ifndef AVT_SLIVR_IMG_COMMUNICATOR_H
+#define AVT_SLIVR_IMG_COMMUNICATOR_H
+
+#include <filters_exports.h>
+#include <pipeline_exports.h>
+
+#include <avtSLIVRImgMetaData.h>
+#include <string>
+#include <vector>
+#include <map>
+#include <algorithm>
+#include <utility>
+
+#ifdef PARALLEL
+#  include <mpi.h>
+#endif
+
+#define MSG_DATA   100
+#define MSG_RESULT 101
+
+const int SEND    = 1;
+const int RECEIVE = 2;
+
+struct imageBuffer{
+    float *image;
+    float  depth;
+};
+
+// ***************************************************************************
+//  Class: avtSLIVRImgCommunicator
+//
+//  Purpose:
+//      Does the composition for Ray casting: SLIVR
+//
+//  Programmer: Pascal Grosset
+//  Creation:   Spetember 20, 2013
+//
+//  Modifications:
+//
+//    Qi WU, Wed Jun 20 2018
+//    Add support for volume rendering using OSPRay (RayCasting:OSPRay)
+//
+// ***************************************************************************
+
+class avtSLIVRImgComm
+{
+public:
+    avtSLIVRImgComm(int mpiSize, int mpiRank) {};
+    virtual ~avtSLIVRImgComm() {};
+    virtual void Init (int W, int H) = 0;
+    virtual void SetTile (const float* data, 
+			  const int* extents, 
+			  const float& depth) = 0;
+    virtual void Composite (float*& output) = 0;
+};
+
+class avtSLIVRImgCommunicator
+{ 
+public:    
+    avtSLIVRImgCommunicator();
+    ~avtSLIVRImgCommunicator();
+
+    virtual const char *GetType(void)
+    { return "avtSLIVRImgCommunicator"; }
+    virtual const char *GetDescription(void) 
+    { return "Doing compositing for ray casting SLIVR"; }
+
+    float* GetFinalImageBuffer () { return finalImage; }
+    int GetParSize ()             { return mpiSize;   }
+    int GetParRank ()             { return mpiRank;   }
+
+    // Those functions can be static
+    static void BlendFrontToBack(const float *, const int srcExtents[4],
+				 const int blendExtents[4], 
+				 float *&, const int dstExtents[4]);
+    static void BlendBackToFront(const float *, const int srcExtents[4], 
+				 const int blendExtents[4], 
+				 float *&, const int dstExtents[4]);
+    static void BlendFrontToBack(const float *, const int srcExtents[4], 
+				 float *&, const int dstExtents[4]);
+    static void BlendBackToFront(const float *, const int srcExtents[4], 
+				 float *&, const int dstExtents[4]);
+
+    void Barrier();
+
+    //----------------------------------------------------------------------//
+    // Different Algorithms
+    //----------------------------------------------------------------------//
+
+    //----------------------------------------------------------------------//
+    // IceT
+    //----------------------------------------------------------------------//
+    bool IceTValid();
+    void IceTInit(int W, int H);
+    void IceTSetTile(const float*, const int*, const float&);
+    void IceTComposite(float*&);
+
+    //----------------------------------------------------------------------//
+    // Both currently unused but good for simple testing
+    //----------------------------------------------------------------------//
+private:
+    void GatherDepthAtRoot(const int, const float *, int &, int *&, float *&);
+public:
+    void SerialDirectSend
+	(int, float*, int*, float*, float bgColor[4], int, int);
+
+    //----------------------------------------------------------------------//
+    // Parallel Direct Send
+    //----------------------------------------------------------------------//
+public:
+    void RegionAllocation(int *&);
+    int  ParallelDirectSendManyPatches
+	(const std::multimap<int, slivr::ImgData>&,
+	 const std::vector<slivr::ImgMetaData>&,
+	 int, int*, int, int tags[2], int fullImageExtents[4]);
+
+private:
+    //----------------------------------------------------------------------//
+    static void ColorImage(float *&, const int, const int, 
+			   const float color[4]);
+    static void PlaceImage(const float *, const int srcExtents[4], 
+			   float *&, const int dstExtents[4]);
+    static void BlendWithBackground(float *&, const int extents[4],
+				    const float bgColor[4]);
+    //----------------------------------------------------------------------//
+    void UpdateBoundingBox
+	(int currentBoundingBox[4], const int imageExtents[4]);
+    //----------------------------------------------------------------------//
+
+private:
+
+    // Basic MPI information
+    int mpiSize; // total number of processes (# of ranks)
+    int mpiRank; // my rank id
+
+    // TODO this communicator shouldnt be in charge of this variable
+    // Final image is here
+    float *finalImage;
+
+    // Image Compisition Implementation
+    avtSLIVRImgComm* compositor;
+
+// CLEAN UP BELOW
+private:
+    ///--------------------------------------
+    // flags for patch
+    int totalPatches;
+    bool compositingDone;
+
+    // image sizing for compositing
+    int maxRegionHeight;
+    int regularRegionSize;
+    std::vector<int> regionRankExtents;
+
+    //----------------------------------------------------------------------//
+      
+    void computeRegionExtents(int numRanks, int height);
+	
+    int getRegularRegionSize(){ return regularRegionSize; } 
+    int getRegionStart(int region){ return regionRankExtents[region*3+0]; }
+    int getRegionEnd(int region){ return regionRankExtents[region*3+1]; }
+    int getRegionSize(int region){ return regionRankExtents[region*3+2]; }
+    int getMaxRegionHeight(){ return maxRegionHeight; }
+	
+    int getScreenRegionStart(int region, int screenImgMinY, int screenImgMaxY)
+    {
+	return CLAMP(getRegionStart(region)+screenImgMinY, 
+		     screenImgMinY, screenImgMaxY); 
+    }
+    int getScreenRegionEnd(int region, int screenImgMinY, int screenImgMaxY)
+    {
+	return CLAMP(getRegionEnd(region)+screenImgMinY, 
+		     screenImgMinY, screenImgMaxY); 
+    }
+
+public:
+    //----------------------------------------------------------------------//
+
+    void getcompositedImage(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage);  // get the final composited image
+
+
+    int findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to);
+
+
+    void parallelDirectSend(float *imgData, int imgExtents[4], int region[], int numRegions, int tags[2], int fullImageExtents[4]);	
+    void gatherImages(int regionGather[], int numToRecv, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight);
+
+public:
+    // TODO: Remove all public fields
+    int finalImageExtents[4];
+    int finalBB[4];
+    float *intermediateImage; // Intermediate image, e.g. in parallel direct send
+    int intermediateImageExtents[4];
+    int intermediateImageBBox[4];
+
+
+};
+
+#endif//AVT_SLIVR_IMG_COMMUNICATOR_H
diff --git a/avt/Filters/avtSLIVRImgMetaData.C b/avt/Filters/avtSLIVRImgMetaData.C
new file mode 100644
index 000000000..1389e560e
--- /dev/null
+++ b/avt/Filters/avtSLIVRImgMetaData.C
@@ -0,0 +1,490 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+#include "avtSLIVRImgMetaData.h"
+#include "avtSLIVROSPRayFilter.h"
+#include <avtMemory.h>
+#include <avtParallel.h>
+#include <ImproperUseException.h>
+#include <DebugStream.h>
+#include <TimingsManager.h>
+
+// ***************************************************************************
+// Threaded Blending
+// ***************************************************************************
+
+inline bool CheckThreadedBlend_MetaData()
+{
+    bool use = true;
+    const char* env_use = std::getenv("SLIVR_NOT_USE_THREADED_BLEND");
+    if (env_use) { 
+	use = atoi(env_use) <= 0; 
+    }
+    if (!use) {
+	ospout << "[avtSLIVRImgMetaData] "
+	       << "Not Using Multi-Threading for Blending"
+	       << std::endl;
+    } else {
+	ospout << "[avtSLIVRImgMetaData] "
+	       << "Using Multi-Threading for Blending"
+	       << std::endl;
+    }
+    return use;
+}
+#ifdef VISIT_OSPRAY
+bool UseThreadedBlend_MetaData = CheckThreadedBlend_MetaData();
+#else
+bool UseThreadedBlend_MetaData = false;
+#endif
+
+// ****************************************************************************
+//  Namespace:  slivr
+//
+//  Purpose:
+//    
+//
+//  Programmer:  
+//  Creation:   
+//
+// ****************************************************************************
+double slivr::ProjectWorldToScreen
+(const double worldCoord[3], const int screenWidth, const int screenHeight,
+ const double panPercentage[2], const double imageZoom,
+ vtkMatrix4x4 *mvp, int screenCoord[2])
+{
+    // world space coordinate in homogeneous coordinate
+    double worldHCoord[4] = {
+	worldCoord[0],
+	worldCoord[1],
+	worldCoord[2],
+	1.0
+    };
+
+    // world to clip space (-1 ~ 1)
+    double clipHCoord[4];
+    mvp->MultiplyPoint(worldHCoord, clipHCoord);
+    if (clipHCoord[3] == 0.0)
+    {
+	std::cerr << "slivr::ProjectWorldToScreen "
+		  << "Zero Division During Projection" 
+		  << std::endl;
+	std::cerr << "world coordinates: (" 
+		  << worldHCoord[0] << ", " 
+		  << worldHCoord[1] << ", " 
+		  << worldHCoord[2] << ", " 
+		  << worldHCoord[3] << ")" << std::endl
+		  << "clip space coordinate: ("
+		  << clipHCoord[0] << ", " 
+		  << clipHCoord[1] << ", " 
+		  << clipHCoord[2] << ", "
+		  << clipHCoord[3] << std::endl;
+	std::cerr << "Matrix: " << *mvp << std::endl;
+	EXCEPTION1(VisItException, "Zero Division During Projection");
+    }
+
+    // normalize clip space coordinate
+    double clipCoord[3] = {
+	clipHCoord[0]/clipHCoord[3],
+	clipHCoord[1]/clipHCoord[3],
+	clipHCoord[2]/clipHCoord[3]
+    };
+
+    // screen coordinates (int integer)
+    screenCoord[0] = round(clipCoord[0]*(screenWidth /2.0)+(screenWidth /2.0));
+    screenCoord[1] = round(clipCoord[1]*(screenHeight/2.0)+(screenHeight/2.0));
+
+    // add panning
+    screenCoord[0] += round(screenWidth  * panPercentage[0] * imageZoom);
+    screenCoord[1] += round(screenHeight * panPercentage[1] * imageZoom); 
+
+    // return point depth
+    return clipCoord[2];
+}
+
+void
+slivr::ProjectScreenToWorld
+(const int screenCoord[2], const double z,
+ const int screenWidth, const int screenHeight, 
+ const double panPercentage[2], const double imageZoom,
+ vtkMatrix4x4 *imvp, double worldCoord[3])
+{
+    // remove panning
+    const int x = 
+	screenCoord[0] - round(screenWidth*panPercentage[0]*imageZoom);
+    const int y = 
+	screenCoord[1] - round(screenHeight*panPercentage[1]*imageZoom);
+    
+    // do projection
+    double worldHCoord[4] = {0,0,0,1};
+    double clipHCoord[4] = {
+	(x - screenWidth/2.0) /(screenWidth/2.0),
+	(y - screenHeight/2.0)/(screenHeight/2.0),
+	z, 1.0};
+    imvp->MultiplyPoint(clipHCoord, worldHCoord);
+    if (worldHCoord[3] == 0) {
+	debug5 << "slivr::ProjectScreenToWorld "
+	       << "Zero Division During Projection" 
+	       << std::endl;
+	std::cerr << "world coordinates: (" 
+		  << worldHCoord[0] << ", " 
+		  << worldHCoord[1] << ", " 
+		  << worldHCoord[2] << ", " 
+		  << worldHCoord[3] << ")" << std::endl
+		  << "clip space coordinate: ("
+		  << clipHCoord[0] << ", " 
+		  << clipHCoord[1] << ", " 
+		  << clipHCoord[2] << ", "
+		  << clipHCoord[3] << std::endl;
+	std::cerr << "Matrix: " << *imvp << std::endl;
+	EXCEPTION1(VisItException, "Zero Division During Projection");
+    }
+    
+    // normalize world space coordinate	
+    worldCoord[0] = worldHCoord[0]/worldHCoord[3];
+    worldCoord[1] = worldHCoord[1]/worldHCoord[3];
+    worldCoord[2] = worldHCoord[2]/worldHCoord[3];
+}
+
+void
+slivr::ProjectScreenToCamera
+(const int screenCoord[2], const double z,
+ const int screenWidth, const int screenHeight, 
+ vtkMatrix4x4 *imvp, double cameraCoord[3])
+{
+    // remove panning
+    const int x = screenCoord[0];
+    const int y = screenCoord[1];
+    
+    // do projection
+    double cameraHCoord[4] = {0,0,0,1};
+    double clipHCoord[4] = {
+	(x - screenWidth /2.0)/(screenWidth /2.0),
+	(y - screenHeight/2.0)/(screenHeight/2.0),
+	z,
+	1.0};
+    imvp->MultiplyPoint(clipHCoord, cameraHCoord);
+    if (cameraHCoord[3] == 0) {
+	debug5 << "slivr::ProjectScreenToWorld "
+	       << "Zero Division During Projection" 
+	       << std::endl;
+	std::cerr << "world coordinates: (" 
+		  << cameraHCoord[0] << ", " 
+		  << cameraHCoord[1] << ", " 
+		  << cameraHCoord[2] << ", " 
+		  << cameraHCoord[3] << ")" << std::endl
+		  << "clip space coordinate: ("
+		  << clipHCoord[0] << ", " 
+		  << clipHCoord[1] << ", " 
+		  << clipHCoord[2] << ", "
+		  << clipHCoord[3] << std::endl;
+	std::cerr << "Matrix: " << *imvp << std::endl;
+	EXCEPTION1(VisItException, "Zero Division During Projection");
+    }
+    
+    // normalize world space coordinate	
+    cameraCoord[0] = cameraHCoord[0]/cameraHCoord[3];
+    cameraCoord[1] = cameraHCoord[1]/cameraHCoord[3];
+    cameraCoord[2] = cameraHCoord[2]/cameraHCoord[3];
+}
+
+void
+slivr::ProjectWorldToScreenCube
+(const double cube[6], const int screenWidth, const int screenHeight, 
+ const double panPercentage[2], const double imageZoom, vtkMatrix4x4 *mvp, 
+ int screenExtents[4], double depthExtents[2])
+{
+    int xMin = std::numeric_limits<int>::max();
+    int xMax = std::numeric_limits<int>::min();
+    int yMin = std::numeric_limits<int>::max();
+    int yMax = std::numeric_limits<int>::min();
+    double zMin = std::numeric_limits<double>::max();
+    double zMax = std::numeric_limits<double>::min();
+
+    float coordinates[8][3];
+    coordinates[0][0] = cube[0];   
+    coordinates[0][1] = cube[2];   
+    coordinates[0][2] = cube[4];	
+
+    coordinates[1][0] = cube[1];   
+    coordinates[1][1] = cube[2];   
+    coordinates[1][2] = cube[4];	
+
+    coordinates[2][0] = cube[1];  
+    coordinates[2][1] = cube[3];
+    coordinates[2][2] = cube[4];	
+
+    coordinates[3][0] = cube[0]; 
+    coordinates[3][1] = cube[3]; 
+    coordinates[3][2] = cube[4];
+
+    coordinates[4][0] = cube[0];
+    coordinates[4][1] = cube[2];
+    coordinates[4][2] = cube[5];
+
+    coordinates[5][0] = cube[1]; 
+    coordinates[5][1] = cube[2]; 
+    coordinates[5][2] = cube[5];	
+
+    coordinates[6][0] = cube[1]; 
+    coordinates[6][1] = cube[3];
+    coordinates[6][2] = cube[5];
+
+    coordinates[7][0] = cube[0]; 
+    coordinates[7][1] = cube[3]; 
+    coordinates[7][2] = cube[5];
+
+    double worldCoord[3];
+    int screenCoord[2]; double depth;
+    for (int i=0; i<8; i++)
+    {
+	worldCoord[0] = coordinates[i][0];
+	worldCoord[1] = coordinates[i][1];
+	worldCoord[2] = coordinates[i][2];
+	depth = slivr::ProjectWorldToScreen
+	    (worldCoord, screenWidth, screenHeight, 
+	     panPercentage, imageZoom, mvp, screenCoord);
+	// clamp values
+	screenCoord[0] = CLAMP(screenCoord[0], 0, screenWidth);
+	screenCoord[1] = CLAMP(screenCoord[1], 0, screenHeight);
+	screenExtents[0] = xMin = std::min(xMin, screenCoord[0]);
+	screenExtents[1] = xMax = std::max(xMax, screenCoord[0]);
+	screenExtents[2] = yMin = std::min(yMin, screenCoord[1]);
+	screenExtents[3] = yMax = std::max(yMax, screenCoord[1]);
+	depthExtents[0] = zMin = std::min(zMin, depth);
+	depthExtents[1] = zMax = std::max(zMax, depth);
+    }
+}
+
+
+void
+slivr::CompositeBackground(int screen[2],
+			 int compositedImageExtents[4],
+			 int compositedImageWidth,
+			 int compositedImageHeight,
+			 float *compositedImageBuffer,
+			 unsigned char *opaqueImageColor,
+			 float         *opaqueImageDepth,
+			 unsigned char *&imgFinal)
+{
+#ifdef VISIT_OSPRAY
+    if (UseThreadedBlend_MetaData) {
+    visit::CompositeBackground(screen,
+			       compositedImageExtents,
+			       compositedImageWidth,
+			       compositedImageHeight,
+			       compositedImageBuffer,
+			       opaqueImageColor,
+			       opaqueImageDepth,
+			       imgFinal);
+    } else {
+#endif
+    for (int y = 0; y < screen[1]; y++)
+    {
+	for (int x = 0; x < screen[0]; x++)
+	{
+	    int indexScreen     = y * screen[0] + x;
+	    int indexComposited =
+		(y - compositedImageExtents[2]) * compositedImageWidth +
+		(x - compositedImageExtents[0]);
+
+	    bool insideComposited = 
+		((x >= compositedImageExtents[0] && 
+		  x < compositedImageExtents[1]) &&
+		 (y >= compositedImageExtents[2] && 
+		  y < compositedImageExtents[3]));
+
+	    if (insideComposited)
+	    {
+		if (compositedImageBuffer[indexComposited*4 + 3] == 0)
+		{
+		    // No data from rendering here! - Good
+		    imgFinal[indexScreen * 3 + 0] = 
+			opaqueImageColor[indexScreen * 3 + 0];
+		    imgFinal[indexScreen * 3 + 1] = 
+			opaqueImageColor[indexScreen * 3 + 1];
+		    imgFinal[indexScreen * 3 + 2] = 
+			opaqueImageColor[indexScreen * 3 + 2];
+		}
+		else
+		{
+		    // Volume in front
+		    float alpha = 
+			(1.0 - compositedImageBuffer[indexComposited * 4 + 3]);
+		    imgFinal[indexScreen * 3 + 0] = 
+			CLAMP(opaqueImageColor[indexScreen * 3 + 0] * alpha +
+			      compositedImageBuffer[indexComposited * 4 + 0] *
+			      255.f,
+			      0.f, 255.f);
+		    imgFinal[indexScreen * 3 + 1] = 
+			CLAMP(opaqueImageColor[indexScreen * 3 + 1] * alpha +
+			      compositedImageBuffer[indexComposited * 4 + 1] *
+			      255.f,
+			      0.f, 255.f);
+		    imgFinal[indexScreen * 3 + 2] =
+			CLAMP(opaqueImageColor[indexScreen * 3 + 2] * alpha +
+			      compositedImageBuffer[indexComposited * 4 + 2] *
+			      255.f,
+			      0.f, 255.f);
+		}
+	    }
+	    else
+	    {
+		// Outside bounding box: Use the background : Good
+		imgFinal[indexScreen * 3 + 0] = 
+		    opaqueImageColor[indexScreen * 3 + 0];
+		imgFinal[indexScreen * 3 + 1] =
+		    opaqueImageColor[indexScreen * 3 + 1];
+		imgFinal[indexScreen * 3 + 2] =
+		    opaqueImageColor[indexScreen * 3 + 2];
+	    }
+	}
+    }
+#ifdef VISIT_OSPRAY
+    }
+#endif
+}
+
+
+// ****************************************************************************
+//  Function:  
+//
+//  Purpose:
+//    
+//
+//  Programmer:  
+//  Creation:    
+//
+// ****************************************************************************
+
+void WriteArrayToPPM(std::string filename, float * image, int dimX, int dimY)
+{
+    std::ofstream outputFile((filename+ ".ppm").c_str(), 
+			     std::ios::out | std::ios::binary);
+    outputFile <<  "P6\n" << dimX << "\n" << dimY << "\n" << 255 << "\n"; 
+    for (int y=dimY-1; y>=0; --y)
+    {
+        for (int x=0; x<dimX; ++x)
+        {
+            int index = (y * dimX + x)*4;
+            char color[3];
+            float alpha = image[index + 3];
+            color[0] = CLAMP(image[index + 0]*alpha, 0.0f, 1.0f) * 255;
+            color[1] = CLAMP(image[index + 1]*alpha, 0.0f, 1.0f) * 255;
+            color[2] = CLAMP(image[index + 2]*alpha, 0.0f, 1.0f) * 255;
+            outputFile.write(color,3);
+        }
+    } 
+    outputFile.close();
+}
+
+void WriteArrayToPPM(std::string filename, 
+		     unsigned char *image, 
+		     int dimX, int dimY)
+{
+    std::ofstream outputFile((filename+ ".ppm").c_str(), 
+			     std::ios::out | std::ios::binary);
+    outputFile <<  "P6\n" << dimX << "\n" << dimY << "\n" << 255 << "\n"; 
+    for (int y=dimY-1; y>=0; --y)
+    {
+	outputFile.write(reinterpret_cast<char*>(&image[y * dimX * 3]), 
+			 dimX * 3);
+    } 
+    outputFile.close();
+}
+
+void WriteArrayGrayToPPM(std::string filename, 
+			 float* image, 
+			 int dimX, int dimY)
+{
+    std::ofstream outputFile((filename+ ".ppm").c_str(), 
+			     std::ios::out | std::ios::binary);
+    outputFile <<  "P6\n" << dimX << "\n" << dimY << "\n" << 255 << "\n"; 
+    for (int y=dimY-1; y>=0; --y)
+    {
+        for (int x=0; x<dimX; ++x)
+        {
+            int index = (y * dimX + x);
+	    char var = CLAMP(image[index], 0.f, 1.f) * 255;
+            char color[3];
+            color[0] = var;
+            color[1] = var;
+            color[2] = var;
+            outputFile.write(color,3);
+        }
+    } 
+    outputFile.close();
+}
+
+// ****************************************************************************
+//  Struct:  convexHull
+//
+//  Purpose:
+//    Holds the image data generated
+//
+//  Programmer:  
+//  Creation:    
+//
+// ****************************************************************************
+int slivr::ConvexHull::Overlap(ConvexHull _hull) 
+{
+    if ( (_hull.extents[1] < extents[0]) || 
+	 (_hull.extents[0] > extents[1]) )   // No overlap in X
+    {
+	if ( (_hull.extents[3] < extents[2]) || 
+	     (_hull.extents[2] > extents[3]) )   // No overlap in Y
+	{
+	    if ( (_hull.extents[5] < extents[4]) ||
+		 (_hull.extents[4] > extents[5]) )   // No overlap in Z
+	    {
+		return 0;
+	    }
+	    else
+	    {
+		return 3;
+	    }
+	}
+	else
+	{
+	    return 2;
+	}
+    }
+    else
+    {
+	return 1;
+    }
+}
diff --git a/avt/Filters/avtSLIVRImgMetaData.h b/avt/Filters/avtSLIVRImgMetaData.h
new file mode 100644
index 000000000..91fe09cbd
--- /dev/null
+++ b/avt/Filters/avtSLIVRImgMetaData.h
@@ -0,0 +1,217 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef IMG_METADATA_H
+#define IMG_METADATA_H
+
+#include <vtkMatrix4x4.h>
+#include <stdio.h>
+#include <string>
+#include <iostream>
+#include <limits>
+#include <cmath>
+
+// ****************************************************************************
+//  Namespace:  slivr
+//
+//  Purpose:
+//    
+//
+//  Programmer:  
+//  Creation:   
+//
+// ****************************************************************************
+namespace slivr
+{
+    double ProjectWorldToScreen
+	(const double worldCoord[3], 
+	 const int screenWidth, const int screenHeight,	 
+	 const double panPercentage[2], const double imageZoom,
+	 vtkMatrix4x4 *mvp, int screenCoord[2]);
+  
+    void ProjectScreenToWorld
+	(const int screenCoord[2], const double z,
+	 const int screenWidth, const int screenHeight, 
+	 const double panPercentage[2], const double imageZoom,
+	 vtkMatrix4x4 *imvp, double worldCoord[3]);
+
+    void ProjectScreenToCamera
+	(const int screenCoord[2], const double z,
+	 const int screenWidth, const int screenHeight,
+	 vtkMatrix4x4 *imvp, double cameraCoord[3]);
+
+    inline void ProjectScreenToWorld
+	(const int x, const int y, const double z,
+	 const int screenWidth, const int screenHeight, 
+	 const double panPercentage[2], const double imageZoom,
+	 vtkMatrix4x4 *imvp, double worldCoord[3]) 
+    {
+	int screen_coord[2] = {x, y};
+	slivr::ProjectScreenToWorld(screen_coord, z, screenWidth, screenHeight, 
+				    panPercentage, imageZoom, imvp, worldCoord);
+    }
+
+    void ProjectWorldToScreenCube
+	(const double cube[6], const int screenWidth, const int screenHeight, 
+	 const double panPercentage[2], const double imageZoom, 
+	 vtkMatrix4x4 *mvp,int screenExtents[4], double depthExtents[2]);
+
+    void CompositeBackground(int screen[2],
+			     int compositedImageExtents[4],
+			     int compositedImageWidth,
+			     int compositedImageHeight,
+			     float *compositedImageBuffer,
+			     unsigned char *opaqueImageColor,
+			     float         *opaqueImageDepth,
+			     unsigned char *&imgFinal);
+};
+
+// ****************************************************************************
+//  Struct:  ImgMetaData
+//
+//  Purpose:
+//    Holds information about patches but not the image 
+//
+//  Programmer:  
+//  Creation:   
+//
+// ****************************************************************************
+namespace slivr
+{
+    struct ImgMetaData
+    {
+	int procId;       // processor that produced the patch
+	int patchNumber;  // id of the patch on that processor
+	int destProcId;   // destination proc where this patch gets composited
+	int inUse;        // whether the patch is composed locally or not
+	int dims[2];      // height, width
+	int screen_ll[2]; // (lower left)  position in the final image
+	int screen_ur[2]; // (upper right)
+	float avg_z;      // camera space depth of the patch (average)
+	float eye_z;      // camera space z
+	float clip_z;     // clip space z
+    };
+};
+
+// ****************************************************************************
+//  Struct:  ImgData
+//
+//  Purpose:
+//    Holds the image data generated
+//
+//  Programmer:  
+//  Creation:    
+//
+// ****************************************************************************
+namespace slivr 
+{
+    struct ImgData
+    {
+	// acts as a key
+	int procId;        // processor that produced the patch
+	int patchNumber;   // id of the patch on that processor
+	float *imagePatch; // the image data - RGBA
+	ImgData() { imagePatch = NULL; }
+	bool operator==(const ImgData &a) {
+	    return (patchNumber == a.patchNumber);
+	}
+    };
+}
+
+// ****************************************************************************
+//  Struct:  convexHull
+//
+//  Purpose:
+//    Holds the image data generated
+//
+//  Programmer:  
+//  Creation:    
+//
+// ****************************************************************************
+namespace slivr 
+{
+    struct ConvexHull
+    {
+	int numPatches;
+	// [0] rows along x axis, [1] rows along y axis, [2] rows along z axis
+	int arrangement[3];
+	float extents[6];       // minX, maxX   minY, maxY   minZ, maxZ
+	float cellDims[3];      // x, y, z
+	float tolerance;  
+	// amount of overlap that is considered ok
+	// -- typically 2 cells for cell centered data
+	// 0: no overlap  
+	// 1: overlpa in Z 
+	// 2: overlap in Y
+	// 3: overlap in Z
+	int Overlap(ConvexHull);
+    };
+};
+
+// ****************************************************************************
+//  Template:  
+//
+//  Purpose:
+//    
+//
+//  Programmer:  
+//  Creation:    
+//
+// ****************************************************************************
+#define CLAMP(x, l, h) (x > l ? x < h ? x : h : l)
+#define M_MIN(x, r) (x < r ? x : r)
+#define M_MAX(x, r) (x > r ? x : r)
+
+// ****************************************************************************
+//  Function:  
+//
+//  Purpose:
+//    
+//
+//  Programmer:  
+//  Creation:    
+//
+// ****************************************************************************
+void WriteArrayToPPM
+(std::string filename, float *image, int dimX, int dimY);
+void WriteArrayToPPM
+(std::string filename, unsigned char *image, int dimX, int dimY);
+void WriteArrayGrayToPPM
+(std::string filename , float * image, int dimX, int dimY);
+
+#endif//IMG_METADATA_H
diff --git a/avt/Filters/avtSLIVROSPRayFilter.C b/avt/Filters/avtSLIVROSPRayFilter.C
new file mode 100644
index 000000000..fa6251993
--- /dev/null
+++ b/avt/Filters/avtSLIVROSPRayFilter.C
@@ -0,0 +1,686 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+#include "avtSLIVROSPRayFilter.h"
+
+#include <avtMemory.h>
+#include <avtParallel.h>
+#include <ImproperUseException.h>
+#include <TimingsManager.h>
+
+#ifdef __unix__
+# include <unistd.h>
+#endif
+
+// helper
+namespace slivr {
+    // output stream
+    std::ostream *osp_out = &DebugStream::Stream5();
+    std::ostream *osp_err = &DebugStream::Stream1();
+};
+
+double slivr::deg2rad (double degrees) {
+    return degrees * 4.0 * atan (1.0) / 180.0;
+}
+double slivr::rad2deg (double radins) {
+    return radins / 4.0 / atan (1.0) * 180.0;
+}
+
+#ifdef VISIT_OSPRAY
+// other function
+void 
+OSPVisItVolume::Set(int type, void *ptr, double *X, double *Y, double *Z, 
+		    int nX, int nY, int nZ,
+		    double volumePBox[6], 
+		    double volumeBBox[6], 
+		    double mtl[4], float sr, bool shading)
+{
+    /* OSPRay Volume */
+    specularKs    = (float)mtl[2];
+    specularNs    = (float)mtl[3];
+    enableShading = shading;
+    samplingRate  = sr;
+    // TODO: It seems if a volume is recovered from a session
+    // ospray will crash during zooming ...
+    // So we refresh volume everytime to fix the bug
+    // which means we need to disable grid accelerator
+    // to speed things up. Until I found the reason of crashing
+    if (ptr != dataPtr) {
+        ospout << "[ospray] update data" << std::endl;
+    };
+    if (true/*!finished*/) {
+	// Because we initialized the volume each frame
+	// we need to removed the old volume from model first
+	volumeType = OSP_INVALID;
+	InitVolume();
+	SetVolume(type, ptr, X, Y, Z, nX, nY, nZ,
+		  volumePBox, volumeBBox);
+    }
+    /* OSPRay Model */
+    if (true/*!finished*/) {
+	worldType = OSP_INVALID; 
+	InitWorld();
+	SetWorld();
+    }
+    /* update volume */
+    finished = true;
+}
+
+// ospModel component
+void OSPVisItVolume::InitWorld() {
+    if (worldType == OSP_INVALID) {
+	CleanWorld();
+	worldType = OSP_VALID;
+	world = ospNewModel();
+    }
+}
+void OSPVisItVolume::SetWorld() {
+    if (world != NULL) { 
+	ospAddVolume(world, volume);
+	ospCommit(world);
+    }
+}
+
+// ospVolume component
+void OSPVisItVolume::InitVolume(unsigned char type) {
+    if (volumeType != type) { // only initialize once
+	CleanVolume();
+	volumeType = type;
+	switch (type) {
+	case (OSP_BLOCK_BRICKED_VOLUME):
+	    volume = ospNewVolume("block_bricked_volume"); 
+	    break;
+	case (OSP_SHARED_STRUCTURED_VOLUME):
+	    volume = ospNewVolume("visit_shared_structured_volume"); 
+	    break;
+	default:
+	    debug1 << "ERROR: ospray volume not initialized"
+		   << std::endl;
+	    volumeType = OSP_INVALID;
+	    EXCEPTION1(VisItException, 
+		       "ERROR: ospray volume not initialized");
+	}
+    }
+}
+void 
+OSPVisItVolume::SetVolume(int type, void *ptr, 
+			  double *X, double *Y, double *Z, 
+			  int nX, int nY, int nZ,
+			  double volumePBox[6], double volumeBBox[6]) 
+{
+    // calculate volume data type
+    if (type == VTK_UNSIGNED_CHAR) {
+	dataType = "uchar";
+	voxelDataType = OSP_UCHAR;
+    } else if (type == VTK_SHORT) {
+	dataType = "short";
+	voxelDataType = OSP_SHORT;
+    } else if (type == VTK_UNSIGNED_SHORT) {
+	dataType = "ushort";
+	voxelDataType = OSP_USHORT;
+    } else if (type == VTK_FLOAT) {
+	dataType = "float";
+	voxelDataType = OSP_FLOAT;
+    } else if (type == VTK_DOUBLE) {
+	dataType = "double";
+	voxelDataType = OSP_DOUBLE;
+    } else {
+	debug1 << "ERROR: Unsupported ospray volume type" << std::endl;
+	EXCEPTION1(VisItException, "ERROR: Unsupported ospray volume type");
+    }
+    ospout << "[ospray] data type " << dataType << std::endl;
+    // assign data pointer
+    dataPtr = ptr;
+    // assign structure
+    regionStart.x   = volumePBox[0];
+    regionStart.y   = volumePBox[1];
+    regionStart.z   = volumePBox[2];
+    regionStop.x    = volumePBox[3];
+    regionStop.y    = volumePBox[4];
+    regionStop.z    = volumePBox[5];
+    regionSize.x    = nX;
+    regionSize.y    = nY;
+    regionSize.z    = nZ;
+    regionSpacing.x = (regionStop.x-regionStart.x)/((float)regionSize.x-1.0f);
+    regionSpacing.y = (regionStop.y-regionStart.y)/((float)regionSize.y-1.0f);
+    regionSpacing.z = (regionStop.z-regionStart.z)/((float)regionSize.z-1.0f);
+    regionLowerClip.x = volumeBBox[0];
+    regionLowerClip.y = volumeBBox[1];
+    regionLowerClip.z = volumeBBox[2];
+    regionUpperClip.x = volumeBBox[3];
+    regionUpperClip.y = volumeBBox[4];
+    regionUpperClip.z = volumeBBox[5];
+
+    // other objects
+    ospSetString(volume, "voxelType", dataType.c_str());
+    ospSetObject(volume, "transferFunction", parent->transferfcn.transferfcn);
+
+    // commit voxel data
+    if (voxelData != NULL) { 
+	debug1 << "ERROR: Found VoxelData to be non-empty "
+	       << "while creating new volume" << std::endl;
+	EXCEPTION1(VisItException, 
+		   "ERROR: Found VoxelData to be non-empty "
+		   "while creating new volume");
+    }
+    voxelSize = nX * nY * nZ;
+    voxelData = ospNewData(voxelSize, voxelDataType,
+			   dataPtr, OSP_DATA_SHARED_BUFFER);
+    ospSetData(volume, "voxelData", voxelData);
+
+    // commit volume
+    // -- no lighting by default
+    ospout << "[ospray] setting specular value to " << specularKs << std::endl;
+    osp::vec3f Ks; Ks.x = Ks.y = Ks.z = specularKs;
+    ospSetVec3f(volume, "specular", Ks);
+    ospSet1f(volume, "Ns", specularNs);
+    ospSet1i(volume, "gradientShadingEnabled", (int)enableShading);
+    // -- other properties
+    osp::vec3f scaledBBoxLower;
+    osp::vec3f scaledBBoxUpper;
+    osp::vec3f scaledSpacing;
+    osp::vec3f scaledOrigin;
+    osp::vec3f scaledGlobalBBoxLower;
+    osp::vec3f scaledGlobalBBoxUpper;
+    scaledGlobalBBoxLower.x = parent->bounds[0] * regionScaling.x;
+    scaledGlobalBBoxUpper.x = parent->bounds[1] * regionScaling.x;
+    scaledGlobalBBoxLower.y = parent->bounds[2] * regionScaling.y;
+    scaledGlobalBBoxUpper.y = parent->bounds[3] * regionScaling.y;
+    scaledGlobalBBoxLower.z = parent->bounds[4] * regionScaling.z;
+    scaledGlobalBBoxUpper.z = parent->bounds[5] * regionScaling.z;
+    // -- x
+    scaledBBoxLower.x = regionLowerClip.x * parent->regionScaling.x;
+    scaledBBoxUpper.x = regionUpperClip.x * parent->regionScaling.x;
+    scaledSpacing.x   = regionSpacing.x   * parent->regionScaling.x;
+    scaledOrigin.x    = regionStart.x     * parent->regionScaling.x;
+    // -- y
+    scaledBBoxLower.y = regionLowerClip.y * parent->regionScaling.y;
+    scaledBBoxUpper.y = regionUpperClip.y * parent->regionScaling.y;
+    scaledSpacing.y   = regionSpacing.y   * parent->regionScaling.y;
+    scaledOrigin.y    = regionStart.y     * parent->regionScaling.y;
+    // -- z
+    scaledBBoxLower.z = regionLowerClip.z * parent->regionScaling.z;
+    scaledBBoxUpper.z = regionUpperClip.z * parent->regionScaling.z;
+    scaledSpacing.z   = regionSpacing.z   * parent->regionScaling.z;
+    scaledOrigin.z    = regionStart.z     * parent->regionScaling.z;
+    // -- commit ospray
+    ospSet1i(volume, "useGridAccelerator", 0);
+    ospSetVec3f(volume, "volumeClippingBoxLower", scaledBBoxLower);
+    ospSetVec3f(volume, "volumeClippingBoxUpper", scaledBBoxUpper);
+    ospSetVec3f(volume, "gridSpacing", scaledSpacing);
+    ospSetVec3f(volume, "gridOrigin",  scaledOrigin);
+    ospSetVec3i(volume, "dimensions",  regionSize);
+    ospSet1f(volume, "samplingRate", samplingRate);
+    ospSet1i(volume, "adaptiveSampling", 0);
+    ospSet1i(volume, "preIntegration", 1);
+    ospSet1i(volume, "singleShade", 0);
+    ospSetVec3f(volume, "volumeGlobalBoundingBoxLower", scaledGlobalBBoxLower);
+    ospSetVec3f(volume, "volumeGlobalBoundingBoxUpper", scaledGlobalBBoxUpper);
+    ospCommit(volume);
+}
+
+// ospFrameBuffer component     
+void OSPVisItVolume::InitFB(unsigned int width, unsigned int height)
+{
+    // preparation
+    osp::vec2i imageSize;
+    imageSize.x = width;
+    imageSize.y = height;
+    // create max depth texture
+    std::vector<float> maxDepth(width * height);
+    //
+    // The reason I use round(r * (N-1)) instead of floor(r * N) is that 
+    // during the composition phase, there will be a wired offset between
+    // rendered image and the background, which is about one pixel in size.
+    // Using round(r * (N - 1)) can remove the problem
+    //
+    // const int Xs = 
+    // 	floor(parent->camera.imgS.x * parent->camera.size[0]);
+    // const int Ys = 
+    // 	floor(parent->camera.imgS.y * parent->camera.size[1]);
+    // const int Xs = 
+    // 	round(parent->camera.imgS.x * (parent->camera.size[0]-1));
+    // const int Ys = 
+    // 	round(parent->camera.imgS.y * (parent->camera.size[1]-1));
+    //
+    // It seems this is the correct way of doing it
+    //
+    // It seems we need to also fix pan and zoom also
+    //
+    const int Xs = 
+    	std::min((int)round((parent->camera.r_xl + parent->camera.panx) * 
+			    parent->camera.size[0]),
+		 parent->camera.size[0]-1);
+    const int Ys =
+	std::min((int)round((parent->camera.r_yl + parent->camera.pany) * 
+			    parent->camera.size[1]),
+		 parent->camera.size[1]-1);
+    for (int i = 0; i < width; ++i) {
+    	for (int j = 0; j < height; ++j) {
+    	    maxDepth[i + j * width] = 
+    		parent->renderer.maxDepthBuffer
+		[Xs + i + (Ys + j) * parent->renderer.maxDepthSize.x];
+    	}
+    }
+    framebufferBg = ospNewTexture2D(imageSize, OSP_TEXTURE_R32F, 
+				    maxDepth.data(),
+				    OSP_TEXTURE_FILTER_NEAREST);
+    ospCommit(framebufferBg);
+    ospSetObject(parent->renderer.renderer, "maxDepthTexture", framebufferBg);
+    ospCommit(parent->renderer.renderer);
+    ospRelease(framebufferBg);
+    framebufferBg = NULL;
+    // create framebuffer
+    CleanFB();
+    framebuffer = ospNewFrameBuffer(imageSize, 
+				    OSP_FB_RGBA32F,
+				    OSP_FB_COLOR);
+}
+void OSPVisItVolume::RenderFB() {
+    ospRenderFrame(framebuffer, parent->renderer.renderer, OSP_FB_COLOR);
+    framebufferData = (float*) ospMapFrameBuffer(framebuffer, OSP_FB_COLOR);
+}
+float* OSPVisItVolume::GetFBData() {
+    return framebufferData;
+}
+
+// ****************************************************************************
+//
+// OSPLight
+//
+// ****************************************************************************
+void OSPVisItLight::Init(const OSPRenderer& renderer)
+{
+    /* TODO check repeated initialization ? */
+    Clean();
+    aLight = ospNewLight(renderer, "ambient");
+    dLight = ospNewLight(renderer, "distant");
+    sLight = ospNewLight(renderer, "distant");
+    ospCommit(aLight);
+    ospCommit(dLight);
+    ospCommit(sLight);
+    OSPLight lights[3] = { aLight, dLight, sLight };
+    lightdata = ospNewData(3, OSP_OBJECT, lights);
+    ospCommit(lightdata);
+}
+void OSPVisItLight::Set(double materialProperties[4], double viewDirection[3])
+{
+    // light direction
+    osp::vec3f lightDir;
+    lightDir.x = (float)viewDirection[0];
+    lightDir.y = (float)viewDirection[1];
+    lightDir.z = (float)viewDirection[2];
+    // ambient light
+    ospSet1f(aLight, "intensity", (float)materialProperties[0]);
+    ospSet1i(aLight, "isVisible", 0);
+    ospCommit(aLight);
+    // directional light
+    ospSet1f(dLight, "intensity", (float)materialProperties[1]);
+    ospSet1f(dLight, "angularDiameter", 0.53f);
+    ospSet1i(dLight, "isVisible", 0);
+    ospSetVec3f(dLight, "direction", lightDir);
+    ospCommit(dLight);
+    // sun light
+    ospSet1f(sLight, "intensity", 1.5f /*TODO hard code it for now*/);
+    ospSet1f(sLight, "angularDiameter", 0.53f);
+    ospSet1i(sLight, "isVisible", 0);
+    ospSetVec3f(sLight, "direction", lightDir);
+    ospCommit(sLight);
+}
+
+// ****************************************************************************
+//
+// OSPRenderer
+//
+// ****************************************************************************
+void OSPVisItRenderer::Init() 
+{
+    if (rendererType == INVALID) {
+	Clean();
+	rendererType = SCIVIS;
+	renderer = ospNewRenderer("scivis");
+	lights.Init(renderer);
+    }
+}
+void OSPVisItRenderer::Set(double materialProperties[4],
+			   double viewDirection[3],
+			   bool flagUseShading) 
+{    
+    ospSet1f(renderer, "bgColor",   0.f);
+    ospSet1i(renderer, "aoSamples", aoSamples);
+    ospSet1i(renderer, "spp",       spp);
+    ospSet1i(renderer, "oneSidedLighting",      flagOneSidedLighting);
+    ospSet1i(renderer, "shadowsEnabled",        flagShadowsEnabled);
+    ospSet1i(renderer, "aoTransparencyEnabled", flagAoTransparencyEnabled);
+    if (flagUseShading)
+    {
+	ospout << "[ospray] use lighting w/ material " 
+	    << "ambient "    << materialProperties[0] << " "
+	    << "diffuse "    << materialProperties[1] << " "
+	    << "specular "   << materialProperties[2] << " "
+	    << "glossiness " << materialProperties[3] << std::endl;
+	lights.Set(materialProperties, viewDirection);
+	ospSetData(renderer, "lights", lights.lightdata);
+	ospCommit(renderer);	
+    }
+    ospCommit(renderer);
+}
+void OSPVisItRenderer::SetCamera(const OSPCamera& camera)
+{
+    ospSetObject(renderer, "camera", camera);
+    ospCommit(renderer);
+}
+void OSPVisItRenderer::SetModel(const OSPModel& world)
+{
+    ospSetObject(renderer, "model",  world);
+    ospCommit(renderer);
+}
+
+// ****************************************************************************
+//
+// OSPCamera
+//
+// ****************************************************************************
+void OSPVisItCamera::Init(State type) 
+{
+    if (cameraType != type) {
+	Clean();
+	cameraType = type;
+	switch (cameraType) {
+	case (PERSPECTIVE):
+	    camera = ospNewCamera("perspective");
+	    break;
+	case (ORTHOGRAPHIC):
+	    camera = ospNewCamera("orthographic");
+	    break;
+	default:
+	    cameraType = INVALID;
+	    EXCEPTION1(VisItException, "ERROR: wrong ospray camera type"); 
+	}
+    }
+}
+void OSPVisItCamera::Set(const double camp[3], 
+			 const double camf[3], 
+			 const double camu[3], 
+			 const double camd[3],
+			 const double sceneSize[2],
+			 const double aspect, 
+			 const double fovy, 
+			 const double zoom_ratio, 
+			 const double pan_ratio[2],
+			 const int bufferExtents[4],
+			 const int screenExtents[2]) 
+{
+    osp::vec3f camP, camD, camU;
+    camP.x = camp[0]; camP.y = camp[1]; camP.z = camp[2];    
+    camD.x = camd[0]; camD.y = camd[1]; camD.z = camd[2];
+    camU.x = camu[0]; camU.y = camu[1]; camU.z = camu[2];
+    panx = pan_ratio[0] * zoom_ratio;
+    pany = pan_ratio[1] * zoom_ratio;
+    size[0] = screenExtents[0];
+    size[1] = screenExtents[1];
+    zoom = zoom_ratio;
+    ospSetVec3f(camera, "pos", camP);
+    ospSetVec3f(camera, "dir", camD);
+    ospSetVec3f(camera, "up",  camU);
+    ospSet1f(camera, "aspect", aspect);
+    if      (cameraType == PERSPECTIVE)  { ospSet1f(camera, "fovy", fovy); }
+    else if (cameraType == ORTHOGRAPHIC) { 
+	ospSet1f(camera, "height", sceneSize[1]); 
+    }
+    ospCommit(camera);
+    this->SetScreen(bufferExtents[0], bufferExtents[1],
+		    bufferExtents[2], bufferExtents[3]);
+}
+void OSPVisItCamera::SetScreen(float xMin, float xMax, float yMin, float yMax) 
+{
+    r_xl = xMin/size[0] - panx; 
+    r_yl = yMin/size[1] - pany; 
+    r_xu = xMax/size[0] - panx;
+    r_yu = yMax/size[1] - pany;	
+    imgS.x = (r_xl - 0.5f) / zoom + 0.5f;
+    imgS.y = (r_yl - 0.5f) / zoom + 0.5f;
+    imgE.x = (r_xu - 0.5f) / zoom + 0.5f;
+    imgE.y = (r_yu - 0.5f) / zoom + 0.5f;
+    ospSetVec2f(camera, "imageStart", imgS);
+    ospSetVec2f(camera, "imageEnd",   imgE);
+    ospCommit(camera);
+}
+
+// ****************************************************************************
+//
+// OSPTransferFunction
+//
+// ****************************************************************************
+void OSPVisItTransferFunction::Init() 
+{
+    if (transferfcnType == INVALID) {
+	Clean();
+	transferfcnType = PIECEWISE_LINEAR;
+	transferfcn = ospNewTransferFunction("piecewise_linear");
+    }
+}
+void OSPVisItTransferFunction::Set(const OSPVisItColor *table,
+				   const unsigned int size, 
+				   const float datamin, 
+				   const float datamax) 
+{
+    std::vector<osp::vec3f> colors;
+    std::vector<float>      opacities;
+    for (int i = 0; i < size; ++i) {
+	osp::vec3f color;
+	color.x = table[i].R;
+	color.y = table[i].G;
+	color.z = table[i].B;
+	colors.push_back(color);
+	opacities.push_back(table[i].A);
+    }
+    OSPData colorData   = 
+	ospNewData(colors.size(), OSP_FLOAT3, colors.data());
+    OSPData opacityData = 
+	ospNewData(opacities.size(), OSP_FLOAT, opacities.data());
+    osp::vec2f range;
+    range.x = datamin;
+    range.y = datamax;
+    ospSetData(transferfcn, "colors",      colorData);
+    ospSetData(transferfcn, "opacities",   opacityData);
+    ospSetVec2f(transferfcn, "valueRange", range);
+    ospCommit(transferfcn);
+    ospRelease(colorData);
+    ospRelease(opacityData);
+}
+
+
+// ****************************************************************************
+//  Struct:  OSPContext
+//
+//  Purpose:
+//
+//
+//  Programmer:  
+//  Creation:   
+//
+// ****************************************************************************
+
+void OSPContext_ErrorFunc(OSPError, const char* msg) { 
+    osperr << "#osp: (rank " << PAR_Rank() << ")" 
+           << msg; 
+}
+void OSPContext_StatusFunc(const char* msg) { 
+    osperr << "#osp: (rank " << PAR_Rank() << ")" 
+           << msg; 
+}
+void OSPVisItContext::InitOSP(int numThreads) 
+{ 
+    OSPDevice device = ospGetCurrentDevice();
+    if (device == NULL) 
+    {
+	// check hostname
+#ifdef __unix__
+	char hname[200];
+	gethostname(hname, 200);
+        ospout << "[ospray] on host >> " << hname << "<<" << std::endl;;
+#endif
+	// initialize ospray
+        ospout << "[ospray] Initialize OSPRay";
+	device = ospNewDevice();	
+	// setup debug 
+	if (DebugStream::Level5()) {
+	    ospout << " debug mode";
+	    ospDeviceSet1i(device, "debug", 0);
+	}
+	// setup number of threads (this can only be hard-coded)
+	if (numThreads > 0) {
+	    ospout << " numThreads: " << numThreads;
+	    ospDeviceSet1i(device, "numThreads", numThreads);
+	}
+	ospout << std::endl;
+	ospDeviceSetErrorFunc(device, OSPContext_ErrorFunc);
+	ospDeviceSetStatusFunc(device, OSPContext_StatusFunc);
+	ospDeviceCommit(device);
+	ospSetCurrentDevice(device);
+	// load ospray module
+	OSPError err = ospLoadModule("visit");
+	if (err != OSP_NO_ERROR) {
+	    osperr << "[Error] can't load visit module" << std::endl;
+	}
+    }
+    initialized = true;
+}
+
+// We use this function to minimize interface
+void OSPVisItContext::Render(float xMin, float xMax, float yMin, float yMax,
+			     int imgWidth, int imgHeight,
+			     float*& dest, OSPVisItVolume* volume) 
+{
+    int timing_SetSubCamera = visitTimer->StartTimer();
+    camera.SetScreen(xMin, xMax, yMin, yMax);
+    visitTimer->StopTimer(timing_SetSubCamera,
+			  "[OSPRay] Calling OSPContext::SetSubCamera");
+
+    int timing_SetModel = visitTimer->StartTimer();
+    renderer.SetModel(volume->GetWorld());
+    renderer.SetCamera(camera.camera);
+    visitTimer->StopTimer(timing_SetModel,
+			  "[OSPRay] Calling OSPContext::SetModel");
+
+    int timing_InitFB = visitTimer->StartTimer();
+    volume->InitFB(imgWidth, imgHeight);
+    visitTimer->StopTimer(timing_InitFB,
+			  "[OSPRay] Calling OSPContext::InitFB");
+
+    int timing_RenderFB = visitTimer->StartTimer();
+    volume->RenderFB();
+    visitTimer->StopTimer(timing_RenderFB,
+			  "[OSPRay] Calling OSPContext::RenderFB");
+
+    int timing_stdcopy = visitTimer->StartTimer();
+    std::copy(volume->GetFBData(), 
+	      volume->GetFBData() + (imgWidth * imgHeight) * 4, dest);
+    visitTimer->StopTimer(timing_stdcopy, 
+			  "[OSPRay] Calling OSPContext::std::copy");
+}
+
+void OSPVisItContext::InitPatch(int id) 
+{
+    if (volumes.size() < id) {
+	debug1 << "ERROR: wrong patch index " << id << std::endl;
+	EXCEPTION1(VisItException, "ERROR: wrong patch index"); 
+	return;
+    }
+    if (volumes.size() == id) { 
+	volumes.push_back(id); 
+    }
+    volumes[id].parent = this;
+}
+#endif//VISIT_OSPRAY
+
+
+// ****************************************************************************
+//  Namespace:  slivr
+//
+//  Purpose:
+//    
+//
+//  Programmer:  
+//  Creation:   
+//
+// ****************************************************************************
+
+void slivr::CheckMemoryHere(const std::string& message, std::string debugN)
+{
+    if (debugN.compare("ospout") == 0) {	
+	slivr::CheckMemoryHere(message, *osp_out);
+    }
+    else if (debugN.compare("debug5") == 0) {
+	if (DebugStream::Level5()) {
+	    slivr::CheckMemoryHere(message, DebugStream::Stream5());
+	}       
+    }
+    else if (debugN.compare("debug4") == 0) {
+	if (DebugStream::Level4()) {
+	    slivr::CheckMemoryHere(message, DebugStream::Stream4());
+	}       
+    }
+    else if (debugN.compare("debug3") == 0) {
+	if (DebugStream::Level3()) {
+	    slivr::CheckMemoryHere(message, DebugStream::Stream3());
+	}       
+    }
+    else if (debugN.compare("debug2") == 0) {
+	if (DebugStream::Level2()) {
+	    slivr::CheckMemoryHere(message, DebugStream::Stream2());
+	}       
+    }
+    else if (debugN.compare("debug1") == 0) {
+	if (DebugStream::Level1()) {
+	    slivr::CheckMemoryHere(message, DebugStream::Stream1());
+	}       
+    }
+}
+
+void slivr::CheckMemoryHere(const std::string& message, std::ostream& out)
+{
+    unsigned long m_size, m_rss;
+    avtMemory::GetMemorySize(m_size, m_rss);
+    out << message << std::endl << "\t"
+	<< " Rank " << PAR_Rank()
+	<< " Memory use begin " << m_size 
+	<< " rss " << m_rss/(1024*1024) << " (MB)"
+	<< std::endl;
+}
diff --git a/avt/Filters/avtSLIVROSPRayFilter.h b/avt/Filters/avtSLIVROSPRayFilter.h
new file mode 100644
index 000000000..013b84910
--- /dev/null
+++ b/avt/Filters/avtSLIVROSPRayFilter.h
@@ -0,0 +1,766 @@
+/*****************************************************************************
+*
+* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
+* Produced at the Lawrence Livermore National Laboratory
+* LLNL-CODE-442911
+* All rights reserved.
+*
+* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
+* full copyright notice is contained in the file COPYRIGHT located at the root
+* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
+*
+* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
+* modification, are permitted provided that the following conditions are met:
+*
+*  - Redistributions of  source code must  retain the above  copyright notice,
+*    this list of conditions and the disclaimer below.
+*  - Redistributions in binary form must reproduce the above copyright notice,
+*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
+*    documentation and/or other materials provided with the distribution.
+*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
+* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
+* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
+* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
+* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
+* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
+* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+* DAMAGE.
+*
+*****************************************************************************/
+
+#ifndef AVT_OSPRAY_FILTER_H
+#define AVT_OSPRAY_FILTER_H
+
+#include <DebugStream.h>
+#include <TimingsManager.h>
+#include <ImproperUseException.h>
+
+#include <vtkType.h>
+#include <iostream>
+#include <cmath>
+#include <cstdlib>
+#include <string>
+#include <vector>
+
+#ifdef VISIT_OSPRAY
+# include "ospray/ospray.h"
+# include "ospray/visit/VisItImageComposite.h"
+# define OSP_PERSPECTIVE              1
+# define OSP_ORTHOGRAPHIC             2
+# define OSP_BLOCK_BRICKED_VOLUME     3
+# define OSP_SHARED_STRUCTURED_VOLUME 4
+# define OSP_INVALID                  5
+# define OSP_VALID                    6
+#else
+#define OSPRAY_ERROR_MSG \
+    "OSPRay is currently not built, please recompile VisIt with OSPRay support."
+#endif
+
+// ****************************************************************************
+// Debug ostreams customized for ospray
+// ****************************************************************************
+namespace slivr 
+{
+    extern std::ostream *osp_out;
+    extern std::ostream *osp_err;
+};
+
+// ****************************************************************************
+// Those function has to be inline, otherwise we need to link this library 
+// to other components manually
+// ****************************************************************************
+namespace slivr 
+{
+    // ************************************************************************
+    //
+    // Detect verbose from environmental variable
+    //
+    // ************************************************************************
+    inline bool InitVerbose() 
+    {
+#ifndef VISIT_OSPRAY
+	return false;
+#else
+        // ********************************************************************
+	//
+	// OSPRay defines following environmental variables
+	//
+	// OSPRAY_THREADS
+	// OSPRAY_SET_AFFINITY
+	// OSPRAY_DEBUG
+	// OSPRAY_LOG_LEVEL
+	// OSPRAY_LOG_OUTPUT
+	//
+	// We define one more environmental variable here
+	//
+	// OSPRAY_VERBOSE
+	//
+        // ********************************************************************
+	const char* env_verbose   = std::getenv("OSPRAY_VERBOSE");
+	const char* env_debug     = std::getenv("OSPRAY_DEBUG");
+	const char* env_log_level = std::getenv("OSPRAY_LOG_LEVEL");	
+	bool verbose = false;
+	if (env_verbose) {
+	    if (atoi(env_verbose) > 0) { verbose = true; }
+	}
+	if (env_debug) {
+	    if (atoi(env_debug) > 0) { verbose = true; }
+	}
+	if (env_log_level) {
+	    if (atoi(env_log_level) > 0) { verbose = true; }
+	}
+	if (verbose) {
+	    slivr::osp_out = &std::cout;
+	    slivr::osp_err = &std::cerr;
+	    return true;
+	} else {
+	    return false;
+	}
+#endif
+    }
+
+    // ************************************************************************
+    //
+    // Detect sample per pixel from environmental variable
+    //
+    // ************************************************************************
+    inline int InitOSPRaySpp() {
+#ifndef VISIT_OSPRAY
+	return 1;
+#else
+	int spp = 1;
+	const char* env_spp = std::getenv("OSPRAY_SPP");
+	if (env_spp) {
+	    if (atoi(env_spp) > 0) { 
+		spp = atoi(env_spp); 
+	    }
+	}	
+	return spp;
+#endif
+    }
+    inline bool CheckVerbose() // initialize OSPRAY_VERBOSE
+    {
+	static bool OSPRAY_VERBOSE = slivr::InitVerbose();
+	return OSPRAY_VERBOSE;
+    }
+    inline int CheckOSPRaySpp()
+    {
+	static int spp = InitOSPRaySpp();
+	return spp;
+    }
+};
+
+// ****************************************************************************
+//
+// Over-write ostream marcos
+//
+// ****************************************************************************
+#define ospout \
+    if (!slivr::CheckVerbose() && !DebugStream::Level5()) ; \
+    else (*slivr::osp_out)
+#define osperr \
+    if (!slivr::CheckVerbose() && !DebugStream::Level1()) ; \
+    else (*slivr::osp_err)
+
+// ****************************************************************************
+//  Struct:  OSPVisItVolume
+//
+//  Purpose:
+//    
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+class OSPVisItContext;
+class OSPVisItVolume 
+{
+ public:
+    void Set(int type, void *ptr, 
+	     double *X, double *Y, double *Z, 
+	     int nX, int nY, int nZ, 
+	     double volumePBox[6], double volumeBBox[6],
+	     double mtl[4], float sr, bool shading)
+#ifdef VISIT_OSPRAY
+	;
+#else
+    {};
+#endif
+
+#ifdef VISIT_OSPRAY
+ private:
+    friend class OSPVisItContext;
+ private:
+    OSPVisItContext *parent;
+
+    // objects owned by the struct
+    // -- ospray model ---
+    OSPModel            world;
+    unsigned char       worldType;
+    // --- ospray framebuffer ---
+    OSPFrameBuffer      framebuffer;
+    float              *framebufferData;
+    OSPTexture2D        framebufferBg;
+    // --- ospray volume ---
+    OSPVolume           volume;
+    unsigned char       volumeType;
+    // --- ospray data ---
+    OSPDataType         voxelDataType;
+    OSPData             voxelData;
+    size_t              voxelSize;
+    void*               dataPtr;
+    std::string         dataType;
+
+    // metadata for volume
+    int                 patchId;       // volume patch id
+    bool                finished;      // check if this volume is initialized
+    bool                enableShading;
+    bool                enableDVR;     // Distributed Volume Renderer
+    float               specularKs;
+    float               specularNs;
+    float               samplingRate;
+
+    // geometric parameters for volume
+    osp::vec3i          regionSize;
+    osp::vec3f          regionStart;
+    osp::vec3f          regionStop;
+    osp::vec3f          regionSpacing;
+    osp::vec3f          regionUpperClip;
+    osp::vec3f          regionLowerClip;
+    osp::vec3f          regionScaling;
+    
+ public:
+    // constructor
+    OSPVisItVolume(int id) {
+	// objects owned by the struct
+	world           = NULL;
+	worldType       = OSP_INVALID;
+	framebuffer     = NULL;
+	framebufferData = NULL;
+	framebufferBg   = NULL;
+	volume          = NULL;
+	volumeType      = OSP_INVALID;
+	voxelDataType   = OSP_VOID_PTR;
+	voxelData       = NULL;
+	voxelSize       = 0;
+	dataPtr         = NULL;
+	dataType        = "";
+	// metadata for volume
+	patchId = id;    
+	finished      = false; 
+	enableShading = false;
+	enableDVR     = false;
+	specularKs    = 1.0f;
+	specularNs    = 15.0f;
+	samplingRate  = 3.0f;
+	// geometric parameters for volume
+	regionSize.x  = regionSize.y  = regionSize.z  = 0;
+	regionStart.x = regionStart.y = regionStart.z = 0.0f;
+	regionStop.x  = regionStop.y  = regionStop.z  = 0.0f;
+	regionSpacing.x   = regionSpacing.y   = regionSpacing.z   = 0.0f;
+	regionUpperClip.x = regionUpperClip.y = regionUpperClip.z = 0.0f;
+	regionLowerClip.x = regionLowerClip.y = regionLowerClip.z = 0.0f;
+	regionScaling.x   = regionScaling.y   = regionScaling.z   = 1.0f;
+    }
+
+    // destructor
+    ~OSPVisItVolume() { Clean(); }    
+    void Clean() {
+	CleanFB();
+	CleanVolume();	
+	CleanWorld();
+    }
+    
+    // other function
+    bool GetDVRFlag() { return enableDVR; }
+    void SetDVRFlag(bool mode) { enableDVR = mode; }
+    bool GetFinishedFlag() { return finished; }
+    void SetFinishedFlag(bool f) { finished = f; } 
+
+    // ospModel component
+    OSPModel GetWorld() { return world; }
+    void InitWorld();
+    void SetWorld();
+    void CleanWorld() {
+	if (world != NULL) {	    
+	    ospRelease(world);
+	    world = NULL;
+	}
+	worldType = OSP_INVALID;
+    }
+	
+    // ospVolume component
+    void InitVolume(unsigned char type = OSP_SHARED_STRUCTURED_VOLUME); 
+    OSPVolume GetVolume() { return volume; }
+    void SetVolume(int type, void *ptr,
+		   double *X, double *Y, double *Z, 
+		   int nX, int nY, int nZ,
+		   double volumePBox[6], 
+		   double volumeBBox[6]);
+    void CleanVolume() {	
+	if (volume != NULL) { ospRelease(volume); volume = NULL; }
+	if (voxelData != NULL) { 
+	    ospRelease(voxelData);
+	    voxelData = NULL; 
+	}
+	volumeType = OSP_INVALID;
+    }
+
+    // framebuffer component     
+    void InitFB(unsigned int width, unsigned int height);
+    void RenderFB();
+    float* GetFBData();
+    void CleanFB() {
+	if (framebufferData != NULL) { 
+	    ospUnmapFrameBuffer(framebufferData, framebuffer); 
+	    framebufferData = NULL;
+	}
+	if (framebuffer != NULL) { 
+	    ospFreeFrameBuffer(framebuffer); 	    
+	    framebuffer = NULL;
+	}
+	if (framebufferBg != NULL) {
+	    ospRelease(framebufferBg); 	    
+	    framebufferBg = NULL;
+	}
+    }
+#endif//VISIT_OSPRAY
+};
+
+
+// ****************************************************************************
+//  Struct:  OSPVisItLight
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+#ifdef VISIT_OSPRAY
+struct OSPVisItLight
+{
+    OSPLight aLight;
+    OSPLight dLight;
+    OSPLight sLight; // constant sun light
+    OSPData  lightdata;
+    OSPVisItLight() {
+	aLight = NULL;
+	dLight = NULL;
+	sLight = NULL;
+	lightdata = NULL;
+    }
+    ~OSPVisItLight() { Clean(); }
+    void Clean() {/* TODO should we delete them? */}
+    void Init(const OSPRenderer& renderer);
+    void Set(double materialProperties[4], double viewDirection[3]);
+};
+#endif//VISIT_OSPRAY
+
+
+// ****************************************************************************
+//  Struct:  OSPVisItRenderer
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+struct OSPVisItRenderer
+{
+public:
+    enum State {
+	INVALID, /* TODO do we need this actually ? */
+	SCIVIS,
+    } rendererType;
+
+#ifdef VISIT_OSPRAY
+public:
+    OSPRenderer renderer;
+    OSPVisItLight lights;
+    // properties
+    int aoSamples;
+    int spp; //!< samples per pixel
+    bool flagOneSidedLighting;
+    bool flagShadowsEnabled;
+    bool flagAoTransparencyEnabled;
+    float       *maxDepthBuffer;  // depth buffer for the background (never delete)
+    osp::vec2i   maxDepthSize;    // buffer extents (minX, maxX, minY, max)  
+public:
+    OSPVisItRenderer() {
+	renderer = NULL;
+	rendererType = INVALID;
+	aoSamples = 0;
+	spp = slivr::CheckOSPRaySpp();
+	flagOneSidedLighting = false;
+	flagShadowsEnabled = false;
+	flagAoTransparencyEnabled = false;
+    }
+    ~OSPVisItRenderer() { Clean(); }
+    void Clean() {
+	if (renderer != NULL) {
+	    lights.Clean();
+	    ospRelease(renderer);
+	    renderer = NULL;
+	    rendererType = INVALID;
+	}
+    }
+    void SetCamera(const OSPCamera& camera);
+    void SetModel(const OSPModel& world);
+#endif
+
+    void Init()
+#ifdef VISIT_OSPRAY
+	;
+#else 
+    {};
+#endif
+
+    void Set(double materialProperties[4], double viewDirection[3], bool)
+#ifdef VISIT_OSPRAY
+	;
+#else 
+    {};
+#endif
+
+};
+
+
+// ****************************************************************************
+//  Struct:  OSPVisItCamera
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+struct OSPVisItCamera
+{
+public:
+    enum State {
+	INVALID,
+	PERSPECTIVE,
+	ORTHOGRAPHIC,
+    } cameraType;
+
+    void Init(State type)
+#ifdef VISIT_OSPRAY
+	;
+#else 
+    {};
+#endif
+
+    void Set(const double camp[3], 
+	     const double camf[3], 
+	     const double camu[3], 
+	     const double camd[3],
+	     const double sceneSize[2],
+	     const double aspect, 
+	     const double fovy, 
+	     const double zoom_ratio, 
+	     const double pan_ratio[2],
+	     const int bufferExtents[4],
+	     const int screenExtents[2])
+#ifdef VISIT_OSPRAY
+	;
+#else 
+    {};
+#endif
+
+    void SetScreen(float xMin, float xMax, float yMin, float yMax)
+#ifdef VISIT_OSPRAY
+	;
+#else 
+    {};
+#endif
+
+#ifdef VISIT_OSPRAY
+public:
+    OSPCamera camera;
+    float panx; // this is a ratio [0, 1]
+    float pany; // this is a ratio [0, 1]
+    float r_xl; 
+    float r_yl;
+    float r_xu;
+    float r_yu;
+    float zoom; 
+    int   size[2];
+    osp::vec2f imgS, imgE;
+public:
+    OSPVisItCamera() {
+	camera = NULL;
+	cameraType = INVALID;
+	panx = 0.0f;
+	pany = 0.0f;
+	zoom = 1.0f;
+	size[0] = size[1] = 0.0f;
+	imgS.x = 0.f;
+	imgS.y = 0.f;
+	imgE.x = 0.f;
+	imgE.y = 0.f;
+    }
+    ~OSPVisItCamera() { Clean(); }
+    void Clean() {
+	if (camera != NULL) {
+	    ospRelease(camera);
+	    camera = NULL;
+	    cameraType = INVALID;
+	}
+    }
+#endif//VISIT_OSPRAY
+};
+
+
+// ****************************************************************************
+//  Struct:  OSPVisItColor
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+struct OSPVisItColor { float R,G,B, A; };
+
+// ****************************************************************************
+//  Struct:  OSPVisItTransferFunction
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+struct OSPVisItTransferFunction
+{
+public:
+    enum State { INVALID, PIECEWISE_LINEAR, } transferfcnType;
+
+#ifdef VISIT_OSPRAY
+public:
+    OSPTransferFunction  transferfcn;
+public:
+    OSPVisItTransferFunction() {
+	transferfcn = NULL;
+	transferfcnType = INVALID;
+    }
+    void Clean() {
+	if (transferfcn != NULL) {
+	    ospRelease(transferfcn);
+	    transferfcn = NULL;
+	    transferfcnType = INVALID;
+	}
+    }
+#endif
+
+    void Init()
+#ifdef VISIT_OSPRAY
+	;
+#else 
+    {};
+#endif
+
+    void Set(const OSPVisItColor* table,
+	     const unsigned int size, 
+	     const float datamin,
+	     const float datamax)
+#ifdef VISIT_OSPRAY
+	;
+#else 
+    {};
+#endif
+
+};
+
+
+// ****************************************************************************
+//  Struct:  OSPVisItContext
+//
+//  Purpose:
+//
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+
+class OSPVisItContext
+{
+#ifdef VISIT_OSPRAY
+private:
+    friend class OSPVisItVolume;
+
+private:
+    // ************************************************************************
+    // class parameters
+    // ************************************************************************
+    osp::vec3f regionScaling;
+    double     bounds[6];
+    // ************************************************************************
+    // ospray mode
+    // ************************************************************************
+    bool initialized;
+#endif//VISIT_OSPRAY
+
+ public:
+    // ************************************************************************
+    // Members
+    // ************************************************************************   
+    OSPVisItRenderer renderer;
+    OSPVisItCamera   camera;
+    OSPVisItTransferFunction transferfcn;
+    std::vector<OSPVisItVolume> volumes;
+
+    // ************************************************************************
+    // We expose this in header because iy will be called in other components
+    // where we dont have direct library linkage
+    // ************************************************************************
+    OSPVisItContext() 
+    {
+#ifdef VISIT_OSPRAY
+	regionScaling.x = regionScaling.y = regionScaling.z = 1.0f;
+	initialized = false;
+#else
+	EXCEPTION1(ImproperUseException, OSPRAY_ERROR_MSG);
+#endif//VISIT_OSPRAY
+    }
+
+    // ************************************************************************
+    // We expose this in header because iy will be called in other components
+    // where we dont have direct library linkage
+    // ************************************************************************
+    ~OSPVisItContext() {	
+#ifdef VISIT_OSPRAY
+	// clean stuffs
+	volumes.clear();
+	renderer.Clean();
+	camera.Clean();
+	transferfcn.Clean();
+#endif//VISIT_OSPRAY
+    }
+
+    // ************************************************************************
+    // helper
+    // ************************************************************************
+    void Render(float xMin, float xMax, float yMin, float yMax,
+		int imgWidth, int imgHeight, 
+		float*& dest, OSPVisItVolume* volume)
+#ifdef VISIT_OSPRAY
+	;
+#else 
+    { EXCEPTION1(ImproperUseException, OSPRAY_ERROR_MSG); }; 
+#endif//VISIT_OSPRAY
+
+    // ************************************************************************
+    // parameters
+    // ************************************************************************
+    void SetDataBounds(double dbounds[6]) {
+#ifdef VISIT_OSPRAY
+	for (int i = 0; i < 6; ++i) { bounds[i] = dbounds[i]; }
+#else
+	EXCEPTION1(ImproperUseException, OSPRAY_ERROR_MSG);
+#endif//VISIT_OSPRAY
+    }
+    void SetBgBuffer(float* depth, int extents[4]) {
+#ifdef VISIT_OSPRAY
+	renderer.maxDepthBuffer = depth;
+	renderer.maxDepthSize.x = extents[1] - extents[0];
+	renderer.maxDepthSize.y = extents[3] - extents[2];
+#else
+	EXCEPTION1(ImproperUseException, OSPRAY_ERROR_MSG);
+#endif//VISIT_OSPRAY
+    }
+    void SetScaling(double s[3]) { 
+#ifdef VISIT_OSPRAY
+	regionScaling.x = (float)s[0];
+	regionScaling.y = (float)s[1];
+	regionScaling.z = (float)s[2]; 
+#else
+	EXCEPTION1(ImproperUseException, OSPRAY_ERROR_MSG);
+#endif//VISIT_OSPRAY
+    }
+
+    // ************************************************************************
+    // patch 
+    // ************************************************************************
+#ifdef VISIT_OSPRAY
+    void InitOSP(int numThreads = 0);
+    void InitPatch(int id);
+#else
+    void InitOSP(int numThreads = 0) {
+    	EXCEPTION1(ImproperUseException, OSPRAY_ERROR_MSG);
+    };
+    void InitPatch(int id) {
+    	EXCEPTION1(ImproperUseException, OSPRAY_ERROR_MSG);
+    };
+#endif//VISIT_OSPRAY
+
+    // ************************************************************************
+    // patch 
+    // ************************************************************************
+    OSPVisItVolume* GetPatch(int id) {
+#ifdef VISIT_OSPRAY
+	return &volumes[id]; 
+#else
+	EXCEPTION1(ImproperUseException, OSPRAY_ERROR_MSG);
+#endif//VISIT_OSPRAY
+    }
+
+};
+
+
+// ****************************************************************************
+//  Namespace:  slivr
+//
+//  Purpose:
+//    
+//
+//  Programmer: Qi WU
+//  Creation:   
+//
+// ****************************************************************************
+namespace slivr
+{
+    double deg2rad (double degrees);
+    double rad2deg (double radins);
+    void CheckMemoryHere(const std::string& message, 
+			 std::string debugN = "debug5");
+    void CheckMemoryHere(const std::string& message, 
+			 std::ostream& out);
+    inline void CheckSectionStart(const std::string& c, const std::string& f,
+				  int& timingDetail, const std::string& str) {
+	debug5 << c << "::" << f << " " << str << " Start" << std::endl;
+	timingDetail = visitTimer->StartTimer();	    
+    }
+    
+    inline void CheckSectionStop(const std::string& c, const std::string& f,
+				 int& timingDetail, const std::string& str) {
+	visitTimer->StopTimer(timingDetail, (c + "::" + f + " " + str).c_str());
+	slivr::CheckMemoryHere(("[" + c + "]" + " " + f + " " + str).c_str(), 
+			       "ospout");
+	debug5 << c << "::" << f << " " << str << " Done" << std::endl;
+    }
+};
+
+#endif//AVT_OSPRAY_FILTER_H
+
diff --git a/avt/Filters/avtSamplePointExtractor.C b/avt/Filters/avtSamplePointExtractor.C
index f1dd3c99e..2a46a4033 100644
--- a/avt/Filters/avtSamplePointExtractor.C
+++ b/avt/Filters/avtSamplePointExtractor.C
@@ -62,6 +62,7 @@
 #include <vtkIdList.h>
 #include <vtkRectilinearGrid.h>
 
+#include <avtCallback.h>
 #include <avtCellList.h>
 #include <avtDatasetExaminer.h>
 #include <avtHexahedronExtractor.h>
@@ -174,26 +175,31 @@ avtSamplePointExtractor::avtSamplePointExtractor(int w, int h, int d)
 
     modeIs3D = true;
     SetKernelBasedSampling(false);
-
+    
     shouldSetUpArbitrator    = false;
     arbitratorPrefersMinimum = false;
     arbitrator               = NULL;
-
+    
     patchCount = 0;
-
+    
     trilinearInterpolation = false;
     rayCastingSLIVR = false;
     rayCastingSLIVRParallel = false;
-
+    
     modelViewProj = vtkMatrix4x4::New();
-
+    
     lighting = false;
     lightPosition[0] = lightPosition[1] = lightPosition[2] = 0.0;   lightPosition[3] = 1.0;
     lightDirection[0] = 0; lightDirection[1] = 0; lightDirection[2] = -1;
-    materialProperties[0] = 0.4; materialProperties[1] = 0.75; materialProperties[3] = 0.0; materialProperties[3] = 15.0;
-
-    depthBuffer = NULL;
+    materialProperties[0] = 0.4; 
+    materialProperties[1] = 0.75; 
+    materialProperties[2] = 0.0; 
+    materialProperties[3] = 15.0;
+    
+    depthBuffer    = NULL;
     rgbColorBuffer = NULL;
+
+    ospray = NULL;
 }
 
 
@@ -261,8 +267,7 @@ avtSamplePointExtractor::~avtSamplePointExtractor()
         delete arbitrator;
         arbitrator = NULL;
     }
-
-    delImgPatches();
+    DelImgPatches();
 }
 
 
@@ -327,10 +332,10 @@ void
 avtSamplePointExtractor::RestrictToTile(int wmin, int wmax, int hmin, int hmax)
 {
     shouldDoTiling = true;
-    width_min  = wmin;
-    width_max  = wmax;
-    height_min = hmin;
-    height_max = hmax;
+    widthMin  = wmin;
+    widthMax  = wmax;
+    heightMin = hmin;
+    heightMax = hmax;
     modified = true;
 }
 
@@ -371,12 +376,20 @@ avtSamplePointExtractor::Execute(void)
 {
     int timingsIndex = visitTimer->StartTimer();
 
+    int timings_SetUpExtractors = visitTimer->StartTimer();
     SetUpExtractors();
+    visitTimer->StopTimer(timings_SetUpExtractors, 
+			  "avtSamplePointExtractor::Execute "
+			  "SetUpExtractors()");
 
+    int timings_ExecuteTree = visitTimer->StartTimer();
     avtDataTree_p tree = GetInputDataTree();
     totalNodes = tree->GetNumberOfLeaves();
     currentNode = 0;
     ExecuteTree(tree);
+    visitTimer->StopTimer(timings_ExecuteTree, 
+			  "avtSamplePointExtractor::Execute "
+			  "ExecuteTree(ree)");
 
     visitTimer->StopTimer(timingsIndex, "Sample point extraction");
 }
@@ -421,7 +434,6 @@ avtSamplePointExtractor::SetUpExtractors(void)
     avtSamplePoints_p output = GetTypedOutput();
     if (kernelBasedSampling)
         output->SetUseWeightingScheme(true);
-
     //
     // This will always be NULL the first time through.  For subsequent tiles
     // (provided we are doing tiling) will not have this issue.
@@ -433,7 +445,7 @@ avtSamplePointExtractor::SetUpExtractors(void)
     output->ResetCellList();
     avtVolume *volume = output->GetVolume();
     if (shouldDoTiling)
-        volume->Restrict(width_min, width_max-1, height_min, height_max-1);
+        volume->Restrict(widthMin, widthMax-1, heightMin, heightMax-1);
 
     if (hexExtractor != NULL)
     {
@@ -496,20 +508,13 @@ avtSamplePointExtractor::SetUpExtractors(void)
 
     if (shouldDoTiling)
     {
-        hexExtractor->Restrict(width_min, width_max-1, 
-                               height_min, height_max-1);
-        hex20Extractor->Restrict(width_min, width_max-1, 
-                                 height_min, height_max-1);
-        massVoxelExtractor->Restrict(width_min, width_max-1,
-                                     height_min, height_max-1);
-        tetExtractor->Restrict(width_min, width_max-1,
-                               height_min, height_max-1);
-        wedgeExtractor->Restrict(width_min, width_max-1, height_min, 
-                                 height_max-1);
-        pointExtractor->Restrict(width_min, width_max-1,
-                                 height_min, height_max-1);
-        pyramidExtractor->Restrict(width_min, width_max-1,
-                                   height_min, height_max-1);
+        hexExtractor->Restrict(widthMin, widthMax-1, heightMin, heightMax-1);
+        hex20Extractor->Restrict(widthMin, widthMax-1, heightMin, heightMax-1);
+        massVoxelExtractor->Restrict(widthMin, widthMax-1, heightMin, heightMax-1);
+        tetExtractor->Restrict(widthMin, widthMax-1, heightMin, heightMax-1);
+        wedgeExtractor->Restrict(widthMin, widthMax-1, heightMin, heightMax-1);
+        pointExtractor->Restrict(widthMin, widthMax-1, heightMin, heightMax-1);
+        pyramidExtractor->Restrict(widthMin, widthMax-1, heightMin, heightMax-1);
     }
 }
 
@@ -596,23 +601,23 @@ avtSamplePointExtractor::PreExecute(void)
         SumLongLongArrayAcrossAllProcessors(&nzones, &total_nzones, 1);
         
 
-        if (total_nzones == 0)
-        {
-            point_radius = 0.1;
-            return;
-        }
-
-        // In image space, the total volume will be 4 (-1->+1 in X,-1->+1 in Y,
-        // 0->+1 in Z).  But: we want to treat all dimensions evenly.  So
-        // use 8 (doubling Z) and then correct for it later (when we use the
-        // number).
-        int dim = GetInput()->GetInfo().GetAttributes().GetSpatialDimension();
-        double start_vol = (dim == 3 ? 8. : 4.);
-        double vol_per_point = start_vol / total_nzones;
-        double exp = (dim == 3 ? 0.333333 : 0.5);
-        double side_length = pow(vol_per_point, exp) / 2;
-        point_radius = side_length * 1.1; // a little extra
-    }
+		if (total_nzones == 0)
+		{
+			pointRadius = 0.1;
+			return;
+		}
+
+		// In image space, the total volume will be 4 (-1->+1 in X,-1->+1 in Y,
+		// 0->+1 in Z).  But: we want to treat all dimensions evenly.  So
+		// use 8 (doubling Z) and then correct for it later (when we use the
+		// number).
+		int dim = GetInput()->GetInfo().GetAttributes().GetSpatialDimension();
+		double start_vol = (dim == 3 ? 8. : 4.);
+		double vol_per_point = start_vol / total_nzones;
+		double exp = (dim == 3 ? 0.333333 : 0.5);
+		double side_length = pow(vol_per_point, exp) / 2;
+		pointRadius = side_length * 1.1; // a little extra
+	}
 }
 
 
@@ -699,115 +704,165 @@ avtSamplePointExtractor::PostExecute(void)
 //    Manasa Prasad, 
 //    Converted the recursive function to iteration
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for volume rendering using OSPRay
+//
 // ****************************************************************************
-    struct datatree_childindex {
-        avtDataTree_p dt; int idx; bool visited;
-        datatree_childindex(avtDataTree_p dt_, int idx_) : dt(dt_),idx(idx_),visited(false) {}
-    };
-
+struct datatree_childindex {
+    avtDataTree_p dt; int idx; bool visited;
+    datatree_childindex(avtDataTree_p dt_, int idx_) : dt(dt_),idx(idx_),visited(false) {}
+};
 
 void
 avtSamplePointExtractor::ExecuteTree(avtDataTree_p dt)
 {
-    debug5<<"got here!"<<endl;
-
-    //check memory
-    unsigned long m_size, m_rss;
-    avtMemory::GetMemorySize(m_size, m_rss);
-    debug5 << PAR_Rank() << " ~ avtSamplePointExtractor::ExecuteTree  .. .  " 
-           << "    Memory use before: " << m_size << "  rss (MB): " << m_rss/(1024*1024) << endl;
-
-    //initialize rayCastingSLIVR sampling state
+    //----------------------------------------------------------
+    // Initialization
+    //----------------------------------------------------------
+    int timings_ExecuteTree_init = visitTimer->StartTimer();
+    // initialize rayCastingSLIVR sampling state
     totalAssignedPatches = dt->GetNChildren();
     patchCount = 0;
     imageMetaPatchVector.clear();
     imgDataHashMap.clear();
-
+    // debug 
+    ospout << "[avtSamplePointExtractor] ExecuteTree with " 
+	   << totalAssignedPatches << " patches" << std::endl;
+    // timing
+    visitTimer->StopTimer(timings_ExecuteTree_init, 
+			  "avtSamplePointExtractor::ExecuteTree "
+			  "Initialization");
+    // if it is an empty node
     if (*dt == NULL || (dt->GetNChildren() <= 0 && (!(dt->HasData()))))
-        return;
-
-    debug5 << " ~ avtSamplePointExtractor::dt->GetNChildren()  "  << dt->GetNChildren() << endl;
+    { 
+	    return;
+    }
 
-    //
+    //----------------------------------------------------------
+    // Process tree
+    //----------------------------------------------------------
+    int timings_ExecuteTree_process = visitTimer->StartTimer();
     // Process tree
     std::stack<datatree_childindex*> nodes;
-
-    //iterative depth-first sampling
+    // iterative depth-first sampling
     nodes.push(new datatree_childindex(dt,0));
     while (!nodes.empty())
     {
-        datatree_childindex *ci=nodes.top();
-        avtDataTree_p ch=ci->dt;
-
-        if (ch->GetNChildren() != 0)
-        {
-            nodes.pop();  // if it has children, it never gets processed below
-            for (int i = 0; i < ch->GetNChildren(); i++)
-            {
-                if (ch->ChildIsPresent(i))
-                {
-                    if (*ch == NULL || (ch->GetNChildren() <= 0 && (!(ch->HasData()))))
-                        continue;
-                    nodes.push(new datatree_childindex(ch->GetChild(i),i));
-                }
-            }
-
-            continue;
-        }
-
-        //do the work
-        nodes.pop();
-
-        if (*ch == NULL || (ch->GetNChildren() <= 0 && (!(ch->HasData()))))
-            continue;
-
-        //
-        // Get the dataset for this leaf in the tree.
-        //
-        vtkDataSet *ds = ch->GetDataRepresentation().GetDataVTK();
-
-        //
-        // Iterate over all cells in the mesh and call the appropriate
-        // extractor for each cell to get the sample points.
-        //
-        if (kernelBasedSampling)
-            KernelBasedSample(ds);
-        else
-        {
-            if (rayCastingSLIVR == true)
-            {
-                double _scalarRange[2];
-                ds->GetScalarRange(_scalarRange);
-
-                double _tfRange[2];
-                _tfRange[0] = transferFn1D->GetMin();
-                _tfRange[1] = transferFn1D->GetMax();
-
-                double _tfVisibleRange[2];
-                _tfVisibleRange[0] = transferFn1D->GetMinVisibleScalar();
-                _tfVisibleRange[1] = transferFn1D->GetMaxVisibleScalar();
-
-                massVoxelExtractor->SetScalarRange(_scalarRange);
-                massVoxelExtractor->SetTFVisibleRange(_tfVisibleRange);
-            }
-
-            RasterBasedSample(ds,ci->idx);
-        }
-
-        UpdateProgress(10*currentNode+9, 10*totalNodes);
-        currentNode++;
-    }
-
-
-    //check memory after
-    avtMemory::GetMemorySize(m_size, m_rss);
-    debug5 << PAR_Rank() << " ~ Memory use after: " << m_size << "  rss (MB): " << m_rss/(1024*1024)
-           <<  "   ... avtSamplePointExtractor::ExecuteTree done@!!!" << endl;
+	//-----------------------------------------------
+    // initialize tree structure
+	//-----------------------------------------------
+	datatree_childindex *ci=nodes.top();
+	avtDataTree_p ch=ci->dt;
+	if (ch->GetNChildren() != 0)
+	{
+	    nodes.pop();  // if it has children, it never gets processed below
+	    for (int i = 0; i < ch->GetNChildren(); i++)
+	    {
+		if (ch->ChildIsPresent(i))
+		{
+		    if (*ch == NULL || 
+			(ch->GetNChildren() <= 0 && 
+			 (!(ch->HasData()))))
+		    { continue; }
+		    nodes.push(new datatree_childindex(ch->GetChild(i),i));
+		    if (rayCastingSLIVR == true && avtCallback::UseOSPRay())
+		    {
+			int timings_init_osp_patch = visitTimer->StartTimer();
+			ospray->InitPatch(i);
+			visitTimer->StopTimer(timings_init_osp_patch,
+					      "avtSamplePointExtractor::ExecuteTree "
+					      "[OSPRay] InitPatch()");			
+		    }	
+		}
+	    }    
+	    continue;
+	}
+	
+	//-----------------------------------------------
+	// do the work
+	//-----------------------------------------------
+	nodes.pop();
+	if (*ch == NULL || (ch->GetNChildren() <= 0 && (!(ch->HasData())))) { continue; }
+	// Get the dataset for this leaf in the tree.
+	int timings_pop_get_data = visitTimer->StartTimer();
+	vtkDataSet *ds = ch->GetDataRepresentation().GetDataVTK();		
+	visitTimer->StopTimer(timings_pop_get_data,
+			      "avtSamplePointExtractor::ExecuteTree "
+			      "Pop and getDataVTK()");		
+
+	//-----------------------------------------------
+	// Iterate over all cells in the mesh and call the appropriate
+	// extractor for each cell to get the sample points.
+	//-----------------------------------------------
+	if (kernelBasedSampling) {
+	    ospout << "[avtSamplePointExtractor] KernelBasedSampling" 
+		   << patchCount << std::endl;
+	    int timings_KernelBasedSample = visitTimer->StartTimer();
+	    KernelBasedSample(ds);
+	    visitTimer->StopTimer(timings_KernelBasedSample,
+				  "avtSamplePointExtractor::ExecuteTree "
+				  "KernelBasedSample(ds)");		
+	}
+	else
+	{
+	    ospout << "[avtSamplePointExtractor] RasterBasedSampling " 
+		   << patchCount << std::endl;
+	    // Get transfer function
+	    int timings_RasterBased_gettfn = visitTimer->StartTimer();
+	    if (rayCastingSLIVR == true)
+	    {
+		int timings_gettfn_range = visitTimer->StartTimer();
+		double _scalarRange[2];
+		ds->GetScalarRange(_scalarRange);		
+		visitTimer->StopTimer(timings_gettfn_range,
+				  "avtSamplePointExtractor::ExecuteTree "
+				  "Get Data Scalar Range");
+		
+		int timings_gettfn_tfnrange = visitTimer->StartTimer();
+		double _tfRange[2];
+		_tfRange[0] = transferFn1D->GetMin();
+		_tfRange[1] = transferFn1D->GetMax();
+		double _tfVisibleRange[2];
+		_tfVisibleRange[0] = transferFn1D->GetMinVisibleScalar();
+		_tfVisibleRange[1] = transferFn1D->GetMaxVisibleScalar();
+		visitTimer->StopTimer(timings_gettfn_tfnrange,
+				  "avtSamplePointExtractor::ExecuteTree "
+				  "Get TFN Range");		
+		
+		int timings_gettfn_setrange = visitTimer->StartTimer();
+		massVoxelExtractor->SetScalarRange(_scalarRange);
+		massVoxelExtractor->SetTFVisibleRange(_tfVisibleRange);
+		visitTimer->StopTimer(timings_gettfn_setrange,
+				  "avtSamplePointExtractor::ExecuteTree "
+				  "Set TFN Range to Extractor");		
+	    } 
+	    visitTimer->StopTimer(timings_RasterBased_gettfn,
+				  "avtSamplePointExtractor::ExecuteTree "
+				  "Get Transfer Function before RasterBasedSample");		
+	    // do the work
+	    int timings_RasterBasedSample = visitTimer->StartTimer();
+	    RasterBasedSample(ds, ci->idx);
+	    visitTimer->StopTimer(timings_RasterBasedSample,
+				  "avtSamplePointExtractor::ExecuteTree "
+				  "RasterBasedSample(ds, ci->idx)");		
+	}
+	// update progress
+	UpdateProgress(10*currentNode+9, 10*totalNodes);
+	currentNode++;
+    }
+    // timing
+    visitTimer->StopTimer(timings_ExecuteTree_process, 
+			  "avtSamplePointExtractor::ExecuteTree "
+			  "Process Tree");
+    // debug
+    ospout << "[avtSamplePointExtractor] parallel rank #" << PAR_Rank() 
+	   << " has " << patchCount << " patches in data tree"
+	   << std::endl;    
 }
 
 
 // ****************************************************************************
-//  Method: avtSamplePointExtractor::delImgPatches
+//  Method: avtSamplePointExtractor::DelImgPatches
 //
 //  Purpose:
 //      allocates space to the pointer address and copy the image generated to it
@@ -819,25 +874,21 @@ avtSamplePointExtractor::ExecuteTree(avtDataTree_p dt)
 //
 // ****************************************************************************
 void
-avtSamplePointExtractor::delImgPatches(){
+avtSamplePointExtractor::DelImgPatches(){
     imageMetaPatchVector.clear();
-
-    for (iter_t it=imgDataHashMap.begin(); it!=imgDataHashMap.end(); it++)
+    for (iter_t it = imgDataHashMap.begin(); 
+	 it != imgDataHashMap.end(); it++)
     {
-        if ((*it).second.imagePatch != NULL)
-            delete [](*it).second.imagePatch;
-
-        (*it).second.imagePatch = NULL;
-;
+	if ((*it).second.imagePatch != NULL)
+	{ delete [](*it).second.imagePatch; }
+	(*it).second.imagePatch = NULL;
     }
-
     imgDataHashMap.clear();
 }
 
 
-
 // ****************************************************************************
-//  Method: avtSamplePointExtractor::getImgData
+//  Method: avtSamplePointExtractor::GetAndDelImgData
 //
 //  Purpose:
 //      copies a patchover
@@ -847,16 +898,27 @@ avtSamplePointExtractor::delImgPatches(){
 //
 //  Modifications:
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for volume rendering using OSPRay
+//
 // ****************************************************************************
+
 void 
-avtSamplePointExtractor::getnDelImgData(int patchId, imgData &tempImgData){
+avtSamplePointExtractor::GetAndDelImgData
+(int patchId, slivr::ImgData &tempImgData)
+{
+    size_t imagePatchSize = 
+	imageMetaPatchVector[patchId].dims[0] * 
+	imageMetaPatchVector[patchId].dims[1] * sizeof(float) * 4;
     iter_t it = imgDataHashMap.find(patchId);
-
     tempImgData.procId = it->second.procId;
     tempImgData.patchNumber = it->second.patchNumber;
-    memcpy(tempImgData.imagePatch,it->second.imagePatch,imageMetaPatchVector[patchId].dims[0] * 4 * imageMetaPatchVector[patchId].dims[1] * sizeof(float));
-
-    delete [](*it).second.imagePatch;
+    // do shallow copy instead of deep copy
+    tempImgData.imagePatch = it->second.imagePatch;
+    // memcpy(tempImgData.imagePatch,
+    // 	      it->second.imagePatch,
+    //        imagePatchSize);
+    // delete [](*it).second.imagePatch;
     it->second.imagePatch = NULL;
 }
 
@@ -865,7 +927,8 @@ avtSamplePointExtractor::getnDelImgData(int patchId, imgData &tempImgData){
 //  Method: avtSamplePointExtractor::
 //
 //  Purpose:
-//      allocates space to the pointer address and copy the image generated to it
+//      allocates space to the pointer address and copy the image
+//      generated to it
 //
 //  Programmer: 
 //  Creation:   
@@ -873,9 +936,9 @@ avtSamplePointExtractor::getnDelImgData(int patchId, imgData &tempImgData){
 //  Modifications:
 //
 // ****************************************************************************
-imgMetaData
+slivr::ImgMetaData
 avtSamplePointExtractor::initMetaPatch(int id){
-    imgMetaData temp;
+    slivr::ImgMetaData temp;
     temp.inUse = 0;
     temp.procId = PAR_Rank();
     temp.destProcId = PAR_Rank();
@@ -886,7 +949,6 @@ avtSamplePointExtractor::initMetaPatch(int id){
     temp.avg_z = -1.0;
     temp.eye_z = -1.0;
     temp.clip_z = -1.0;
-
     return temp;
 }
 
@@ -913,10 +975,10 @@ avtSamplePointExtractor::initMetaPatch(int id){
 void
 avtSamplePointExtractor::KernelBasedSample(vtkDataSet *ds)
 {
-    int numCells = ds->GetNumberOfCells();
-    int lastMilestone = 0;
+    size_t numCells = ds->GetNumberOfCells();
+    size_t lastMilestone = 0;
     vtkUnsignedCharArray *ghosts = (vtkUnsignedCharArray *)
-                                  ds->GetCellData()->GetArray("avtGhostZones");
+	ds->GetCellData()->GetArray("avtGhostZones");
 
     bool is2D = GetInput()->GetInfo().GetAttributes().GetSpatialDimension()==2;
     LoadingInfo li;
@@ -925,7 +987,7 @@ avtSamplePointExtractor::KernelBasedSample(vtkDataSet *ds)
     if (li.nVars <= 0)
         return;
 
-    for (int j = 0 ; j < numCells ; j++)
+    for (size_t j = 0 ; j < numCells ; j++)
     {
         //
         // Make sure this is a cell we should be processing.
@@ -933,7 +995,7 @@ avtSamplePointExtractor::KernelBasedSample(vtkDataSet *ds)
         if (ghosts != NULL && ghosts->GetValue(j) > 0)
             continue;
         vtkCell *cell = ds->GetCell(j);
-        int npts = cell->GetNumberOfPoints();
+        size_t npts = cell->GetNumberOfPoints();
 
         avtPoint pt;
         pt.nVars = li.nVars;
@@ -945,7 +1007,7 @@ avtSamplePointExtractor::KernelBasedSample(vtkDataSet *ds)
         {
             if (li.cellDataIndex[v] < 0)
                 continue;
-            for (int k = 0 ; k < li.cellDataSize[v] ; k++)
+            for (size_t k = 0 ; k < li.cellDataSize[v] ; k++)
                 pt.val[li.cellDataIndex[v]+k] = 
                                          li.cellArrays[v]->GetComponent(j, k);
         }
@@ -958,10 +1020,10 @@ avtSamplePointExtractor::KernelBasedSample(vtkDataSet *ds)
         {
             if (li.pointDataIndex[v] < 0)
                 continue;
-            for (int k = 0 ; k < li.pointDataSize[v] ; k++)
+            for (size_t k = 0 ; k < li.pointDataSize[v] ; k++)
             {
                 double accum = 0;
-                for (int i = 0 ; i < npts ; i++)
+                for (size_t i = 0 ; i < npts ; i++)
                     accum += li.pointArrays[v]->GetComponent(ids->GetId(i),k);
                 accum /= npts;
                 pt.val[li.pointDataIndex[v]+k] = accum;
@@ -980,12 +1042,12 @@ avtSamplePointExtractor::KernelBasedSample(vtkDataSet *ds)
             vtkIdList *ids = cell->GetPointIds();
             vtkIdType id = ids->GetId(0);
             ds->GetPoint(id, pt_loc);
-            bbox[0] = pt_loc[0]-point_radius;
-            bbox[1] = pt_loc[0]+point_radius;
-            bbox[2] = pt_loc[1]-point_radius;
-            bbox[3] = pt_loc[1]+point_radius;
-            bbox[4] = (is2D ? 0. : pt_loc[2]-point_radius/2.);
-            bbox[5] = (is2D ? 0. : pt_loc[2]+point_radius/2.);
+            bbox[0] = pt_loc[0]-pointRadius;
+            bbox[1] = pt_loc[0]+pointRadius;
+            bbox[2] = pt_loc[1]-pointRadius;
+            bbox[3] = pt_loc[1]+pointRadius;
+            bbox[4] = (is2D ? 0. : pt_loc[2]-pointRadius/2.);
+            bbox[5] = (is2D ? 0. : pt_loc[2]+pointRadius/2.);
         }
 
         pt.bbox[0] = bbox[0];
@@ -997,7 +1059,7 @@ avtSamplePointExtractor::KernelBasedSample(vtkDataSet *ds)
 
         pointExtractor->Extract(pt);
 
-        int currentMilestone = (int)(((double) j) / numCells * 10);
+        size_t currentMilestone = (size_t)(((double) j) / numCells * 10);
         if (currentMilestone > lastMilestone)
         {
             UpdateProgress(10*currentNode+currentMilestone, 10*totalNodes);
@@ -1032,20 +1094,82 @@ avtSamplePointExtractor::KernelBasedSample(vtkDataSet *ds)
 //    Kevin Griffin, Fri Apr 22 16:31:57 PDT 2016
 //    Added support for polygons.
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for volume rendering using OSPRay
+//
 // ****************************************************************************
+void CheckCellType(const int cellType) 
+{
+    switch (cellType)
+    {
+    case VTK_HEXAHEDRON:
+	ospout << "[avtSamplePointExtractor] RasterBasedSample "
+	       << "DataObjectType == VTK_HEXAHEDRON" << std::endl;
+	break;
+    case VTK_QUADRATIC_HEXAHEDRON:
+	ospout << "[avtSamplePointExtractor] RasterBasedSample "
+	       << "DataObjectType == VTK_QUADRATIC_HEXAHEDRON" << std::endl;
+	break;
+    case VTK_VOXEL:
+	ospout << "[avtSamplePointExtractor] RasterBasedSample "
+	       << "DataObjectType == VTK_VOXEL" << std::endl;
+	break;
+    case VTK_TETRA:
+	ospout << "[avtSamplePointExtractor] RasterBasedSample "
+	       << "DataObjectType == VTK_TETRA" << std::endl;
+	break;
+    case VTK_WEDGE:
+	ospout << "[avtSamplePointExtractor] RasterBasedSample "
+	       << "DataObjectType == VTK_WEDGE" << std::endl;
+	break;
+    case VTK_PYRAMID:
+	ospout << "[avtSamplePointExtractor] RasterBasedSample "
+	       << "DataObjectType == VTK_PYRAMID" << std::endl;
+	break;
+    case VTK_TRIANGLE:
+	ospout << "[avtSamplePointExtractor] RasterBasedSample "
+	       << "DataObjectType == VTK_TRIANGLE" << std::endl;
+	break;
+    case VTK_QUAD:
+	ospout << "[avtSamplePointExtractor] RasterBasedSample "
+	       << "DataObjectType == VTK_QUAD" << std::endl;	    
+	break;
+    case VTK_PIXEL:
+	ospout << "[avtSamplePointExtractor] RasterBasedSample "
+	       << "DataObjectType == VTK_PIXEL" << std::endl;	    
+	break;
+    case VTK_POLYGON:
+	ospout << "[avtSamplePointExtractor] RasterBasedSample "
+	       << "DataObjectType == VTK_POLYGON" << std::endl;	    
+	break;
+    default:
+	EXCEPTION1(InvalidCellTypeException, 
+		   "surfaces or anything outside the finite element zoo.");
+    }
+}
 
 void
 avtSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
 {
-    //debug5 << PAR_Rank() << " avtSamplePointExtractor::RasterBasedSample  " << num << std::endl;
+    int timingsIndex = visitTimer->StartTimer();
+    //---------------------------------------------------------
+    // Rectlinear
+    //---------------------------------------------------------
     if (modeIs3D && ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
     {
+        ospout << "[avtSamplePointExtractor] RasterBasedSample "
+               << "modeIs3D = " << modeIs3D << std::endl
+               << "[avtSamplePointExtractor] RasterBasedSample "
+               << "DataObjectType = VTK_RECTILINEAR_GRID"
+               << std::endl;
+        //-----------------------------
+        // Initialization
+        //-----------------------------
         avtDataAttributes &atts = GetInput()->GetInfo().GetAttributes();
         const double *xform = NULL;
-        if (atts.GetRectilinearGridHasTransform())
-            xform = atts.GetRectilinearGridTransform();
-        massVoxelExtractor->SetGridsAreInWorldSpace(
-           rectilinearGridsAreInWorldSpace, viewInfo, aspect, xform);
+        if (atts.GetRectilinearGridHasTransform()) { xform = atts.GetRectilinearGridTransform(); }
+        massVoxelExtractor->SetGridsAreInWorldSpace
+            (rectilinearGridsAreInWorldSpace, viewInfo, aspect, xform);
         avtSamplePoints_p samples = GetTypedOutput();
         int numVars = samples->GetNumberOfRealVariables();
         std::vector<std::string> varnames;
@@ -1054,139 +1178,188 @@ avtSamplePointExtractor::RasterBasedSample(vtkDataSet *ds, int num)
         {
             varnames.push_back(samples->GetVariableName(i));
             varsizes.push_back(samples->GetVariableSize(i));
+            // debug5 << varsizes[i] << " " << varnames[i] << std::endl;
+            // size of the variable (in case it is not a single number ?)
+            // name of the variable
         }
 
-        //
+        //-----------------------------
         // Compositing Setup
+        //-----------------------------
+        int timings_setup_extractor = visitTimer->StartTimer();
         if (rayCastingSLIVR == true)
         {
-            massVoxelExtractor->setDepthBuffer(depthBuffer, bufferExtents[1]*bufferExtents[3]);
-            massVoxelExtractor->setRGBBuffer(rgbColorBuffer, bufferExtents[1],bufferExtents[3]);
-            massVoxelExtractor->setBufferExtents(bufferExtents);
-
-            massVoxelExtractor->SetViewDirection(view_direction);
+            massVoxelExtractor->SetDepthBuffer(depthBuffer, bufferExtents[1]*bufferExtents[3]);
+            massVoxelExtractor->SetRGBBuffer(rgbColorBuffer, bufferExtents[1],bufferExtents[3]);
+            massVoxelExtractor->SetBufferExtents(bufferExtents);
+            massVoxelExtractor->SetViewDirection(viewDirection);
             massVoxelExtractor->SetMVPMatrix(modelViewProj);
             massVoxelExtractor->SetClipPlanes(clipPlanes);
             massVoxelExtractor->SetPanPercentages(panPercentage);
+            massVoxelExtractor->SetImageZoom(imageZoom);
+            massVoxelExtractor->SetRendererSampleRate(rendererSampleRate);
             massVoxelExtractor->SetDepthExtents(depthExtents);
-
-            massVoxelExtractor->setProcIdPatchID(PAR_Rank(),num);
-
+            massVoxelExtractor->SetProcIdPatchID(PAR_Rank(),num);
             massVoxelExtractor->SetLighting(lighting);
             massVoxelExtractor->SetLightDirection(lightDirection);
             massVoxelExtractor->SetMatProperties(materialProperties);
             massVoxelExtractor->SetTransferFn(transferFn1D);
+            // pass reference to ospray
+            massVoxelExtractor->SetOSPRay(ospray);
+            massVoxelExtractor->SetFullImageExtents(fullImageExtents);
         }
-
-        //debug5 << PAR_Rank() << " avtSamplePointExtractor::RasterBasedSample extract ...  " << num << std::endl;
-
-        massVoxelExtractor->Extract((vtkRectilinearGrid *) ds, varnames, varsizes);
-
-        //debug5 << PAR_Rank() << " avtSamplePointExtractor::RasterBasedSample extract done!" << num << std::endl;
-
-        //
+        // timing
+        visitTimer->StopTimer(timings_setup_extractor,
+                              "avtSamplePointExtractor::RasterBasedSample "
+                              "Setup RectlinearGrid Extractor");
+
+        //-----------------------------
+        // Extract
+        //-----------------------------
+        int timings_extract = visitTimer->StartTimer();
+        massVoxelExtractor->Extract((vtkRectilinearGrid *)ds,
+                                    varnames, varsizes);
+        visitTimer->StopTimer(timings_extract,
+                              "avtSamplePointExtractor::RasterBasedSample "
+                              "Do Extraction");
+
+        //-----------------------------
         // Get rendering results
+        // put them into a proper vector, sort them based on z value
+        //-----------------------------
+        int timings_get_result = visitTimer->StartTimer();
         if (rayCastingSLIVR == true)
         {
-            imgMetaData      tmpImageMetaPatch;
+            slivr::ImgMetaData tmpImageMetaPatch;
             tmpImageMetaPatch = initMetaPatch(patchCount);
-
-            massVoxelExtractor->getImageDimensions(tmpImageMetaPatch.inUse, tmpImageMetaPatch.dims, tmpImageMetaPatch.screen_ll, tmpImageMetaPatch.screen_ur, tmpImageMetaPatch.eye_z, tmpImageMetaPatch.clip_z);
+            massVoxelExtractor->GetImageDimensions(
+                tmpImageMetaPatch.inUse,
+                tmpImageMetaPatch.dims,
+                tmpImageMetaPatch.screen_ll,
+                tmpImageMetaPatch.screen_ur,
+                tmpImageMetaPatch.eye_z,
+                tmpImageMetaPatch.clip_z);
             if (tmpImageMetaPatch.inUse == 1)
             {
                 tmpImageMetaPatch.avg_z = tmpImageMetaPatch.eye_z;
                 tmpImageMetaPatch.destProcId = tmpImageMetaPatch.procId;
                 imageMetaPatchVector.push_back(tmpImageMetaPatch);
-
-                imgData tmpImageDataHash;
+                slivr::ImgData tmpImageDataHash;
                 tmpImageDataHash.procId = tmpImageMetaPatch.procId;
                 tmpImageDataHash.patchNumber = tmpImageMetaPatch.patchNumber;
-                tmpImageDataHash.imagePatch = new float[ tmpImageMetaPatch.dims[0]*tmpImageMetaPatch.dims[1] * 4 ];
-
-                massVoxelExtractor->getComputedImage(tmpImageDataHash.imagePatch);
-                imgDataHashMap.insert( std::pair<int, imgData> (tmpImageDataHash.patchNumber , tmpImageDataHash) );
-                //writeArrayToPPM("/home/pascal/Desktop/debugImages/local_" + toStr(tmpImageMetaPatch.procId) + "_"+ toStr(tmpImageMetaPatch.patchNumber), tmpImageDataHash.imagePatch, tmpImageMetaPatch.dims[0], tmpImageMetaPatch.dims[1]);
-
+                tmpImageDataHash.imagePatch =
+                    new float[tmpImageMetaPatch.dims[0] *
+                              tmpImageMetaPatch.dims[1] * 4];
+                massVoxelExtractor->GetComputedImage
+                    (tmpImageDataHash.imagePatch);
+                imgDataHashMap.insert
+                    (std::pair<int, slivr::ImgData>
+		     (tmpImageDataHash.patchNumber, tmpImageDataHash));
                 patchCount++;
             }
         }
+        visitTimer->StopTimer(timings_get_result,
+                              "avtSamplePointExtractor::RasterBasedSample "
+                              "Get Result");
+        // timing
+        visitTimer->StopTimer(timingsIndex,
+                              "avtSamplePointExtractor::RasterBasedSample "
+                              "RectlinearGrid");
         return;
     }
 
+    //---------------------------------------------------------
+    // Other Grid
+    //---------------------------------------------------------
+    ospout << "[avtSamplePointExtractor] RasterBasedSample "
+           << "modeIs3D = " << modeIs3D << " " << std::endl;
+    if (rayCastingSLIVR == true)
+    {
+	std::cerr << (int)(ds->GetDataObjectType()) << std::endl
+		  << "Warning: Dataset is not a VTK_RECTILINEAR_GRID." << std::endl
+		  << "         Currently Ray Casting: SLIVR/OSPRay-SLIVR renderer" << std::endl
+		  << "         only support rectilinear grid." << std::endl;
+    }
+
     int numCells = ds->GetNumberOfCells();
     LoadingInfo li;
     GetLoadingInfoForArrays(ds, li);
 
     int lastMilestone = 0;
     vtkUnsignedCharArray *ghosts = (vtkUnsignedCharArray *)
-                                  ds->GetCellData()->GetArray("avtGhostZones");
+	ds->GetCellData()->GetArray("avtGhostZones");
     for (int j = 0 ; j < numCells ; j++)
     {
-        if (ghosts != NULL && ghosts->GetValue(j) > 0)
-            continue;
-
-        vtkCell *cell = ds->GetCell(j);
-        if (modeIs3D && cell->GetCellDimension() != 3)
-        {
-            continue;
-        }
-        if (!modeIs3D && cell->GetCellDimension() != 2)
-            EXCEPTION1(InvalidCellTypeException, "surfaces or anything outside"
-                                                 " the finite element zoo.");
-
-        switch (cell->GetCellType())
-        {
-          case VTK_HEXAHEDRON:
-            ExtractHex((vtkHexahedron *) cell, ds, j, li);
-            break;
-
-          case VTK_QUADRATIC_HEXAHEDRON:
-            ExtractHex20((vtkQuadraticHexahedron *) cell, ds, j, li);
-            break;
-
-          case VTK_VOXEL:
-            ExtractVoxel((vtkVoxel *) cell, ds, j, li);
-            break;
-
-          case VTK_TETRA:
-            ExtractTet((vtkTetra *) cell, ds, j, li);
-            break;
-
-          case VTK_WEDGE:
-            ExtractWedge((vtkWedge *) cell, ds, j, li);
-            break;
-
-          case VTK_PYRAMID:
-            ExtractPyramid((vtkPyramid *) cell, ds, j, li);
-            break;
-
-          case VTK_TRIANGLE:
-            ExtractTriangle((vtkTriangle *) cell, ds, j, li);
-            break;
-
-          case VTK_QUAD:
-            ExtractQuad((vtkQuad *) cell, ds, j, li);
-            break;
-
-          case VTK_PIXEL:
-            ExtractPixel((vtkPixel *) cell, ds, j, li);
-            break;
-
-          case VTK_POLYGON:
-            ExtractPolygon((vtkPolygon *)cell, ds, j, li);
-            break;
-
-          default:
-            EXCEPTION1(InvalidCellTypeException, "surfaces or anything outside"
-                                                 " the finite element zoo.");
-        }
-        int currentMilestone = (int)(((double) j) / numCells * 10);
-        if (currentMilestone > lastMilestone)
-        {
-            UpdateProgress(10*currentNode+currentMilestone, 10*totalNodes);
-            lastMilestone = currentMilestone;
-        }
-    }
+	if (ghosts != NULL && ghosts->GetValue(j) > 0)
+	    continue;
+
+	vtkCell *cell = ds->GetCell(j);
+	if (modeIs3D && cell->GetCellDimension() != 3)
+	{
+	    continue;
+	}
+	if (!modeIs3D && cell->GetCellDimension() != 2)
+	    EXCEPTION1(InvalidCellTypeException, "surfaces or anything outside"
+		       " the finite element zoo.");
+
+	CheckCellType(cell->GetCellType());
+	switch (cell->GetCellType())
+	{
+	case VTK_HEXAHEDRON:
+	    ExtractHex((vtkHexahedron *) cell, ds, j, li);
+	    break;
+
+	case VTK_QUADRATIC_HEXAHEDRON:
+	    ExtractHex20((vtkQuadraticHexahedron *) cell, ds, j, li);
+	    break;
+
+	case VTK_VOXEL:
+	    ExtractVoxel((vtkVoxel *) cell, ds, j, li);
+	    break;
+
+	case VTK_TETRA:
+	    ExtractTet((vtkTetra *) cell, ds, j, li);
+	    break;
+
+	case VTK_WEDGE:
+	    ExtractWedge((vtkWedge *) cell, ds, j, li);
+	    break;
+
+	case VTK_PYRAMID:
+	    ExtractPyramid((vtkPyramid *) cell, ds, j, li);
+	    break;
+
+	case VTK_TRIANGLE:
+	    ExtractTriangle((vtkTriangle *) cell, ds, j, li);
+	    break;
+
+	case VTK_QUAD:
+	    ExtractQuad((vtkQuad *) cell, ds, j, li);
+	    break;
+
+	case VTK_PIXEL:
+	    ExtractPixel((vtkPixel *) cell, ds, j, li);
+	    break;
+
+	case VTK_POLYGON:
+	    ExtractPolygon((vtkPolygon *) cell, ds, j, li);
+	    break;
+
+	default:
+	    EXCEPTION1(InvalidCellTypeException,
+		       "surfaces or anything outside the finite element zoo.");
+	}
+	int currentMilestone = (int)(((double) j) / numCells * 10);
+	if (currentMilestone > lastMilestone)
+	{
+	    UpdateProgress(10*currentNode+currentMilestone, 10*totalNodes);
+	    lastMilestone = currentMilestone;
+	}
+    }
+    // timing
+    visitTimer->StopTimer(timingsIndex, 
+			  "avtSamplePointExtractor::RasterBasedSample "
+			  "Others");
 }
 
 
@@ -2360,57 +2533,57 @@ avtSamplePointExtractor::GetLoadingInfoForArrays(vtkDataSet *ds,
 {
     int  i, j, k;
 
-    avtSamplePoints_p samples = GetTypedOutput();
-    int numVars = samples->GetNumberOfRealVariables(); // Counts vector as 1
-    li.nVars = samples->GetNumberOfVariables();        // Counts vector as 3
-
-    int ncd = ds->GetCellData()->GetNumberOfArrays();
-    li.cellDataIndex.resize(ncd);
-    li.cellDataSize.resize(ncd);
-    li.cellArrays.resize(ncd);
-    for (i = 0 ; i < ncd ; i++)
-    {
-        vtkDataArray *arr = ds->GetCellData()->GetArray(i);
-        li.cellArrays[i] = arr;
-        const char *name = arr->GetName();
-        li.cellDataSize[i]  = arr->GetNumberOfComponents();
-        li.cellDataIndex[i] = -1;
-        for (j = 0 ; j < numVars ; j++)
-        {
-            if (samples->GetVariableName(j) == name)
-            {
-                int idx = 0;
-                for (k = 0 ; k < j ; k++)
-                    idx += samples->GetVariableSize(k);
-                li.cellDataIndex[i] = idx;
-                break;
-            }
-        }
-    }
-
-    int npd = ds->GetPointData()->GetNumberOfArrays();
-    li.pointDataIndex.resize(npd);
-    li.pointDataSize.resize(npd);
-    li.pointArrays.resize(npd);
-    for (i = 0 ; i < npd ; i++)
-    {
-        vtkDataArray *arr = ds->GetPointData()->GetArray(i);
-        li.pointArrays[i] = arr;
-        const char *name = arr->GetName();
-        li.pointDataSize[i]  = arr->GetNumberOfComponents();
-        li.pointDataIndex[i] = -1;
-        for (j = 0 ; j < numVars ; j++)
-        {
-            if (samples->GetVariableName(j) == name)
-            {
-                int idx = 0;
-                for (k = 0 ; k < j ; k++)
-                    idx += samples->GetVariableSize(k);
-                li.pointDataIndex[i] = idx;
-                break;
-            }
-        }
-    }
+	avtSamplePoints_p samples = GetTypedOutput();
+	int numVars = samples->GetNumberOfRealVariables(); // Counts vector as 1
+	li.nVars = samples->GetNumberOfVariables();        // Counts vector as 3
+
+	int ncd = ds->GetCellData()->GetNumberOfArrays();
+	li.cellDataIndex.resize(ncd);
+	li.cellDataSize.resize(ncd);
+	li.cellArrays.resize(ncd);
+	for (i = 0 ; i < ncd ; i++)
+	{
+		vtkDataArray *arr = ds->GetCellData()->GetArray(i);
+		li.cellArrays[i] = arr;
+		const char *name = arr->GetName();
+		li.cellDataSize[i]  = arr->GetNumberOfComponents();
+		li.cellDataIndex[i] = -1;
+		for (j = 0 ; j < numVars ; j++)
+		{
+			if (samples->GetVariableName(j) == name)
+			{
+				int idx = 0;
+				for (k = 0 ; k < j ; k++)
+					idx += samples->GetVariableSize(k);
+				li.cellDataIndex[i] = idx;
+				break;
+			}
+		}
+	}
+
+	int npd = ds->GetPointData()->GetNumberOfArrays();
+	li.pointDataIndex.resize(npd);
+	li.pointDataSize.resize(npd);
+	li.pointArrays.resize(npd);
+	for (i = 0 ; i < npd ; i++)
+	{
+		vtkDataArray *arr = ds->GetPointData()->GetArray(i);
+		li.pointArrays[i] = arr;
+		const char *name = arr->GetName();
+		li.pointDataSize[i]  = arr->GetNumberOfComponents();
+		li.pointDataIndex[i] = -1;
+		for (j = 0 ; j < numVars ; j++)
+		{
+			if (samples->GetVariableName(j) == name)
+			{
+				int idx = 0;
+				for (k = 0 ; k < j ; k++)
+					idx += samples->GetVariableSize(k);
+				li.pointDataIndex[i] = idx;
+				break;
+			}
+		}
+	}
 }
 
 
diff --git a/avt/Filters/avtSamplePointExtractor.h b/avt/Filters/avtSamplePointExtractor.h
index fb40e83df..ac5700576 100644
--- a/avt/Filters/avtSamplePointExtractor.h
+++ b/avt/Filters/avtSamplePointExtractor.h
@@ -47,22 +47,21 @@
 
 #include <avtDatasetToSamplePointsFilter.h>
 #include <avtVolume.h>
-
 #include <avtViewInfo.h>
-#include <avtImgCommunicator.h>
+#include <avtOpacityMap.h>
+#include <avtSLIVROSPRayFilter.h>
+#include <avtSLIVRImgCommunicator.h>
+#include <avtSLIVRImgMetaData.h>
 
-#include <imgMetaData.h>
+#include <vtkCamera.h>
+#include <vtkMatrix4x4.h>
 
-#include <avtOpacityMap.h>
 #include <fstream>
 #include <vector>
 #include <map>
 #include <algorithm>
 #include <utility>
 
-#include <vtkCamera.h>
-#include <vtkMatrix4x4.h>
-
 class  vtkDataArray;
 class  vtkDataSet;
 class  vtkHexahedron;
@@ -147,94 +146,169 @@ class  avtRayFunction;
 //    Kevin Griffin, Fri Apr 22 16:31:57 PDT 2016
 //    Added support for polygons.
 //
+//    Qi Wu, to be determined
+//
 // ****************************************************************************
 
 class AVTFILTERS_API avtSamplePointExtractor 
     : public avtDatasetToSamplePointsFilter
 {
-  public:
+public:
+    typedef std::multimap<int, slivr::ImgData>::iterator iter_t;
+
+public:
+    // Output data for RC SLIVR
+    std::vector<slivr::ImgMetaData>    imageMetaPatchVector;
+    std::multimap<int, slivr::ImgData> imgDataHashMap;
+
+public:
                               avtSamplePointExtractor(int, int, int);
     virtual                  ~avtSamplePointExtractor();
-
     virtual const char       *GetType(void)
-                                         { return "avtSamplePointExtractor"; };
+    { return "avtSamplePointExtractor"; };
     virtual const char       *GetDescription(void)
-                                         { return "Extracting sample points";};
-
-    void                      RegisterRayFunction(avtRayFunction *rf)
-                                         { rayfoo = rf; };
-    void                      SendCellsMode(bool);
-    void                      SetRectilinearGridsAreInWorldSpace(bool, 
-                                                   const avtViewInfo &,double);
+    { return "Extracting sample points"; };
+    void                      RegisterRayFunction(avtRayFunction *_rf) { rayfoo = _rf; };
     void                      RestrictToTile(int, int, int, int);
+    void                      StartTiling(void) { shouldDoTiling = true; }; // added by Qi 
     void                      StopTiling(void) { shouldDoTiling = false; };
-
-    void                      Set3DMode(bool m) { modeIs3D = m; };
+    void                      SendCellsMode(bool);
+    void                      SetRectilinearGridsAreInWorldSpace(bool, 
+								 const avtViewInfo &,double);
+    void                      Set3DMode(bool _m) { modeIs3D = _m; };
     void                      SetKernelBasedSampling(bool);
     void                      SetJittering(bool);
+    void                      SetUpArbitrator(std::string &, bool);
+    void                      SetTrilinear(bool _t) { trilinearInterpolation = _t; };
+    void                      SetRayCastingSLIVR(bool _s) { rayCastingSLIVR = _s; };
+    void                      SetRayCastingSLIVRParallel(bool _p)
+    {
+	rayCastingSLIVRParallel = _p;
+    };
+    void                      SetLighting(bool _l) { lighting = _l; };
+    void                      SetLightPosition(double _lp[4])
+    {
+	for (int i=0;i<4;i++) { lightPosition[i] = _lp[i]; }
+    }
+    void                      SetLightDirection(double _ld[3])
+    {
+	for (int i=0;i<3;i++) { lightDirection[i] = _ld[i]; }
+    }
+    void                      SetMatProperties(double _matProp[4])
+    {
+	for (int i=0;i<4;i++) { materialProperties[i] = _matProp[i]; }
+    }
+    void                      SetTransferFn(avtOpacityMap *_transferFn1D)
+    {
+	transferFn1D = _transferFn1D;
+    };
+    void                      SetViewDirection(double *_vD) 
+    {
+	std::copy(_vD, _vD + 3, viewDirection);
+    }
+    void                      SetClipPlanes(double _camClip[2])
+    {
+	clipPlanes[0] = _camClip[0]; clipPlanes[1] = _camClip[1];
+    }
+    void                      SetPanPercentages(double _pan[2])
+    {
+	panPercentage[0] = _pan[0]; panPercentage[1] = _pan[1];
+    }
+    void                      SetImageZoom(double _zoom) { imageZoom = _zoom; }
+    void                      SetDepthExtents(double _depthExtents[2])
+    {
+	depthExtents[0] = _depthExtents[0]; depthExtents[1] = _depthExtents[1];
+    }
+    void                      SetMVPMatrix(vtkMatrix4x4 *_mvp)
+    {
+	modelViewProj->DeepCopy(_mvp);
+    }
 
-    void                      SetUpArbitrator(std::string &name, bool min);
-
-    void                      SetTrilinear(bool t) {trilinearInterpolation = t;  };
-    void                      SetRayCastingSLIVR(bool s) {rayCastingSLIVR = s;  };
-    void                      SetRayCastingSLIVRParallel(bool p) {rayCastingSLIVRParallel = p;  };
-    void                      SetLighting(bool l) {lighting = l; };
-    void                      SetLightPosition(double _lightPos[4]) { for (int i=0;i<4;i++) lightPosition[i]=_lightPos[i]; }
-    void                      SetLightDirection(double _lightDir[3]) { for (int i=0;i<3;i++) lightDirection[i]=_lightDir[i]; }
-    void                      SetMatProperties(double _matProp[4]) { for (int i=0;i<4;i++) materialProperties[i]=_matProp[i]; }
-    void                      SetTransferFn(avtOpacityMap *_transferFn1D) {transferFn1D = _transferFn1D; };
-    void                      SetViewDirection(double *vD){ for (int i=0; i<3; i++) viewDirection[i]=view_direction[i] = vD[i]; }
-    void                      SetClipPlanes(double _camClip[2]){ clipPlanes[0]=_camClip[0]; clipPlanes[1]=_camClip[1]; }
-    void                      SetPanPercentages(double _pan[2]){ panPercentage[0]=_pan[0]; panPercentage[1]=_pan[1]; }
-    void                      SetDepthExtents(double _depthExtents[2]){ depthExtents[0]=_depthExtents[0]; depthExtents[1]=_depthExtents[1]; }
-    void                      SetMVPMatrix(vtkMatrix4x4 *_mvp){ modelViewProj->DeepCopy(_mvp); }
-
-    void                      getSpatialExtents(double _spatialExtents[6]){ for (int i=0; i<6; i++) _spatialExtents[i] = minMaxSpatialBounds[i]; }
-    void                      getAvgPatchExtents(double _avgPatchExtents[6]){ for (int i=0; i<3; i++) _avgPatchExtents[i] = avgPatchExtents[i]; }
-    void                      getCellDimension(double _cellDimension[6]){ for (int i=0; i<3; i++) _cellDimension[i] = cellDimension[i]; }
-
-    void                      getProjectedExents(int _projectedExtents[4]){ for (int i=0; i<4; i++) _projectedExtents[i]=projectedImageExtents[i]; }
-
+    void                      GetSpatialExtents(double _spatialExtents[6])
+    {
+	for (int i=0; i<6; i++) _spatialExtents[i] = minMaxSpatialBounds[i];
+    }
+    void                      GetAvgPatchExtents(double _avgPatchExtents[6])
+    {
+	for (int i=0; i<3; i++) _avgPatchExtents[i] = avgPatchExtents[i];
+    }
+    void                      GetCellDimension(double _cellDimension[6])
+    {
+	for (int i=0; i<3; i++) _cellDimension[i] = cellDimension[i];
+    }
+    void                      GetProjectedExents(int _projectedExtents[4])
+    {
+	for (int i=0; i<4; i++) _projectedExtents[i]=projectedImageExtents[i];
+    }
+    //
     // Getting image information
-    int                       getTotalAssignedPatches() { return totalAssignedPatches; }              // gets the max number of patches it could have
-    int                       getImgPatchSize(){ return patchCount;};                                 // gets the number of patches
-    imgMetaData               getImgMetaPatch(int patchId){ return imageMetaPatchVector.at(patchId);} // gets the metadata
-    void                      getnDelImgData(int patchId, imgData &tempImgData);                      // gets the image & erase its existence
-    void                      delImgPatches();                                                        // deletes patches
-
+    //
+    // gets the max number of patches it could have
+    int                       GetTotalAssignedPatches() 
+    {
+	return totalAssignedPatches;
+    }    
+    // gets the number of patches
+    int                       GetImgPatchSize(){ return patchCount;};
+
+    // gets the metadata
+    slivr::ImgMetaData&       GetImgMetaPatch(int patchId)
+    { return imageMetaPatchVector.at(patchId); }
+    // gets the image & erase its existence
+    void                      GetAndDelImgData
+	(int patchId, slivr::ImgData &tempImgData);
+
+    // deletes patches
+    void                      DelImgPatches();
     // Set background buffer
-    void                      setDepthBuffer(float *_zBuffer, int size){ depthBuffer=_zBuffer; }
-    void                      setRGBBuffer(unsigned char  *_colorBuffer, int width, int height){ rgbColorBuffer=_colorBuffer; };
-    void                      setBufferExtents(int _extents[4]){ for (int i=0;i<4; i++) bufferExtents[i]=_extents[i]; }
+    void                      SetDepthBuffer(float *_zBuffer, int _size)
+    {
+	depthBuffer = _zBuffer;
+    }
+    void                      SetRGBBuffer(unsigned char *_colorBuffer, 
+					   int _width, int _height)
+    {
+	rgbColorBuffer = _colorBuffer;
+    }
+    void                      SetBufferExtents(int _extents[4])
+    {
+	for (int i=0;i<4; i++) bufferExtents[i] = _extents[i];
+    }
 
-    // Output data for RC SLIVR
-    std::vector<imgMetaData>    imageMetaPatchVector;
-    std::multimap<int, imgData> imgDataHashMap;
-    typedef std::multimap<int, imgData>::iterator iter_t;
-  protected:
-    int                       width, height, depth;
+    // Qi add for ospray  
+    void SetOSPRay(OSPVisItContext* o) { ospray = o; }
+    void SetRendererSampleRate(double r) { rendererSampleRate = r; }
+    void SetFullImageExtents(int extents[4]) 
+    {
+	fullImageExtents[0] = extents[0];
+	fullImageExtents[1] = extents[1];
+	fullImageExtents[2] = extents[2];	
+	fullImageExtents[3] = extents[3];
+    }
+
+protected:
+    int                       fullImageExtents[4];
+    int                       width,       height,       depth;
     int                       currentNode, totalNodes;
-
+    int                       widthMin,    widthMax;
+    int                       heightMin,   heightMax;
     bool                      shouldDoTiling;
-    int                       width_min, width_max;
-    int                       height_min, height_max;
     bool                      modeIs3D;
     bool                      kernelBasedSampling;
-    double                    point_radius;
+    double                    pointRadius;
     double                    minMaxSpatialBounds[6];
     double                    avgPatchExtents[3];
     double                    cellDimension[3];
-
-    // Background + other plots
-    float                     *depthBuffer;             // depth buffer for the background and other plots
-    unsigned char             *rgbColorBuffer;          // bounding box + pseudo color + ...
-    int                       bufferExtents[4];         // extents of the buffer( minX, maxX, minY, maxY)
-
+    // background + other plots
+    float                     *depthBuffer;       // depth buffer for the background and other plots
+    unsigned char             *rgbColorBuffer;    // bounding box + pseudo color + ...
+    int                       bufferExtents[4];   // extents of the buffer( minX, maxX, minY, maxY)
+    // attributor
     bool                      shouldSetUpArbitrator;
     std::string               arbitratorVarName;
     bool                      arbitratorPrefersMinimum;
     avtSamplePointArbitrator *arbitrator;
-
+    // different extractors
     avtHexahedronExtractor   *hexExtractor;
     avtHexahedron20Extractor *hex20Extractor;
     avtMassVoxelExtractor    *massVoxelExtractor;
@@ -242,32 +316,27 @@ class AVTFILTERS_API avtSamplePointExtractor
     avtPyramidExtractor      *pyramidExtractor;
     avtTetrahedronExtractor  *tetExtractor;
     avtWedgeExtractor        *wedgeExtractor;
-
+    // miscellaneous
     bool                      sendCells;
     bool                      jitter;
     avtRayFunction           *rayfoo;
-
     bool                      rectilinearGridsAreInWorldSpace;
     avtViewInfo               viewInfo;
     double                    aspect;
     int                       projectedImageExtents[4];
-
     int                       patchCount;
     int                       totalAssignedPatches;
-
     // triliniear / raycastin SLIVR
     bool                      trilinearInterpolation;
     bool                      rayCastingSLIVR;
     bool                      rayCastingSLIVRParallel;
-
     // Camera stuff
-    double                    view_direction[3];
-    double                    viewDirection[3];
+    double                    viewDirection[3];  // this is camera direction also
     double                    depthExtents[2];
     double                    clipPlanes[2];
     double                    panPercentage[2];
-    vtkMatrix4x4              *modelViewProj;
-
+    double                    imageZoom;
+    vtkMatrix4x4             *modelViewProj;
     // lighting & material
     bool                      lighting;
     double                    lightPosition[4];
@@ -279,8 +348,14 @@ class AVTFILTERS_API avtSamplePointExtractor
     virtual void              PostExecute(void);
     virtual void              ExecuteTree(avtDataTree_p);
     void                      SetUpExtractors(void);
-    imgMetaData               initMetaPatch(int id);    // initialize a patch
-
+    slivr::ImgMetaData        initMetaPatch(int id);    // initialize a patch
+    //
+    // OSPRay stuffs
+    //
+    OSPVisItContext               *ospray;
+    double                    rendererSampleRate;
+    
+protected:
     typedef struct 
     {
       std::vector<int>                  cellDataIndex;
@@ -292,36 +367,22 @@ class AVTFILTERS_API avtSamplePointExtractor
       int                               nVars;
     } LoadingInfo;
 
-    inline void               ExtractHex(vtkHexahedron*,vtkDataSet*, int,
-                                           LoadingInfo &);
-    inline void               ExtractHex20(vtkQuadraticHexahedron*,vtkDataSet*, int,
-                                           LoadingInfo &);
-    inline void               ExtractVoxel(vtkVoxel *, vtkDataSet *, int,
-                                           LoadingInfo &);
-    inline void               ExtractTet(vtkTetra *, vtkDataSet *, int,
-                                           LoadingInfo &);
-    inline void               ExtractPyramid(vtkPyramid *, vtkDataSet *, int,
-                                           LoadingInfo &);
-    inline void               ExtractWedge(vtkWedge *, vtkDataSet *, int,
-                                           LoadingInfo &);
-    inline void               ExtractTriangle(vtkTriangle *, vtkDataSet *, int,
-                                           LoadingInfo &);
-    inline void               ExtractQuad(vtkQuad *, vtkDataSet *, int,
-                                           LoadingInfo &);
-    inline void               ExtractPixel(vtkPixel *, vtkDataSet *, int, 
-                                           LoadingInfo &);
-    inline void               ExtractPolygon(vtkPolygon *, vtkDataSet *, int,
-                                             LoadingInfo &);
-
+    inline void               ExtractHex(vtkHexahedron*,vtkDataSet*, int, LoadingInfo &);
+    inline void               ExtractHex20(vtkQuadraticHexahedron*,vtkDataSet*, int, LoadingInfo &);
+    inline void               ExtractVoxel(vtkVoxel *, vtkDataSet *, int, LoadingInfo &);
+    inline void               ExtractTet(vtkTetra *, vtkDataSet *, int, LoadingInfo &);
+    inline void               ExtractPyramid(vtkPyramid *, vtkDataSet *, int, LoadingInfo &);
+    inline void               ExtractWedge(vtkWedge *, vtkDataSet *, int, LoadingInfo &);
+    inline void               ExtractTriangle(vtkTriangle *, vtkDataSet *, int, LoadingInfo &);
+    inline void               ExtractQuad(vtkQuad *, vtkDataSet *, int, LoadingInfo &);
+    inline void               ExtractPixel(vtkPixel *, vtkDataSet *, int, LoadingInfo &);
+    inline void               ExtractPolygon(vtkPolygon *, vtkDataSet *, int, LoadingInfo &);
     void                      KernelBasedSample(vtkDataSet *);
     void                      RasterBasedSample(vtkDataSet *, int num = 0);
-
     virtual bool              FilterUnderstandsTransformedRectMesh();
-
     void                      GetLoadingInfoForArrays(vtkDataSet *, LoadingInfo &);
 };
 
-
 #endif
 
 
diff --git a/avt/Pipeline/Data/avtOpacityMap.C b/avt/Pipeline/Data/avtOpacityMap.C
index dfe3673c1..b96537c76 100644
--- a/avt/Pipeline/Data/avtOpacityMap.C
+++ b/avt/Pipeline/Data/avtOpacityMap.C
@@ -78,7 +78,7 @@ avtOpacityMap::avtOpacityMap(int te)
     tableEntries = te;
     table = new RGBA[tableEntries];
   
-    transferFn1D = new _RGBA[tableEntries]();
+    transferFn1D = new RGBAF[tableEntries]();
     // RGBA contains a padded byte after the B and before the A.  Use a memset
     // to make sure this inaccessible byte is initialized.  This will allow
     // us to avoid purify issues.
@@ -94,6 +94,8 @@ avtOpacityMap::avtOpacityMap(int te)
 */
     min = 0.;
     max = 1.;
+    minVisibleScalarIndex = maxVisibleScalarIndex = 0;
+    minVisibleScalar = maxVisibleScalar = 0.;
     SetIntermediateVars();
 }
 
@@ -224,18 +226,25 @@ avtOpacityMap::SetTable(unsigned char *arr, int te, double attenuation)
     }
 
     if (table != NULL)
-    {
         delete [] table;
-    }
+    if (transferFn1D != NULL)
+        delete [] transferFn1D;
 
     tableEntries = te;
     table = new RGBA[tableEntries];
+    transferFn1D = new RGBAF[tableEntries];
     for (int i = 0 ; i < tableEntries ; i++)
     {
         table[i].R = arr[i*4];
         table[i].G = arr[i*4+1];
         table[i].B = arr[i*4+2];
-        table[i].A = ((float) arr[i*4+3] / 255.) * attenuation;
+        double alpha = (static_cast<double>(arr[i*4+3]) / 255.) * attenuation;
+        table[i].A = static_cast<unsigned char>(static_cast<int>(alpha * 255.));
+
+        transferFn1D[i].R = static_cast<float>(arr[i*4]) / 255.f;
+        transferFn1D[i].G = static_cast<float>(arr[i*4+1]) / 255.f;
+        transferFn1D[i].B = static_cast<float>(arr[i*4+2]) / 255.f;
+        transferFn1D[i].A = alpha;
     }
 
     //
@@ -316,6 +325,50 @@ avtOpacityMap::SetTable(unsigned char *arr, int te, double attenuation, float ov
 //  Creation:   June 6, 2013
 //
 // ****************************************************************************
+
+void
+avtOpacityMap::SetTableFloatNOC(unsigned char *arr, int te, double attenuation)
+{
+    if (attenuation < -1. || attenuation > 1.)
+    {
+        debug1 << "Bad attenuation value " << attenuation << std::endl;
+        EXCEPTION0(ImproperUseException);
+    }
+
+    if (transferFn1D != NULL) { delete [] transferFn1D; }
+
+    tableEntries = te;
+    transferFn1D = new RGBAF[tableEntries]();
+    minVisibleScalarIndex = maxVisibleScalarIndex = -1;
+
+    for (int i = 0 ; i < tableEntries ; i++)
+    {
+	double bp = tan(1.570796327 * (0.5 - attenuation*0.49999));
+	double alpha = pow((float) arr[i*4+3]/255.0f, (float)bp);
+        transferFn1D[i].R = (float)arr[i*4+0]/255.0f;
+        transferFn1D[i].G = (float)arr[i*4+1]/255.0f;
+        transferFn1D[i].B = (float)arr[i*4+2]/255.0f;
+        transferFn1D[i].A = alpha;
+        if (transferFn1D[i].A != 0 && minVisibleScalarIndex == -1) {
+            minVisibleScalarIndex = i;
+        }
+
+    }
+
+    for (int i=tableEntries-1; i>=0; i--)
+    {
+        if (transferFn1D[i].A != 0 && maxVisibleScalarIndex == -1){
+            maxVisibleScalarIndex = i;
+        }
+    }
+
+    //
+    // We need to set the intermediate vars again since the table size has
+    // potentially changed.
+    //
+    SetIntermediateVars();
+}
+
 void
 avtOpacityMap::SetTableFloat(unsigned char *arr, int te, double attenuation, float over)
 {
@@ -331,7 +384,7 @@ avtOpacityMap::SetTableFloat(unsigned char *arr, int te, double attenuation, flo
     }
 
     tableEntries = te;
-    transferFn1D = new _RGBA[tableEntries]();
+    transferFn1D = new RGBAF[tableEntries]();
     minVisibleScalarIndex =  maxVisibleScalarIndex = -1;
     for (int i = 0 ; i < tableEntries ; i++)
     {
@@ -345,28 +398,24 @@ avtOpacityMap::SetTableFloat(unsigned char *arr, int te, double attenuation, flo
         transferFn1D[i].A = alpha;
         if (alpha != 0 && minVisibleScalarIndex == -1){
             minVisibleScalarIndex = i;
-            //debug5 << "starting alpha = 0 at i= " << i << std::endl;
         }
 
-        //debug5 << i << " : " << transferFn1D[i].R << ", " << transferFn1D[i].G << ", " << transferFn1D[i].B <<  ", " << transferFn1D[i].A << std::endl;
     }
     for (int i=tableEntries-1; i>=0; i--)
     {
         if (transferFn1D[i].A != 0 && maxVisibleScalarIndex == -1){
             maxVisibleScalarIndex = i;
-            //debug5 << "ending alpha = 0 at i= " << i << std::endl;
         }
     }
 
-
-    //debug5 << "minVisibleScalarIndex: " << minVisibleScalarIndex << "   maxVisibleScalarIndex: " << maxVisibleScalarIndex << std::endl;
-
     //
     // We need to set the intermediate vars again since the table size has
     // potentially changed.
     //
     SetIntermediateVars();
 }
+
+
 // ****************************************************************************
 //  Method: avtOpacityMap::GetMinVisibleScalar
 //
@@ -417,17 +466,16 @@ void avtOpacityMap::computeVisibleRange()
     else
         minVisibleScalar = ( ((float)minVisibleScalarIndex/(tableEntries-1)) * scalarRange) + min;
     
-
-
     if (maxVisibleScalarIndex == tableEntries-1)
         maxVisibleScalar =  max;
     else
         maxVisibleScalar = ( ((float)maxVisibleScalarIndex/(tableEntries-1)) * scalarRange) + min;
 
-
-     debug5 << "max: " << max << "  min: " << min << "  scalarRange: " << scalarRange << "  minVisibleScalarIndex: " << minVisibleScalarIndex <<
-             "  maxVisibleScalarIndex: " << maxVisibleScalarIndex << "   tableEntries: " << tableEntries << 
-             "  maxVisibleScalar: " << maxVisibleScalar << "   minVisibleScalar: " << minVisibleScalar << std::endl;
+     debug5 << " max: " << max << " min: " << min 
+	    << " scalarRange: " << scalarRange << " minVisibleScalarIndex: " << minVisibleScalarIndex 
+	    << " maxVisibleScalarIndex: " << maxVisibleScalarIndex << " tableEntries: " << tableEntries
+	    << " maxVisibleScalar: " << maxVisibleScalar << " minVisibleScalar: " << minVisibleScalar 
+	    << std::endl;
 }
 
 // ****************************************************************************
@@ -488,9 +536,6 @@ avtOpacityMap::SetTable(RGBA *arr, int te, double attenuation)
 }
 
 
-
-
-
 // ****************************************************************************
 //  Method: avtOpacityMap::GetOpacity
 //
diff --git a/avt/Pipeline/Data/avtOpacityMap.h b/avt/Pipeline/Data/avtOpacityMap.h
index 099d39e8f..b2774044f 100644
--- a/avt/Pipeline/Data/avtOpacityMap.h
+++ b/avt/Pipeline/Data/avtOpacityMap.h
@@ -54,7 +54,7 @@ struct RGBA
     float         A;
 };
 
-struct _RGBA
+struct RGBAF
 {
     float R;
     float G;
@@ -96,9 +96,11 @@ class PIPELINE_API avtOpacityMap
     virtual                     ~avtOpacityMap();
 
     const RGBA                  *GetTable(void) { return table; };
+    const RGBAF                 *GetTableFloat(void) { return transferFn1D; };
     void                         SetTable(unsigned char *, int, double = 1.);
     void                         SetTable(unsigned char *arr, int te, double attenuation, float over);
     void                         SetTableFloat(unsigned char *arr, int te, double attenuation, float over);
+    void                         SetTableFloatNOC(unsigned char *arr, int te, double attenuation);
     void                         SetTable(RGBA *, int, double = 1.);
     const RGBA                  &GetOpacity(double);
 
@@ -122,7 +124,7 @@ class PIPELINE_API avtOpacityMap
 
   protected:
     RGBA                        *table;
-    _RGBA                       *transferFn1D;
+    RGBAF                       *transferFn1D;
     int                          tableEntries;
 
     double                       max, min;
@@ -239,7 +241,7 @@ avtOpacityMap::QueryTF(double scalarValue, double color[4])
     if (scalarValue <= min){
         int index = 0;
 
-        _RGBA colorRGBA = transferFn1D[index];
+        RGBAF colorRGBA = transferFn1D[index];
         color[0] = colorRGBA.R;
         color[1] = colorRGBA.G;
         color[2] = colorRGBA.B;
@@ -250,7 +252,7 @@ avtOpacityMap::QueryTF(double scalarValue, double color[4])
 
     if (scalarValue >= max){
         int index = tableEntries-1;
-        _RGBA colorRGBA = transferFn1D[index];
+        RGBAF colorRGBA = transferFn1D[index];
         color[0] = colorRGBA.R;
         color[1] = colorRGBA.G;
         color[2] = colorRGBA.B;
@@ -260,7 +262,7 @@ avtOpacityMap::QueryTF(double scalarValue, double color[4])
     }
 
     int indexLow, indexHigh;
-    _RGBA colorRGBALow, colorRGBAHigh;
+    RGBAF colorRGBALow, colorRGBAHigh;
     double colorLow[4], colorHigh[4];
     float indexPos, indexDiff;
 
diff --git a/avt/Plotter/CMakeLists.txt b/avt/Plotter/CMakeLists.txt
index d69770c75..076e63864 100644
--- a/avt/Plotter/CMakeLists.txt
+++ b/avt/Plotter/CMakeLists.txt
@@ -61,11 +61,11 @@
 #
 #****************************************************************************/
 
-if(VISIT_OSPRAY)
-   SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH}
-       ${VISIT_SOURCE_DIR}/avt/Plotter/OSPRay/CMake)
-   FIND_PACKAGE(OSPRay REQUIRED)
-endif()
+# if(VISIT_OSPRAY)
+#    SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH}
+#        ${VISIT_SOURCE_DIR}/avt/Plotter/OSPRay/CMake)
+#    FIND_PACKAGE(OSPRay REQUIRED)
+# endif()
 
 SET(VISIT_VTK_MANTA_SOURCES
 Manta/vtkMantaPolyDataMapper.C 
@@ -81,22 +81,22 @@ Manta/vtkMantaManager.C
 Manta/vtkMantaCubeAxesActor.C
 )
 
-SET(VISIT_VTK_OSPRAY_SOURCES
-    OSPRay/vtkOSPRay/vtkOSPRay.h
-    OSPRay/vtkOSPRay/vtkOSPRayActor.cxx
-    OSPRay/vtkOSPRay/vtkOSPRayCamera.cxx
-    OSPRay/vtkOSPRay/vtkOSPRayLight.cxx
-    OSPRay/vtkOSPRay/vtkOSPRayManager.cxx
-    OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.cxx
-    OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.h
-    OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.cxx
-    OSPRay/vtkOSPRay/vtkOSPRayProperty.cxx
-    OSPRay/vtkOSPRay/vtkOSPRayRenderer.cxx
-    OSPRay/vtkOSPRay/vtkOSPRayTexture.cxx
-    OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.h
-    OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.cxx
-    OSPRay/vtkOSPRayModule.h
-)
+# SET(VISIT_VTK_OSPRAY_SOURCES
+#     OSPRay/vtkOSPRay/vtkOSPRay.h
+#     OSPRay/vtkOSPRay/vtkOSPRayActor.cxx
+#     OSPRay/vtkOSPRay/vtkOSPRayCamera.cxx
+#     OSPRay/vtkOSPRay/vtkOSPRayLight.cxx
+#     OSPRay/vtkOSPRay/vtkOSPRayManager.cxx
+#     OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.cxx
+#     OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.h
+#     OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.cxx
+#     OSPRay/vtkOSPRay/vtkOSPRayProperty.cxx
+#     OSPRay/vtkOSPRay/vtkOSPRayRenderer.cxx
+#     OSPRay/vtkOSPRay/vtkOSPRayTexture.cxx
+#     OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.h
+#     OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.cxx
+#     OSPRay/vtkOSPRayModule.h
+# )
 
 # create configuration file to pass off cmake options
 CONFIGURE_FILE(
@@ -187,11 +187,11 @@ IF(VISIT_MANTA)
   SET(AVTPLOTTER_SOURCES ${AVTPLOTTER_SOURCES} ${VISIT_VTK_MANTA_SOURCES} )
 ENDIF(VISIT_MANTA)
 
-IF(VISIT_OSPRAY)
-    SET(AVTPLOTTER_SOURCES ${AVTPLOTTER_SOURCES} ${VISIT_VTK_OSPRAY_SOURCES} )
-    SET(VTK_INCLUDE_DIRS ${VTK_INCLUDE_DIRS}
-        ${VISIT_SOURCE_DIR}/../../VTK-6.1.0/Rendering/Volume)
-ENDIF(VISIT_OSPRAY)
+# IF(VISIT_OSPRAY)
+#   SET(AVTPLOTTER_SOURCES ${AVTPLOTTER_SOURCES} ${VISIT_VTK_OSPRAY_SOURCES})
+#   SET(VTK_INCLUDE_DIRS ${VTK_INCLUDE_DIRS}
+#       ${VISIT_SOURCE_DIR}/../../VTK-6.1.0/Rendering/Volume)
+# ENDIF(VISIT_OSPRAY)
 
 INCLUDE_DIRECTORIES(
 ${VISIT_COMMON_INCLUDES}
@@ -209,8 +209,8 @@ ${VISIT_SOURCE_DIR}/avt/Pipeline/Pipeline
 ${VISIT_SOURCE_DIR}/avt/Pipeline/Sinks
 ${VISIT_SOURCE_DIR}/avt/Pipeline/Sources
 ${VISIT_SOURCE_DIR}/avt/Plotter/Manta
-${VISIT_SOURCE_DIR}/avt/Plotter/OSPRay
-${VISIT_SOURCE_DIR}/avt/Plotter/OSPRay/vtkOSPRay
+# ${VISIT_SOURCE_DIR}/avt/Plotter/OSPRay
+# ${VISIT_SOURCE_DIR}/avt/Plotter/OSPRay/vtkOSPRay
 ${VISIT_SOURCE_DIR}/avt/View
 ${VISIT_SOURCE_DIR}/visit_vtk/full
 ${VISIT_SOURCE_DIR}/visit_vtk/lightweight
@@ -235,14 +235,16 @@ ADD_TARGET_DEFINITIONS(avtplotter_ser "${VTK_DEFINITIONS}")
 IF(VISIT_MANTA)
   TARGET_LINK_LIBRARIES(avtplotter_ser ${MANTA_TARGET_LINK_LIBRARIES})
 ENDIF(VISIT_MANTA)
-IF(VISIT_OSPRAY)
-    MESSAGE(STATUS "OSPRAY_TARGET_LINK_LIBRARIES: " ${OSPRAY_TARGET_LINK_LIBRARIES})
-    MESSAGE(STATUS "OSPRAY_LIBRARIES: " ${OSPRAY_LIBRARIES})
-    MESSAGE(STATUS "OSPRAY_INCLUDE_DIRS: " ${OSPRAY_INCLUDE_DIRS})
-    TARGET_LINK_LIBRARIES(avtplotter_ser ${OSPRAY_TARGET_LINK_LIBRARIES}
-        ${OSPRAY_LIBRARIES} ${VTK_LIBRARIES})
-    INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS} ${VISIT_SOURCE_DIR}/../../VTK-6.1.0/Parallel/Core)
-ENDIF(VISIT_OSPRAY)
+# IF(VISIT_OSPRAY)
+#     # MESSAGE(STATUS "OSPRAY_TARGET_LINK_LIBRARIES: " ${OSPRAY_TARGET_LINK_LIBRARIES})
+#     # MESSAGE(STATUS "OSPRAY_LIBRARIES: " ${OSPRAY_LIBRARIES})
+#     # MESSAGE(STATUS "OSPRAY_INCLUDE_DIRS: " ${OSPRAY_INCLUDE_DIRS})
+#     # TARGET_LINK_LIBRARIES(avtplotter_ser ${OSPRAY_TARGET_LINK_LIBRARIES}
+#     #     ${OSPRAY_LIBRARIES} ${VTK_LIBRARIES})
+#     # INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIRS} ${VISIT_SOURCE_DIR}/../../VTK-6.1.0/Parallel/Core)
+#     TARGET_LINK_LIBRARIES(avtplotter_ser ${OSPRAY_LIBRARIES})
+#     INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIR})
+# ENDIF(VISIT_OSPRAY)
 VISIT_INSTALL_TARGETS(avtplotter_ser)
 
 #********************************* PARALLEL **********************************
@@ -262,10 +264,10 @@ IF(VISIT_PARALLEL)
       #  LINK_DIRECTORIES(${ICET_LIBRARY_DIR})
       #ENDIF(ICET_FOUND)
     ENDIF(VISIT_MANTA)
-    IF(VISIT_OSPRAY)
-        TARGET_LINK_LIBRARIES(avtplotter_par ${OSPRAY_TARGET_LINK_LIBRARIES}
-            ${OSPRAY_LIBRARIES})
-    ENDIF(VISIT_OSPRAY)
+    # IF(VISIT_OSPRAY)
+    #     TARGET_LINK_LIBRARIES(avtplotter_par ${OSPRAY_LIBRARIES})
+    # 	INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIR})
+    # ENDIF(VISIT_OSPRAY)
 
     VISIT_INSTALL_TARGETS(avtplotter_par)
 ENDIF(VISIT_PARALLEL)
diff --git a/avt/Plotter/vtk/InitVTKRendering.C b/avt/Plotter/vtk/InitVTKRendering.C
index da047a338..1d330547c 100644
--- a/avt/Plotter/vtk/InitVTKRendering.C
+++ b/avt/Plotter/vtk/InitVTKRendering.C
@@ -58,9 +58,9 @@
 #include <vtkMantaObjectFactory.h>
 #endif
 
-#ifdef VISIT_OSPRAY
-#include <vtkOSPRayObjectFactory.h>
-#endif
+// #ifdef VISIT_OSPRAY
+// #include "ospray/ospray.h"
+// #endif
 
 #include <avtCallback.h>
 #include <DebugStream.h>
@@ -180,19 +180,15 @@ vtkVisItGraphicsFactory::vtkVisItGraphicsFactory()
 void
 InitVTKRendering::Initialize(void)
 {
-#ifdef VISIT_OSPRAY
-    if (avtCallback::UseOSPRay())
-    {
-      debug1 << "InitVTKRendering::Initializing turning on OSPRay" << endl;
-      vtkOSPRayObjectFactory* ofactory = vtkOSPRayObjectFactory::New();
-      vtkObjectFactory::RegisterFactory(ofactory);
-      ofactory->Delete();
-    }
-    else
-    {
-      debug1 << "InitVTKRendering::Initializing not turning on OSPRay" << endl;
-    }
-#endif
+// #ifdef VISIT_OSPRAY
+//     if (avtCallback::UseOSPRay())
+//     {
+// 	// debug1 << "InitVTKRendering::Initializing turning on OSPRay" << endl;
+// 	// vtkOSPRayObjectFactory* ofactory = vtkOSPRayObjectFactory::New();
+// 	// vtkObjectFactory::RegisterFactory(ofactory);
+// 	// ofactory->Delete();
+//     }
+// #endif
 
     // Register the factory that allows VisIt objects to override vtk objects.
     vtkVisItGraphicsFactory *factory = vtkVisItGraphicsFactory::New();
diff --git a/avt/Plotter/vtk/InitVTKRenderingConfig.h.in b/avt/Plotter/vtk/InitVTKRenderingConfig.h.in
index bf7d525e6..4db7ec6e0 100644
--- a/avt/Plotter/vtk/InitVTKRenderingConfig.h.in
+++ b/avt/Plotter/vtk/InitVTKRenderingConfig.h.in
@@ -1,2 +1,2 @@
 #cmakedefine VISIT_MANTA
-#cmakedefine VISIT_OSPRAY
+//#cmakedefine VISIT_OSPRAY
diff --git a/config-site/.DS_Store b/config-site/.DS_Store
new file mode 100644
index 000000000..5008ddfcf
Binary files /dev/null and b/config-site/.DS_Store differ
diff --git a/plots/Volume/CMakeLists.txt b/plots/Volume/CMakeLists.txt
index 4b7e63e71..3c40a9ac1 100644
--- a/plots/Volume/CMakeLists.txt
+++ b/plots/Volume/CMakeLists.txt
@@ -125,6 +125,25 @@ ${VISIT_INCLUDE_DIR}/avt/Expressions/Abstract
 ${VISIT_INCLUDE_DIR}/avt/Expressions/General
 )
 
+IF (VISIT_OSPRAY) 
+  INCLUDE_DIRECTORIES(${OSPRAY_INCLUDE_DIR})
+ENDIF ()
+
+IF(ICET_FOUND)
+  # We need to link with OpenGL on Mac when we have IceT.
+  IF(APPLE)
+    SET(ICET_OPENGL ${OPENGL_gl_LIBRARY})
+  ENDIF(APPLE)
+  # full path IceT libraries 
+  SET(ICET_FULL_LIB "")
+  FOREACH(X ${ICET_LIB})
+    LIST(APPEND ICET_FULL_LIB "${ICET_LIBRARY_DIR}/${X}")
+  ENDFOREACH()
+  SET(ICET_LINK_LIB ${ICET_FULL_LIB} ${ICET_OPENGL})  
+  # add include path
+  INCLUDE_DIRECTORIES(${ICET_INCLUDE_DIR})
+ENDIF(ICET_FOUND)
+
 LINK_DIRECTORIES(${VISIT_LIBRARY_DIR} ${QT_LIBRARY_DIR} ${QWT_LIBRARY_DIR} ${GLEW_LIBRARY_DIR} ${EAVL_LIBRARY_DIR} ${VTKM_LIBRARY_DIR} ${VTK_LIBRARY_DIRS} )
 
 ADD_LIBRARY(IVolumePlot ${LIBI_SOURCES})
@@ -139,6 +158,12 @@ IF(NOT VISIT_SERVER_COMPONENTS_ONLY AND NOT VISIT_ENGINE_ONLY AND NOT VISIT_DBIO
     ADD_LIBRARY(VVolumePlot ${LIBV_SOURCES})
     TARGET_LINK_LIBRARIES(VVolumePlot visitcommon viewer ${TUVOK_LIB} ${SLIVR_LIB} ${GLEW_LIB} ${OPENGL_gl_LIBRARY} )
 
+    IF(VISIT_OSPRAY)
+      TARGET_LINK_LIBRARIES(VVolumePlot ${OSPRAY_LIBRARIES})
+    ENDIF()
+    IF(ICET_FOUND)
+      TARGET_LINK_LIBRARIES(VVolumePlot ${ICET_LINK_LIB})  
+    ENDIF(ICET_FOUND)
     SET(INSTALLTARGETS ${INSTALLTARGETS} GVolumePlot VVolumePlot)
 
     IF(VISIT_PYTHON_SCRIPTING)
@@ -164,12 +189,24 @@ ENDIF(NOT VISIT_SERVER_COMPONENTS_ONLY AND NOT VISIT_ENGINE_ONLY AND NOT VISIT_D
 
 ADD_LIBRARY(EVolumePlot_ser ${LIBE_SOURCES})
 TARGET_LINK_LIBRARIES(EVolumePlot_ser visitcommon avtplotter_ser avtpipeline_ser ${TUVOK_LIB} ${SLIVR_LIB} ${GLEW_LIB} ${OPENGL_gl_LIBRARY} avtexpressions_ser )
+IF(VISIT_OSPRAY)
+  TARGET_LINK_LIBRARIES(EVolumePlot_ser ${OSPRAY_LIBRARIES})
+ENDIF()
+IF(ICET_FOUND)
+  TARGET_LINK_LIBRARIES(EVolumePlot_ser ${ICET_LINK_LIB})  
+ENDIF(ICET_FOUND)
 SET(INSTALLTARGETS ${INSTALLTARGETS} EVolumePlot_ser)
 ADD_TARGET_DEFINITIONS(EVolumePlot_ser ENGINE)
 
 IF(VISIT_PARALLEL)
     ADD_PARALLEL_LIBRARY(EVolumePlot_par ${LIBE_SOURCES})
     TARGET_LINK_LIBRARIES(EVolumePlot_par visitcommon avtplotter_par avtpipeline_par ${TUVOK_LIB} ${SLIVR_LIB} ${GLEW_LIB} ${OPENGL_gl_LIBRARY} avtexpressions_par )
+    IF(VISIT_OSPRAY)
+      TARGET_LINK_LIBRARIES(EVolumePlot_par ${OSPRAY_LIBRARIES})
+    ENDIF()
+    IF(ICET_FOUND)
+      TARGET_LINK_LIBRARIES(EVolumePlot_par ${ICET_LINK_LIB})  
+    ENDIF(ICET_FOUND)
     SET(INSTALLTARGETS ${INSTALLTARGETS} EVolumePlot_par)
     ADD_TARGET_DEFINITIONS(EVolumePlot_par ENGINE)
 ENDIF(VISIT_PARALLEL)
diff --git a/plots/Volume/PyVolumeAttributes.C b/plots/Volume/PyVolumeAttributes.C
index 51861ca78..880ce0bdc 100644
--- a/plots/Volume/PyVolumeAttributes.C
+++ b/plots/Volume/PyVolumeAttributes.C
@@ -183,7 +183,7 @@ PyVolumeAttributes_ToString(const VolumeAttributes *atts, const char *prefix)
     SNPRINTF(tmpStr, 1000, "%ssamplesPerRay = %d\n", prefix, atts->GetSamplesPerRay());
     str += tmpStr;
     const char *rendererType_names = "Splatting, Texture3D, RayCasting, RayCastingIntegration, SLIVR, "
-        "RayCastingSLIVR, Tuvok";
+        "RayCastingSLIVR, RayCastingOSPRay, Tuvok";
     switch (atts->GetRendererType())
     {
       case VolumeAttributes::Splatting:
@@ -210,6 +210,10 @@ PyVolumeAttributes_ToString(const VolumeAttributes *atts, const char *prefix)
           SNPRINTF(tmpStr, 1000, "%srendererType = %sRayCastingSLIVR  # %s\n", prefix, prefix, rendererType_names);
           str += tmpStr;
           break;
+      case VolumeAttributes::RayCastingOSPRay:
+          SNPRINTF(tmpStr, 1000, "%srendererType = %sRayCastingOSPRay  # %s\n", prefix, prefix, rendererType_names);
+          str += tmpStr;
+          break;
       case VolumeAttributes::Tuvok:
           SNPRINTF(tmpStr, 1000, "%srendererType = %sTuvok  # %s\n", prefix, prefix, rendererType_names);
           str += tmpStr;
@@ -988,15 +992,15 @@ VolumeAttributes_SetRendererType(PyObject *self, PyObject *args)
         return NULL;
 
     // Set the rendererType in the object.
-    if(ival >= 0 && ival < 7)
+    if(ival >= 0 && ival < 8)
         obj->data->SetRendererType(VolumeAttributes::Renderer(ival));
     else
     {
         fprintf(stderr, "An invalid rendererType value was given. "
-                        "Valid values are in the range of [0,6]. "
+                        "Valid values are in the range of [0,7]. "
                         "You can also use the following names: "
                         "Splatting, Texture3D, RayCasting, RayCastingIntegration, SLIVR, "
-                        "RayCastingSLIVR, Tuvok.");
+                        "RayCastingSLIVR, RayCastingOSPRay, Tuvok.");
         return NULL;
     }
 
@@ -1662,6 +1666,8 @@ PyVolumeAttributes_getattr(PyObject *self, char *name)
         return PyInt_FromLong(long(VolumeAttributes::SLIVR));
     if(strcmp(name, "RayCastingSLIVR") == 0)
         return PyInt_FromLong(long(VolumeAttributes::RayCastingSLIVR));
+    if(strcmp(name, "RayCastingOSPRay") == 0)
+        return PyInt_FromLong(long(VolumeAttributes::RayCastingOSPRay));
     if(strcmp(name, "Tuvok") == 0)
         return PyInt_FromLong(long(VolumeAttributes::Tuvok));
 
diff --git a/plots/Volume/QvisVolumePlotWindow.C b/plots/Volume/QvisVolumePlotWindow.C
index 1216fdf04..8c7d6c82e 100644
--- a/plots/Volume/QvisVolumePlotWindow.C
+++ b/plots/Volume/QvisVolumePlotWindow.C
@@ -1314,6 +1314,22 @@ void QvisVolumePlotWindow::UpdateSamplingGroup()
         sobelButton->setEnabled(false);
         break;
 
+    case VolumeAttributes::RayCastingOSPRay:
+        EnableSLIVRGroup();
+        resampleGroup->setEnabled(false);
+        raycastingGroup->setVisible(false);
+        UpdateLowGradientGroup(false);
+        materialProperties->setEnabled(volumeAtts->GetRendererType()==VolumeAttributes::RayCastingOSPRay);
+        EnableSamplingMethods(true);
+        samplesPerRayWidget->setEnabled(volumeAtts->GetRendererType()!=VolumeAttributes::RayCastingOSPRay);
+        rendererSamplesWidget->setEnabled(volumeAtts->GetRendererType()==VolumeAttributes::RayCastingOSPRay);
+        rendererSamplesSLIVRLabel->setEnabled(true);
+        rendererSamplesSLIVR->setEnabled(true);
+        centeredDiffButton->setEnabled(true);
+        centeredDiffButton->setChecked(true);
+        sobelButton->setEnabled(false);
+        break;
+
     default:
         EXCEPTION1(ImproperUseException, "No such renderer type.");
     }        
@@ -1357,6 +1373,9 @@ QvisVolumePlotWindow::CreateRendererOptionsGroup(int maxWidth)
 #ifdef HAVE_LIBSLIVR
     rendererTypesComboBox->addItem(tr("SLIVR"));
     rendererTypesComboBox->addItem(tr("Ray casting: SLIVR"));
+#ifdef VISIT_OSPRAY
+    rendererTypesComboBox->addItem(tr("Ray casting: OSPRay"));
+#endif
 #endif
     connect(rendererTypesComboBox, SIGNAL(activated(int)),
             this, SLOT(rendererTypeChanged(int)));
@@ -1921,6 +1940,12 @@ QvisVolumePlotWindow::UpdateWindow(bool doAll)
                 int idx=std::max(1,rendererTypesComboBox->findText("Ray casting: SLIVR"));
                 rendererTypesComboBox->setCurrentIndex(idx);
             }
+            else if (volumeAtts->GetRendererType() == VolumeAttributes::RayCastingOSPRay)
+            {
+                int idx=std::max(1,rendererTypesComboBox->findText("Ray casting: OSPRay"));
+                rendererTypesComboBox->setCurrentIndex(idx);
+            }
+
 
 
             // Just for now, disable the opacity variable if we are using the
@@ -3790,6 +3815,7 @@ QvisVolumePlotWindow::rendererTypeChanged(int val)
       case 4:
       case 5:
       case 6:
+      case 7:
       {
           if (rendererTypesComboBox->findText("Tuvok") == val)
               volumeAtts->SetRendererType(VolumeAttributes::Tuvok);
@@ -3797,6 +3823,9 @@ QvisVolumePlotWindow::rendererTypeChanged(int val)
               volumeAtts->SetRendererType(VolumeAttributes::SLIVR);
           else if (rendererTypesComboBox->findText("Ray casting: SLIVR") == val)
               volumeAtts->SetRendererType(VolumeAttributes::RayCastingSLIVR);
+          else if (rendererTypesComboBox->findText("Ray casting: OSPRay") == val)
+              volumeAtts->SetRendererType(VolumeAttributes::RayCastingOSPRay);
+
           break;
       }
       default:
diff --git a/plots/Volume/Volume.xml b/plots/Volume/Volume.xml
index 58994cdc7..90f144836 100644
--- a/plots/Volume/Volume.xml
+++ b/plots/Volume/Volume.xml
@@ -88,7 +88,8 @@
         RayCasting
         RayCastingIntegration
         SLIVR
-    RayCastingSLIVR
+	RayCastingSLIVR
+	RayCastingOSPRay
         Tuvok
       </Enum>
       <Enum name="GradientType">
diff --git a/plots/Volume/VolumeAttributes.C b/plots/Volume/VolumeAttributes.C
index f6b9abfa7..06e77d60e 100644
--- a/plots/Volume/VolumeAttributes.C
+++ b/plots/Volume/VolumeAttributes.C
@@ -48,7 +48,9 @@
 
 static const char *Renderer_strings[] = {
 "Splatting", "Texture3D", "RayCasting", 
-"RayCastingIntegration", "SLIVR", "RayCastingSLIVR", 
+"RayCastingIntegration", "SLIVR", 
+"RayCastingSLIVR", 
+"RayCastingOSPRay", 
 "Tuvok"};
 
 std::string
@@ -2546,6 +2548,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
 
     if (rendererType == VolumeAttributes::RayCasting ||
         rendererType == VolumeAttributes::RayCastingSLIVR || 
+        rendererType == VolumeAttributes::RayCastingOSPRay || 
         rendererType == VolumeAttributes::RayCastingIntegration)
     {
         // Trilinear requires ghost zone while Rasterization and KernelBased do not
@@ -2574,6 +2577,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
         // modes does not require a reexecute.
         if(obj.rendererType == VolumeAttributes::RayCasting ||
            obj.rendererType == VolumeAttributes::RayCastingSLIVR || 
+           obj.rendererType == VolumeAttributes::RayCastingOSPRay || 
            obj.rendererType == VolumeAttributes::RayCastingIntegration)
         {
             return true;
diff --git a/plots/Volume/VolumeAttributes.code b/plots/Volume/VolumeAttributes.code
index ac6257a1f..15179b0d8 100644
--- a/plots/Volume/VolumeAttributes.code
+++ b/plots/Volume/VolumeAttributes.code
@@ -71,6 +71,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
 
     if (rendererType == VolumeAttributes::RayCasting ||
         rendererType == VolumeAttributes::RayCastingSLIVR || 
+        rendererType == VolumeAttributes::RayCastingOSPRay || 
         rendererType == VolumeAttributes::RayCastingIntegration)
     {
         // Trilinear requires ghost zone while Rasterization and KernelBased do not
@@ -99,6 +100,7 @@ VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
         // modes does not require a reexecute.
         if(obj.rendererType == VolumeAttributes::RayCasting ||
            obj.rendererType == VolumeAttributes::RayCastingSLIVR || 
+           obj.rendererType == VolumeAttributes::RayCastingOSPRay || 
            obj.rendererType == VolumeAttributes::RayCastingIntegration)
         {
             return true;
diff --git a/plots/Volume/VolumeAttributes.h b/plots/Volume/VolumeAttributes.h
index 5214c6aea..2cf23c207 100644
--- a/plots/Volume/VolumeAttributes.h
+++ b/plots/Volume/VolumeAttributes.h
@@ -71,6 +71,7 @@ public:
         RayCastingIntegration,
         SLIVR,
         RayCastingSLIVR,
+        RayCastingOSPRay,
         Tuvok
     };
     enum GradientType
diff --git a/plots/Volume/VolumeAttributes.java b/plots/Volume/VolumeAttributes.java
index 2f06eca51..c07eb4e03 100644
--- a/plots/Volume/VolumeAttributes.java
+++ b/plots/Volume/VolumeAttributes.java
@@ -72,7 +72,8 @@ public class VolumeAttributes extends AttributeSubject implements Plugin
     public final static int RENDERER_RAYCASTINGINTEGRATION = 3;
     public final static int RENDERER_SLIVR = 4;
     public final static int RENDERER_RAYCASTINGSLIVR = 5;
-    public final static int RENDERER_TUVOK = 6;
+    public final static int RENDERER_RAYCASTINGOSPRAY = 6;
+    public final static int RENDERER_TUVOK = 7;
 
     public final static int GRADIENTTYPE_CENTEREDDIFFERENCES = 0;
     public final static int GRADIENTTYPE_SOBELOPERATOR = 1;
diff --git a/plots/Volume/avtVolumeFilter.C b/plots/Volume/avtVolumeFilter.C
index a4da38b0c..4c78aadaf 100644
--- a/plots/Volume/avtVolumeFilter.C
+++ b/plots/Volume/avtVolumeFilter.C
@@ -63,6 +63,7 @@
 #include <avtSourceFromAVTDataset.h>
 #include <avtView3D.h>
 #include <avtViewInfo.h>
+#include <avtMemory.h>
 
 #include <DebugStream.h>
 #include <InvalidDimensionsException.h>
@@ -96,11 +97,15 @@ static void CreateViewInfoFromViewAttributes(avtViewInfo &,
 //    Hank Childs, Wed Nov 24 16:23:41 PST 2004
 //    Removed references to data members that have been moved.
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for ospray volume rendering
+//
 // ****************************************************************************
 
 avtVolumeFilter::avtVolumeFilter()
 {
     primaryVariable = NULL;
+    ospray = NULL;
 }
 
 
@@ -115,6 +120,9 @@ avtVolumeFilter::avtVolumeFilter()
 //    Hank Childs, Wed Nov 24 16:23:41 PST 2004
 //    Removed references to data members that have been moved.
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for ospray volume rendering
+//
 // ****************************************************************************
 
 avtVolumeFilter::~avtVolumeFilter()
@@ -124,6 +132,9 @@ avtVolumeFilter::~avtVolumeFilter()
         delete [] primaryVariable;
         primaryVariable = NULL;
     }
+    if (ospray != NULL) {
+	delete ospray;
+    }
 }
 
 
@@ -362,6 +373,9 @@ avtVolumeFilter::Execute(void)
 //    We don't use lighting in the raycasting integration case.
 //    Make sure we don't require the gradient calc.
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for ospray volume rendering
+//
 // ****************************************************************************
 extern bool GetLogicalBounds(avtDataObject_p input,int &width,int &height, int &depth);
 
@@ -379,19 +393,35 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     //
     // Set up the volume renderer.
     //
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay) {
+	avtCallback::SetOSPRayMode(true);
+	debug1 << "running with OSPRay backend" << std::endl;
+    } else {
+	avtCallback::SetOSPRayMode(false);
+	debug1 << "running with CPU Raycasting backend" << std::endl;
+    }
     avtRayTracer *software = new avtRayTracer;
     software->SetRayCastingSLIVR(true);
     software->SetTrilinear(false);
     software->SetInput(termsrc.GetOutput());
     software->InsertOpaqueImage(opaque_image);
-
+    if (avtCallback::UseOSPRay()) 
+    {
+	if (ospray == NULL) { ospray = new OSPVisItContext(); }
+	software->SetOSPRay(ospray);
+    }
     //
     // Set up the transfer function
     //
     unsigned char vtf[4*256];
     atts.GetTransferFunction(vtf);
     avtOpacityMap om(256);
-    om.SetTableFloat(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0, atts.GetRendererSamples());
+    // remove alpha correction when using ospray (because ospray will handle that also)
+    if (avtCallback::UseOSPRay()) {
+	om.SetTableFloatNOC(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0); // no alpha correction
+    } else {
+	om.SetTableFloat(vtf, 256, atts.GetOpacityAttenuation()*2.0 - 1.0, atts.GetRendererSamples());
+    }
 
     double actualRange[2];
     bool artificialMin = atts.GetUseColorVarMin();
@@ -441,9 +471,8 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     avtCompositeRF *compositeRF = new avtCompositeRF(lm, &om, &om);
     software->SetTransferFn(&om);
 
-    debug5 << "Min visible scalar range:" << om.GetMinVisibleScalar() << "  Max visible scalar range: "  <<  om.GetMaxVisibleScalar() << std::endl;
-
-
+    debug5 << "Min visible scalar range: " << om.GetMinVisibleScalar() << " "
+	   << "Max visible scalar range: " << om.GetMaxVisibleScalar() << std::endl;
 
     //
     // Determine which variables to use and tell the ray function.
@@ -523,10 +552,10 @@ avtVolumeFilter::RenderImageRaycastingSLIVR(avtImage_p opaque_image,
     //
     software->SetRayFunction(compositeRF);
     software->SetSamplesPerRay(atts.GetSamplesPerRay());
+    software->SetRendererSampleRate(atts.GetRendererSamples());
 
-    debug5 << "Sampling rate: "  << atts.GetRendererSamples() << std::endl;
-
-
+    debug5 << "Sampling rate: (GetSamplesPerRay)   " << atts.GetSamplesPerRay() << std::endl;
+    debug5 << "Sampling rate: (GetRendererSamples) " << atts.GetRendererSamples() << std::endl;
 
     //
     // Set camera parameters
@@ -632,8 +661,9 @@ avtImage_p
 avtVolumeFilter::RenderImage(avtImage_p opaque_image,
                              const WindowAttributes &window)
 {
-    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR){
-        return RenderImageRaycastingSLIVR(opaque_image,window);
+    if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+	atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay) {
+	return RenderImageRaycastingSLIVR(opaque_image,window);
     }
 
 
@@ -1188,6 +1218,9 @@ CreateViewInfoFromViewAttributes(avtViewInfo &vi, const View3DAttributes &view)
 //    Modify how expressions are setup, to prevent multiple expressions
 //    with the same name being added to the ExpressionList.
 //
+//    Qi WU, Wed Jun 20 2018
+//    Add support for ospray volume rendering
+//
 // ****************************************************************************
 
 avtContract_p
@@ -1210,9 +1243,13 @@ avtVolumeFilter::ModifyContract(avtContract_p contract)
     if (atts.GetScaling() == VolumeAttributes::Linear)
     {
 #ifdef HAVE_LIBSLIVR
-        if ((atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) ||
-            ((atts.GetRendererType() == VolumeAttributes::RayCasting) && (atts.GetSampling() == VolumeAttributes::Trilinear)))
+        if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+	    atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay) {
             ds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
+	} else if ((atts.GetRendererType() == VolumeAttributes::RayCasting) && 
+		   (atts.GetSampling() == VolumeAttributes::Trilinear)) {	    
+            ds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
+	}
 #endif
         newcontract = new avtContract(contract, ds);
         primaryVariable = new char[strlen(var)+1];
@@ -1235,9 +1272,13 @@ avtVolumeFilter::ModifyContract(avtContract_p contract)
                                ds->GetTimestep(), ds->GetRestriction());
         nds->AddSecondaryVariable(var);
 #ifdef HAVE_LIBSLIVR
-        if ((atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) ||
-            ((atts.GetRendererType() == VolumeAttributes::RayCasting) && (atts.GetSampling() == VolumeAttributes::Trilinear)))
+        if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+	    atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay) {
+            nds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
+	} else if ((atts.GetRendererType() == VolumeAttributes::RayCasting) && 
+		   (atts.GetSampling() == VolumeAttributes::Trilinear)) {	    
             nds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
+	}
 #endif
         newcontract = new avtContract(contract, nds);
         primaryVariable = new char[exprName.size()+1];
@@ -1253,9 +1294,13 @@ avtVolumeFilter::ModifyContract(avtContract_p contract)
                                ds->GetTimestep(), ds->GetRestriction());
         nds->AddSecondaryVariable(var);
 #ifdef HAVE_LIBSLIVR
-        if ((atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR) ||
-            ((atts.GetRendererType() == VolumeAttributes::RayCasting) && (atts.GetSampling() == VolumeAttributes::Trilinear)))
+        if (atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+	    atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay) {
+	    nds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
+	} else if ((atts.GetRendererType() == VolumeAttributes::RayCasting) && 
+		   (atts.GetSampling() == VolumeAttributes::Trilinear)) {
             nds->SetDesiredGhostDataType(GHOST_ZONE_DATA);
+	}
 #endif
         newcontract = new avtContract(contract, nds);
         primaryVariable = new char[strlen(exprName.c_str())+1];
diff --git a/plots/Volume/avtVolumeFilter.h b/plots/Volume/avtVolumeFilter.h
index 5b3cedd3e..90a6fa68b 100644
--- a/plots/Volume/avtVolumeFilter.h
+++ b/plots/Volume/avtVolumeFilter.h
@@ -46,8 +46,9 @@
 #include <avtDatasetToDatasetFilter.h>
 
 #include <VolumeAttributes.h>
-
 #include <avtImage.h>
+#include <avtSLIVROSPRayFilter.h> // ospray integration
+
 #include <vtkMatrix4x4.h>
 #include <vtkCamera.h>
 
@@ -90,7 +91,8 @@ class avtVolumeFilter : public avtDatasetToDatasetFilter
                                   { return "Volume rendering"; };
 
     avtImage_p               RenderImage(avtImage_p, const WindowAttributes &);
-    avtImage_p               RenderImageRaycastingSLIVR(avtImage_p opaque_image, const WindowAttributes &);
+    avtImage_p               RenderImageRaycastingSLIVR(avtImage_p opaque_image, 
+							const WindowAttributes &);
     int                      GetNumberOfStages(const WindowAttributes &);
 
   protected:
@@ -101,6 +103,9 @@ class avtVolumeFilter : public avtDatasetToDatasetFilter
     virtual avtContract_p    ModifyContract(avtContract_p);
     virtual void             VerifyInput(void);
     virtual bool             FilterUnderstandsTransformedRectMesh();
+
+    // ospray integration
+    OSPVisItContext *ospray;
 };
 
 
diff --git a/plots/Volume/avtVolumePlot.C b/plots/Volume/avtVolumePlot.C
index 9fbc788ad..7ff38dbc9 100644
--- a/plots/Volume/avtVolumePlot.C
+++ b/plots/Volume/avtVolumePlot.C
@@ -233,6 +233,7 @@ avtVolumePlot::PlotIsImageBased(void)
 {
     return (atts.GetRendererType() == VolumeAttributes::RayCasting ||
             atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR ||
+	    atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay ||
             atts.GetRendererType() == VolumeAttributes::RayCastingIntegration);
 }
 
@@ -686,6 +687,7 @@ avtVolumePlot::ApplyRenderingTransformation(avtDataObject_p input)
 
     if (atts.GetRendererType() == VolumeAttributes::RayCasting ||
         atts.GetRendererType() == VolumeAttributes::RayCastingIntegration ||
+        atts.GetRendererType() == VolumeAttributes::RayCastingOSPRay ||
         atts.GetRendererType() == VolumeAttributes::RayCastingSLIVR)
     {
 #ifdef ENGINE
diff --git a/svn_bin/bv_support/bv_embree.sh b/svn_bin/bv_support/bv_embree.sh
new file mode 100644
index 000000000..c0d0aa003
--- /dev/null
+++ b/svn_bin/bv_support/bv_embree.sh
@@ -0,0 +1,172 @@
+function bv_embree_initialize
+{
+    export DO_EMBREE="no"
+    export USE_SYSTEM_EMBREE="no"
+    export EMBREE_INSTALL_DIR=""
+    add_extra_commandline_args "embree" "alt-embree-dir" 1 "Use alternative directory for embree"
+}
+
+function bv_embree_enable
+{
+    DO_EMBREE="yes"
+}
+
+function bv_embree_disable
+{
+    DO_EMBREE="no"
+}
+
+function bv_embree_alt_embree_dir
+{
+    echo "Using alternate embree directory"
+    bv_embree_enable
+    USE_SYSTEM_EMBREE="yes"
+    EMBREE_INSTALL_DIR="$1"
+}
+
+function bv_embree_depends_on
+{
+    echo ""
+}
+
+function bv_embree_initialize_vars
+{
+    info "initializing embree vars"
+    if [[ "$DO_EMBREE" == "yes" ]] ; then
+        if [[ "$USE_SYSTEM_EMBREE" == "no" ]]; then
+            EMBREE_INSTALL_DIR=$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH
+        fi
+    fi
+}
+
+function bv_embree_info
+{
+    export EMBREE_VERSION=${EMBREE_VERSION:-"2.16.5"}
+    if [[ "$OPSYS" == "Darwin" ]] ; then
+        export EMBREE_FILE=${EMBREE_FILE:-"embree-${EMBREE_VERSION}.x86_64.macosx.tar.gz"}
+    else
+        export EMBREE_FILE=${EMBREE_FILE:-"embree-${EMBREE_VERSION}.x86_64.linux.tar.gz"}
+    fi
+    export EMBREE_COMPATIBILITY_VERSION=${EMBREE_COMPATIBILITY_VERSION:-"${EMBREE_VERSION}"}
+    export EMBREE_BUILD_DIR=${EMBREE_BUILD_DIR:-"${EMBREE_VERSION}"}
+    export EMBREE_URL=${EMBREE_URL:-"https://github.com/embree/embree/releases/download/v${EMBREE_VERSION}/"}
+    export EMBREE_INSTALL_DIR_NAME=embree-$EMBREE_VERSION.x86_64.linux
+    export EMBREE_MD5_CHECKSUM=""
+    export EMBREE_SHA256_CHECKSUM=""
+}
+
+function bv_embree_print
+{
+    printf "%s%s\n" "EMBREE_FILE=" "${EMBREE_FILE}"
+    printf "%s%s\n" "EMBREE_VERSION=" "${EMBREE_VERSION}"
+    printf "%s%s\n" "EMBREE_COMPATIBILITY_VERSION=" "${EMBREE_COMPATIBILITY_VERSION}"
+    printf "%s%s\n" "EMBREE_BUILD_DIR=" "${EMBREE_BUILD_DIR}"
+}
+
+function bv_embree_host_profile
+{
+    if [[ "$DO_EMBREE" == "yes" ]] ; then
+        echo >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        echo "## EMBREE" >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        if [[ "$USE_SYSTEM_EMBREE" == "no" ]]; then
+            echo "VISIT_OPTION_DEFAULT(VISIT_EMBREE_ROOT \${VISITHOME}/embree/$EMBREE_VERSION/\${VISITARCH})" >> $HOSTCONF
+        else
+            echo "VISIT_OPTION_DEFAULT(VISIT_EMBREE_ROOT ${EMBREE_INSTALL_DIR})" >> $HOSTCONF
+        fi
+    fi
+}
+
+function bv_embree_print_usage
+{
+    #embree does not have an option, it is only dependent on embree.
+    printf "%-15s %s [%s]\n" "--embree" "Build embree" "$DO_EMBREE"
+}
+
+function bv_embree_ensure
+{
+    if [[ "$DO_EMBREE" == "yes" && "$USE_SYSTEM_EMBREE" == "no" ]] ; then
+        ensure_built_or_ready "embree" $EMBREE_VERSION $EMBREE_BUILD_DIR $EMBREE_FILE $EMBREE_URL
+        if [[ $? != 0 ]] ; then
+            ANY_ERRORS="yes"
+            DO_EMBREE="no"
+            error "Unable to build embree.  ${EMBREE_FILE} not found."
+        fi
+    elif [[ "$USE_SYSTEM_EMBREE" == "yes" ]] ; then
+        if [[ ! -d $EMBREE_INSTALL_DIR/include/embree2 ]]; then
+            error "Unable to find embree2 in the alternative path, perhaps a wrong embree version is provided."
+        fi
+    fi
+}
+
+function bv_embree_dry_run
+{
+    if [[ "$DO_EMBREE" == "yes" ]] ; then
+        echo "Dry run option not set for embree."
+    fi
+}
+
+# ***************************************************************************
+# build_embree
+#
+# Modifications:
+#
+# ***************************************************************************
+
+function build_embree
+{
+    # Unzip the EMBREE tarball and copy it to the VisIt installation.
+    info "Installing prebuilt embree"    
+    tar zxvf $EMBREE_FILE
+    rm $EMBREE_INSTALL_DIR_NAME/lib/libtbbmalloc.so.2
+    rm $EMBREE_INSTALL_DIR_NAME/lib/libtbb.so.2
+    mkdir -p $VISITDIR/embree/$EMBREE_VERSION/$VISITARCH
+    cp -R $EMBREE_INSTALL_DIR_NAME/* "$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH"
+    rm -rf $EMBREE_INSTALL_DIR_NAME
+    if [[ "$DO_GROUP" == "yes" ]] ; then
+        chmod -R ug+w,a+rX "$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH"
+        chgrp -R ${GROUP} "$VISITDIR/embree/$EMBREE_VERSION/$VISITARCH"
+    fi
+    cd "$START_DIR"
+    info "Done with embree"
+    return 0
+}
+
+function bv_embree_is_enabled
+{
+    if [[ $DO_EMBREE == "yes" ]]; then
+        return 1    
+    fi
+    return 0
+}
+
+function bv_embree_is_installed
+{
+    if [[ "$USE_SYSTEM_EMBREE" == "yes" ]]; then   
+        return 1
+    fi
+
+    check_if_installed "embree" $EMBREE_VERSION
+    if [[ $? == 0 ]] ; then
+        return 1
+    fi
+    return 0
+}
+
+function bv_embree_build
+{
+    if [[ "$DO_EMBREE" == "yes" && "$USE_SYSTEM_EMBREE" == "no" ]] ; then
+        check_if_installed "embree" $EMBREE_VERSION
+        if [[ $? == 0 ]] ; then
+            info "Skipping build of embree"
+        else
+            build_embree
+            if [[ $? != 0 ]] ; then
+                error "Unable to build or install embree.  Bailing out."
+            fi
+            info "Done building embree"
+        fi
+    fi
+}
+
diff --git a/svn_bin/bv_support/bv_ispc.sh b/svn_bin/bv_support/bv_ispc.sh
new file mode 100644
index 000000000..89690c4fe
--- /dev/null
+++ b/svn_bin/bv_support/bv_ispc.sh
@@ -0,0 +1,167 @@
+function bv_ispc_initialize
+{
+    export DO_ISPC="no"
+    export USE_SYSTEM_ISPC="no"
+    export ISPC_INSTALL_DIR=""
+    add_extra_commandline_args "ispc" "alt-ispc-dir" 1 "Use alternative directory for ispc"
+}
+
+function bv_ispc_enable
+{
+    DO_ISPC="yes"
+}
+
+function bv_ispc_disable
+{
+    DO_ISPC="no"
+}
+
+function bv_ispc_alt_ispc_dir
+{
+    echo "Using alternate ispc directory"
+    bv_ispc_enable
+    USE_SYSTEM_ISPC="yes"
+    ISPC_INSTALL_DIR="$1"
+}
+
+function bv_ispc_depends_on
+{
+    echo ""
+}
+
+function bv_ispc_initialize_vars
+{
+    info "initializing ispc vars"
+    if [[ "$DO_ISPC" == "yes" ]] ; then
+        if [[ "$USE_SYSTEM_ISPC" == "no" ]]; then
+            ISPC_INSTALL_DIR=$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH
+        fi
+    fi
+}
+
+function bv_ispc_info
+{
+    export ISPC_VERSION=${ISPC_VERSION:-"1.9.2"}
+    if [[ "$OPSYS" == "Darwin" ]] ; then
+        export ISPC_FILE=${ISPC_FILE:-"ispc-v${ISPC_VERSION}-osx.tar.gz"}
+        export ISPC_URL=${ISPC_URL:-"http://sdvis.org/ospray/download/dependencies/osx/"}
+    else
+        export ISPC_FILE=${ISPC_FILE:-"ispc-v${ISPC_VERSION}-linux.tar.gz"}
+        export ISPC_URL=${ISPC_URL:-"http://sdvis.org/ospray/download/dependencies/linux/"}
+    fi
+    export ISPC_COMPATIBILITY_VERSION=${ISPC_COMPATIBILITY_VERSION:-"${ISPC_VERSION}"}
+    export ISPC_BUILD_DIR=${ISPC_BUILD_DIR:-"${ISPC_VERSION}"}
+    export ISPC_INSTALL_DIR_NAME=ispc-v$ISPC_VERSION-linux
+    export ISPC_MD5_CHECKSUM=""
+    export ISPC_SHA256_CHECKSUM=""
+}
+
+function bv_ispc_print
+{
+    printf "%s%s\n" "ISPC_FILE=" "${ISPC_FILE}"
+    printf "%s%s\n" "ISPC_VERSION=" "${ISPC_VERSION}"
+    printf "%s%s\n" "ISPC_COMPATIBILITY_VERSION=" "${ISPC_COMPATIBILITY_VERSION}"
+    printf "%s%s\n" "ISPC_BUILD_DIR=" "${ISPC_BUILD_DIR}"
+}
+
+function bv_ispc_host_profile
+{
+    if [[ "$DO_ISPC" == "yes" ]]; then
+        echo >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        echo "## ISPC" >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        if [[ "$USE_SYSTEM_ISPC" == "no" ]]; then
+            echo "VISIT_OPTION_DEFAULT(VISIT_ISPC_ROOT \${VISITHOME}/ispc/$ISPC_VERSION/\${VISITARCH})" >> $HOSTCONF
+        else
+            echo "VISIT_OPTION_DEFAULT(VISIT_ISPC_ROOT ${ISPC_INSTALL_DIR})" >> $HOSTCONF
+        fi
+    fi
+}
+
+function bv_ispc_print_usage
+{
+    #ispc does not have an option, it is only dependent on ispc.
+    printf "%-15s %s [%s]\n" "--ispc" "Build ISPC" "$DO_ISPC"
+}
+
+function bv_ispc_ensure
+{
+    if [[ "$DO_ISPC" == "yes" && "$USE_SYSTEM_ISPC" == "no" ]] ; then
+        ensure_built_or_ready "ispc" $ISPC_VERSION $ISPC_BUILD_DIR $ISPC_FILE $ISPC_URL
+        if [[ $? != 0 ]] ; then
+            ANY_ERRORS="yes"
+            DO_ISPC="no"
+            error "Unable to build ISPC.  ${ISPC_FILE} not found."
+        fi
+    fi
+}
+
+function bv_ispc_dry_run
+{
+    if [[ "$DO_ISPC" == "yes" ]] ; then
+        echo "Dry run option not set for ISPC."
+    fi
+}
+
+# ***************************************************************************
+# build_ispc
+#
+# Modifications:
+#
+# ***************************************************************************
+
+function build_ispc
+{
+    # Unzip the ISPC tarball and copy it to the VisIt installation.
+    info "Installing prebuilt ISPC"    
+    tar zxvf $ISPC_FILE
+    mkdir -p $VISITDIR/ispc/$ISPC_VERSION/$VISITARCH
+    cp -R $ISPC_INSTALL_DIR_NAME/* "$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH"
+    rm -rf $ISPC_INSTALL_DIR_NAME
+    if [[ "$DO_GROUP" == "yes" ]] ; then
+        chmod -R ug+w,a+rX "$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH"
+        chgrp -R ${GROUP} "$VISITDIR/ispc/$ISPC_VERSION/$VISITARCH"
+    fi
+    cd "$START_DIR"
+    info "Done with ISPC"
+    return 0
+}
+
+function bv_ispc_is_enabled
+{
+    if [[ $DO_ISPC == "yes" ]]; then
+        return 1    
+    fi
+    return 0
+}
+
+function bv_ispc_is_installed
+{
+    if [[ "$USE_SYSTEM_ISPC" == "yes" ]]; then   
+        return 1
+    fi
+
+    check_if_installed "ispc" $ISPC_VERSION
+    if [[ $? == 0 ]] ; then
+        return 1
+    fi
+    return 0
+}
+
+function bv_ispc_build
+{
+    if [[ "$DO_ISPC" == "yes" && "$USE_SYSTEM_ISPC" == "no" ]] ; then
+        check_if_installed "ispc" $ISPC_VERSION
+        if [[ $? == 0 ]] ; then
+            info "Skipping build of ISPC"
+        else
+            build_ispc
+            if [[ $? != 0 ]] ; then
+                error "Unable to build or install ISPC.  Bailing out."
+            fi
+            info "Done building ISPC"
+        fi
+    fi
+}
+
diff --git a/svn_bin/bv_support/bv_ospray.sh b/svn_bin/bv_support/bv_ospray.sh
new file mode 100644
index 000000000..0f2dc6b70
--- /dev/null
+++ b/svn_bin/bv_support/bv_ospray.sh
@@ -0,0 +1,236 @@
+# Module automatically read in from construct_build_visit
+# Insert header and comments
+function bv_ospray_initialize
+{
+    export DO_OSPRAY="no"
+}
+
+function bv_ospray_enable
+{
+    DO_OSPRAY="yes"
+}
+
+function bv_ospray_disable
+{
+    DO_OSPRAY="no"
+}
+
+function bv_ospray_depends_on
+{
+    depends_on="cmake ispc embree tbb"
+    #echo | cpp -fopenmp -dM | grep -i open
+    #if [[ "$DO_TBB" == "yes" ]]; then
+    #    depends_on="${depends_on} tbb"
+    #fi
+    echo ${depends_on}
+}
+
+function bv_ospray_info
+{
+    # versions
+    export OSPRAY_VERSION=${OSPRAY_VERSION:-"1.4.3"}
+    export OSPRAY_VISIT_MODULE_VERSION=${OSPRAY_VISIT_MODULE_VERSION:-"1.4.x"}
+    
+    # ospray source
+    export OSPRAY_TARBALL=${OSPRAY_TARBALL:-"ospray-${OSPRAY_VERSION}.tar.gz"}
+    export OSPRAY_BUILD_DIR=${OSPRAY_BUILD_DIR:-"ospray-${OSPRAY_VERSION}"}
+    export OSPRAY_DOWNLOAD_URL=${OSPRAY_DOWNLOAD_URL:-"https://github.com/wilsonCernWq/module_visit/releases/download/v${OSPRAY_VISIT_MODULE_VERSION}"}
+
+    # ospray module
+    export OSPRAY_VISIT_MODULE_TARBALL=${OSPRAY_VISIT_MODULE_TARBALL:-"module_visit-${OSPRAY_VISIT_MODULE_VERSION}.zip"}
+    export OSPRAY_VISIT_MODULE_UNTAR_DIR=${OSPRAY_VISIT_MODULE_UNTAR_DIR:-"module_visit-${OSPRAY_VISIT_MODULE_VERSION}"}
+    export OSPRAY_VISIT_MODULE_BUILD_DIR=${OSPRAY_VISIT_MODULE_BUILD_DIR:-"${OSPRAY_BUILD_DIR}/modules/module_visit"}
+    export OSPRAY_VISIT_MODULE_DOWNLOAD_URL=${OSPRAY_VISIT_MODULE_DOWNLOAD_URL:-"https://github.com/wilsonCernWq/module_visit/releases/download/v${OSPRAY_VISIT_MODULE_VERSION}"}
+    
+    # checksum
+    export OSPRAY_MD5_CHECKSUM=""
+    export OSPRAY_SHA256_CHECKSUM=""
+}
+
+function bv_ospray_print
+{
+    print "%s%s\n" "OSPRAY_TARBALL=" "${OSPRAY_TARBALL}"
+    print "%s%s\n" "OSPRAY_VERSION=" "${OSPRAY_VERSION}"
+    print "%s%s\n" "OSPRAY_TARGET=" "${OSPRAY_TARGET}"
+    print "%s%s\n" "OSPRAY_BUILD_DIR=" "${OSPRAY_BUILD_DIR}"
+}
+
+function bv_ospray_print_usage
+{
+    printf "%-15s %s [%s]\n" "--ospray" "Build OSPRay rendering support" "$DO_OSPRAY"
+}
+
+function bv_ospray_host_profile
+{
+    if [[ "$DO_OSPRAY" == "yes" ]]; then
+        echo >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        echo "## OSPRay" >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY ON TYPE BOOL)" >> $HOSTCONF
+        if [[ -d $OSPRAY_INSTALL_DIR/lib ]]; then
+            echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY_DIR \${VISITHOME}/ospray/$OSPRAY_VERSION/\${VISITARCH}/lib/cmake/ospray-${OSPRAY_VERSION})" >> $HOSTCONF
+        elif [[ -d $OSPRAY_INSTALL_DIR/lib64 ]]; then
+            echo "VISIT_OPTION_DEFAULT(VISIT_OSPRAY_DIR \${VISITHOME}/ospray/$OSPRAY_VERSION/\${VISITARCH}/lib64/cmake/ospray-${OSPRAY_VERSION})" >> $HOSTCONF
+        else
+            error "No library path for OSPRay has been found."
+        fi
+    fi
+}
+
+function bv_ospray_is_enabled
+{
+    if [[ $DO_OSPRAY == "yes" ]]; then
+        return 1
+    fi
+    return 0
+}
+
+function bv_ospray_ensure
+{
+    if [[ "$DO_OSPRAY" == "yes" ]]; then
+        ensure_built_or_ready "ospray" \
+            $OSPRAY_VERSION \
+            $OSPRAY_BUILD_DIR \
+            $OSPRAY_TARBALL \
+            $OSPRAY_DOWNLOAD_URL 
+        if [[ $? != 0 ]] ; then
+            return 1
+        fi
+        ensure_built_or_ready "ospray-visit-module" \
+            $OSPRAY_VISIT_MODULE_VERSION \
+            $OSPRAY_VISIT_MODULE_BUILD_DIR \
+            $OSPRAY_VISIT_MODULE_TARBALL \
+            $OSPRAY_VISIT_MODULE_DOWNLOAD_URL
+        if [[ $? != 0 ]] ; then
+            return 1
+        fi
+
+    fi
+}
+
+function bv_ospray_initialize_vars
+{
+    info "initializing ospray vars"
+    if [[ "$DO_OSPRAY" == "yes" ]]; then
+        OSPRAY_INSTALL_DIR="${VISITDIR}/ospray/${OSPRAY_VERSION}/${VISITARCH}"
+        OSPRAY_INCLUDE_DIR="${OSPRAY_INSTALL_DIR}/include"
+        OSPRAY_LIB_DIR="${OSPRAY_INSTALL_DIR}/lib"
+        OSPRAY_LIB="${OSPRAY_LIB_DIR}/libospray.so"
+
+        VTK_USE_OSPRAY="yes"
+    fi
+}
+
+function bv_ospray_dry_run
+{
+    if [[ "$DO_OSPRAY" == "yes" ]] ; then
+        echo "Dry run option not set for ospray."
+    fi
+}
+
+function bv_ospray_is_installed
+{
+    check_if_installed "ospray" $OSPRAY_VERSION
+    if [[ $? == 0 ]] ; then
+        return 1
+    fi
+    return 0
+}
+
+function build_ospray_in_source
+{
+    # set compiler if the user hasn't explicitly set CC and CXX
+    if [ -z $CC ]; then
+        echo "***NOTE: using compiler $C_COMPILER/$CXX_COMPILER!"
+        export CC=$C_COMPILER
+        export CXX=$CXX_COMPILER
+    fi
+
+    #### Build OSPRay ####
+    mkdir -p build
+    cd build
+
+    # Clean out build directory to be sure we are doing a fresh build
+    rm -rf *
+
+    # set release and RPM settings
+    info "Configure OSPRay . . . "
+    CMAKE_INSTALL=${CMAKE_INSTALL:-"$VISITDIR/cmake/${CMAKE_VERSION}/$VISITARCH/bin"}
+    ${CMAKE_INSTALL}/cmake -D CMAKE_INSTALL_PREFIX=$OSPRAY_INSTALL_DIR \
+        -D embree_DIR=$EMBREE_INSTALL_DIR \
+        -D TBB_ROOT=$TBB_INSTALL_DIR \
+        -D ISPC_EXECUTABLE=$ISPC_INSTALL_DIR/ispc \
+        -D OSPRAY_BUILD_ISA=ALL \
+        -D OSPRAY_MODULE_VISIT=ON \
+        -D OSPRAY_MODULE_MPI=OFF \
+        -D OSPRAY_MODULE_MPI_APPS=OFF \
+        -D OSPRAY_APPS_EXAMPLEVIEWER=OFF \
+        -D OSPRAY_APPS_BENCHMARK=OFF \
+        -D OSPRAY_SG_CHOMBO=OFF \
+        -D OSPRAY_SG_OPENIMAGEIO=OFF \
+        -D OSPRAY_SG_VTK=OFF \
+        -D OSPRAY_ZIP_MODE=OFF \
+        .. || error "OSPRay did not configure correctly.  Giving up."
+
+    #
+    # Now build OSPRay
+    #
+    info "Building OSPRay (~10 minute)"
+    env DYLD_LIBRARY_PATH=`pwd`/bin $MAKE $MAKE_OPT_FLAGS || \
+        error "OSPRay did not build correctly.  Giving up."
+
+    info "Installing OSPRay . . . "
+    $MAKE install || error "OSPRay did not install correctly."
+}
+
+function build_ospray
+{
+    # prepare directories
+    prepare_build_dir $OSPRAY_BUILD_DIR $OSPRAY_TARBALL
+    untarred_ospray=$?
+    if [[ $untarred_ospray == -1 ]]; then
+        warn "Unable to prepare OSPRay build directory. Giving up!"
+        return 1
+    fi
+    prepare_build_dir $OSPRAY_VISIT_MODULE_BUILD_DIR $OSPRAY_VISIT_MODULE_TARBALL
+    untarred_ospray_visit_module=$?
+    if [[ $untarred_ospray_visit_module == -1 ]]; then
+        warn "Unable to prepare OSPRay build directory. Giving up!"
+        return 1
+    elif [[ $untarred_ospray_visit_module == 1 ]]; then
+        rm -fr $OSPRAY_VISIT_MODULE_BUILD_DIR
+        mv $OSPRAY_VISIT_MODULE_UNTAR_DIR $OSPRAY_VISIT_MODULE_BUILD_DIR \
+            || error "Couldn't find module_visit for OSPRay"
+    fi
+
+    # build and install
+    cd $OSPRAY_BUILD_DIR || error "Couldn't cd to OSPRay build dir."
+    build_ospray_in_source
+
+    # others
+    if [[ "$DO_GROUP" == "yes" ]]; then
+        chmod -R ug+w,a+rX "$VISITDIR/ospray"
+        chgrp -R ${GROUP} "$VISITDIR/ospray"
+    fi
+    cd "$START_DIR"
+    info "Done with OSPRay"
+    return 0
+}
+
+function bv_ospray_build
+{
+    cd "$START_DIR"
+    if [[ "$DO_OSPRAY" == "yes" ]]; then
+        check_if_installed "ospray" $OSPRAY_VERSION
+        if [[ $? == 0 ]] ; then
+            info "Skipping OSPRay build. OSPRay is already installed."
+        else
+            build_ospray
+            if [[ $? != 0 ]]; then
+                error "Unable to build or install OSPRay. Bailing out."
+            fi
+        fi
+    fi
+}
+
diff --git a/svn_bin/bv_support/bv_tbb.sh b/svn_bin/bv_support/bv_tbb.sh
new file mode 100644
index 000000000..4b247dcc9
--- /dev/null
+++ b/svn_bin/bv_support/bv_tbb.sh
@@ -0,0 +1,171 @@
+function bv_tbb_initialize
+{
+    export DO_TBB="no"
+    export USE_SYSTEM_TBB="no"
+    export TBB_INSTALL_DIR=""
+    add_extra_commandline_args "tbb" "alt-tbb-dir" 1 "Use alternative directory for tbb"
+}
+
+function bv_tbb_enable
+{
+    DO_TBB="yes"
+}
+
+function bv_tbb_disable
+{
+    DO_TBB="no"
+}
+
+function bv_tbb_alt_tbb_dir
+{
+    echo "Using alternate TBB directory"
+    bv_tbb_enable
+    USE_SYSTEM_TBB="yes"
+    TBB_INSTALL_DIR="$1"
+}
+
+function bv_tbb_depends_on
+{
+    if [[ "$USE_SYSTEM_TBB" == "yes" ]] ; then
+        echo ""
+    else
+        echo ""
+    fi
+}
+
+function bv_tbb_initialize_vars
+{
+    info "initializing TBB vars"
+    if [[ "$DO_TBB" == "yes" ]] ; then
+        if [[ "$USE_SYSTEM_TBB" == "no" ]]; then
+            TBB_INSTALL_DIR=$VISITDIR/tbb/$TBB_VERSION/$VISITARCH
+        fi
+    fi
+    export TBB_ROOT="${TBB_INSTALL_DIR}"
+}
+
+function bv_tbb_info
+{
+    export TBB_VERSION=${TBB_VERSION:-"tbb2018_20171205oss"}
+    if [[ "$OPSYS" == "Darwin" ]] ; then
+        export TBB_FILE=${TBB_FILE:-"${TBB_VERSION}_mac.tgz"}
+    else
+        export TBB_FILE=${TBB_FILE:-"${TBB_VERSION}_lin.tgz"}
+    fi
+    export TBB_COMPATIBILITY_VERSION=${TBB_COMPATIBILITY_VERSION:-"${TBB_VERSION}"}
+    export TBB_BUILD_DIR=${TBB_BUILD_DIR:-"${TBB_VERSION}"}
+    export TBB_MD5_CHECKSUM=""
+    export TBB_SHA256_CHECKSUM=""
+}
+
+function bv_tbb_print
+{
+    printf "%s%s\n" "TBB_FILE=" "${TBB_FILE}"
+    printf "%s%s\n" "TBB_VERSION=" "${TBB_VERSION}"
+    printf "%s%s\n" "TBB_COMPATIBILITY_VERSION=" "${TBB_COMPATIBILITY_VERSION}"
+    printf "%s%s\n" "TBB_BUILD_DIR=" "${TBB_BUILD_DIR}"
+}
+
+function bv_tbb_host_profile
+{
+    if [[ "$DO_TBB" == "yes" ]] ; then
+        echo >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        echo "## TBB" >> $HOSTCONF
+        echo "##" >> $HOSTCONF
+        if [[ "$USE_SYSTEM_TBB" == "no" ]]; then
+            echo "VISIT_OPTION_DEFAULT(TBB_ROOT \${VISITHOME}/tbb/$TBB_VERSION/\${VISITARCH})" >> $HOSTCONF
+        else
+            echo "VISIT_OPTION_DEFAULT(TBB_ROOT ${TBB_INSTALL_DIR})" >> $HOSTCONF
+        fi
+    fi
+}
+
+function bv_tbb_print_usage
+{
+    #tbb does not have an option, it is only dependent on tbb.
+    printf "%-15s %s [%s]\n" "--tbb" "Build TBB" "$DO_TBB"
+}
+
+function bv_tbb_ensure
+{
+    if [[ "$DO_TBB" == "yes" && "$USE_SYSTEM_TBB" == "no" ]] ; then
+        ensure_built_or_ready "tbb" $TBB_VERSION $TBB_BUILD_DIR $TBB_FILE
+        if [[ $? != 0 ]] ; then
+            ANY_ERRORS="yes"
+            DO_TBB="no"
+            error "Unable to build TBB.  ${TBB_FILE} not found."
+        fi
+    fi
+}
+
+function bv_tbb_dry_run
+{
+    if [[ "$DO_TBB" == "yes" ]] ; then
+        echo "Dry run option not set for TBB."
+    fi
+}
+
+# ***************************************************************************
+# build_tbb
+#
+# Modifications:
+#
+# ***************************************************************************
+
+function build_tbb
+{
+    # Unzip the TBB tarball and copy it to the VisIt installation.
+    info "Installing prebuilt TBB"
+    tar zxvf $TBB_FILE
+    mkdir -p $VISITDIR/tbb/$TBB_VERSION/$VISITARCH
+    cp -R $TBB_VERSION/* "$VISITDIR/tbb/$TBB_VERSION/$VISITARCH"
+    rm -rf $TBB_VERSION
+
+    # others
+    if [[ "$DO_GROUP" == "yes" ]] ; then
+        chmod -R ug+w,a+rX "$VISITDIR/tbb/$TBB_VERSION/$VISITARCH"
+        chgrp -R ${GROUP} "$VISITDIR/tbb/$TBB_VERSION/$VISITARCH"
+    fi
+    cd "$START_DIR"
+    info "Done with TBB"
+    return 0
+}
+
+function bv_tbb_is_enabled
+{
+    if [[ $DO_TBB == "yes" ]]; then
+        return 1    
+    fi
+    return 0
+}
+
+function bv_tbb_is_installed
+{
+    if [[ "$USE_SYSTEM_TBB" == "yes" ]]; then   
+        return 1
+    fi
+
+    check_if_installed "tbb" $TBB_VERSION
+    if [[ $? == 0 ]] ; then
+        return 1
+    fi
+    return 0
+}
+
+function bv_tbb_build
+{
+    if [[ "$DO_TBB" == "yes" && "$USE_SYSTEM_TBB" == "no" ]] ; then
+        check_if_installed "tbb" $TBB_VERSION
+        if [[ $? == 0 ]] ; then
+            info "Skipping build of TBB"
+        else
+            build_tbb
+            if [[ $? != 0 ]] ; then
+                error "Unable to build or install TBB.  Bailing out."
+            fi
+            info "Done building TBB"
+        fi
+    fi
+}
+
diff --git a/svn_bin/bv_support/modules.xml b/svn_bin/bv_support/modules.xml
index cb23e67fe..6b9616678 100644
--- a/svn_bin/bv_support/modules.xml
+++ b/svn_bin/bv_support/modules.xml
@@ -20,6 +20,7 @@
             <lib name="conduit"/>
             <lib name="cgns"/>
             <lib name="eavl"/>
+            <lib name="embree"/>
             <lib name="fastbit"/>
             <lib name="fastquery"/>
             <lib name="gdal"/>
@@ -28,6 +29,7 @@
             <lib name="hdf4"/>
             <lib name="hdf5"/>
             <lib name="icet"/>
+            <lib name="ispc"/>
             <lib name="llvm"/>
             <lib name="manta"/>
 <!--        <lib name="mdsplus"/>    Removed for now by Allen Sanderson-->
@@ -42,10 +44,12 @@
             <lib name="pidx"/>
             <lib name="openssl"/>
             <lib name="openswr"/>
+            <lib name="ospray"/>
             <lib name="pyside"/>
             <lib name="silo"/>
             <lib name="szip"/>
             <lib name="tcmalloc"/>
+            <lib name="tbb"/>
             <lib name="uintah"/>
             <lib name="visus"/>
             <lib name="vtkm"/>
