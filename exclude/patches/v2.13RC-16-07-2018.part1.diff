diff --git a/avt/Filters/avtImgCommunicator.C b/avt/Filters/avtImgCommunicator.C
deleted file mode 100644
index d02d0c66d..000000000
--- a/avt/Filters/avtImgCommunicator.C
+++ /dev/null
@@ -1,1651 +0,0 @@
-/*****************************************************************************
-*
-* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
-* Produced at the Lawrence Livermore National Laboratory
-* LLNL-CODE-442911
-* All rights reserved.
-*
-* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
-* full copyright notice is contained in the file COPYRIGHT located at the root
-* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
-*
-* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
-* modification, are permitted provided that the following conditions are met:
-*
-*  - Redistributions of  source code must  retain the above  copyright notice,
-*    this list of conditions and the disclaimer below.
-*  - Redistributions in binary form must reproduce the above copyright notice,
-*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
-*    documentation and/or other materials provided with the distribution.
-*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
-*    be used to endorse or promote products derived from this software without
-*    specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
-* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
-* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
-* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
-* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
-* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
-* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
-* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
-* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
-* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
-* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-* DAMAGE.
-*
-*****************************************************************************/
-
-// ************************************************************************* //
-//                         avtImgCommunicator.C                              //
-// ************************************************************************* //
-#include <cmath>
-#include <avtParallel.h>
-#include <ImproperUseException.h>
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>     /* srand, rand */
-#include <time.h>       /* time */
-
-#include <avtImgCommunicator.h>
-#include <fstream>
-#include <DebugStream.h>
-#include <limits>
-#include <algorithm>
-#include <set>
-
-
-#if defined (_MSC_VER) && (_MSC_VER < 1800) && !defined(round)
-inline double round(double x) {return (x-floor(x)) > 0.5 ? ceil(x) : floor(x);}
-#endif
-
-enum blendDirection {FRONT_TO_BACK = 0, BACK_TO_FRONT = 1};
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::avtImgCommunicator
-//
-//  Purpose: Constructor
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// ****************************************************************************
-avtImgCommunicator::avtImgCommunicator()
-{
-  #ifdef PARALLEL
-    MPI_Comm_size(VISIT_MPI_COMM, &num_procs);
-    MPI_Comm_rank(VISIT_MPI_COMM, &my_id);
-
-  #else
-    num_procs = 1;
-    my_id = 0;
-  #endif
-
-    totalPatches = 0;
-
-    intermediateImage = NULL;
-    imgBuffer = NULL;
-
-    for (int i=0; i<4; i++)
-    {
-        intermediateImageExtents[i] = 0;
-        intermediateImageBB[i] = 0;
-    }
-}
-
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::~avtImgCommunicator
-//
-//  Purpose:
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// ****************************************************************************
-avtImgCommunicator::~avtImgCommunicator()
-{
-    if (my_id == 0)
-    {
-        if (imgBuffer != NULL)
-            delete []imgBuffer;
-    }
-}
-
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::
-//
-//  Purpose:
-//    Barrier, useful for debugging
-//
-//  Programmer: Pascal Grosset
-//  Creation: July 2013
-//
-//  Modifications:
-//
-// ****************************************************************************
-void avtImgCommunicator::barrier(){
-  #ifdef PARALLEL
-    MPI_Barrier( MPI_COMM_WORLD );
-  #endif
-}
-
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::getcompositedImage
-//
-//  Purpose:
-//      Returns the whole image if needed
-//
-//  Programmer: Pascal Grosset
-//  Creation: July 2013
-//
-//  Modifications:
-//
-// ****************************************************************************
-void avtImgCommunicator::getcompositedImage(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage)
-{
-    for (int i=0; i< imgBufferHeight; i++)
-        for (int j=0; j<imgBufferWidth; j++){
-            int bufferIndex = (imgBufferWidth*4*i) + (j*4);
-            int wholeImgIndex = (imgBufferWidth*3*i) + (j*3);
-
-            wholeImage[wholeImgIndex+0] = (imgBuffer[bufferIndex+0] ) * 255;
-            wholeImage[wholeImgIndex+1] = (imgBuffer[bufferIndex+1] ) * 255;
-            wholeImage[wholeImgIndex+2] = (imgBuffer[bufferIndex+2] ) * 255;
-        }
-
-    if (imgBuffer != NULL)
-        delete []imgBuffer;
-    imgBuffer = NULL;
-}
-
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::
-//
-//  Purpose:
-//       Fills an image with a specific color
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// ****************************************************************************
-void
-avtImgCommunicator::colorImage(float *& srcImage, int widthSrc, int heightSrc, float _color[4])
-{
-    for (int _y=0; _y<heightSrc; _y++)
-        for (int _x=0; _x<widthSrc; _x++)
-        {
-            int srcIndex = widthSrc*_y*4 + _x*4;
-
-            srcImage[srcIndex+0] = _color[0];
-            srcImage[srcIndex+1] = _color[1];
-            srcImage[srcIndex+2] = _color[2];
-            srcImage[srcIndex+3] = _color[3];
-        }
-}
-
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::placeInImage
-//
-//  Purpose:
-//      Puts srcImage into dstImage
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// ****************************************************************************
-void
-avtImgCommunicator::placeInImage(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
-{
-    int widthSrc, heightSrc, widthDst;
-    widthSrc  = srcExtents[1] - srcExtents[0];
-    heightSrc = srcExtents[3] - srcExtents[2];
-
-    widthDst  = dstExtents[1] - dstExtents[0];
-
-    for (int _y=0; _y<heightSrc; _y++)
-        for (int _x=0; _x<widthSrc; _x++)
-        {
-            int startingX = srcExtents[0];
-            int startingY = srcExtents[2];
-
-            int srcIndex = widthSrc*_y*4 + _x*4;                                                                  // index in the subimage
-            int dstIndex = ( (startingY+_y - dstExtents[2])*widthDst*4  + (startingX+_x - dstExtents[0])*4 );     // index in the big buffer
-
-            dstImage[dstIndex+0] = srcImage[srcIndex+0];
-            dstImage[dstIndex+1] = srcImage[srcIndex+1];
-            dstImage[dstIndex+2] = srcImage[srcIndex+2];
-            dstImage[dstIndex+3] = srcImage[srcIndex+3];
-        }
-}
-
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::blendWithBackground
-//
-//  Purpose:
-//      Blends _image with the backgroundColor
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// **************************************************************************
-void
-avtImgCommunicator::blendWithBackground(float *_image, int extents[4], float backgroundColor[4])
-{
-    int numPixels = (extents[3]-extents[2]) * (extents[1]-extents[0]);
-
-    for (int index=0; index<numPixels; index++)      // estimated potential speedup: 2.240
-    {
-        int indexSrc = index*4;
-        float alpha = (1.0 - _image[indexSrc+3]);
-
-        _image[indexSrc+0] = backgroundColor[0] * alpha +  _image[indexSrc+0];
-        _image[indexSrc+1] = backgroundColor[1] * alpha +  _image[indexSrc+1];
-        _image[indexSrc+2] = backgroundColor[2] * alpha +  _image[indexSrc+2];
-        _image[indexSrc+3] = backgroundColor[3] * alpha +  _image[indexSrc+3];
-    }
-}
-
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::
-//
-//  Purpose:
-//      Blends tow patches in a front to back manner
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// **************************************************************************
-void
-avtImgCommunicator::blendFrontToBack(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4])
-{
-    int widthSrc, heightSrc, widthDst;
-    widthSrc  = srcExtents[1] - srcExtents[0];
-    heightSrc = srcExtents[3] - srcExtents[2];
-
-    widthDst  = dstExtents[1] - dstExtents[0];
-
-    #if defined(VISIT_THREADS)
-    #endif
-
-    for (int _y=blendExtents[2]; _y<blendExtents[3]; _y++)
-        for (int _x=blendExtents[0]; _x<blendExtents[1]; _x++)
-        {
-
-            int srcIndex = (_y-srcExtents[2]) * widthSrc * 4 + (_x-srcExtents[0]) * 4;
-            int dstIndex = (_y-dstExtents[2]) * widthDst * 4 + (_x-dstExtents[0]) * 4;
-
-            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
-            float alpha = 1.0 - dstImage[dstIndex+3];
-            dstImage[dstIndex+0] = clamp( (srcImage[srcIndex+0] * alpha) + dstImage[dstIndex+0] );
-            dstImage[dstIndex+1] = clamp( (srcImage[srcIndex+1] * alpha) + dstImage[dstIndex+1] );
-            dstImage[dstIndex+2] = clamp( (srcImage[srcIndex+2] * alpha) + dstImage[dstIndex+2] );
-            dstImage[dstIndex+3] = clamp( (srcImage[srcIndex+3] * alpha) + dstImage[dstIndex+3] );
-        }
-}
-
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::
-//
-//  Purpose:
-//      Blends tow patches in a back to front manner
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// **************************************************************************
-void
-avtImgCommunicator::blendBackToFront(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4])
-{
-    int widthSrc, heightSrc, widthDst;
-    widthSrc  = srcExtents[1] - srcExtents[0];
-    heightSrc = srcExtents[3] - srcExtents[2];
-
-    widthDst  = dstExtents[1] - dstExtents[0];
-
-    for (int _y=blendExtents[2]; _y<blendExtents[3]; _y++)
-        for (int _x=blendExtents[0]; _x<blendExtents[1]; _x++)
-        {
-
-            int srcIndex = (_y-srcExtents[2]) * widthSrc * 4 + (_x-srcExtents[0]) * 4;
-            int dstIndex = (_y-dstExtents[2]) * widthDst * 4 + (_x-dstExtents[0]) * 4;
-
-            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
-            float alpha = 1.0 - srcImage[srcIndex+3];
-            dstImage[dstIndex+0] = clamp( (dstImage[dstIndex+0] * alpha) + srcImage[srcIndex+0] );
-            dstImage[dstIndex+1] = clamp( (dstImage[dstIndex+1] * alpha) + srcImage[srcIndex+1] );
-            dstImage[dstIndex+2] = clamp( (dstImage[dstIndex+2] * alpha) + srcImage[srcIndex+2] );
-            dstImage[dstIndex+3] = clamp( (dstImage[dstIndex+3] * alpha) + srcImage[srcIndex+3] );
-        }
-}
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::
-//
-//  Purpose:
-//      Blends tow patches in a front to back manner
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// **************************************************************************
-void
-avtImgCommunicator::blendFrontToBack(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
-{
-    int widthSrc, heightSrc, widthDst;
-    widthSrc  = srcExtents[1] - srcExtents[0];
-    heightSrc = srcExtents[3] - srcExtents[2];
-
-    widthDst  = dstExtents[1] - dstExtents[0];
-
-    for (int _y=0; _y<heightSrc; _y++)
-        for (int _x=0; _x<widthSrc; _x++)
-        {
-            int startingX = srcExtents[0];
-            int startingY = srcExtents[2];
-
-            if ((startingX + _x) > dstExtents[1])
-                continue;
-
-            if ((startingY + _y) > dstExtents[3])
-                continue;
-
-            int srcIndex = widthSrc*_y*4 + _x*4;                                                                  // index in the subimage
-            int dstIndex = ( (startingY+_y - dstExtents[2])*widthDst*4  + (startingX+_x - dstExtents[0])*4 );     // index in the big buffer
-
-            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
-            float alpha = 1.0 - dstImage[dstIndex+3];
-            dstImage[dstIndex+0] = clamp( (srcImage[srcIndex+0] * alpha) + dstImage[dstIndex+0] );
-            dstImage[dstIndex+1] = clamp( (srcImage[srcIndex+1] * alpha) + dstImage[dstIndex+1] );
-            dstImage[dstIndex+2] = clamp( (srcImage[srcIndex+2] * alpha) + dstImage[dstIndex+2] );
-            dstImage[dstIndex+3] = clamp( (srcImage[srcIndex+3] * alpha) + dstImage[dstIndex+3] );
-        }
-}
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::
-//
-//  Purpose:
-//      Blends tow patches in a back to front manner
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// **************************************************************************
-void
-avtImgCommunicator::blendBackToFront(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4])
-{
-    int widthSrc, heightSrc, widthDst;
-    widthSrc  = srcExtents[1] - srcExtents[0];
-    heightSrc = srcExtents[3] - srcExtents[2];
-
-    widthDst  = dstExtents[1] - dstExtents[0];
-
-    for (int _y=0; _y<heightSrc; _y++)
-        for (int _x=0; _x<widthSrc; _x++)
-        {
-            int startingX = srcExtents[0];
-            int startingY = srcExtents[2];
-
-            if ((startingX + _x) > dstExtents[1])
-                continue;
-
-            if ((startingY + _y) > dstExtents[3])
-                continue;
-
-            int srcIndex = widthSrc*_y*4 + _x*4;                                                                  // index in the subimage
-            int dstIndex = ( (startingY+_y - dstExtents[2])*widthDst*4  + (startingX+_x - dstExtents[0])*4 );     // index in the big buffer
-
-            // back to Front compositing: composited_i = composited_i-1 * (1.0 - alpha_i) + incoming; alpha = alpha_i-1 * (1- alpha_i)
-            float alpha = 1.0 - srcImage[srcIndex+3];
-            dstImage[dstIndex+0] = clamp( (dstImage[dstIndex+0] * alpha) + srcImage[srcIndex+0] );
-            dstImage[dstIndex+1] = clamp( (dstImage[dstIndex+1] * alpha) + srcImage[srcIndex+1] );
-            dstImage[dstIndex+2] = clamp( (dstImage[dstIndex+2] * alpha) + srcImage[srcIndex+2] );
-            dstImage[dstIndex+3] = clamp( (dstImage[dstIndex+3] * alpha) + srcImage[srcIndex+3] );
-        }
-}
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::regionAllocation
-//
-//  Purpose:
-//      Arbitrarily allocates regions to MPI ranks
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// ***************************************************************************
-void
-avtImgCommunicator::regionAllocation(int numMPIRanks, int *& regions)
-{
-    regions = new int[numMPIRanks];
-
-    // Initial allocation: partition for section rank
-    for (int i=0; i<numMPIRanks; i++)
-        regions[i] = i;
-}
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::
-//
-//  Purpose:
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// **************************************************************************
-void
-avtImgCommunicator::updateBoundingBox(int currentBoundingBox[4], int imageExtents[4])
-{
-    if ( (currentBoundingBox[0] == 0 && currentBoundingBox[1] == 0) && (currentBoundingBox[2] == 0 && currentBoundingBox[3] == 0))
-    {
-        currentBoundingBox[0]=imageExtents[0];
-        currentBoundingBox[1]=imageExtents[1];
-        currentBoundingBox[2]=imageExtents[2];
-        currentBoundingBox[3]=imageExtents[3];
-
-        return;
-    }
-
-    if (imageExtents[0] < currentBoundingBox[0])
-        currentBoundingBox[0] = imageExtents[0];
-
-    if (imageExtents[2] < currentBoundingBox[2])
-        currentBoundingBox[2] = imageExtents[2];
-
-    if (imageExtents[1] > currentBoundingBox[1])
-        currentBoundingBox[1] = imageExtents[1];
-
-    if (imageExtents[3] > currentBoundingBox[3])
-        currentBoundingBox[3] = imageExtents[3];
-}
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::gatherDepthAtRoot
-//
-//  Purpose:
-//      Used by Serial Direct Send
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// **************************************************************************
-void
-avtImgCommunicator::gatherDepthAtRoot(int numlocalPatches, float *localPatchesDepth, int &totalPatches, int *& patchCountPerRank, float *& allPatchesDepth)
-{
-  #ifdef PARALLEL
-    //
-    // Get how many patches are coming from each MPI rank
-    totalPatches = 0;
-    int *patchesOffset = NULL;
-
-
-    if (my_id == 0) // root!
-        patchCountPerRank = new int[num_procs]();
-
-    MPI_Gather(&numlocalPatches, 1, MPI_INT,   patchCountPerRank, 1, MPI_INT,    0, MPI_COMM_WORLD);
-
-
-    //
-    // Gather number of patch group
-    if (my_id == 0)
-    {
-        patchesOffset = new int[num_procs]();
-        patchesOffset[0] = 0;
-
-        for (int i=0; i<num_procs; i++)
-        {
-            totalPatches += patchCountPerRank[i];
-
-            if (i == 0)
-                patchesOffset[i] = 0;
-            else
-                patchesOffset[i] = patchesOffset[i-1] + patchCountPerRank[i-1];
-        }
-
-        allPatchesDepth = new float[totalPatches];
-    }
-
-    MPI_Gatherv(localPatchesDepth, numlocalPatches, MPI_FLOAT,   allPatchesDepth, patchCountPerRank, patchesOffset,    MPI_FLOAT, 0, MPI_COMM_WORLD);
-
-    //
-    // Cleanup
-    if (my_id == 0)
-        if (patchesOffset != NULL)
-            delete []patchesOffset;
-
-    patchesOffset = NULL;
-  #endif
-}
-
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::serialDirectSend
-//
-//  Purpose:
-//      A very simple compositing that we can fall back to if Parallel direct send is buggy.
-//      Works with convex patches though
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// **************************************************************************
-void
-avtImgCommunicator::serialDirectSend(int numPatches, float *localPatchesDepth, int *extents, float *imgData, float backgroundColor[4], int width, int height)
-{
-  #ifdef PARALLEL
-    //debug5 << "serialDirectSend" << std::endl;
-
-    float *recvImage = NULL;
-
-    int tags[2] = {5781, 5782};
-
-    int totalPatches;
-    int *patchCountPerRank = NULL;
-    float *patchesDepth = NULL;
-    gatherDepthAtRoot(numPatches, localPatchesDepth, totalPatches, patchCountPerRank, patchesDepth);
-
-    if (my_id == 0)
-    {
-        //
-        // Root
-        int srcSize[2], srcPos[2], dstSize[2], dstPos[2];
-        srcSize[0] = width;  srcSize[1] = height;
-        srcPos[0] = 0;       srcPos[1] = 0;
-
-        //
-        // Sort patches we will receive
-        std::multimap<float,int> depthRankPatches;
-
-        int index = 0;
-        for (int i=0; i<num_procs; i++)
-            for (int j=0; j<patchCountPerRank[i]; j++)
-            {
-                depthRankPatches.insert( std::pair<float,int>(patchesDepth[index],i) );
-                index++;
-            }
-
-
-        //
-        // Create space for buffers
-        int recvParams[4];                          // minX, maxX, minY, maxY
-        int imgExtents[4];
-        imgExtents[0] = 0;  imgExtents[1] = width;
-        imgExtents[2] = 0;  imgExtents[3] = height;
-
-        recvImage = new float[width*height*4]();
-        imgBuffer = new float[width*height*4]();
-
-        int localIndex = 0;
-
-        //
-        // Compositing
-        for (std::multimap<float,int>::iterator it=depthRankPatches.begin(); it!=depthRankPatches.end(); ++it)
-        {
-            int rank = (*it).second;
-
-            //debug5 << "\nRecv and blend from " << rank << " depth: " << (*it).first << std::endl;
-
-            if (rank != my_id)
-            {
-                MPI_Recv(recvParams,             4, MPI_INT,   rank, tags[0],  MPI_COMM_WORLD, MPI_STATUS_IGNORE);  // recv image info
-                MPI_Recv(recvImage, width*height*4, MPI_FLOAT, rank, tags[1],  MPI_COMM_WORLD, MPI_STATUS_IGNORE);  // recv image
-
-                dstPos[0]  = dstPos[0];                      dstPos[1]  = dstPos[1];
-                dstSize[0] = recvParams[2]-recvParams[0];    dstSize[1] = recvParams[3]-recvParams[1];
-            }
-            else
-            {
-                // It's local
-                recvParams[0] = extents[ localIndex*4 + 0];
-                recvParams[1] = extents[ localIndex*4 + 1];
-                recvParams[2] = extents[ localIndex*4 + 2];
-                recvParams[3] = extents[ localIndex*4 + 3];
-
-                recvImage = &imgData[ localIndex*(width*height*4) ];
-                localIndex++;
-            }
-
-            blendFrontToBack(recvImage, recvParams, imgBuffer, imgExtents);
-        }
-        blendWithBackground(imgBuffer, imgExtents, backgroundColor);
-
-        //writeArrayToPPM("/home/pascal/Desktop/debugImages/full_with back_" + toStr(__index), imgBuffer, imgExtents[1]-imgExtents[0], imgExtents[3]-imgExtents[2]);
-    }
-    else
-    {
-        //
-        // Sender
-        for (int i=0; i<numPatches; i++)
-        {
-            int imgSize = (extents[i*4 + 1] - extents[i*4 + 0]) * (extents[i*4 + 3] - extents[i*4 + 2]) * 4;
-
-            if (imgSize > 0)
-            {
-                //debug5 << "Sending: Extents " <<  extents[i*4 + 0] << ", " << extents[i*4 + 1] << ", " << extents[i*4 + 2] << ", " << extents[i*4 + 3] << std::endl;
-                //writeArrayToPPM("/home/pascal/Desktop/debugImages/sending_to_root_from_" + toStr(my_id), &imgData[i*(width*height*4)], (extents[i*4 + 1] - extents[i*4 + 0]), (extents[i*4 + 3] - extents[i*4 + 2]) );
-
-                MPI_Send( &extents[i*4],                       4, MPI_INT,   0, tags[0], MPI_COMM_WORLD);
-                MPI_Send( &imgData[i*(width*height*4)],  imgSize, MPI_FLOAT, 0, tags[1], MPI_COMM_WORLD);
-            }
-        }
-    }
-
-    //debug5 << "Free memory" << std::endl;
-
-    //
-    // Cleanup
-    if (patchesDepth != NULL)
-      delete []patchesDepth;
-
-    if (patchCountPerRank != NULL)
-        delete []patchCountPerRank;
-
-    if (recvImage != NULL)
-        delete []recvImage;
-
-    recvImage = NULL;
-    patchCountPerRank = NULL;
-    patchesDepth = NULL;
-
-  #endif
-}
-
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::parallelDirectSend
-//
-//  Purpose:
-//      Parallel Direct Send rendering that can blend convex patches from each MPI rank.
-//      However, since we are not guaranteed to have convex patches. It's not used.
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// **************************************************************************
-void
-avtImgCommunicator::parallelDirectSend(float *imgData, int imgExtents[4], int region[], int numRegions, int tags[2], int fullImageExtents[4])
-{
-  #ifdef PARALLEL
-    //
-    // Determine position in region (myPositionInRegion)
-    int width =  fullImageExtents[1]-fullImageExtents[0];
-    int height = fullImageExtents[3]-fullImageExtents[2];
-
-    //debug5 << "fullImageExtents: " << fullImageExtents[0] << ", " << fullImageExtents[1] << "   " << fullImageExtents[2] << ", " << fullImageExtents[3] << endl;
-
-    compositingDone = false;
-    int myPositionInRegion = -1;
-    bool inRegion = true;
-    std::vector<int> regionVector(region, region+numRegions);
-    std::vector<int>::iterator it = std::find(regionVector.begin(), regionVector.end(), my_id);
-
-    if (it == regionVector.end())
-    {
-        inRegion = false;
-        //debug5 << my_id << " ~ SHOULD NOT HAPPEN: Not found " << my_id <<  " !!!" << std::endl;
-    }
-    else
-        myPositionInRegion = it - regionVector.begin();
-
-    //
-    // Region boundaries
-    int regionHeight = height/numRegions;
-    int lastRegionHeight = height - regionHeight*(numRegions-1);
-
-    // Extents of my region
-    int myStartingHeight = fullImageExtents[2] + myPositionInRegion * regionHeight;
-    int myEndingHeight = myStartingHeight + regionHeight;
-    if (myPositionInRegion == numRegions-1)
-        myEndingHeight = fullImageExtents[3];
-
-    int myRegionHeight = myEndingHeight-myStartingHeight;
-
-    // Size of one buffer
-    int sizeOneBuffer = std::max(regionHeight,lastRegionHeight) * width * 4;
-
-    //debug5 << "myPositionInRegion: " << myPositionInRegion << std::endl;
-    //debug5 << "My extents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
-    //debug5 << "myRegionHeight: " << myRegionHeight << "  lastRegionHeight: " << lastRegionHeight << " regionHeight: " << regionHeight << "  myStartingHeight: " << myStartingHeight << "  myEndingHeight: " << myEndingHeight << std::endl;
-
-
-    //
-    // MPI Async
-
-    // Recv
-    MPI_Request *recvMetaRq = new MPI_Request[ numRegions-1 ];
-    MPI_Request *recvImageRq = new MPI_Request[ numRegions-1 ];
-
-    MPI_Status *recvMetaSt = new MPI_Status[ numRegions-1 ];
-    MPI_Status *recvImageSt = new MPI_Status[ numRegions-1 ];
-
-    // Send
-    MPI_Request *sendMetaRq = new MPI_Request[ numRegions-1 ];
-    MPI_Request *sendImageRq = new MPI_Request[ numRegions-1 ];
-
-    MPI_Status *sendMetaSt = new MPI_Status[ numRegions-1 ];
-    MPI_Status *sendImageSt = new MPI_Status[ numRegions-1 ];
-
-
-    //
-    // Create Buffers
-
-    // Create buffer for receiving images
-    float *recvDataBuffer;
-    recvDataBuffer = new float[ sizeOneBuffer * numRegions];
-
-    // Create buffer for receiving messages
-    std::vector<int> msgBuffer;
-    msgBuffer.clear();
-    msgBuffer.resize(5 * numRegions);
-
-    // Create buffer for sending messages
-    int *sendExtents = new int[numRegions*5];
-
-    //
-    // Async Recv
-    if (inRegion)
-    {
-        int recvCount=0;
-        for (int i=0; i<numRegions; i++)
-        {
-            if ( regionVector[i] == my_id )
-                continue;
-
-            int src = regionVector[i];
-            MPI_Irecv(&msgBuffer[i*5],                              5, MPI_INT,   src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvCount] );
-            MPI_Irecv(&recvDataBuffer[i*sizeOneBuffer], sizeOneBuffer, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvCount] );
-            recvCount++;
-        }
-    }
-
-    //debug5 << "Async Recv setup done " << std::endl;
-
-    //
-    // Async Send
-    int sendCount = 0;
-    int sendingOffset;
-    for (int i=0; i<numRegions; i++)
-    {
-        int regionStart, regionEnd, imgSize, dest;
-        dest = regionVector[i];
-
-        if ( dest == my_id )
-            continue;
-
-        regionStart = i*regionHeight;
-        regionEnd = regionStart + regionHeight;
-        if (i == numRegions-1) // the last one in region
-            regionEnd = height;
-
-        int startingYExtents = fullImageExtents[2] + regionStart;
-        int endingYExtents = fullImageExtents[2] + regionEnd;
-
-        //debug5 << "startingYExtents: " << startingYExtents <<"   endingYExtents: " << endingYExtents <<  std::endl;
-
-        if (startingYExtents < imgExtents[2])
-            startingYExtents = imgExtents[2];
-
-        if (endingYExtents > imgExtents[3])
-            endingYExtents = imgExtents[3];
-
-        bool hasData = true;
-        if (endingYExtents - startingYExtents <= 0 || imgExtents[1]-imgExtents[0] <= 0)
-        {
-            hasData = false;
-
-            sendingOffset = 0;
-            imgSize = sendExtents[i*5 + 0] = sendExtents[i*5 + 1] = sendExtents[i*5 + 2] = sendExtents[i*5 + 3] =  sendExtents[i*5 + 4] = 0;
-        }
-        else
-        {
-            imgSize = (endingYExtents-startingYExtents) * (imgExtents[1]-imgExtents[0]) * 4;
-            sendingOffset = (startingYExtents-imgExtents[2]) * (imgExtents[1]-imgExtents[0]) * 4;
-
-            sendExtents[i*5 + 0] = imgExtents[0];
-            sendExtents[i*5 + 1] = imgExtents[1];
-            sendExtents[i*5 + 2] = startingYExtents;
-            sendExtents[i*5 + 3] = endingYExtents;
-            sendExtents[i*5 + 4] = 0;
-        }
-
-        //std::cout << my_id << " ~ i: " << i << "   regionVector[index]: " << regionVector[index] << "  extents: " <<  sendExtents[index*5 + 0] << ", " << sendExtents[index*5 + 1]  << ", " << sendExtents[index*5 + 2] << ", " << sendExtents[index*5 + 3] << "  sending ... " << std::endl;
-        MPI_Isend(&sendExtents[i*5],             5,   MPI_INT, dest, tags[0], MPI_COMM_WORLD, &sendMetaRq[sendCount]);
-        MPI_Isend(&imgData[sendingOffset], imgSize, MPI_FLOAT, dest, tags[1], MPI_COMM_WORLD, &sendImageRq[sendCount]);
-
-        //debug5 << "dest: " << dest <<"   sendExtents: " << sendExtents[i*5 +0] << ", " << sendExtents[i*5 +1] << "    " << sendExtents[i*5 +2] << ", " << sendExtents[i*5 +3] << std::endl << std::endl;
-
-        sendCount++;
-    }
-
-    //debug5 << "Async Recv" << std::endl;
-
-    //
-    // Create buffer for region
-    intermediateImageExtents[0] = fullImageExtents[0];  intermediateImageExtents[1] = fullImageExtents[1];
-    intermediateImageExtents[2] = myStartingHeight;     intermediateImageExtents[3] = myEndingHeight;
-
-    intermediateImage = new float[width * (myEndingHeight-myStartingHeight) * 4]();
-
-    int recvImageExtents[4];
-    float *recvImageData;
-
-    //
-    // Blend
-    int numBlends = 0;
-    int countBlend = 0;
-
-    intermediateImageBB[0] = intermediateImageBB[2] = 0;
-    intermediateImageBB[1] = intermediateImageBB[3] = 0;
-
-    if (inRegion)
-    {
-        for (int i=0; i<numRegions; i++)
-        {
-            int index = i;
-
-            //debug5 << "regionVector[" << i << "] " << regionVector[index] << std::endl;
-
-            if (regionVector[index] == my_id)
-            {
-                int startingYExtents = myStartingHeight;
-                int endingYExtents = myEndingHeight;
-
-                if (startingYExtents < imgExtents[2])
-                    startingYExtents = imgExtents[2];
-
-                if (endingYExtents > imgExtents[3])
-                    endingYExtents = imgExtents[3];
-
-
-                bool hasData = true;
-                if (endingYExtents - startingYExtents <= 0)
-                {
-                    hasData = false;
-                    endingYExtents = startingYExtents = 0;
-                }
-
-                if (hasData == true)
-                {
-                    int extentsSectionRecv[4];
-                    extentsSectionRecv[0] = imgExtents[0];
-                    extentsSectionRecv[1] = imgExtents[1];
-                    extentsSectionRecv[2] = startingYExtents;
-                    extentsSectionRecv[3] = endingYExtents;
-
-                    blendFrontToBack(imgData, imgExtents, extentsSectionRecv, intermediateImage, intermediateImageExtents);
-                    //debug5 << "Blend with: " << regionVector[index]  << "  extentsSectionRecv: " << extentsSectionRecv[0] << ", " << extentsSectionRecv[1] << "    " << extentsSectionRecv[2] << ", " << extentsSectionRecv[3] << ", "  << std::endl;
-                    //writeArrayToPPM("/home/pascal/Desktop/debugImages/composited_AFTER_recv_from_" + toStr(regionVector[index]) + "_at_" + toStr(my_id), intermediateImage, intermediateImageExtents[1]-intermediateImageExtents[0], intermediateImageExtents[3]-intermediateImageExtents[2]);
-
-
-                    updateBoundingBox(intermediateImageBB, extentsSectionRecv);
-                    numBlends++;
-                }
-            }
-            else
-            {
-                MPI_Wait(&recvMetaRq[countBlend], &recvMetaSt[countBlend]);
-
-                for (int j=0; j<4; j++)
-                    recvImageExtents[j] = msgBuffer[index*5 + j];
-
-                bool hasData =  false;
-                if (recvImageExtents[1]-recvImageExtents[0] > 0 && recvImageExtents[3]-recvImageExtents[2] > 0)
-                {
-                    hasData = true;
-                    MPI_Wait(&recvImageRq[countBlend], &recvImageSt[countBlend]);
-                    recvImageData = &recvDataBuffer[index*sizeOneBuffer];
-                }
-
-                if (hasData)
-                {
-
-                    blendFrontToBack(recvImageData, recvImageExtents, intermediateImage, intermediateImageExtents);
-
-                    updateBoundingBox(intermediateImageBB, recvImageExtents);
-                    numBlends++;
-                }
-
-                countBlend++;
-            }
-        }
-    }
-    else
-        compositingDone = true;
-
-    //debug5 << "PDS blending done" << std::endl;
-
-    msgBuffer.clear();
-
-
-    if (recvDataBuffer != NULL)
-        delete []recvDataBuffer;
-    recvDataBuffer = NULL;
-
-
-    if (numBlends == 0)
-        intermediateImageBB[0]=intermediateImageBB[1]=intermediateImageBB[2]=intermediateImageBB[3] = 0;
-
-    delete []recvMetaRq;
-    delete []recvImageRq;
-    delete []recvMetaSt;
-    delete []recvImageSt;
-
-    delete []sendMetaRq;
-    delete []sendImageRq;
-    delete []sendMetaSt;
-    delete []sendImageSt;
-
-    recvMetaRq = NULL;
-    recvImageRq = NULL;
-    recvMetaSt = NULL;
-    recvImageSt = NULL;
-
-    sendMetaRq = NULL;
-    sendImageRq = NULL;
-    sendMetaSt = NULL;
-    sendImageSt = NULL;
-  #endif
-}
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::findRegionsForPatch
-//
-//  Purpose:
-//      Needed by Parallel Direct Send to determine the regions a patch will overlap
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// **************************************************************************
-int
-avtImgCommunicator::findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to)
-{
-    from = to = 0;
-    if (patchExtents[1]-patchExtents[0] <=0 || patchExtents[3]-patchExtents[2] <=0)
-        return 0;
-
-    if ( patchExtents[0] > screenProjectedExtents[1])
-        return 0;
-
-    if ( patchExtents[1] < screenProjectedExtents[0])
-        return 0;
-
-    if ( patchExtents[2] > screenProjectedExtents[3])
-        return 0;
-
-    if ( patchExtents[3] < screenProjectedExtents[2])
-        return 0;
-
-
-    // find from
-    for (int i=numRegions-1; i>=0; i--)
-        if ( patchExtents[2] >= getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
-        {
-            from = i;
-            break;
-        }
-    
-
-    // find to
-    for (int i=numRegions-1; i>=0; i--)
-        if ( patchExtents[3] > getScreenRegionStart(i, screenProjectedExtents[2], screenProjectedExtents[3]) )
-        {
-            to = i;
-            break;
-        }
-
-    return ( std::max( (to - from) + 1, 0) );
-}
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::computeRegionExtents
-//
-//  Purpose:
-//      Compute extents for each region
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// **************************************************************************
-void
-avtImgCommunicator::computeRegionExtents(int numRanks, int height)
-{
-    int regionHeight = round((float)height/numRanks);
-    regularRegionSize = regionHeight;
-    maxRegionHeight = 0;
-    regionRankExtents.resize(numRanks*3);
-    for (int i=0; i<numRanks; i++)
-    {
-        int startRegionExtents, endRegionExtents, _currentRegionHeight;
-
-        startRegionExtents = clamp(regionHeight * i, 0, height);
-        endRegionExtents = clamp(regionHeight * i + regionHeight, 0, height);
-
-        if ( i == numRanks -1 )
-            if ( endRegionExtents < height )
-                endRegionExtents = height;
-
-        _currentRegionHeight = clamp(endRegionExtents-startRegionExtents, 0, height);
-        maxRegionHeight = std::max(maxRegionHeight, _currentRegionHeight);
-
-        regionRankExtents[i*3+0] = startRegionExtents;
-        regionRankExtents[i*3+1] = endRegionExtents;
-        regionRankExtents[i*3+2] = _currentRegionHeight;
-
-        debug5 << i << " : (start, end, region): " << startRegionExtents << ", " << endRegionExtents << ", " << _currentRegionHeight << std::endl;
-    }
-}
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::parallelDirectSendManyPatches
-//
-//  Purpose:
-//      Parallel Direct Send rendering that can blend individual patches
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// **************************************************************************
-int
-avtImgCommunicator::parallelDirectSendManyPatches(std::multimap<int, imgData> imgDataHashMap, std::vector<imgMetaData> imageMetaPatchVector, int numPatches, int region[], int numRegions, int tags[2], int fullImageExtents[4])
-{
-    int myRegionHeight = 0;
-  #ifdef PARALLEL
-    debug5 << "Parallel Direct Send" << endl;
-
-    //
-    // Some initializations
-    for (int i=0; i<4; i++)
-    {
-        intermediateImageExtents[i] = 0;
-        intermediateImageBB[i] = 0;
-    }
-
-    //
-    // Find my position in region
-    compositingDone = false;
-    int myPositionInRegion = -1;
-    bool inRegion = true;
-    std::vector<int> regionVector(region, region+numRegions);
-    std::vector<int>::iterator it = std::find(regionVector.begin(), regionVector.end(), my_id);
-
-    if (it == regionVector.end())
-    {
-        inRegion = false;
-        debug5 << my_id << " ~ SHOULD NOT HAPPEN!!!!: Not found " << my_id <<  " !!!" << std::endl;
-    }
-    else
-        myPositionInRegion = it - regionVector.begin();
-
-    int width =  fullImageExtents[1]-fullImageExtents[0];
-    int height = fullImageExtents[3]-fullImageExtents[2];
-
-    debug5 << my_id << " ~ myPositionInRegion: " << myPositionInRegion << ", num_procs: " << num_procs << std::endl;
-    debug5 << "width: " << width << ", height : " << height 
-           << " | fullImageExtents: " << fullImageExtents[0] << ", " << fullImageExtents[1] << ", " << fullImageExtents[2] << ", " << fullImageExtents[3] << std::endl;
-    
-    //
-    // Region boundaries
-    computeRegionExtents(num_procs,height);
-    int myStartingHeight = getScreenRegionStart(myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
-    int myEndingHeight   = getScreenRegionEnd(myPositionInRegion, fullImageExtents[2], fullImageExtents[3]);
-    myRegionHeight = clamp( (myEndingHeight-myStartingHeight), 0, height);
-
-    debug5 << "myStartingHeight: " << myStartingHeight << ", myEndingHeight: " << myEndingHeight << ", myRegionHeight: " << myRegionHeight << std::endl;
-
-
-    // Size of one buffer
-    int sizeOneBuffer = getMaxRegionHeight() * width * 4;
-
-
-    //
-    // Determine how many patches and pixel to send to each region
-    std::vector<int> numPatchesPerRegion;
-    std::vector<int> areaPerRegion;
-    std::set<int> numOfRegions;
-
-    numPatchesPerRegion.resize(numRegions);
-    areaPerRegion.resize(numRegions);
-
-
-    // 2D array: extents for each partition
-    std::vector < std::vector<float> > extentsPerPartiton;
-    for (int i=0; i<numRegions; i++)
-        extentsPerPartiton.push_back( std::vector<float>() );
-
-    debug5 << "Parallel Direct Send ~ numPatches " << numPatches << endl;
-
-    int totalSendBufferSize = 0;
-    for (int i=0; i<numPatches; i++)
-    {
-        int _patchExtents[4];
-        imgMetaData temp;
-        temp = imageMetaPatchVector.at(i);
-
-        _patchExtents[0]=temp.screen_ll[0];   // minX
-        _patchExtents[1]=temp.screen_ur[0];   // maxX
-        _patchExtents[2]=temp.screen_ll[1];   // minY
-        _patchExtents[3]=temp.screen_ur[1];   // maxY
-
-        std::multimap<int, imgData>::iterator it = imgDataHashMap.find( i );
-
-        int from, to;
-        int numRegionIntescection = findRegionsForPatch(_patchExtents, fullImageExtents, numRegions, from, to);
-        if (numRegionIntescection <= 0)
-            continue;
-
-        debug5 << "\nParallel Direct Send ~ patch " << i << "  from:" << from << "  to:" << to << "  numPatches: " << numPatches 
-        << "   _patchExtents: " << _patchExtents[0] << ", " << _patchExtents[1] << ", " << _patchExtents[2] << ", " << _patchExtents[3] 
-        << ", fullImageExtents[2]: " << fullImageExtents[2] << ", numRegions: " <<  numRegions << ", totalSendBufferSize: " << totalSendBufferSize << endl;
-
-        for (int j=from; j<=to; j++)
-            numPatchesPerRegion[j]++;
-
-        for (int partition=from; partition<=to; partition++)
-        {
-            int _extentsYStart = std::max( _patchExtents[2], getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) );
-            int _extentsYEnd   = std::min( _patchExtents[3], getScreenRegionEnd(  partition, fullImageExtents[2], fullImageExtents[3]) );
-
-            int _area = (_extentsYEnd-_extentsYStart)*(_patchExtents[1]-_patchExtents[0]);
-            areaPerRegion[partition] += _area;
-            totalSendBufferSize += _area;
-
-            debug5 << "_patchExtents[2]: " << _patchExtents[2] << ", region start: " << getScreenRegionStart(partition, fullImageExtents[2], fullImageExtents[3]) <<  ", _extentsYStart: " << _extentsYStart<< endl;
-            debug5 << "_patchExtents[3]: " << _patchExtents[3] << ", region end: " << getScreenRegionEnd(partition, fullImageExtents[2], fullImageExtents[3]) << ", _extentsYEnd: " << _extentsYEnd << endl;
-            debug5 << "_area " << _area << endl;
-
-            extentsPerPartiton[partition].push_back(i);
-            extentsPerPartiton[partition].push_back(_patchExtents[0]);
-            extentsPerPartiton[partition].push_back(_patchExtents[1]);
-            extentsPerPartiton[partition].push_back(_extentsYStart);
-            extentsPerPartiton[partition].push_back(_extentsYEnd);
-            extentsPerPartiton[partition].push_back(temp.eye_z);
-
-            numOfRegions.insert(partition);
-        }
-    }
-    totalSendBufferSize *= 4;                           // to account for RGBA
-    int numRegionsWithData = numOfRegions.size();
-
-    debug5 << "\nParallel Direct Send ~ creating buffers" << endl;
-
-    //
-    // Copy the data for each region for each patch
-
-    // Create buffer
-    float *sendDataBuffer = new float[totalSendBufferSize];     // contains all the data arranged by region
-    int *sendDataBufferSize = new int[numRegionsWithData]();
-    int *sendDataBufferOffsets = new int[numRegionsWithData]();
-
-    int *sendBuffer = new int[numRegions*2]();
-    int regionWithDataCount = 0;
-    int numRegionsToSend = 0;
-
-    // Populate the buffer with data
-    int dataSendBufferOffset = 0;
-    for (int i=0; i<numRegions; i++)
-    {
-        int _dataSize = 0;
-        debug5 << "Region: " << i << "  size: " << extentsPerPartiton[i].size() << std::endl;
-        for (int j=0; j<extentsPerPartiton[i].size(); j+=6)
-        {
-            int _patchID = extentsPerPartiton[i][j + 0];
-            std::multimap<int, imgData>::iterator it = imgDataHashMap.find( _patchID );
-
-            int _width = (extentsPerPartiton[i][j+2] - extentsPerPartiton[i][j+1]);
-            int _bufferSize = _width * (extentsPerPartiton[i][j+4] - extentsPerPartiton[i][j+3]) * 4;
-            int _dataOffset = extentsPerPartiton[i][j+3] - imageMetaPatchVector[_patchID].screen_ll[1];
-
-            memcpy(&sendDataBuffer[dataSendBufferOffset], &(((*it).second).imagePatch[_width * _dataOffset * 4]), _bufferSize*sizeof(float) );
-
-            dataSendBufferOffset += _bufferSize;
-            _dataSize += _bufferSize;
-        }
-
-        if (_dataSize != 0){
-            sendDataBufferSize[regionWithDataCount] = _dataSize;
-
-            regionWithDataCount ++;
-            if (regionWithDataCount != numRegionsWithData)
-                sendDataBufferOffsets[regionWithDataCount] = sendDataBufferOffsets[regionWithDataCount-1] + sendDataBufferSize[regionWithDataCount-1];
-
-            if (regionVector[i] != my_id)
-                numRegionsToSend++;
-        }
-
-        sendBuffer[i*2+0] = numPatchesPerRegion[i];
-        sendBuffer[i*2+1] = areaPerRegion[i];
-
-        debug5 << "Region: " << i << "  numPatchesPerRegion: " << sendBuffer[i*2+0] << ", sendBuffer[i*2+1]: " << sendBuffer[i*2+1] << std::endl;
-    }
-
-    
-
-    //
-    // Exchange information about size to recv
-    int *recvInfoATABuffer = new int[numRegions*2]();
-    MPI_Alltoall(sendBuffer, 2, MPI_INT,  recvInfoATABuffer, 2, MPI_INT, MPI_COMM_WORLD);
-    delete []sendBuffer;
-    sendBuffer = NULL;
-
-    debug5 << "\nParallel Direct Send ~ Exchange information about size to recv" << endl;
-
-    //
-    // Calculate buffer size needed
-    int infoBufferSize = 0;
-    int dataBufferSize = 0;
-    int numRegionsToRecvFrom = 0;
-    for (int i=0; i<numRegions; i++)
-    {
-        infoBufferSize += recvInfoATABuffer[i*2 + 0];   // number of patches per region
-        dataBufferSize += recvInfoATABuffer[i*2 + 1];   // area per region
-
-        debug5 << "From: " << i << ", #patches: " << recvInfoATABuffer[i*2 + 0] << ", " << recvInfoATABuffer[i*2 + 1] << std::endl;
-
-        if (i == my_id)
-            continue;
-
-        if (recvInfoATABuffer[i*2 + 0] != 0)
-            numRegionsToRecvFrom++;
-    }
-
-
-    //
-    // Create structure for MPI Async send/recv
-
-    // Send
-    MPI_Request *sendMetaRq = new MPI_Request[ numRegionsToSend ];
-    MPI_Status *sendMetaSt = new MPI_Status[ numRegionsToSend ];
-
-    MPI_Request *sendImageRq = new MPI_Request[ numRegionsToSend  ];
-    MPI_Status *sendImageSt = new MPI_Status[ numRegionsToSend  ];
-
-    // Recv
-    MPI_Request *recvMetaRq = NULL;
-    MPI_Status *recvMetaSt = NULL;
-
-    MPI_Request *recvImageRq = NULL;
-    MPI_Status *recvImageSt = NULL;
-
-    int recvInfoCount = 0;
-    int offsetMeta = 0;
-    int offsetData = 0;
-    
-    //
-    // Create recv buffers
-    float *recvInfoBuffer = new float[infoBufferSize*6];  // 6 - passing 6 parameters for each patch
-    float *recvDataBuffer =  new float[dataBufferSize*4]; // 4 - to account for RGBA
-
-    debug5 << "infoBufferSize: " << infoBufferSize << ", dataBufferSize: " << dataBufferSize << std::endl;
-    if (myRegionHeight != 0)
-    {
-
-        // Recv
-        recvMetaRq = new MPI_Request[ numRegionsToRecvFrom ];
-        recvMetaSt = new MPI_Status[ numRegionsToRecvFrom ];
-
-        recvImageRq = new MPI_Request[ numRegionsToRecvFrom  ];
-        recvImageSt = new MPI_Status[ numRegionsToRecvFrom  ];
-
-
-        //
-        // Async Recv for info
-        for (int i=0; i<numRegions; i++)
-        {
-            if (recvInfoATABuffer[i*2 + 0] == 0)
-                continue;
-
-            if ( regionVector[i] == my_id )
-                continue;
-
-
-            int src = regionVector[i];
-            MPI_Irecv(&recvInfoBuffer[offsetMeta], recvInfoATABuffer[i*2 + 0]*6, MPI_FLOAT, src, tags[0], MPI_COMM_WORLD,  &recvMetaRq[recvInfoCount] );
-            MPI_Irecv(&recvDataBuffer[offsetData], recvInfoATABuffer[i*2 + 1]*4, MPI_FLOAT, src, tags[1], MPI_COMM_WORLD,  &recvImageRq[recvInfoCount] );
-
-            offsetMeta += recvInfoATABuffer[i*2 + 0]*6;
-            offsetData += recvInfoATABuffer[i*2 + 1]*4;
-            recvInfoCount++;
-        }
-
-        debug5 << "Async recv setup - numRegionsToRecvFrom: " << numRegionsToRecvFrom << "   recvInfoCount: " << recvInfoCount << endl;
-    }
-
-
-    //
-    // Async Send
-    int offset = 0;
-    int sendCount = 0;
-    int mpiSendCount = 0;
-
-    for (int i=0; i<numRegions; i++)
-    {
-        if ( extentsPerPartiton[i].size() != 0 ){
-            if ( regionVector[i] == my_id )
-            {
-                memcpy( &recvInfoBuffer[offsetMeta], &extentsPerPartiton[i][0], extentsPerPartiton[i].size()*sizeof(float) );
-                memcpy( &recvDataBuffer[offsetData], &sendDataBuffer[offset],   sendDataBufferSize[ sendCount ]*sizeof(float) );
-
-                offset += sendDataBufferSize[sendCount];
-                sendCount++;
-            }
-            else
-            {
-                MPI_Isend(&extentsPerPartiton[i][0],  extentsPerPartiton[i].size(),  MPI_FLOAT, region[i], tags[0], MPI_COMM_WORLD, &sendMetaRq[mpiSendCount]);
-                MPI_Isend(&sendDataBuffer[offset], sendDataBufferSize[ sendCount ], MPI_FLOAT, region[i], tags[1], MPI_COMM_WORLD, &sendImageRq[mpiSendCount]);
-
-                offset += sendDataBufferSize[sendCount];
-                sendCount++;
-                mpiSendCount++;
-            }
-        }
-    }
-
-    debug5 << "Asyn send setup done ~ numRegionsToSend: " << numRegionsToSend << "  mpiSendCount: " << mpiSendCount << endl;
-
-    if (myRegionHeight != 0)
-    {
-        debug5 << "MPI_Waitall ..." << std::endl;
-        MPI_Waitall(recvInfoCount, recvImageRq, recvImageSt);   // Means that we have reveived everything!
-
-        debug5 << "MAPI_WAITALL done!" << std::endl;
-
-        if (recvInfoATABuffer != NULL)
-            delete []recvInfoATABuffer;
-        recvInfoATABuffer = NULL;
-
-
-        debug5 << "Sorting..." << std::endl;
-
-        //
-        // Sort the data
-        std::multimap<float,int> patchData;
-        std::vector<int> patchOffset;
-        patchOffset.push_back(0);
-        for (int i=0; i<infoBufferSize; i++)
-        {
-            patchData.insert( std::pair<float,int> (recvInfoBuffer[i*6 + 5],i));
-            int _patchSize = (recvInfoBuffer[i*6 + 4]-recvInfoBuffer[i*6 + 3]) * (recvInfoBuffer[i*6 + 2]-recvInfoBuffer[i*6 + 1]) * 4;
-            int _offset = patchOffset[i] + _patchSize;
-
-            if (i != infoBufferSize-1)
-                patchOffset.push_back(_offset);
-        }
-
-
-        //
-        // Create buffer for current region
-        intermediateImageBB[0] = intermediateImageExtents[0] = fullImageExtents[0];
-        intermediateImageBB[1] = intermediateImageExtents[1] = fullImageExtents[1];
-        intermediateImageBB[2] = intermediateImageExtents[2] = myStartingHeight;
-        intermediateImageBB[3] = intermediateImageExtents[3] = myEndingHeight;
-
-        intermediateImage = new float[width * (myEndingHeight-myStartingHeight) * 4]();
-
-
-        //
-        // Blend
-        int numBlends = 0;
-        for (std::multimap<float,int>::iterator it=patchData.begin(); it!=patchData.end(); ++it)
-        {
-            int _id = (*it).second;
-            int _extents[4];
-            _extents[0] = recvInfoBuffer[_id*6 + 1];
-            _extents[1] = recvInfoBuffer[_id*6 + 2];
-            _extents[2] = recvInfoBuffer[_id*6 + 3];
-            _extents[3] = recvInfoBuffer[_id*6 + 4];
-
-            blendFrontToBack(&recvDataBuffer[ patchOffset[_id] ], _extents, _extents, intermediateImage, intermediateImageExtents);
-
-            //writeArrayToPPM("/home/pascal/Desktop/debugImages/blending_" + toStr(my_id) + "_"+ toStr(numBlends), intermediateImage, intermediateImageExtents[1]-intermediateImageExtents[0], intermediateImageExtents[3]-intermediateImageExtents[2]);
-            numBlends++;
-        }
-
-        if (numBlends == 0)
-            intermediateImageBB[0]=intermediateImageBB[1]=intermediateImageBB[2]=intermediateImageBB[3] = 0;
-    }
-
-
-    MPI_Waitall(numRegionsToSend, sendImageRq, sendImageSt);   // Means that we have sent everything!
-
-
-    if (myRegionHeight == 0)
-        compositingDone = true;
-
-    //
-    // Cleanup
-    if (sendDataBuffer != NULL)
-        delete []sendDataBuffer;
-    sendDataBuffer = NULL;
-
-    if (sendDataBufferSize != NULL)
-        delete []sendDataBufferSize;
-    sendDataBufferSize = NULL;
-
-    if (sendDataBufferOffsets != NULL)
-        delete []sendDataBufferOffsets;
-    sendDataBufferOffsets = NULL;
-
-
-    if (sendMetaRq != NULL)
-        delete []sendMetaRq;
-
-    if (sendImageRq != NULL)
-        delete []sendImageRq;
-
-    if (sendMetaSt != NULL)
-        delete []sendMetaSt;
-
-    if (sendImageSt != NULL)
-        delete []sendImageSt;
-
-    sendMetaRq = NULL;
-    sendImageRq = NULL;
-    sendMetaSt = NULL;
-    sendImageSt = NULL;
-
-    if (myRegionHeight != 0)
-    {
-        if (recvInfoBuffer != NULL)
-            delete []recvInfoBuffer;
-        recvInfoBuffer = NULL;
-
-        if (recvDataBuffer != NULL)
-            delete []recvDataBuffer;
-        recvDataBuffer = NULL;
-
-        if (recvMetaRq != NULL)
-            delete []recvMetaRq;
-
-        if (recvMetaSt != NULL)
-            delete []recvMetaSt;
-
-        if (recvImageRq != NULL)
-            delete []recvImageRq;
-
-        if (recvImageSt != NULL)
-            delete []recvImageSt;
-
-        recvMetaRq = NULL;
-        recvImageRq = NULL;
-        recvMetaSt = NULL;
-        recvImageSt = NULL;
-    }
-
-    debug5 << "All PDS done" << std::endl;
-  #endif
-    return myRegionHeight;
-}
-
-
-
-
-// ****************************************************************************
-//  Method: avtImgCommunicator::gatherImages
-//
-//  Purpose:
-//      Gather images from Parallel Direct Send
-//
-//  Programmer: Pascal Grosset
-//  Creation:   August 19, 2016
-//
-//  Modifications:
-//
-// **************************************************************************
-void
-avtImgCommunicator::gatherImages(int regionGather[], int totalNumRanks, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight)
-{
-  #ifdef PARALLEL
-    debug5 << "gatherImages starting... totalNumRanks: " << totalNumRanks << ", compositingDone: " << compositingDone
-           << ", imgExtents: " << imgExtents[0] << ", " << imgExtents[1] << ", " << imgExtents[2] << ", " << imgExtents[3] << std::endl;
-
-    for (int i=0; i<4; i++)
-        finalImageExtents[i] = finalBB[i] = 0;
-
-    if (my_id == 0)
-    {
-        int width =  fullImageExtents[1]-fullImageExtents[0];
-        int height = fullImageExtents[3]-fullImageExtents[2];
-
-        debug5 << "Gather Images at 0, final size: " << fullImageExtents[1]-fullImageExtents[0] << " x " << fullImageExtents[3]-fullImageExtents[2] << std::endl;
-
-        //
-        // Receive at root/display node!
-        imgBuffer = new float[width*height*4];
-        finalImageExtents[0] = fullImageExtents[0];
-        finalImageExtents[1] = fullImageExtents[1];
-        finalImageExtents[2] = fullImageExtents[2];
-        finalImageExtents[3] = fullImageExtents[3];
-
-        int numRegionsWithData = 0;
-        int numToRecv = 0;
-        for (int i=0; i<totalNumRanks; i++)
-        {
-            if (getRegionSize(i) != 0)
-                numRegionsWithData++;
-        }
-        numToRecv = numRegionsWithData;
-
-        // remove itself from the recv
-        if (getRegionSize(my_id) != 0) 
-            numToRecv--;
-
-
-        //
-        // Create buffers for async reciving
-        MPI_Request *recvImageRq = new MPI_Request[ numToRecv ];
-        MPI_Status  *recvImageSt = new MPI_Status[ numToRecv ];
-
-        int lastBufferSize    = getRegionSize(totalNumRanks-1) * width * 4;
-        int regularBufferSize = regularRegionSize * width * 4;
-
-        debug5 << "numToRecv: " << numToRecv << ", numRegionsWithData: " << numRegionsWithData << std::endl;
-        debug5 << "regularBufferSize: " << regularBufferSize << ", lastBufferSize: " << lastBufferSize << std::endl;
-
-        // Async Recv
-        int recvCount=0;
-        for (int i=0; i<numRegionsWithData; i++)
-        {
-            int src = regionGather[i];
-
-            if (src == my_id)
-                continue;
-
-            if (i == totalNumRanks-1)
-            {
-                if (lastBufferSize != 0)
-                {
-                    MPI_Irecv(&imgBuffer[i*regularBufferSize], lastBufferSize,     MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
-                }
-            }
-            else
-                MPI_Irecv(&imgBuffer[i*regularBufferSize], regularBufferSize,  MPI_FLOAT, src, tag, MPI_COMM_WORLD,  &recvImageRq[recvCount] );
-            
-
-            debug5 << i << " ~ recvCount: " << recvCount << std::endl;
-            recvCount++;
-        }
-
-        if (compositingDone == false)   // If root has data for the final image
-            placeInImage(inputImg, imgExtents, imgBuffer, finalImageExtents);
-
-        MPI_Waitall(numToRecv, recvImageRq, recvImageSt);
-        compositingDone = true;
-
-        delete []recvImageRq;
-        recvImageRq = NULL;
-        delete []recvImageSt;
-        recvImageSt = NULL;
-    }
-    else
-    {
-        if (compositingDone == false)   
-        {
-            int imgSize = (imgExtents[1]-imgExtents[0]) * (imgExtents[3]-imgExtents[2]) * 4;
-            debug5 << "imgSize: " << imgSize << std::endl;
-
-            MPI_Send(inputImg, imgSize, MPI_FLOAT, 0, tag, MPI_COMM_WORLD);
-            compositingDone = true;
-        }
-    }
-
-  #endif
-}
diff --git a/avt/Filters/avtImgCommunicator.h b/avt/Filters/avtImgCommunicator.h
deleted file mode 100644
index 4a69d2231..000000000
--- a/avt/Filters/avtImgCommunicator.h
+++ /dev/null
@@ -1,161 +0,0 @@
-/*****************************************************************************
-*
-* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
-* Produced at the Lawrence Livermore National Laboratory
-* LLNL-CODE-442911
-* All rights reserved.
-*
-* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
-* full copyright notice is contained in the file COPYRIGHT located at the root
-* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
-*
-* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
-* modification, are permitted provided that the following conditions are met:
-*
-*  - Redistributions of  source code must  retain the above  copyright notice,
-*    this list of conditions and the disclaimer below.
-*  - Redistributions in binary form must reproduce the above copyright notice,
-*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
-*    documentation and/or other materials provided with the distribution.
-*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
-*    be used to endorse or promote products derived from this software without
-*    specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
-* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
-* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
-* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
-* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
-* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
-* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
-* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
-* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
-* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
-* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-* DAMAGE.
-*
-*****************************************************************************/
-
-// ************************************************************************* //
-//                          avtImgCommunicator.h                             //
-// ************************************************************************* //
-
-#ifndef AVT_IMG_COMMUNICATOR_H
-#define AVT_IMG_COMMUNICATOR_H
-
-#include <filters_exports.h>
-#include <pipeline_exports.h>
-#include <imgMetaData.h>
-#include <avtSamplePointExtractor.h>
-#include <algorithm>
-#include <string>
-
-#ifdef PARALLEL
-#   include <mpi.h>
-#endif
-
-#define MSG_DATA 100
-#define MSG_RESULT 101
-
-const int SEND = 1;
-const int RECEIVE = 2;
-
-struct imageBuffer{
-    float *image;
-    float depth;
-};
-
-// ****************************************************************************
-//  Class: avtRayTracer
-//
-//  Purpose:
-//      Does the composition for Ray casting: SLIVR
-//
-//  Programmer: Pascal Grosset
-//  Creation:   Spetember 20, 2013
-//
-// ****************************************************************************
-
-class avtImgCommunicator
-{
-    int num_procs;
-    int my_id;
-    int totalPatches;
-    bool compositingDone;
-
-    // image sizing for compositing
-    int maxRegionHeight;
-    int regularRegionSize;
-    std::vector<int>regionRankExtents;
-
-    void placeInImage(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4]);
-    void colorImage(float *& srcImage, int widthSrc, int heightSrc, float _color[4]);
-    void updateBoundingBox(int currentBoundingBox[4], int imageExtents[4]);
-
-    void gatherDepthAtRoot(int numlocalPatches, float *localPatchesDepth, int &totalPatches, int *& patchCountPerRank, float *& allPatchesDepth);
-    void blendWithBackground(float *_image, int extents[4], float backgroundColor[4]);
-
-    void blendFrontToBack(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4]);
-    void blendBackToFront(float * srcImage, int srcExtents[4], float *& dstImage, int dstExtents[4]);
-
-    void blendFrontToBack(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4]);
-    void blendBackToFront(float * srcImage, int srcExtents[4], int blendExtents[4], float *& dstImage, int dstExtents[4]);
-
-    
-
-    void computeRegionExtents(int numRanks, int height);
-    
-    int getRegularRegionSize(){ return regularRegionSize; } 
-    int getRegionStart(int region){ return regionRankExtents[region*3+0]; }
-    int getRegionEnd(int region){ return regionRankExtents[region*3+1]; }
-    int getRegionSize(int region){ return regionRankExtents[region*3+2]; }
-    int getMaxRegionHeight(){ return maxRegionHeight; }
-    
-    int getScreenRegionStart(int region, int screenImgMinY, int screenImgMaxY){
-        return clamp( getRegionStart(region)+screenImgMinY, screenImgMinY, screenImgMaxY); 
-    }
-    int getScreenRegionEnd(int region, int screenImgMinY, int screenImgMaxY){
-        return clamp( getRegionEnd(region)+screenImgMinY, screenImgMinY, screenImgMaxY); 
-    }
-
-    
-
-public:
-    float *imgBuffer;                   // Final image is here
-    int finalImageExtents[4];
-    int finalBB[4];
-
-    float *intermediateImage;           // Intermediate image, e.g. in parallel direct send
-    int intermediateImageExtents[4];
-    int intermediateImageBB[4];
-
-
-    avtImgCommunicator();
-    ~avtImgCommunicator();
-
-    virtual const char *GetType(void) { return "avtImgCommunicator"; };
-    virtual const char *GetDescription(void) { return "Doing compositing for ray casting SLIVR";};
-
-    int clamp(int value, int _min, int _max){ return std::max( std::min(value,_max), _min); }
-    float clamp(float x){ return std::min( std::max(x, 0.0f), 1.0f); }
-    
-    void barrier();
-
-    int GetNumProcs(){ return num_procs;};
-    int GetMyId(){ return my_id;};
-
-    void getcompositedImage(int imgBufferWidth, int imgBufferHeight, unsigned char *wholeImage);  // get the final composited image
-    void regionAllocation(int numMPIRanks, int *& regions);
-
-    int findRegionsForPatch(int patchExtents[4], int screenProjectedExtents[4], int numRegions, int &from, int &to);
-
-    // Both currently unused but good for simple testing
-    void serialDirectSend(int numPatches, float *localPatchesDepth, int *extents, float *imgData, float backgroundColor[4], int width, int height);
-    void parallelDirectSend(float *imgData, int imgExtents[4], int region[], int numRegions, int tags[2], int fullImageExtents[4]);
-    
-    int parallelDirectSendManyPatches(std::multimap<int, imgData> imgDataHashMap, std::vector<imgMetaData> imageMetaPatchVector, int numPatches, int region[], int numRegions, int tags[2], int fullImageExtents[4]);
-    void gatherImages(int regionGather[], int numToRecv, float * inputImg, int imgExtents[4], int boundingBox[4], int tag, int fullImageExtents[4], int myRegionHeight);
-};
-
-
-#endif
diff --git a/avt/Filters/imgMetaData.h b/avt/Filters/imgMetaData.h
deleted file mode 100644
index eddea3f89..000000000
--- a/avt/Filters/imgMetaData.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/*****************************************************************************
-*
-* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
-* Produced at the Lawrence Livermore National Laboratory
-* LLNL-CODE-442911
-* All rights reserved.
-*
-* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
-* full copyright notice is contained in the file COPYRIGHT located at the root
-* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
-*
-* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
-* modification, are permitted provided that the following conditions are met:
-*
-*  - Redistributions of  source code must  retain the above  copyright notice,
-*    this list of conditions and the disclaimer below.
-*  - Redistributions in binary form must reproduce the above copyright notice,
-*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
-*    documentation and/or other materials provided with the distribution.
-*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
-*    be used to endorse or promote products derived from this software without
-*    specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
-* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
-* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
-* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
-* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
-* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
-* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
-* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
-* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
-* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
-* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-* DAMAGE.
-*
-*****************************************************************************/
-#ifndef IMG_METADATA_H
-#define IMG_METADATA_H
-#include <stdio.h>
-#include <string>
-#include <iostream>
-
-// ****************************************************************************
-//  Struct:  imgMetaData
-//
-//  Purpose:
-//    Holds information about patches but not the image 
-//
-//  Programmer:  
-//  Creation:   
-//
-// ****************************************************************************
-struct imgMetaData
-{
-    int procId;       // processor that produced the patch
-    int patchNumber;  // id of the patch on that processor - with procId, acts as a key
-
-    int destProcId;   // destination proc where this patch gets composited
-
-    int inUse;   // whether the patch is composed locally or not
-    int dims[2];      // height, width
-    int screen_ll[2]; // position in the final image
-    int screen_ur[2];
-
-    float avg_z;        // camera space z = depth of the patch - used for compositing
-    float eye_z;        // camera space z
-    float clip_z;       // clip space z
-};
-
-
-// ****************************************************************************
-//  Struct:  imgData
-//
-//  Purpose:
-//    Holds the image data generated
-//
-//  Programmer:  
-//  Creation:    
-//
-// ****************************************************************************
-struct imgData
-{
-    int procId;         // processor that produced the patch
-    int patchNumber;    // id of the patch on that processor  - with procId, acts as a key
-
-    float *imagePatch;  // the image data - RGBA
-
-    bool operator==(const imgData &a){
-        return (patchNumber == a.patchNumber);
-    }
-};
-
-
-// ****************************************************************************
-//  Struct:  convexHull
-//
-//  Purpose:
-//    Holds the image data generated
-//
-//  Programmer:  
-//  Creation:    
-//
-// ****************************************************************************
-struct convexHull
-{
-    int numPatches;
-    int arrangement[3];     // [0] rows along x axis, [1] rows along y axis, [2] rows along z axis
-
-    float extents[6];       // minX, maxX   minY, maxY   minZ, maxZ
-    float cellDims[3];      // x, y, z
-    float tolerance;        // amount of overlap that is considered ok - typically 2 cells for cell centered data
-
-
-    // 0: no overlap    1: overlpa in Z    2: overlap in Y    3: overlap in Z
-    int overlap(convexHull _hull)
-    {
-
-        if ( (_hull.extents[1] < extents[0]) || (_hull.extents[0] > extents[1]) )   // No overlap in X
-        {
-            if ( (_hull.extents[3] < extents[2]) || (_hull.extents[2] > extents[3]) )   // No overlap in Y
-            {
-                if ( (_hull.extents[5] < extents[4]) || (_hull.extents[4] > extents[5]) )   // No overlap in Z
-                {
-                    return 0;
-                }
-                else
-                    return 3;
-            }
-            else
-                return 2;
-        }
-        else
-            return 1;
-    }
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/CMake/FindOSPRay.cmake b/avt/Plotter/OSPRay/CMake/FindOSPRay.cmake
deleted file mode 100644
index 02ecdda96..000000000
--- a/avt/Plotter/OSPRay/CMake/FindOSPRay.cmake
+++ /dev/null
@@ -1,105 +0,0 @@
-## ======================================================================================= ##
-## Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  ##
-## All rights reserved.                                                                    ##
-##                                                                                         ##
-## Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     ##
-## except in compliance with the License.                                                  ##
-## A copy of the License is included with this software in the file LICENSE.               ##
-## If your copy does not contain the License, you may obtain a copy of the License at:     ##
-##                                                                                         ##
-##     http://opensource.org/licenses/BSD-3-Clause                                         ##
-##                                                                                         ##
-## Unless required by applicable law or agreed to in writing, software distributed under   ##
-## the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY ##
-## KIND, either express or implied.                                                        ##
-## See the License for the specific language governing permissions and limitations under   ##
-## limitations under the License.                                                          ##
-## ======================================================================================= ##
-
-
-###############################################################################
-# Find OSPRay
-# defines:
-# OSPRAY_FOUND
-# OSPRAY_INCLUDE_DIRS
-# OSPRAY_LIBRARIES
-
-# guess that OSPRay is installed in a peer directory (if in dev) or in a peer to the ParaView source
-FIND_PATH(OSPRAY_DIR ospray
-  HINTS ${PROJECT_SOURCE_DIR}/../OSPRay  ${PROJECT_SOURCE_DIR}/../../../OSPRay
-  DOC "OSPRay base directory"
-  )
-IF(NOT OSPRAY_DIR)
-  MESSAGE("Could not find OSPRay base directory. Please set OSPRAY_DIR to the root of your local OSPRay git repository.")
-ENDIF(NOT OSPRAY_DIR)
-
-FIND_PATH(OSPRAY_CMAKE_DIR ospray.cmake
-  HINTS ${PROJECT_SOURCE_DIR}/../OSPRay/cmake ${PROJECT_SOURCE_DIR}/../../../OSPRay/cmake ${OSPRAY_DIR}/cmake
-  DOC "OSPRay cmake directory"
-  )
-IF(NOT OSPRAY_CMAKE_DIR)
-  MESSAGE("Could not find OSPRay cmake directory. Please set OSPRAY_CMAKE_DIR to the cmake directory of your local OSPRay git repository, usually <root>/cmake.")
-ENDIF(NOT OSPRAY_CMAKE_DIR)
-
-FIND_PATH(OSPRAY_BUILD_DIR ospModelViewer
-  HINTS ${OSPRAY_DIR}/build ${PROJECT_SOURCE_DIR}/../OSPRay/build ${PROJECT_SOURCE_DIR}/../OSPRay ${PROJECT_SOURCE_DIR}/../../../OSPRay/build ${PROJECT_SOURCE_DIR}/../../../OSPRay
-  DOC "OSPRay build directory"
-  )
-IF(NOT OSPRAY_BUILD_DIR)
-  MESSAGE("Could not find OSPRay build directory. Please set OSPRAY_BUILD_DIR to the directory where OSPRay was built.")
-ENDIF(NOT OSPRAY_BUILD_DIR)
-
-if (OSPRAY_BUILD_DIR)
-    SET(VISIT_OSPRAY ON TYPE BOOL)
-  LOAD_CACHE(${OSPRAY_BUILD_DIR} READ_WITH_PREFIX OSP_ 
-    OSPRAY_BUILD_MIC_SUPPORT
-    OSPRAY_BUILD_MPI_DEVICE
-    OSPRAY_COMPILER
-    OSPRAY_XEON_TARGET
-    )
-
-  SET(OSPRAY_INCLUDE_DIRS
-    ${OSPRAY_DIR}
-    ${OSPRAY_DIR}/ospray
-    ${OSPRAY_DIR}/ospray/embree/common
-    ${OSPRAY_DIR}/ospray/embree
-    ${OSPRAY_DIR}/ospray/include
-    )
-
-  SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${OSPRAY_CMAKE_DIR} ${OSPRAY_DIR})
-  # which compiler was used to build OSPRay
-  SET(OSPRAY_CC ${OSP_OSPRAY_COMPILER} CACHE STRING "OSPRay Compiler (ICC, GCC, CLANG)")
-  # whehter to build in MIC/xeon phi support
-  SET(OSPRAY_MIC ${OSP_OSPRAY_BUILD_MIC_SUPPORT} CACHE BOOL "Was OSPRay buit with Xeon Phi Support?")
-  # whehter to build in MIC/xeon phi support
-  SET(OSPRAY_MPI ${OSP_OSPRAY_BUILD_MPI_DEVICE} CACHE BOOL "Was OSPRay built with MPI Remote/Distributed rendering support?")
-  # the arch we're targeting for the non-MIC/non-xeon phi part of ospray
-  SET(OSPRAY_XEON_TARGET ${OSP_OSPRAY_XEON_TARGET} CACHE STRING "OSPRay target ISA on host (SSE,AVX,AVX2)")
-
-  ADD_DEFINITIONS(${OSPRAY_EMBREE_CXX_FLAGS})
-endif(OSPRAY_BUILD_DIR)
-
-# MESSAGE("ospray_dir ${OSPRAY_DIR}")
-# SET(OSPRAY_DIR2 ${OSPRAY_DIR})
-# INCLUDE(${OSPRAY_DIR}/cmake/ospray.cmake)
-# SET(OSPRAY_DIR ${OSPRAY_DIR2})
-# MESSAGE("ospray_dir ${OSPRAY_DIR}")
-
-if(OSPRAY_CMAKE_DIR)
-  INCLUDE(${OSPRAY_CMAKE_DIR}/ospray.cmake)
-  INCLUDE(${OSPRAY_CMAKE_DIR}/mpi.cmake)
-endif(OSPRAY_CMAKE_DIR)
-
-SET(LIB_OSPRAY_EMBREE LIB_OSPRAY_EMBREE-NOTFOUND)
-SET(LIB_OSPRAY LIB_OSPRAY-NOTFOUND)
-FIND_LIBRARY(LIB_OSPRAY_EMBREE ospray_embree ${OSPRAY_BUILD_DIR})
-FIND_LIBRARY(LIB_OSPRAY ospray ${OSPRAY_BUILD_DIR})
-IF (OSPRAY_MIC)
-  # Xeon Phi specific build ops here
-ENDIF(OSPRAY_MIC)
-
-SET(OSPRAY_LIBRARIES
-  ${LIB_OSPRAY_EMBREE}
-  ${LIB_OSPRAY}
-  )
-
diff --git a/avt/Plotter/OSPRay/README b/avt/Plotter/OSPRay/README
deleted file mode 100644
index 139597f9c..000000000
--- a/avt/Plotter/OSPRay/README
+++ /dev/null
@@ -1,2 +0,0 @@
-
-
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/CMake/FindOSPRay.cmake b/avt/Plotter/OSPRay/vtkOSPRay/CMake/FindOSPRay.cmake
deleted file mode 100644
index 3d5e0851d..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/CMake/FindOSPRay.cmake
+++ /dev/null
@@ -1,95 +0,0 @@
-## ======================================================================================= ##
-## Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  ##
-##                                                                                         ##
-## Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     ##
-## except in compliance with the License.                                                  ##
-## A copy of the License is included with this software in the file LICENSE.               ##
-## If your copy does not contain the License, you may obtain a copy of the License at:     ##
-##                                                                                         ##
-##     http://opensource.org/licenses/BSD-3-Clause                                         ##
-##                                                                                         ##
-## Unless required by applicable law or agreed to in writing, software distributed under   ##
-## the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY ##
-## KIND, either express or implied.                                                        ##
-## See the License for the specific language governing permissions and limitations under   ##
-## limitations under the License.                                                          ##
-## ======================================================================================= ##
-
-###############################################################################
-# Find OSPRay
-# defines:
-# OSPRAY_FOUND
-# OSPRAY_INCLUDE_DIRS
-# OSPRAY_LIBRARIES
-
-# guess that OSPRay is installed in a peer directory
-FIND_PATH(OSPRAY_DIR ospray
-  HINTS ${PROJECT_SOURCE_DIR}/../OSPRay 
-  DOC "OSPRay base directory"
-  )
-IF(NOT OSPRAY_DIR)
-  MESSAGE("Could not find OSPRay base directory. Please set OSPRAY_DIR to the root of your local OSPRay git repository.")
-ENDIF(NOT OSPRAY_DIR)
-
-FIND_PATH(OSPRAY_CMAKE_DIR ospray.cmake
-  HINTS ${PROJECT_SOURCE_DIR}/../OSPRay/cmake
-  DOC "OSPRay cmake directory"
-  )
-IF(NOT OSPRAY_CMAKE_DIR)
-  MESSAGE("Could not find OSPRay cmake directory. Please set OSPRAY_CMAKE_DIR to the cmake directory of your local OSPRay git repository, usually <root>/cmake.")
-ENDIF(NOT OSPRAY_CMAKE_DIR)
-
-FIND_PATH(OSPRAY_BUILD_DIR ospModelViewer
-  HINTS ${PROJECT_SOURCE_DIR}/../OSPRay/build ${PROJECT_SOURCE_DIR}/../OSPRay
-  DOC "OSPRay build directory"
-  )
-IF(NOT OSPRAY_BUILD_DIR)
-  MESSAGE("Could not find OSPRay build directory. Please set OSPRAY_BUILD_DIR to the directory where OSPRay was built.")
-ENDIF(NOT OSPRAY_BUILD_DIR)
-
-LOAD_CACHE(${OSPRAY_BUILD_DIR} READ_WITH_PREFIX OSP_ 
-  OSPRAY_BUILD_MIC_SUPPORT
-  OSPRAY_BUILD_MPI_DEVICE
-  OSPRAY_COMPILER
-  OSPRAY_XEON_TARGET
-  )
-
-SET(OSPRAY_INCLUDE_DIRS
-  ${OSPRAY_DIR}
-  ${OSPRAY_DIR}/ospray
-  ${OSPRAY_DIR}/ospray/embree/common
-  ${OSPRAY_DIR}/ospray/embree
-  ${OSPRAY_DIR}/ospray/include
-  )
-
-SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${OSPRAY_CMAKE_DIR} ${OSPRAY_DIR})
-# which compiler was used to build OSPRay
-SET(OSPRAY_CC ${OSP_OSPRAY_COMPILER} CACHE STRING "OSPRay Compiler (ICC, GCC, CLANG)")
-# whehter to build in MIC/xeon phi support
-SET(OSPRAY_MIC ${OSP_OSPRAY_BUILD_MIC_SUPPORT} CACHE BOOL "Was OSPRay buit with Xeon Phi Support?")
-# whehter to build in MIC/xeon phi support
-SET(OSPRAY_MPI ${OSP_OSPRAY_BUILD_MPI_DEVICE} CACHE BOOL "Was OSPRay built with MPI Remote/Distributed rendering support?")
-# the arch we're targeting for the non-MIC/non-xeon phi part of ospray
-SET(OSPRAY_XEON_TARGET ${OSP_OSPRAY_XEON_TARGET} CACHE STRING "OSPRay target ISA on host (SSE,AVX,AVX2)")
-
-ADD_DEFINITIONS(${OSPRAY_EMBREE_CXX_FLAGS})
-MESSAGE("ospray_dir ${OSPRAY_DIR}")
-SET(OSPRAY_DIR2 ${OSPRAY_DIR})
-INCLUDE(${OSPRAY_DIR}/cmake/ospray.cmake)
-SET(OSPRAY_DIR ${OSPRAY_DIR2})
-MESSAGE("ospray_dir ${OSPRAY_DIR}")
-INCLUDE(${OSPRAY_DIR}/cmake/mpi.cmake)
-
-SET(LIB_OSPRAY_EMBREE LIB_OSPRAY_EMBREE-NOTFOUND)
-SET(LIB_OSPRAY LIB_OSPRAY-NOTFOUND)
-FIND_LIBRARY(LIB_OSPRAY_EMBREE ospray_embree ${OSPRAY_BUILD_DIR})
-FIND_LIBRARY(LIB_OSPRAY ospray ${OSPRAY_BUILD_DIR})
-IF (OSPRAY_MIC)
-  # Xeon Phi specific build ops here
-ENDIF(OSPRAY_MIC)
-
-SET(OSPRAY_LIBRARIES
-  ${LIB_OSPRAY_EMBREE}
-  ${LIB_OSPRAY}
-  )
-
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/CMakeLists.txt b/avt/Plotter/OSPRay/vtkOSPRay/CMakeLists.txt
deleted file mode 100755
index 85a3fcd04..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/CMakeLists.txt
+++ /dev/null
@@ -1,125 +0,0 @@
-## ======================================================================================= ##
-## Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  ##
-## All rights reserved.                                                                    ##
-##                                                                                         ##
-## Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     ##
-## except in compliance with the License.                                                  ##
-## A copy of the License is included with this software in the file LICENSE.               ##
-## If your copy does not contain the License, you may obtain a copy of the License at:     ##
-##                                                                                         ##
-##     http://opensource.org/licenses/BSD-3-Clause                                         ##
-##                                                                                         ##
-## Unless required by applicable law or agreed to in writing, software distributed under   ##
-## the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY ##
-## KIND, either express or implied.                                                        ##
-## See the License for the specific language governing permissions and limitations under   ##
-## limitations under the License.                                                          ##
-## ======================================================================================= ##
-
-# vtkOSPRay is an interface from VTK's rendering classes to OSPRay,
-# a "real time" Ray Tracer.
-
-# It creates a library that includes OSPRay specific subclasses
-# of VTK's rendering classes, Renderer, Camera, etc.
-# These can be instantiated by name, or by using object factory overloading
-# at post compile time (ie, set VTK_AUTOLOAD_PATH to vtkOSPRay's build
-# directory and run a normal vtk app)
-
-project(vtkOSPRay)
-
-
-
-#Configure vtkOSPRay source proper ############################################
-
-# Define a flag
-if (BUILD_AGAINST_PARAVIEW)
-    add_definitions(-DVTKOSPRAY_FOR_PARAVIEW)
-endif(BUILD_AGAINST_PARAVIEW)
-
-# Set vtkOSPRay source files.
-SET ( OSPRAY_CLASSES
-    vtkOSPRayActor.cxx
-    #vtkOSPRayRenderable.cxx
-    vtkOSPRayCamera.cxx
-    vtkOSPRayLight.cxx
-    vtkOSPRayManager.cxx
-    vtkOSPRayPolyDataMapper.cxx
-    vtkOSPRayProperty.cxx
-    vtkOSPRayRenderer.cxx
-    vtkOSPRayTestSource.cxx
-    vtkOSPRayTexture.cxx
-    vtkOSPRayVolumeRayCastMapper.h
-    vtkOSPRayVolumeRayCastMapper.cxx
-    vtkOSPRayPVLODVolume.cxx
-    )
-
-IF (BUILD_AGAINST_PARAVIEW)
-    add_definitions(-DVTKOSPRAY_FOR_PARAVIEW)
-    # paraview uses its own LOD actor, put it in here
-    SET ( OSPRAY_CLASSES ${OSPRAY_CLASSES}
-        vtkOSPRayLODActor.cxx
-        vtkPVOSPRayRepresentation.cxx
-        vtkPVOSPRayRepresentation.h
-        vtkPVOSPRayOutlineRepresentation.cxx
-        vtkPVOSPRayOutlineRepresentation.h
-        # pnav - ParaView 4.3 is unhappy with some code in these, disabling for now
-        #        something changed between the VTK in PV 4.1 and PV 4.3
-        vtkPVOSPRayImageVolumeRepresentation.cxx
-        vtkPVOSPRayImageVolumeRepresentation.h
-        vtkOSPRayCompositeMapper.cxx)
-ENDIF (BUILD_AGAINST_PARAVIEW)
-
-add_definitions(
-    -DvtkCommonCore_EXPORTS
-    -DvtkPVClientServerCoreRendering_EXPORTS
-    -DvtkRenderingVolume_EXPORTS
-    -DvtkPVVTKExtensionsRendering_EXPORTS
-    )
-
-SET ( OSPRAY_SRCS
-    ${OSPRAY_CLASSES}
-    #   vtkOSPRayObjectFactory.cxx
-    )
-
-set (${vtk-module}_NO_HeaderTest 1)
-
-vtk_module_library(${vtk-module} ${OSPRAY_SRCS} ${MOCSrcs} ${UISrcs})
-find_package(OSPRay)
-
-
-# setup include paths
-INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})
-INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR})
-INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR}/vtkOSPRay)
-INCLUDE_DIRECTORIES(${PROJECT_BINARY_DIR})
-INCLUDE_DIRECTORIES(${PROJECT_BINARY_DIR}/vtkOSPRay)
-INCLUDE_DIRECTORIES(${PROJECT_BINARY_DIR}/Base)
-INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR}/Base)
-
-
-# if(PARAVIEW_BUILD_QT_GUI)
-#   INCLUDE(${QT_USE_FILE})
-# endif(PARAVIEW_BUILD_QT_GUI)
-FIND_PACKAGE(Qt4 REQUIRED)
-INCLUDE(${QT_USE_FILE})
-INCLUDE_DIRECTORIES(
-    ${QT_INCLUDE_DIR}
-    )
-
-if(VTK_USE_X)
-    vtk_module_link_libraries(${vtk-module}
-        LINK_PRIVATE ${OSPRAY_LIBRARIES} ${QT_LIBRARIES} ${X11_LIBRARIES} ${X11_Xt_LIB})
-elseif(VTK_USE_COCOA)
-    vtk_module_link_libraries(${vtk-module} ${OSPRAY_LIBRARIES} ${QT_LIBRARIES} "-framework OpenGL -framework Cocoa")
-    target_link_libraries(${vtk-module} ${OSPRAY_LIBRARIES} ${QT_LIBRARIES} ${VTK_LIBRARIES})
-endif()
-
-# OSPRay_Core uses MMTime which is in it's own special library.
-if(WIN32)
-    TARGET_LINK_LIBRARIES(${PROJECT_NAME} LINK_PRIVATE Winmm)
-endif()
-
-#Examples ####################################################################
-#IF ( BUILD_EXAMPLES )
-#ADD_SUBDIRECTORY(Examples)
-#ENDIF ( BUILD_EXAMPLES )
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/LICENSE b/avt/Plotter/OSPRay/vtkOSPRay/LICENSE
deleted file mode 100644
index 66d0235bc..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/LICENSE
+++ /dev/null
@@ -1,77 +0,0 @@
-/*=========================================================================
-Copyright (c) 2014 - 2015, Texas Advanced Computing Center, The University of Texas at Austin.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-
-3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-=========================================================================*/
-
-
-
-Portions of this code are derived from the MantaView module developed at Los Alamos National Laboratory, which is licensed as follows:
-/*=========================================================================
-
-Copyright (c) 2007, Los Alamos National Security, LLC
-
-All rights reserved.
-
-Copyright 2007. Los Alamos National Security, LLC.
-This software was produced under U.S. Government contract DE-AC52-06NA25396
-for Los Alamos National Laboratory (LANL), which is operated by
-Los Alamos National Security, LLC for the U.S. Department of Energy.
-The U.S. Government has rights to use, reproduce, and distribute this software.
-NEITHER THE GOVERNMENT NOR LOS ALAMOS NATIONAL SECURITY, LLC MAKES ANY WARRANTY,
-EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE.
-If software is modified to produce derivative works, such modified software
-should be clearly marked, so as not to confuse it with the version available
-from LANL.
-
-Additionally, redistribution and use in source and binary forms, with or
-without modification, are permitted provided that the following conditions
-are met:
--   Redistributions of source code must retain the above copyright notice,
-    this list of conditions and the following disclaimer.
--   Redistributions in binary form must reproduce the above copyright notice,
-    this list of conditions and the following disclaimer in the documentation
-    and/or other materials provided with the distribution.
--   Neither the name of Los Alamos National Security, LLC, Los Alamos National
-    Laboratory, LANL, the U.S. Government, nor the names of its contributors
-    may be used to endorse or promote products derived from this software
-    without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL LOS ALAMOS NATIONAL SECURITY, LLC OR
-CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-=========================================================================*/
-
-
-
-
-Portions of this code utilize the Visualization Toolkit (VTK) interface, which is licensed as follows:
-/*=========================================================================
-
-  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
-  All rights reserved.
-  See http://www.kitware.com/Copyright.htm for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
\ No newline at end of file
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/R b/avt/Plotter/OSPRay/vtkOSPRay/R
deleted file mode 100644
index 096a02db9..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/R
+++ /dev/null
@@ -1 +0,0 @@
-Binary file vtkOSPRay_src.tar matches
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/README b/avt/Plotter/OSPRay/vtkOSPRay/README
deleted file mode 100755
index 139597f9c..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/README
+++ /dev/null
@@ -1,2 +0,0 @@
-
-
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/README.md b/avt/Plotter/OSPRay/vtkOSPRay/README.md
deleted file mode 100644
index eb244451f..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/README.md
+++ /dev/null
@@ -1,9 +0,0 @@
-vtkOSPRay <a href="https://tacc.github.io/vtkOSPRay/">https://tacc.github.io/vtkOSPRay</a>
-======
-
-<h2>About</h2>
-The base VTK code without ParaView is contained in the VTK directory and makes up vtkOSPRay.  vtkOSPRay is a VTK module which utilizes Intel's OSPRay ray tracing framework (http://ospray.github.io) for rendering.  This offers a performant CPU rendering package with enhanced image quality and includes plugins for the commonly used visualization tools ParaView and VisIt.
-
-<h2>Building</h2>
-vtkOSPRay is currently built as part of the pvOSPRay and visitOSPRay builds. A stand-alone library build process will be released soon.
-
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/module.cmake b/avt/Plotter/OSPRay/vtkOSPRay/module.cmake
deleted file mode 100755
index 5a091d988..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/module.cmake
+++ /dev/null
@@ -1,48 +0,0 @@
-## ======================================================================================= ##
-## Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  ##
-## All rights reserved.                                                                    ##
-##                                                                                         ##
-## Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     ##
-## except in compliance with the License.                                                  ##
-## A copy of the License is included with this software in the file LICENSE.               ##
-## If your copy does not contain the License, you may obtain a copy of the License at:     ##
-##                                                                                         ##
-##     http://opensource.org/licenses/BSD-3-Clause                                         ##
-##                                                                                         ##
-## Unless required by applicable law or agreed to in writing, software distributed under   ##
-## the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY ##
-## KIND, either express or implied.                                                        ##
-## See the License for the specific language governing permissions and limitations under   ##
-## limitations under the License.                                                          ##
-## ======================================================================================= ##
-
-set (_vtk_modules)
-if(PARAVIEW_USE_MPI)
-  list(APPEND _vtk_modules vtkParallelMPI)
-endif()
-
-if (BUILD_AGAINST_PARAVIEW)
-  list(APPEND _vtk_modules vtkPVClientServerCoreRendering)
-endif()
-
-if (VTK_RENDERING_BACKEND STREQUAL "OpenGL2")
-  message("GL2")
-  list(APPEND _vtk_modules vtkRenderingOpenGL2)
-else()
-  message("GL1")
-  list(APPEND _vtk_modules vtkRenderingOpenGL)
-endif()
-
-vtk_module(vtkOSPRay
-  DEPENDS
-    vtkFiltersCore
-    vtkParallelCore
-    vtkFiltersHybrid
-    ${_vtk_modules}
-  TEST_DEPENDS
-    vtkTestingRendering
-    vtkIOPLY
-  TEST_LABELS
-    PARAVIEW
-  EXCLUDE_FROM_WRAP_HIERARCHY
-)
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRay.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRay.h
deleted file mode 100755
index f39a3952f..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRay.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRay.h -
-// .SECTION Description
-//
-#ifndef __vtkOSPRay_h
-#define __vtkOSPRay_h
-
-#include "ospray/ospray.h"
-
-#include "vtkConfigure.h"
-#include "vtkOSPRayModule.h"
-
-#if defined(__APPLE__) && (defined(VTK_USE_CARBON) || defined(VTK_USE_COCOA))
-# include <OpenGL/gl.h> // Include OpenGL API.
-#else
-#include "vtkOpenGL.h"
-#endif
-
-#define DEBUG(x) {   std::cout << __PRETTY_FUNCTION__ << ":" << __LINE__ << " " << x << std::endl; }
-#define USE_OSPRAY 1
-#define USE_VBOS 0
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayActor.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayActor.cxx
deleted file mode 100755
index 5dd2cf854..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayActor.cxx
+++ /dev/null
@@ -1,165 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "ospray/ospray.h"
-
-#define GL_GLEXT_PROTOTYPES
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayActor.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkOSPRayRenderer.h"
-#include "vtkMapper.h"
-
-#include "vtkDataSet.h"
-#include "vtkObjectFactory.h"
-#include "vtkRendererCollection.h"
-#include "vtkTimerLog.h"
-
-#include <map>
-#include <algorithm>
-
-
-#include "vtkInformation.h"
-#include "vtkInformationVector.h"
-
-vtkStandardNewMacro(vtkOSPRayActor);
-
-//----------------------------------------------------------------------------
-vtkOSPRayActor::vtkOSPRayActor()
-{
-  this->OSPRayManager = NULL;
-  this->SortType = DYNBVH;
-  this->OSPRayModel = ospNewModel();
-  LastFrame=-1;
-  Renderable = NULL;
-}
-
-// now some OSPRay resources, ignored previously, can be de-allocated safely
-//
-vtkOSPRayActor::~vtkOSPRayActor()
-{
-  if (this->OSPRayManager)
-  {
-    this->ReleaseGraphicsResources(NULL);
-    this->OSPRayManager->Delete();
-  }
-  // delete this->OSPRayModel;
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::PrintSelf( ostream & os, vtkIndent indent )
-{
-  this->Superclass::PrintSelf( os, indent );
-}
-
-//----------------------------------------------------------------------------
-vtkProperty *vtkOSPRayActor::MakeProperty()
-{
-  return vtkOSPRayProperty::New();
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::ReleaseGraphicsResources( vtkWindow * win )
-{
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::Render( vtkRenderer * ren, vtkMapper * mapper )
-{
-  if ( vtkOSPRayRenderer * OSPRayRenderer = vtkOSPRayRenderer::SafeDownCast( ren ) )
-  {
-    if (!this->OSPRayManager)
-    {
-      this->OSPRayManager = OSPRayRenderer->GetOSPRayManager();
-      this->OSPRayManager->Register(this);
-    }
-    // if (LastFrame < OSPRayRenderer->GetFrame())
-    // {
-      // printf("creating new model for actor\n");
-      // this->OSPRayModel = ospNewModel();
-    // }
-
-    // TODO: be smarter on update or create rather than create every time
-    // build transformation (with AffineTransfrom and Instance?)
-
-    // TODO: the way "real FLAT" shading is done right now (by not supplying vertex
-    // normals), changing from FLAT to Gouraud shading needs to create a new mesh.
-
-      mapper->Render(ren, this);
-      LastFrame = OSPRayRenderer->GetFrame();
-    }
-      UpdateObjects(ren);
-  }
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::SetVisibility(int newval)
-{
-  if (newval == this->GetVisibility())
-  {
-    return;
-  }
-  if (this->OSPRayManager && !newval)
-  {
-  }
-  this->Superclass::SetVisibility(newval);
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::RemoveObjects()
-{
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::PreRender()
-{
-  // std::cout << __PRETTY_FUNCTION__ << std::endl;
-  // this->OSPRayModel = ospNewModel();
-}
-
-
-//----------------------------------------------------------------------------
-void vtkOSPRayActor::UpdateObjects( vtkRenderer * ren )
-{
-  vtkOSPRayRenderer * OSPRayRenderer =
-  vtkOSPRayRenderer::SafeDownCast( ren );
-  if (!OSPRayRenderer)
-  {
-    return;
-  }
-
-  //Remove whatever we used to show in the scene
-  if (!this->OSPRayManager)
-  {
-    return;
-  }
-
-  if (!this->OSPRayModel)
-    return;
-
-  if (!this->GetVisibility())
-    return;
-  
-  Renderable = new vtkOSPRayRenderable(this->OSPRayModel);
-  OSPRayRenderer->AddOSPRayRenderable(Renderable);
-
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayActor.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayActor.h
deleted file mode 100755
index 401a8f8d8..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayActor.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayActor - vtkActor for OSPRay Ray traced scenes
-// .SECTION Description
-// vtkOSPRayActor is a concrete implementation of the abstract class vtkActor.
-// vtkOSPRayActor interfaces to the OSPRay Raytracer library.
-
-#ifndef __vtkOSPRayActor_h
-#define __vtkOSPRayActor_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkOSPRayRenderable.h"
-#include "vtkActor.h"
-#include <map>
-#include <vector>
-
-
-//BTX
-namespace OSPRay {
-class Group;
-class AccelerationStructure;
-class Object;
-};
-//ETX
-
-namespace osp
-{
-  class Model;
-}
-
-class vtkTimeStamp;
-class vtkOSPRayProperty;
-class vtkOSPRayRenderer;
-class vtkOSPRayManager;
-
-
-
-class VTKOSPRAY_EXPORT vtkOSPRayActor : public vtkActor
-{
-public:
-  static vtkOSPRayActor *New();
-  vtkTypeMacro(vtkOSPRayActor,vtkActor);
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-
-  //Description:
-  // Overriden to help ensure that a OSPRay compatible class is created.
-  vtkProperty * MakeProperty();
-
-  // Description:
-  // This causes the actor to be rendered. It in turn will render the actor's
-  // property, texture map and then mapper. If a property hasn't been
-  // assigned, then the actor will create one automatically. Note that a side
-  // effect of this method is that the pipeline will be updated.
-  void Render(vtkRenderer *ren, vtkMapper *mapper);
-
-  // Description:
-  // Release any graphics resources that are being consumed by this actor.
-  // The parameter window could be used to determine which graphic
-  // resources to release.
-  void ReleaseGraphicsResources(vtkWindow *);
-
-  //Description:
-  // Overridden to schedule a transaction to hide the object
-  virtual void SetVisibility(int);
-
-  //Description:
-  // Transaction callback that hides the object
-  void RemoveObjects();
-
-  void PreRender();
-
-  //Description:
-  //Lets you choose the OSPRay space sorting (acceleration) structure
-  //type used internally. Default is 0=DYNBVH
-  vtkSetMacro(SortType, int);
-  vtkGetMacro(SortType, int);
-
-  int GetLastFrame() { return LastFrame; }
-
- protected:
-  vtkOSPRayActor();
-  ~vtkOSPRayActor();
-
-  virtual void CreateOwnLODs () {}
-  virtual void UpdateOwnLODs() {}
-
- private:
-  vtkOSPRayActor(const vtkOSPRayActor&);  // Not implemented.
-  void operator=(const vtkOSPRayActor&);  // Not implemented.
-
-  void UpdateObjects(vtkRenderer *);
-
-  int SortType;
-
-  //BTX
-  enum {DYNBVH, RECURSIVEGRID3};
-  //ETX
-
-  vtkOSPRayManager *OSPRayManager;
-  vtkOSPRayRenderable* Renderable;
-
-public:
-  int LastFrame;
-  vtkTimeStamp MeshMTime;
-  osp::Model* OSPRayModel;
-  std::map<int, osp::Model*> cache;
-};
-
-#endif // __vtkOSPRayActor_h
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCamera.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCamera.cxx
deleted file mode 100755
index 5d48dc39d..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCamera.cxx
+++ /dev/null
@@ -1,113 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayCamera.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayRenderer.h"
-
-#include "vtkObjectFactory.h"
-
-#include <math.h>
-
-#ifndef __APPLE__
-#include <GL/glu.h>
-#else
-#include <OpenGL/glu.h>
-#endif
-
-   vtkStandardNewMacro(vtkOSPRayCamera);
-
-//----------------------------------------------------------------------------
-   vtkOSPRayCamera::vtkOSPRayCamera()
-   {
-    this->OSPRayManager = NULL;
-  }
-
-//----------------------------------------------------------------------------
-  vtkOSPRayCamera::~vtkOSPRayCamera()
-  {
-    if (this->OSPRayManager)
-    {
-      this->OSPRayManager->Delete();
-    }
-  }
-
-//----------------------------------------------------------------------------
-  void vtkOSPRayCamera::OrientOSPRayCamera(vtkRenderer *ren)
-  {
-    vtkOSPRayRenderer * OSPRayRenderer = vtkOSPRayRenderer::SafeDownCast(ren);
-    if (!OSPRayRenderer)
-    {
-      return;
-    }
-    OSPRayRenderer->ClearAccumulation();
-
-    if (!this->OSPRayManager)
-    {
-      this->OSPRayManager = OSPRayRenderer->GetOSPRayManager();
-      this->OSPRayManager->Register(this);
-    }
-
-  // for figuring out aspect ratio
-    int lowerLeft[2];
-    int usize, vsize;
-    ren->GetTiledSizeAndOrigin(&usize, &vsize, lowerLeft, lowerLeft + 1);
-
-    double *eye, *lookat, *up, vfov;
-    eye    = this->Position;
-    lookat = this->FocalPoint;
-    up     = this->ViewUp;
-    vfov   = this->ViewAngle;
-
-    OSPCamera ospCamera = ((OSPCamera)this->OSPRayManager->OSPRayCamera);
-    if (vsize == 0)
-      return;
-    ospSetf(ospCamera,"aspect",float(usize)/float(vsize));
-    ospSetf(ospCamera,"fovy",vfov);
-    Assert(ospCamera != NULL && "could not create camera");
-    ospSet3f(ospCamera,"pos",eye[0], eye[1], eye[2]);
-    ospSet3f(ospCamera,"up",up[0], up[1], up[2]);
-    ospSet3f(ospCamera,"dir",lookat[0]-eye[0],lookat[1]-eye[1],lookat[2]-eye[2]);
-    ospCommit(ospCamera);
-
-  }
-
-//----------------------------------------------------------------------------
-// called by Renderer::UpdateCamera()
-  void vtkOSPRayCamera::Render(vtkRenderer *ren)
-  {
-    int lowerLeft[2];
-    int usize, vsize;
-    ren->GetTiledSizeAndOrigin(&usize, &vsize, lowerLeft, lowerLeft + 1);
-    double newAspect = float(usize)/float(vsize);
-    if (this->GetMTime() > this->LastRenderTime || (newAspect != this->Aspect) )
-    {
-      this->Aspect = newAspect;
-      this->OrientOSPRayCamera(ren);
-
-      this->LastRenderTime.Modified();
-
-    }
-  }
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCamera.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCamera.h
deleted file mode 100755
index b27f64f0e..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCamera.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayCamera - OSPRay camera
-// .SECTION Description
-// vtkOSPRayCamera is a concrete implementation of the abstract class
-// vtkCamera.  vtkOSPRayCamera interfaces to the OSPRay Raytracer library.
-
-#ifndef __vtkOSPRayCamera_h
-#define __vtkOSPRayCamera_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkCamera.h"
-
-//BTX
-namespace OSPRay {
-class Camera;
-}
-//ETX
-
-class vtkTimeStamp;
-class vtkOSPRayManager;
-
-class VTKOSPRAY_EXPORT vtkOSPRayCamera : public vtkCamera
-{
-public:
-  static vtkOSPRayCamera *New();
-  vtkTypeMacro(vtkOSPRayCamera,vtkCamera);
-
-  void Render(vtkRenderer *ren);
-
-protected:
-   vtkOSPRayCamera();
-  ~vtkOSPRayCamera();
-
-private:
-  vtkOSPRayCamera(const vtkOSPRayCamera&);  // Not implemented.
-  void operator=(const vtkOSPRayCamera&);  // Not implemented.
-
-  void OrientOSPRayCamera(vtkRenderer *);
-
-  vtkTimeStamp LastRenderTime;
-
-  vtkOSPRayManager *OSPRayManager;
-  double Aspect;
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCompositeMapper.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCompositeMapper.cxx
deleted file mode 100755
index 22fd34294..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCompositeMapper.cxx
+++ /dev/null
@@ -1,45 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "vtkOSPRayCompositeMapper.h"
-
-#include "vtkOSPRayPolyDataMapper.h"
-#include "vtkObjectFactory.h"
-
-vtkStandardNewMacro(vtkOSPRayCompositeMapper);
-
-vtkOSPRayCompositeMapper::vtkOSPRayCompositeMapper()
-{
-}
-
-vtkOSPRayCompositeMapper::~vtkOSPRayCompositeMapper()
-{
-}
-
-vtkPolyDataMapper * vtkOSPRayCompositeMapper::MakeAMapper()
-{
-  return vtkOSPRayPolyDataMapper::New();
-}
-
-void vtkOSPRayCompositeMapper::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os,indent);
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCompositeMapper.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCompositeMapper.h
deleted file mode 100755
index 250bbbf29..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayCompositeMapper.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayCompositeMapper - OSPRayMapper for composite data
-// .SECTION Description
-// This class is an adapter between composite data produced by the data
-// processing pipeline and the non composite capable vtkOSPRayPolyDataMapper.
-
-#ifndef __vtkOSPRayCompositeMapper_h
-#define __vtkOSPRayCompositeMapper_h
-
-#include "vtkCompositePolyDataMapper.h"
-#include "vtkOSPRayModule.h"
-class vtkPolyDataMapper;
-
-class VTKOSPRAY_EXPORT vtkOSPRayCompositeMapper :
-  public vtkCompositePolyDataMapper
-{
-
-public:
-  static vtkOSPRayCompositeMapper *New();
-  vtkTypeMacro(vtkOSPRayCompositeMapper, vtkCompositePolyDataMapper);
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-
-protected:
-  vtkOSPRayCompositeMapper();
-  ~vtkOSPRayCompositeMapper();
-
-  // Description:
-  // Need to define the type of data handled by this mapper.
-  virtual vtkPolyDataMapper * MakeAMapper();
-
-private:
-  vtkOSPRayCompositeMapper(const vtkOSPRayCompositeMapper&);  // Not implemented.
-  void operator=(const vtkOSPRayCompositeMapper&);    // Not implemented.
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayConfigure.h.in b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayConfigure.h.in
deleted file mode 100755
index 2ecddcc9d..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayConfigure.h.in
+++ /dev/null
@@ -1,37 +0,0 @@
-/*=========================================================================
-This source has no copyright.  It is intended to be copied by users
-wishing to create their own VTK classes locally.
-=========================================================================*/
-#ifndef __@PROJECT_NAME@Configure_h
-#define __@PROJECT_NAME@Configure_h
-
-// Define @PROJECT_NAME@_SHARED if the library was built shared.
-#if @BUILD_SHARED_LIBS@
-# define @PROJECT_NAME@_SHARED
-#endif
-
-#if @BUILD_AGAINST_PARAVIEW@
-# define VTKOSPRAY_FOR_PARAVIEW
-#endif
-
-// Disable warning caused from static VTK and shared @PROJECT_NAME@.
-#if defined(_MSC_VER) && defined(@PROJECT_NAME@_SHARED)
-# pragma warning (disable: 4275) /* non-DLL-interface base class used */
-#endif
-
-// Setup export/import macro for DLL.  The symbol
-// "@PROJECT_NAME@_EXPORTS" is defined by CMake when building source
-// files for a shared library named "@PROJECT_NAME@".  For these
-// sources we should export if building a shared library.  For other
-// sources we should import if using a shared library.
-#if defined(_WIN32) && defined(VTK_BUILD_SHARED_LIBS)
-# if defined(@PROJECT_NAME@_EXPORTS)
-#  define VTK_@PROJECT_NAME@_EXPORT __declspec(dllexport)
-# else
-#  define VTK_@PROJECT_NAME@_EXPORT __declspec(dllimport)
-# endif
-#else
-# define VTK_@PROJECT_NAME@_EXPORT
-#endif
-
-#endif // __@PROJECT_NAME@Configure_h
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLODActor.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLODActor.cxx
deleted file mode 100755
index 5f1692c25..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLODActor.cxx
+++ /dev/null
@@ -1,56 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayLODActor -
-// .SECTION Description
-//
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayLODActor.h"
-#include "vtkObjectFactory.h"
-#include "vtkOSPRayActor.h"
-#include "vtkMatrix4x4.h"
-
-vtkStandardNewMacro(vtkOSPRayLODActor);
-
-//----------------------------------------------------------------------------
-vtkOSPRayLODActor::vtkOSPRayLODActor()
-{
-  this->Device->Delete();
-  this->Device = vtkOSPRayActor::New();
-  vtkMatrix4x4 *m;
-  m = vtkMatrix4x4::New();
-  this->Device->SetUserMatrix(m);
-  m->Delete();
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayLODActor::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os,indent);
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayLODActor::SetVisibility(int newval)
-{
-  this->Device->SetVisibility(newval);
-  this->Superclass::SetVisibility(newval);
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLODActor.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLODActor.h
deleted file mode 100755
index a132a1a29..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLODActor.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayLODActor.h -
-// .SECTION Description
-//
-
-#ifndef __vtkOSPRayLODActor_h
-#define __vtkOSPRayLODActor_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkPVLODActor.h"
-
-class VTKOSPRAY_EXPORT vtkOSPRayLODActor : public vtkPVLODActor
-{
-public:
-  static vtkOSPRayLODActor *New();
-  vtkTypeMacro(vtkOSPRayLODActor,vtkPVLODActor);
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-
-  vtkActor * GetDevice() { return  this->Device; }
-  virtual void SetVisibility(int);
-
-protected:
-  vtkOSPRayLODActor();
-  ~vtkOSPRayLODActor() {};
-
-private:
-  vtkOSPRayLODActor(const vtkOSPRayLODActor&);  // Not implemented.
-  void operator=(const vtkOSPRayLODActor&);  // Not implemented.
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLight.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLight.cxx
deleted file mode 100755
index bb4a56df3..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLight.cxx
+++ /dev/null
@@ -1,136 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayLight.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayRenderer.h"
-
-#include "vtkObjectFactory.h"
-
-#include <math.h>
-
-vtkStandardNewMacro(vtkOSPRayLight);
-
-//----------------------------------------------------------------------------
-vtkOSPRayLight::vtkOSPRayLight()
-{
-  this->OSPRayManager = NULL;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayLight::~vtkOSPRayLight()
-{
-  if (this->OSPRayManager)
-    {
-    this->OSPRayManager->Delete();
-    }
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayLight::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os,indent);
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayLight::Render(vtkRenderer *ren, int /* not used */)
-{
-  vtkOSPRayRenderer *renderer = vtkOSPRayRenderer::SafeDownCast(ren);
-  if (!renderer)
-    {
-    return;
-    }
-
-  // if (!this->OSPRayLight)
-    {
-    CreateLight(ren);
-    }
-  // else
-    {
-    // UpdateLight(ren);
-    }
-}
-
-//----------------------------------------------------------------------------
-// called in Transaction context, it is safe to modify the engine state here
-void vtkOSPRayLight::CreateLight(vtkRenderer *ren)
-{
-  vtkOSPRayRenderer *OSPRayRenderer = vtkOSPRayRenderer::SafeDownCast(ren);
-  if (!OSPRayRenderer)
-    {
-    return;
-    }
-
-    if (!this->OSPRayManager)
-    {
-    this->OSPRayManager = OSPRayRenderer->GetOSPRayManager();
-    this->OSPRayManager->Register(this);
-    }
-
-  OSPRenderer renderer = ((OSPRenderer)this->OSPRayManager->OSPRayRenderer);
-      std::vector<OSPLight> pointLights;
-      std::vector<OSPLight> directionalLights;
-
-
-  double *color, *position, *focal, direction[3];
-
-  // OSPRay Lights only have one "color"
-  color    = this->GetDiffuseColor();
-  position = this->GetTransformedPosition();
-  focal    = this->GetTransformedFocalPoint();
-
-  if (this->GetPositional())
-    {
-    OSPLight ospLight = ospNewLight(renderer, "OBJPointLight");
-    ospSetString(ospLight, "name", "point" );
-    ospSet3f(ospLight, "color", color[0],color[1],color[2]);
-    ospSet3f(ospLight, "position", position[0],position[1],position[2]);
-    ospCommit(ospLight);
-    pointLights.push_back(ospLight);
-    OSPData pointLightArray = ospNewData(pointLights.size(), OSP_OBJECT, &pointLights[0], 0);
-    ospSetData(renderer, "pointLights", pointLightArray);
-    }
-  else
-    {
-    direction[0] = position[0] - focal[0];
-    direction[1] = position[1] - focal[1];
-    direction[2] = position[2] - focal[2];
-    OSPLight ospLight = ospNewLight(renderer, "DirectionalLight");
-    ospSetString(ospLight, "name", "sun" );
-    ospSet3f(ospLight, "color", color[0],color[1],color[2]);
-    ospSet3f(ospLight, "direction", direction[0],direction[1],direction[2]);
-    ospCommit(ospLight);
-    directionalLights.push_back(ospLight);
-    OSPData pointLightArray = ospNewData(directionalLights.size(), OSP_OBJECT, &directionalLights[0], 0);
-    ospSetData(renderer, "directionalLights", pointLightArray);
-
-    }
-}
-
-//------------------------------------------------------------------------------
-void vtkOSPRayLight::UpdateLight(vtkRenderer *ren)
-{
-  CreateLight(ren);
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLight.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLight.h
deleted file mode 100755
index ab2578323..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayLight.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayLight - OSPRay light
-// .SECTION Description
-// vtkOSPRayLight is a concrete implementation of the abstract class vtkLight.
-// vtkOSPRayLight interfaces to the OSPRay Raytracer library.
-
-#ifndef __vtkOSPRayLight_h
-#define __vtkOSPRayLight_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkLight.h"
-
-//BTX
-namespace OSPRay {
-class Light;
-}
-//ETX
-
-class vtkOSPRayRenderer;
-class vtkTimeStamp;
-class vtkOSPRayManager;
-
-class VTKOSPRAY_EXPORT vtkOSPRayLight : public vtkLight
-{
-public:
-  static vtkOSPRayLight *New();
-  vtkTypeMacro(vtkOSPRayLight, vtkLight);
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-
-  // Description:
-  // Implement base class method.
-  void Render(vtkRenderer *ren, int light_index);
-
-protected:
-  vtkOSPRayLight();
-  ~vtkOSPRayLight();
-
-private:
-  vtkOSPRayLight(const vtkOSPRayLight&); // Not implemented.
-  void operator=(const vtkOSPRayLight&); // Not implemented.
-
-  void CreateLight(vtkRenderer *);
-  void UpdateLight(vtkRenderer *ren);
-
-  vtkOSPRayManager *OSPRayManager;
-
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayManager.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayManager.cxx
deleted file mode 100755
index 310083f73..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayManager.cxx
+++ /dev/null
@@ -1,76 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "ospray/ospray.h"
-
-#include "vtkOSPRayManager.h"
-#include "vtkObjectFactory.h"
-#include "vtkOSPRay.h"
-
-vtkOSPRayManager* vtkOSPRayManager::__singleton = NULL;
-
-// vtkStandardNewMacro(vtkOSPRayManager);
-
-vtkOSPRayManager* vtkOSPRayManager::New()
-{
-  return vtkOSPRayManager::Singleton();
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayManager::vtkOSPRayManager()
-{
-  VolumeModelLastFrame=-1;
-  if (1)
-  {
-    int ac =1;
-    const char* av[] = {"pvOSPRay\0","--osp:verbose\0"};
-    ospInit(&ac, av);
-  }
-  else  //coi
-  {
-    int ac =2;
-    const char* av[] = {"pvOSPRay\0","--osp:coi","\0"};
-    ospInit(&ac, av);
-  }
-  this->OSPRayVolumeRenderer = (osp::Renderer*)ospNewRenderer("raycast_volume_renderer");
-  this->OSPRayCamera = ospNewCamera("perspective");
-  this->OSPRayModel = ospNewModel();
-  this->OSPRayVolumeModel = this->OSPRayModel;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayManager::~vtkOSPRayManager()
-{
-
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayManager::PrintSelf( ostream& os, vtkIndent indent )
-{
-  this->Superclass::PrintSelf( os, indent );
-}
-
-vtkOSPRayManager* vtkOSPRayManager::Singleton()
-{
-  if (!__singleton)
-    __singleton = new vtkOSPRayManager();
-  return __singleton;
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayManager.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayManager.h
deleted file mode 100755
index df0c99486..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayManager.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayManager - persistant access to OSPRay engine
-// .SECTION Description
-// vtkOSPRayManager is a reference counted wrapper around the OSPRay engine.
-// Because it is reference counted, it outlives all vtkOSPRay classes that
-// reference it. That means that they can safely use it to manage their
-// own OSPRay side resources and that the engine itself will be destructed
-// when the wrapper is.
-//
-// Carson: This class initializes OSPRay and must be called through
-// the singleton before any OSPRay code is used.
-//
-
-#ifndef __vtkOSPRayManager_h
-#define __vtkOSPRayManager_h
-
-#include "vtkObject.h"
-#include "vtkOSPRayModule.h"
-#include <vector>
-
-
-//BTX
-namespace OSPRay {
-class Camera;
-class Factory;
-class Group;
-class LightSet;
-class OSPRayInterface;
-class Scene;
-class SyncDisplay;
-};
-//ETX
-
-namespace osp
-{
-class Renderer;
-class Model;
-class Camera;
-}
-
-
-class VTKOSPRAY_EXPORT vtkOSPRayManager : public vtkObject
-{
-public:
-  vtkTypeMacro(vtkOSPRayManager,vtkObject);
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-  static vtkOSPRayManager* Singleton();
-  static vtkOSPRayManager* New();
-
-protected:
-  vtkOSPRayManager();
-  ~vtkOSPRayManager();
-
-private:
-  vtkOSPRayManager(const vtkOSPRayManager&);  // Not implemented.
-  void operator=(const vtkOSPRayManager&);  // Not implemented.
-
-  static vtkOSPRayManager* __singleton;
-
-public:
-//
-//  OSPRay vars
-//
-  osp::Model* OSPRayModel;
-  osp::Renderer*    OSPRayRenderer;
-  osp::Camera*      OSPRayCamera;
-  osp::Model* OSPRayDynamicModel;
-  osp::Renderer*    OSPRayVolumeRenderer;
-  osp::Model* OSPRayVolumeModel;
-  vtkTimeStamp  VolumeModelBuildTime;
-  int VolumeModelLastFrame;
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayModule.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayModule.h
deleted file mode 100755
index 7566a539d..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayModule.h
+++ /dev/null
@@ -1,41 +0,0 @@
-
-#ifndef VTKOSPRAY_EXPORT_H
-#define VTKOSPRAY_EXPORT_H
-
-#ifdef VTKOSPRAY_STATIC_DEFINE
-#  define VTKOSPRAY_EXPORT
-#  define VTKOSPRAY_NO_EXPORT
-#else
-#  ifndef VTKOSPRAY_EXPORT
-#    ifdef vtkOSPRay_EXPORTS
-        /* We are building this library */
-#      define VTKOSPRAY_EXPORT __attribute__((visibility("default")))
-#    else
-        /* We are using this library */
-#      define VTKOSPRAY_EXPORT __attribute__((visibility("default")))
-#    endif
-#  endif
-
-#  ifndef VTKOSPRAY_NO_EXPORT
-#    define VTKOSPRAY_NO_EXPORT __attribute__((visibility("hidden")))
-#  endif
-#endif
-
-#ifndef VTKOSPRAY_DEPRECATED
-#  define VTKOSPRAY_DEPRECATED __attribute__ ((__deprecated__))
-#  define VTKOSPRAY_DEPRECATED_EXPORT VTKOSPRAY_EXPORT __attribute__ ((__deprecated__))
-#  define VTKOSPRAY_DEPRECATED_NO_EXPORT VTKOSPRAY_NO_EXPORT __attribute__ ((__deprecated__))
-#endif
-
-#define DEFINE_NO_DEPRECATED 0
-#if DEFINE_NO_DEPRECATED
-# define VTKOSPRAY_NO_DEPRECATED
-#endif
-
-/* AutoInit dependencies.  */
-// #include "vtkFiltersCoreModule.h"
-// #include "vtkFiltersHybridModule.h"
-//#include "vtkPVClientServerCoreRenderingModule.h"
-//#include "vtkRenderingOpenGLModule.h"
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.cxx
deleted file mode 100755
index d38fb7948..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.cxx
+++ /dev/null
@@ -1,148 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayObjectFactory -
-// .SECTION Description
-//
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayRenderer.h"
-
-#include "vtkOSPRayObjectFactory.h"
-
-#include "vtkDebugLeaks.h"
-#include "vtkDynamicLoader.h"
-#include "vtkOverrideInformation.h"
-#include "vtkOverrideInformationCollection.h"
-#include "vtkVersion.h"
-
-#include "vtkOSPRayActor.h"
-#include "vtkOSPRayCamera.h"
-#include "vtkOSPRayLight.h"
-#include "vtkOSPRayPolyDataMapper.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkOSPRayTexture.h"
-
-#ifdef VTKOSPRAY_FOR_PARAVIEW
-#include "vtkOSPRayLODActor.h"
-#endif
-
-#include <DebugStream.h>
-
-vtkStandardNewMacro(vtkOSPRayObjectFactory);
-
-//----------------------------------------------------------------------------
-void vtkOSPRayObjectFactory::PrintSelf(ostream& os, vtkIndent indent)
-{
-  os << indent << "VTK OSPRay object factory" << endl;
-}
-
-//----------------------------------------------------------------------------
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayActor);
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayCamera);
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayLight);
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayPolyDataMapper);
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayProperty);
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayRenderer);
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayTexture);
-#ifdef VTKOSPRAY_FOR_PARAVIEW
-VTK_CREATE_CREATE_FUNCTION(vtkOSPRayLODActor);
-#endif
-
-//----------------------------------------------------------------------------
-vtkOSPRayObjectFactory::vtkOSPRayObjectFactory()
-{
-#ifdef VTKOSPRAY_FOR_PARAVIEW
-  this->RegisterOverride("vtkPVLODActor",
-                         "vtkOSPRayLODActor",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayLODActor);
-#endif
-
-  vtkOverrideInformationCollection *oic = 
-      vtkOverrideInformationCollection::New();
-
-  vtkObjectFactory::GetOverrideInformation("vtkActor", oic);
-  if(oic->GetNumberOfItems() != 0)
-      vtkObjectFactory::SetAllEnableFlags(0, "vtkActor");
-  this->RegisterOverride("vtkActor",
-                         "vtkOSPRayActor",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayActor);
-  vtkObjectFactory::GetOverrideInformation("vtkCamera", oic);
-  if(oic->GetNumberOfItems() != 0)
-      vtkObjectFactory::SetAllEnableFlags(0, "vtkCamera");
-  this->RegisterOverride("vtkCamera",
-                         "vtkOSPRayCamera",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayCamera);
-  vtkObjectFactory::GetOverrideInformation("vtkPolyDataMapper", oic);
-  if(oic->GetNumberOfItems() != 0)
-      vtkObjectFactory::SetAllEnableFlags(0, "vtkPolyDataMapper");
-  this->RegisterOverride("vtkPolyDataMapper",
-                         "vtkOSPRayPolyDataMapper",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayPolyDataMapper);
-  vtkObjectFactory::GetOverrideInformation("vtkProperty", oic);
-  if(oic->GetNumberOfItems() != 0)
-      vtkObjectFactory::SetAllEnableFlags(0, "vtkProperty");
-  this->RegisterOverride("vtkProperty",
-                         "vtkOSPRayProperty",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayProperty);
-  vtkObjectFactory::GetOverrideInformation("vtkRenderer", oic);
-  if(oic->GetNumberOfItems() != 0)
-      vtkObjectFactory::SetAllEnableFlags(0, "vtkRenderer");
-  this->RegisterOverride("vtkRenderer",
-                         "vtkOSPRayRenderer",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayRenderer);
-  vtkObjectFactory::GetOverrideInformation("vtkTexture", oic);
-  if(oic->GetNumberOfItems() != 0)
-      vtkObjectFactory::SetAllEnableFlags(0, "vtkTexture");
-  this->RegisterOverride("vtkTexture",
-                         "vtkOSPRayTexture",
-                         "OSPRay",
-                         1,
-                         vtkObjectFactoryCreatevtkOSPRayTexture);
-}
-
-//----------------------------------------------------------------------------
-//ALOK: removing this because it conflicts with vtkManta
-//VTK_FACTORY_INTERFACE_IMPLEMENT(vtkOSPRayObjectFactory);
-
-//----------------------------------------------------------------------------
-const char *vtkOSPRayObjectFactory::GetVTKSourceVersion()
-{
-  return VTK_SOURCE_VERSION;
-}
-
-//----------------------------------------------------------------------------
-const char *vtkOSPRayObjectFactory::GetDescription()
-{
-  return "VTK OSPRay Object Factory";
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.h
deleted file mode 100755
index 539281142..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayObjectFactory.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayObjectFactory -
-// .SECTION Description
-//
-#ifndef __vtkOSPRayObjectFactory_h
-#define __vtkOSPRayObjectFactory_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkObjectFactory.h"
-
-class VTKOSPRAY_EXPORT vtkOSPRayObjectFactory : public vtkObjectFactory
-{
-
-public:
-  // Methods from vtkObject
-  vtkTypeMacro(vtkOSPRayObjectFactory,vtkObjectFactory);
-  static vtkOSPRayObjectFactory *New();
-  void PrintSelf(ostream& os, vtkIndent indent);
-  virtual const char* GetVTKSourceVersion();
-  virtual const char* GetDescription();
-
-protected:
-  vtkOSPRayObjectFactory();
-  ~vtkOSPRayObjectFactory() {}
-
-private:
-  vtkOSPRayObjectFactory(const vtkOSPRayObjectFactory&); // Not implemented.
-  void operator=(const vtkOSPRayObjectFactory&);   // Not implemented.
-};
-
-#endif /* vtkOSPRayObjectFactory_h */
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPVLODVolume.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPVLODVolume.cxx
deleted file mode 100755
index c6f35b6f9..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPVLODVolume.cxx
+++ /dev/null
@@ -1,401 +0,0 @@
-/*=========================================================================
-
-  Program:   ParaView
-  Module:    vtkOSPRayPVLODVolume.cxx
-
-  Copyright (c) Kitware, Inc.
-  All rights reserved.
-  See Copyright.txt or http://www.paraview.org/HTML/Copyright.html for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-#include "vtkOSPRayPVLODVolume.h"
-
-#include "vtkDataSet.h"
-#include "vtkImageData.h"
-#include "vtkLODProp3D.h"
-#include "vtkMapper.h"
-#include "vtkMath.h"
-#include "vtkObjectFactory.h"
-#include "vtkProperty.h"
-#include "vtkTransform.h"
-#include "vtkUnstructuredGridBase.h"
-#include "vtkUnstructuredGridVolumeMapper.h"
-#include "vtkVolumeMapper.h"
-#include "vtkVolumeProperty.h"
-
-#include <math.h>
-
-//-----------------------------------------------------------------------------
-vtkStandardNewMacro(vtkOSPRayPVLODVolume);
-
-//----------------------------------------------------------------------------
-vtkOSPRayPVLODVolume::vtkOSPRayPVLODVolume()
-{
-  this->LODProp = vtkLODProp3D::New();
-  this->LODProp->AutomaticLODSelectionOff();
-  this->LODProp->AutomaticPickLODSelectionOff();
-
-  this->HighLODId = -1;
-  this->LowLODId = -1;
-
-  this->MapperBounds[0] = this->MapperBounds[1] = this->MapperBounds[2] = 0;
-  this->MapperBounds[3] = this->MapperBounds[4] = this->MapperBounds[5] = 0;
-
-  this->EnableLOD = 0;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayPVLODVolume::~vtkOSPRayPVLODVolume()
-{
-  this->LODProp->Delete();
-}
-
-//----------------------------------------------------------------------------
-int vtkOSPRayPVLODVolume::SelectLOD()
-{
-  if (this->LowLODId < 0)
-    {
-    return this->HighLODId;
-    }
-  if (this->HighLODId < 0)
-    {
-    return this->LowLODId;
-    }
-
-  if (this->EnableLOD)
-    {
-    return this->LowLODId;
-    }
-
-  return this->HighLODId;
-}
-
-
-//-----------------------------------------------------------------------------
-bool vtkOSPRayPVLODVolume::CanRender()
-{
-  int lodid =this->LODProp->GetSelectedLODID();
-  if (lodid >= 0)
-    {
-    vtkAbstractMapper3D* mapper = this->LODProp->GetLODMapper(lodid);
-    if (vtkVolumeMapper* imageVolumeMapper = vtkVolumeMapper::SafeDownCast(mapper))
-      {
-      int unused = 0;
-      vtkDataSet* input = imageVolumeMapper->GetInput();
-      vtkDataArray* scalars = input == NULL? NULL :
-        vtkAbstractMapper::GetScalars(input,
-          imageVolumeMapper->GetScalarMode(),
-          imageVolumeMapper->GetArrayAccessMode(),
-          imageVolumeMapper->GetArrayId(),
-          imageVolumeMapper->GetArrayName(),
-          unused);
-      return scalars != NULL;
-      }
-    else if (vtkUnstructuredGridVolumeMapper* ugMapper = vtkUnstructuredGridVolumeMapper::SafeDownCast(mapper))
-      {
-      int unused = 0;
-      vtkDataSet* input = ugMapper->GetInput();
-      vtkDataArray* scalars = input == NULL? NULL :
-        vtkAbstractMapper::GetScalars(input,
-          ugMapper->GetScalarMode(),
-          ugMapper->GetArrayAccessMode(),
-          ugMapper->GetArrayId(),
-          ugMapper->GetArrayName(),
-          unused);
-      return scalars != NULL;
-      }
-    }
-  return true;
-}
-
-//-----------------------------------------------------------------------------
-int vtkOSPRayPVLODVolume::RenderOpaqueGeometry(vtkViewport *vp)
-{
-  if (!this->CanRender()) { return 1; }
-  int retval = this->LODProp->RenderOpaqueGeometry(vp);
-
-  this->EstimatedRenderTime = this->LODProp->GetEstimatedRenderTime();
-
-  return retval;
-}
-
-//-----------------------------------------------------------------------------
-int vtkOSPRayPVLODVolume::RenderTranslucentPolygonalGeometry(vtkViewport *vp)
-{
-  if (!this->CanRender()) { return 1; }
-  //std::cout << __PRETTY_FUNCTION__ << " 1" << std::endl;
-  int retval = this->LODProp->RenderTranslucentPolygonalGeometry(vp);
-
-  this->EstimatedRenderTime = this->LODProp->GetEstimatedRenderTime();
-
-  return retval;
-}
-
-
-//-----------------------------------------------------------------------------
-int vtkOSPRayPVLODVolume::RenderVolumetricGeometry(vtkViewport *vp)
-{
-  int retval = this->LODProp->RenderVolumetricGeometry(vp);
-
-  this->EstimatedRenderTime = this->LODProp->GetEstimatedRenderTime();
-
-  return retval;
-}
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::ReleaseGraphicsResources(vtkWindow *renWin)
-{
-  this->Superclass::ReleaseGraphicsResources(renWin);
-  this->LODProp->ReleaseGraphicsResources(renWin);
-}
-
-
-//-----------------------------------------------------------------------------
-// Get the bounds for this Actor as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax).
-double *vtkOSPRayPVLODVolume::GetBounds()
-{
-  int i,n;
-  double *bounds, bbox[24], *fptr;
-
-  int lod = this->SelectLOD();
-  if (lod < 0)
-    {
-    return this->Bounds;
-    }
-
-  vtkAbstractMapper3D *mapper = this->LODProp->GetLODMapper(lod);
-
-  vtkDebugMacro( << "Getting Bounds" );
-
-  // get the bounds of the Mapper if we have one
-  if (!mapper)
-    {
-    return this->Bounds;
-    }
-
-  bounds = mapper->GetBounds();
-  // Check for the special case when the mapper's bounds are unknown
-  if (!bounds)
-    {
-    return bounds;
-    }
-
-  // Check for the special case when the actor is empty.
-  if (bounds[0] > bounds[1])
-    {
-    memcpy( this->MapperBounds, bounds, 6*sizeof(double) );
-    vtkMath::UninitializeBounds(this->Bounds);
-    this->BoundsMTime.Modified();
-    return this->Bounds;
-    }
-
-  // Check if we have cached values for these bounds - we cache the
-  // values returned by this->Mapper->GetBounds() and we store the time
-  // of caching. If the values returned this time are different, or
-  // the modified time of this class is newer than the cached time,
-  // then we need to rebuild.
-  if ( ( memcmp( this->MapperBounds, bounds, 6*sizeof(double) ) != 0 ) ||
-       ( this->GetMTime() > this->BoundsMTime ) )
-    {
-    vtkDebugMacro( << "Recomputing bounds..." );
-
-    memcpy( this->MapperBounds, bounds, 6*sizeof(double) );
-
-    // fill out vertices of a bounding box
-    bbox[ 0] = bounds[1]; bbox[ 1] = bounds[3]; bbox[ 2] = bounds[5];
-    bbox[ 3] = bounds[1]; bbox[ 4] = bounds[2]; bbox[ 5] = bounds[5];
-    bbox[ 6] = bounds[0]; bbox[ 7] = bounds[2]; bbox[ 8] = bounds[5];
-    bbox[ 9] = bounds[0]; bbox[10] = bounds[3]; bbox[11] = bounds[5];
-    bbox[12] = bounds[1]; bbox[13] = bounds[3]; bbox[14] = bounds[4];
-    bbox[15] = bounds[1]; bbox[16] = bounds[2]; bbox[17] = bounds[4];
-    bbox[18] = bounds[0]; bbox[19] = bounds[2]; bbox[20] = bounds[4];
-    bbox[21] = bounds[0]; bbox[22] = bounds[3]; bbox[23] = bounds[4];
-
-    // save the old transform
-    this->Transform->Push();
-    this->Transform->SetMatrix(this->GetMatrix());
-
-    // and transform into actors coordinates
-    fptr = bbox;
-    for (n = 0; n < 8; n++)
-      {
-      this->Transform->TransformPoint(fptr,fptr);
-      fptr += 3;
-      }
-
-    this->Transform->Pop();
-
-    // now calc the new bounds
-    this->Bounds[0] = this->Bounds[2] = this->Bounds[4] = VTK_DOUBLE_MAX;
-    this->Bounds[1] = this->Bounds[3] = this->Bounds[5] = -VTK_DOUBLE_MAX;
-    for (i = 0; i < 8; i++)
-      {
-      for (n = 0; n < 3; n++)
-        {
-        if (bbox[i*3+n] < this->Bounds[n*2])
-          {
-          this->Bounds[n*2] = bbox[i*3+n];
-          }
-        if (bbox[i*3+n] > this->Bounds[n*2+1])
-          {
-          this->Bounds[n*2+1] = bbox[i*3+n];
-          }
-        }
-      }
-    this->BoundsMTime.Modified();
-    }
-
-  return this->Bounds;
-}
-
-
-//-----------------------------------------------------------------------------
-int vtkOSPRayPVLODVolume::HasTranslucentPolygonalGeometry()
-{
-  if (this->SelectLOD() == this->LowLODId)
-    {
-    return 1;
-    }
-  return 0;
-}
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::ShallowCopy(vtkProp *prop)
-{
-  vtkOSPRayPVLODVolume *a = vtkOSPRayPVLODVolume::SafeDownCast(prop);
-  if ( a != NULL )
-    {
-    this->LODProp->ShallowCopy(a->LODProp);
-    }
-
-  // Now do superclass
-  this->vtkVolume::ShallowCopy(prop);
-}
-
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::SetProperty(vtkVolumeProperty *property)
-{
-  this->Superclass::SetProperty(property);
-
-  this->UpdateLODProperty();
-}
-
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::SetMapper(vtkAbstractVolumeMapper *mapper)
-{
-  if (this->HighLODId >= 0)
-    {
-    if (mapper == this->LODProp->GetLODMapper(this->HighLODId)) return;
-    this->LODProp->RemoveLOD(this->HighLODId);
-    this->HighLODId = -1;
-    }
-
-  if (mapper)
-    {
-    this->HighLODId = this->LODProp->AddLOD(mapper, this->GetProperty(), 1.0);
-    this->UpdateLODProperty();
-    }
-}
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::SetLODMapper(vtkAbstractVolumeMapper *mapper)
-{
-  if (this->LowLODId >= 0)
-    {
-    if (mapper == this->LODProp->GetLODMapper(this->LowLODId)) return;
-    this->LODProp->RemoveLOD(this->LowLODId);
-    this->LowLODId = -1;
-    }
-
-  if (mapper)
-    {
-    this->LowLODId = this->LODProp->AddLOD(mapper, this->GetProperty(), 0.0);
-    this->UpdateLODProperty();
-    }
-}
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::SetLODMapper(vtkMapper *mapper)
-{
-  if (this->LowLODId >= 0)
-    {
-    if (mapper == this->LODProp->GetLODMapper(this->LowLODId)) return;
-    this->LODProp->RemoveLOD(this->LowLODId);
-    this->LowLODId = -1;
-    }
-
-  if (mapper)
-    {
-    vtkProperty *property = vtkProperty::New();
-    property->SetOpacity(0.5);
-    this->LowLODId = this->LODProp->AddLOD(mapper, property, 0.0);
-    property->Delete();
-    this->UpdateLODProperty();
-    }
-}
-
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::SetAllocatedRenderTime(double t, vtkViewport *v)
-{
-  this->Superclass::SetAllocatedRenderTime(t, v);
-
-  // This is a good time to update the LODProp.
-  this->LODProp->SetUserMatrix(this->GetMatrix());
-
-  int lod = this->SelectLOD();
-  if (lod < 0)
-    {
-    vtkErrorMacro(<< "You must give me a mapper!");
-    }
-  this->LODProp->SetSelectedLODID(lod);
-  this->LODProp->SetSelectedPickLODID(lod);
-
-  this->LODProp->SetAllocatedRenderTime(t, v);
-}
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::UpdateLODProperty()
-{
-  if (!this->Property)
-    {
-    vtkErrorMacro("No property is defined cannot update.");
-    return;
-    }
-
-  if (this->HighLODId >= 0)
-    {
-    this->LODProp->SetLODProperty(this->HighLODId, this->Property);
-    }
-
-  if (this->LowLODId >= 0)
-    {
-    vtkMapper *mapper;
-    this->LODProp->GetLODMapper(this->LowLODId, &mapper);
-    if (mapper)
-      {
-      }
-    else
-      {
-      // This is a volume mapper.  Just share the property.
-      this->LODProp->SetLODProperty(this->LowLODId, this->Property);
-      }
-    }
-}
-
-
-//----------------------------------------------------------------------------
-void vtkOSPRayPVLODVolume::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os,indent);
-
-  os << indent << "EnableLOD: " << this->EnableLOD << endl;
-  os << indent << "LODProp: " << endl;
-  this->LODProp->PrintSelf(os, indent.GetNextIndent());
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPVLODVolume.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPVLODVolume.h
deleted file mode 100755
index 83f58604d..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPVLODVolume.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/*=========================================================================
-
-  Program:   ParaView
-  Module:    vtkOSPRayPVLODVolume.h
-
-  Copyright (c) Kitware, Inc.
-  All rights reserved.
-  See Copyright.txt or http://www.paraview.org/HTML/Copyright.html for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-// .NAME vtkOSPRayPVLODVolume - an actor that supports multiple levels of detail
-// .SECTION Description
-// vtkOSPRayPVLODVolume is much like vtkPVLODActor except that it works on
-// volumes instead of surfaces.  This just has two mappers: full res and
-// LOD, and this actor knows which is which.
-
-// .SECTION see also
-// vtkActor vtkRenderer vtkLODProp3D vtkLODActor
-
-#ifndef __vtkOSPRayPVLODVolume_h
-#define __vtkOSPRayPVLODVolume_h
-
-#include "vtkVolume.h"
-#include "vtkPVVTKExtensionsRenderingModule.h" // needed for export macro
-
-class vtkLODProp3D;
-class vtkMapper;
-
-class VTKPVVTKEXTENSIONSRENDERING_EXPORT vtkOSPRayPVLODVolume : public vtkVolume
-{
-public:
-  vtkTypeMacro(vtkOSPRayPVLODVolume,vtkVolume);
-  void PrintSelf(ostream& os, vtkIndent indent);
-
-  static vtkOSPRayPVLODVolume *New();
-
-  // Description:
-  // This method is used internally by the rendering process.
-  virtual int RenderOpaqueGeometry(vtkViewport *viewport);
-  virtual int RenderVolumetricGeometry(vtkViewport *viewport);
-  virtual int RenderTranslucentPolygonalGeometry( vtkViewport *);
-
-  // Description:
-  // Does this prop have some translucent polygonal geometry?
-  virtual int HasTranslucentPolygonalGeometry();
-
-  // Description:
-  // Release any graphics resources that are being consumed by this actor.
-  // The parameter window could be used to determine which graphic
-  // resources to release.
-  virtual void ReleaseGraphicsResources(vtkWindow *);
-
-  // Description:
-  // Set the high res input.  Overloads the virtual vtkVolume method.
-  virtual void SetMapper(vtkAbstractVolumeMapper *);
-
-  // Description:
-  // This sets the low res input.
-  virtual void SetLODMapper(vtkAbstractVolumeMapper *);
-  virtual void SetLODMapper(vtkMapper *);
-
-  // Description:
-  // Sets the volume propery.  Overloads the virtual vtkVolume method.
-  virtual void SetProperty(vtkVolumeProperty *property);
-
-  // Description:
-  // Shallow copy of an LOD actor. Overloads the virtual vtkProp method.
-  virtual void ShallowCopy(vtkProp *prop);
-
-  // Description:
-  // Get the bounds of the current mapper.
-  virtual double *GetBounds();
-
-  // Description:
-  // Overloads the virtual vtkProp method.
-  virtual void SetAllocatedRenderTime(double t, vtkViewport *v);
-
-  // Description:
-  // When set, LODMapper, if present it used, otherwise the regular mapper is
-  // used.
-  vtkSetMacro(EnableLOD, int);
-  vtkGetMacro(EnableLOD, int);
-protected:
-  vtkOSPRayPVLODVolume();
-  ~vtkOSPRayPVLODVolume();
-
-  // Description:
-  // Since volume mapper are notorious for segfaulting when the scalar array is
-  // missing we use this method to validate that we can actually render the
-  // data.
-  bool CanRender();
-
-  vtkLODProp3D *LODProp;
-  int HighLODId;
-  int LowLODId;
-  int EnableLOD;
-  int SelectLOD();
-  double MapperBounds[6];
-  vtkTimeStamp BoundsMTime;
-  virtual void UpdateLODProperty();
-private:
-  vtkOSPRayPVLODVolume(const vtkOSPRayPVLODVolume&); // Not implemented.
-  void operator=(const vtkOSPRayPVLODVolume&); // Not implemented.
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.cxx
deleted file mode 100755
index beec2db66..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.cxx
+++ /dev/null
@@ -1,1018 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas
-   at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use
-   this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the
-   License at:
-
-http://opensource.org/licenses/BSD-3-Clause
-
-Unless required by applicable law or agreed to in writing, software
-distributed under
-the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
-CONDITIONS OF ANY
-KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under
-limitations under the License.
-
-pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules
-(PVLANL)
-Copyright (c) 2007, Los Alamos National Security, LLC
-=======================================================================================
-*/
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayActor.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayPolyDataMapper.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkOSPRayRenderer.h"
-#include "vtkOSPRayTexture.h"
-
-#include "vtkAppendPolyData.h"
-#include "vtkCellArray.h"
-#include "vtkCellData.h"
-#include "vtkCommand.h"
-#include "vtkDataArray.h"
-#include "vtkDoubleArray.h"
-#include "vtkFloatArray.h"
-#include "vtkGenericCell.h"
-#include "vtkGlyph3D.h"
-#include "vtkImageData.h"
-#include "vtkMatrix4x4.h"
-#include "vtkObjectFactory.h"
-#include "vtkPointData.h"
-#include "vtkPoints.h"
-#include "vtkPolyData.h"
-#include "vtkProperty.h"
-#include "vtkScalarsToColors.h"
-#include "vtkSphereSource.h"
-#include "vtkTransform.h"
-#include "vtkTubeFilter.h"
-#include "vtkUnsignedCharArray.h"
-
-#include "vtkInformation.h"
-#include "vtkInformationVector.h"
-
-#include <vector>
-
-#include <math.h>
-#include <algorithm>
-
-
-vtkStandardNewMacro(vtkOSPRayPolyDataMapper);
-
-namespace vtkosp {
-    class Vec3 {
-        public:
-            Vec3(float x, float y, float z) {
-                vals[0] = x;
-                vals[1] = y;
-                vals[2] = z;
-            }
-            float operator[](unsigned int i) const { return vals[i]; }
-            float x() { return vals[0]; }
-            float y() { return vals[1]; }
-            float z() { return vals[2]; }
-
-            float vals[3];
-    };
-    class Vec4 {
-        public:
-            Vec4(float x, float y, float z, float w) {
-                vals[0] = x;
-                vals[1] = y;
-                vals[2] = z;
-                vals[3] = w;
-            }
-            float operator[](unsigned int i) const { return vals[i]; }
-            float x() { return vals[0]; }
-            float y() { return vals[1]; }
-            float z() { return vals[2]; }
-            float w() { return vals[3]; }
-
-            float vals[4];
-    };
-    class Vec2 {
-        public:
-            Vec2(float x, float y) {
-                vals[0] = x;
-                vals[1] = y;
-            }
-            float operator[](unsigned int i) const { return vals[i]; }
-            float x() { return vals[0]; }
-            float y() { return vals[1]; }
-
-            float vals[2];
-    };
-    class Mesh {
-        public:
-            size_t size() { return vertex_indices.size() / 3; }
-            std::vector<size_t> vertex_indices;
-            std::vector<Vec3> vertices;
-            std::vector<Vec3> vertexNormals;
-            std::vector<Vec2> texCoords;
-            std::vector<size_t> texture_indices;
-            std::vector<size_t> normal_indices;
-            std::vector<Vec4> colors;
-            std::vector<ospray::vec3fa> wireframe_vertex;
-            std::vector<int> wireframe_index;
-            std::vector<ospray::vec3f> points_vertex;
-    };
-}
-
-int vtkOSPRayPolyDataMapper::timestep = 0;  // HACK!
-void* alignedMalloc(size_t size, size_t align=64)
-{
-    if (size == 0) return NULL;
-    char* base = (char*)malloc(size + align + sizeof(int));
-    if (base == NULL) throw std::bad_alloc();
-
-    char* unaligned = base + sizeof(int);
-    char*   aligned = unaligned + align - ((size_t)unaligned & (align - 1));
-    ((int*)aligned)[-1] = (int)((size_t)aligned - (size_t)base);
-    return aligned;
-}
-
-void alignedFree(const void* ptr) {
-    if (ptr == NULL) return;
-    int ofs = ((int*)ptr)[-1];
-    free((char*)ptr - ofs);
-}
-
-//----------------------------------------------------------------------------
-// Construct empty object.
-vtkOSPRayPolyDataMapper::vtkOSPRayPolyDataMapper() {
-    this->InternalColorTexture = NULL;
-    this->OSPRayManager = NULL;
-    this->PointSize = 1.0;
-    this->LineWidth = 1.0;
-    this->Representation = VTK_SURFACE;
-}
-
-//----------------------------------------------------------------------------
-// Destructor (don't call ReleaseGraphicsResources() since it is virtual
-vtkOSPRayPolyDataMapper::~vtkOSPRayPolyDataMapper() {
-    if (this->InternalColorTexture) {
-        this->InternalColorTexture->Delete();
-    }
-
-    if (this->OSPRayManager) {
-        this->OSPRayManager->Delete();
-    }
-
-}
-
-//----------------------------------------------------------------------------
-// Release the graphics resources used by this mapper.  In this case, release
-// the display list if any.
-void vtkOSPRayPolyDataMapper::ReleaseGraphicsResources(vtkWindow *win) {
-    this->Superclass::ReleaseGraphicsResources(win);
-
-    if (this->InternalColorTexture) {
-        this->InternalColorTexture->Delete();
-    }
-    this->InternalColorTexture = NULL;
-}
-
-//----------------------------------------------------------------------------
-// Receives from Actor -> maps data to primitives
-// called by Mapper->Render() (which is called by Actor->Render())
-void vtkOSPRayPolyDataMapper::RenderPiece(vtkRenderer *ren, vtkActor *act) {
-    vtkOSPRayRenderer *OSPRayRenderer = vtkOSPRayRenderer::SafeDownCast(ren);
-    if (!OSPRayRenderer) {
-        return;
-    }
-    if (!this->OSPRayManager) {
-        this->OSPRayManager = OSPRayRenderer->GetOSPRayManager();
-        this->OSPRayManager->Register(this);
-    }
-
-    // write geometry, first ask the pipeline to update data
-    vtkPolyData *input = this->GetInput();
-    if (input == NULL) {
-        vtkErrorMacro(<< "No input to vtkOSPRayPolyDataMapper!");
-        return;
-    } else {
-        this->InvokeEvent(vtkCommand::StartEvent, NULL);
-
-        // Static = 1:  this mapper does NOT need to propagate updates to other
-        // mappers
-        // down the pipeline and therefore saves the time that would be otherwise
-        // taken
-        if (!this->Static) {
-            this->Update();
-        }
-
-        this->InvokeEvent(vtkCommand::EndEvent, NULL);
-
-        vtkIdType numPts = input->GetNumberOfPoints();
-        if (numPts == 0) {
-            vtkDebugMacro(<< "No points from the input to vtkOSPRayPolyDataMapper!");
-            input = NULL;
-            return;
-        }
-    }
-
-    if (this->LookupTable == NULL) {
-        this->CreateDefaultLookupTable();
-    }
-
-    // For vertex coloring, this sets this->Colors as side effect.
-    // For texture map coloring, this sets ColorCoordinates
-    // and ColorTextureMap as a side effect.
-    this->MapScalars(act->GetProperty()->GetOpacity());
-
-    if (this->ColorTextureMap) {
-        if (!this->InternalColorTexture) {
-            this->InternalColorTexture = vtkOSPRayTexture::New();
-            this->InternalColorTexture->RepeatOff();
-        }
-        this->InternalColorTexture->SetInputData(this->ColorTextureMap);
-    }
-
-    // if something has changed, regenerate OSPRay primitives if required
-    if (this->GetMTime() > this->BuildTime ||
-            input->GetMTime() > this->BuildTime ||
-            act->GetProperty()->GetMTime() > this->BuildTime ||
-            act->GetMatrix()->GetMTime() > this->BuildTime) {
-
-        // If we are coloring by texture, then load the texture map.
-        // Use Map as indicator, because texture hangs around.
-        if (this->ColorTextureMap) {
-            this->InternalColorTexture->Load(ren, true);
-        }
-
-        this->Draw(ren, act);
-        this->BuildTime.Modified();
-    }
-
-    this->Update();
-    input = NULL;
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayPolyDataMapper::DrawPolygons(vtkPolyData *polys,
-        vtkPoints *ptarray,
-        vtkosp::Mesh *mesh
-        ) {
-
-    int total_triangles = 0;
-    vtkCellArray *cells = polys->GetPolys();
-    vtkIdType npts = 0, *index = 0, cellNum = 0;
-
-    switch (this->Representation) {
-        case VTK_POINTS: {
-                             double coord[3];
-                             for (cells->InitTraversal(); cells->GetNextCell(npts, index); cellNum++) {
-                                 ptarray->GetPoint(index[0], coord);
-                                 mesh->points_vertex.push_back
-                                     (ospray::vec3f(coord[0], coord[1], coord[2]));
-                                 for (vtkIdType i = 1; i < npts; i++) {
-
-                                     ptarray->GetPoint(index[i], coord);
-                                     mesh->points_vertex.push_back
-                                         (ospray::vec3f(coord[0], coord[1], coord[2]));
-                                 }
-                             }
-                         }  // VTK_POINTS;
-                         break;
-        case VTK_WIREFRAME: {
-                                double coord0[3];
-                                for (cells->InitTraversal(); cells->GetNextCell(npts, index); cellNum++) {
-                                    ptarray->GetPoint(index[0], coord0);
-                                    mesh->wireframe_vertex.push_back(
-                                            ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-                                    for (vtkIdType i = 1; i < npts; i++) {
-
-                                        mesh->wireframe_index.push_back(mesh->wireframe_vertex.size() - 1);
-                                        ptarray->GetPoint(index[i], coord0);
-                                        mesh->wireframe_vertex.push_back(
-                                                ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-                                    }
-                                }
-                            }  // VTK_WIREFRAME:
-                            break;
-        case VTK_SURFACE: {
-                              // write polygons with on the fly triangulation, assuming polygons are
-                              // simple and
-                              // can be triangulated into "fans"
-                              for (cells->InitTraversal(); cells->GetNextCell(npts, index); cellNum++) {
-                                  int triangle[3];
-
-                                  // the first triangle
-                                  triangle[0] = index[0];
-                                  triangle[1] = index[1];
-                                  triangle[2] = index[2];
-                                  mesh->vertex_indices.push_back(triangle[0]);
-                                  mesh->vertex_indices.push_back(triangle[1]);
-                                  mesh->vertex_indices.push_back(triangle[2]);
-
-                                  if (!mesh->vertexNormals.empty()) {
-                                      mesh->normal_indices.push_back(triangle[0]);
-                                      mesh->normal_indices.push_back(triangle[1]);
-                                      mesh->normal_indices.push_back(triangle[2]);
-                                  }
-
-                                  if (!mesh->texCoords.empty()) {
-                                      if (this->CellScalarColor) {
-                                          mesh->texture_indices.push_back(cellNum);
-                                          mesh->texture_indices.push_back(cellNum);
-                                          mesh->texture_indices.push_back(cellNum);
-                                      } else {
-                                          mesh->texture_indices.push_back(triangle[0]);
-                                          mesh->texture_indices.push_back(triangle[1]);
-                                          mesh->texture_indices.push_back(triangle[2]);
-                                      }
-                                  }
-                                  total_triangles++;
-
-                                  // the remaining triangles, of which
-                                  // each introduces a triangle after extraction
-                                  for (int i = 3; i < npts; i++) {
-                                      triangle[1] = triangle[2];
-                                      triangle[2] = index[i];
-                                      mesh->vertex_indices.push_back(triangle[0]);
-                                      mesh->vertex_indices.push_back(triangle[1]);
-                                      mesh->vertex_indices.push_back(triangle[2]);
-
-                                      if (!mesh->vertexNormals.empty()) {
-                                          mesh->normal_indices.push_back(triangle[0]);
-                                          mesh->normal_indices.push_back(triangle[1]);
-                                          mesh->normal_indices.push_back(triangle[2]);
-                                      }
-
-                                      if (!mesh->texCoords.empty()) {
-                                          if (this->CellScalarColor) {
-                                              mesh->texture_indices.push_back(cellNum);
-                                              mesh->texture_indices.push_back(cellNum);
-                                              mesh->texture_indices.push_back(cellNum);
-                                          } else {
-                                              mesh->texture_indices.push_back(triangle[0]);
-                                              mesh->texture_indices.push_back(triangle[1]);
-                                              mesh->texture_indices.push_back(triangle[2]);
-                                          }
-                                      }
-                                      total_triangles++;
-                                  }
-                              }
-
-                              for (int i = 0; i < total_triangles; i++) {
-                              }
-
-                              for (cells->InitTraversal();
-                                      this->Edges && cells->GetNextCell(npts, index); cellNum++) {
-                                  double coord0[3];
-                                  ptarray->GetPoint(index[0], coord0);
-                                  mesh->wireframe_vertex.push_back(
-                                          ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-                                  for (vtkIdType i = 1; i < npts; i++) {
-                                      mesh->wireframe_index.push_back(mesh->wireframe_vertex.size() - 1);
-                                      ptarray->GetPoint(index[i], coord0);
-                                      mesh->wireframe_vertex.push_back(
-                                              ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-                                  }
-                              }
-
-
-                          }  // VTK_SURFACE
-                          break;
-        default:
-                          std::cerr << "unknwon representation type\n";
-                          break;
-    }
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayPolyDataMapper::DrawTStrips(vtkPolyData *polys,
-        vtkPoints *ptarray,
-        vtkosp::Mesh *mesh)
-{
-
-    // total number of triangles
-    int total_triangles = 0;
-
-    vtkCellArray *cells = polys->GetStrips();
-    vtkIdType npts = 0, *index = 0, cellNum = 0;
-    ;
-
-    switch (this->Representation) {
-        case VTK_POINTS: {
-                             for (cells->InitTraversal(); cells->GetNextCell(npts, index); cellNum++) {
-                                 double coord[3];
-                                 for (int i = 0; i < npts; i++) {
-                                     ptarray->GetPoint(index[i], coord);
-                                 }
-                                 total_triangles++;
-                             }
-                         }  // VTK_POINTS;
-                         break;
-        case VTK_WIREFRAME: {
-                                double coord0[3];
-                                double coord1[3];
-                                double coord2[3];
-                                for (cells->InitTraversal(); cells->GetNextCell(npts, index); cellNum++) {
-                                    ptarray->GetPoint(index[0], coord0);
-                                    mesh->wireframe_vertex.push_back(
-                                            ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-                                    for (vtkIdType i = 2; i < npts; i++) {
-                                        mesh->wireframe_index.push_back(mesh->wireframe_vertex.size() - 1);
-                                        ptarray->GetPoint(index[0], coord0);
-                                        mesh->wireframe_vertex.push_back(
-                                                ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-                                    }
-                                }
-                            }  // VTK_WIREFRAME:
-                            break;
-        case VTK_SURFACE: {
-                              for (cells->InitTraversal(); cells->GetNextCell(npts, index); cellNum++) {
-                                  // count of the i-th triangle in a strip
-                                  int numtriangles2 = 0;
-
-                                  int triangle[3];
-                                  // the first triangle
-                                  triangle[0] = index[0];
-                                  triangle[1] = index[1];
-                                  triangle[2] = index[2];
-                                  mesh->vertex_indices.push_back(triangle[0]);
-                                  mesh->vertex_indices.push_back(triangle[1]);
-                                  mesh->vertex_indices.push_back(triangle[2]);
-
-                                  if (!mesh->vertexNormals.empty()) {
-                                      mesh->normal_indices.push_back(triangle[0]);
-                                      mesh->normal_indices.push_back(triangle[1]);
-                                      mesh->normal_indices.push_back(triangle[2]);
-                                  }
-
-                                  if (!mesh->texCoords.empty()) {
-                                      if (this->CellScalarColor) {
-                                          mesh->texture_indices.push_back(cellNum);
-                                          mesh->texture_indices.push_back(cellNum);
-                                          mesh->texture_indices.push_back(cellNum);
-                                      } else {
-                                          mesh->texture_indices.push_back(triangle[0]);
-                                          mesh->texture_indices.push_back(triangle[1]);
-                                          mesh->texture_indices.push_back(triangle[2]);
-                                      }
-                                  }
-
-                                  total_triangles++;
-                                  numtriangles2++;
-
-                                  // the rest of triangles
-                                  for (int i = 3; i < npts; i++) {
-                                      int tmp[3];
-                                      if (numtriangles2 % 2 == 1) {
-                                          // an odd triangle
-                                          tmp[0] = triangle[1];
-                                          tmp[1] = triangle[2];
-                                          tmp[2] = index[i];
-
-                                          triangle[0] = tmp[0];
-                                          triangle[1] = tmp[2];
-                                          triangle[2] = tmp[1];
-                                      } else {
-                                          // an even triangle
-                                          tmp[0] = triangle[1];
-                                          tmp[1] = triangle[2];
-                                          tmp[2] = index[i];
-
-                                          triangle[0] = tmp[1];
-                                          triangle[1] = tmp[0];
-                                          triangle[2] = tmp[2];
-                                      }
-
-                                      mesh->vertex_indices.push_back(triangle[0]);
-                                      mesh->vertex_indices.push_back(triangle[1]);
-                                      mesh->vertex_indices.push_back(triangle[2]);
-
-                                      if (!mesh->vertexNormals.empty()) {
-                                          mesh->normal_indices.push_back(triangle[0]);
-                                          mesh->normal_indices.push_back(triangle[1]);
-                                          mesh->normal_indices.push_back(triangle[2]);
-                                      }
-
-                                      if (!mesh->texCoords.empty()) {
-                                          if (this->CellScalarColor) {
-                                              mesh->texture_indices.push_back(cellNum);
-                                              mesh->texture_indices.push_back(cellNum);
-                                              mesh->texture_indices.push_back(cellNum);
-                                          } else {
-                                              mesh->texture_indices.push_back(triangle[0]);
-                                              mesh->texture_indices.push_back(triangle[1]);
-                                              mesh->texture_indices.push_back(triangle[2]);
-                                          }
-                                      }
-
-                                      total_triangles++;
-                                      numtriangles2++;
-                                  }
-                              }
-
-
-                          } break;
-
-        default:
-                          std::cerr << "unkown representation type\n";
-    }
-}
-
-void FindAllData(vtkPolyData *polydata) {
-
-    std::cout << "------------------------------------------------ " << std::endl;
-
-    std::cout << "Normals: " << polydata->GetPointData()->GetNormals()
-        << std::endl;
-
-    vtkIdType numberOfPointArrays = polydata->GetPointData()->GetNumberOfArrays();
-    std::cout << "Number of PointData arrays: " << numberOfPointArrays
-        << std::endl;
-
-    vtkIdType numberOfCellArrays = polydata->GetCellData()->GetNumberOfArrays();
-    std::cout << "Number of CellData arrays: " << numberOfCellArrays << std::endl;
-
-    std::cout << "Type table/key: " << std::endl;
-    ;
-    // more values can be found in <VTK_DIR>/Common/vtkSetGet.h
-    std::cout << VTK_UNSIGNED_CHAR << " unsigned char" << std::endl;
-    std::cout << VTK_UNSIGNED_INT << " unsigned int" << std::endl;
-    std::cout << VTK_FLOAT << " float" << std::endl;
-    std::cout << VTK_DOUBLE << " double" << std::endl;
-
-    for (vtkIdType i = 0; i < numberOfPointArrays; i++) {
-        int dataTypeID = polydata->GetPointData()->GetArray(i)->GetDataType();
-        int arrayTypeID = polydata->GetPointData()->IsArrayAnAttribute(i);
-        std::cout << "Array " << i << ": "
-            << polydata->GetPointData()->GetArrayName(i)
-            << " (type: " << dataTypeID << ")" << arrayTypeID << std::endl;
-    }
-
-    for (vtkIdType i = 0; i < numberOfCellArrays; i++) {
-        int dataTypeID = polydata->GetCellData()->GetArray(i)->GetDataType();
-        std::cout << "Array " << i << ": "
-            << polydata->GetCellData()->GetArrayName(i)
-            << " (type: " << dataTypeID << ")" << std::endl;
-    }
-    std::cout << "------------------------------------------------ " << std::endl;
-}
-
-//----------------------------------------------------------------------------
-// Draw method for OSPRay.
-void vtkOSPRayPolyDataMapper::Draw(vtkRenderer *renderer, vtkActor *actor) {
-    vtkOSPRayActor *OSPRayActor = vtkOSPRayActor::SafeDownCast(actor);
-    if (!OSPRayActor) {
-        return;
-    }
-    vtkOSPRayProperty *OSPRayProperty =
-        vtkOSPRayProperty::SafeDownCast(OSPRayActor->GetProperty());
-    if (!OSPRayProperty) {
-        return;
-    }
-    vtkOSPRayRenderer *OSPRayRenderer = vtkOSPRayRenderer::SafeDownCast(renderer);
-
-    vtkPolyData *input = this->GetInput();
-
-    vtkInformation *inputInfo = this->GetInput()->GetInformation();
-    // std::cout << __PRETTY_FUNCTION__ << " (" << this << ") " << "actor: (" <<
-    // OSPRayActor << ") mode: (" << OSPRayActor->OSPRayModel << ") " << std::endl;
-
-
-    // if (inputInfo && inputInfo->Has(vtkDataObject::DATA_TIME_STEP())) {
-    //   double time = inputInfo->Get(vtkDataObject::DATA_TIME_STEP());
-    //   timestep = time;
-    //   if (OSPRayActor->cache[time] != NULL) {
-
-    //     OSPRayActor->OSPRayModel = OSPRayActor->cache[time];
-    //     return;
-
-    //   }
-
-    // } else if (!inputInfo) {
-    // } else {
-    //   if (OSPRayActor->cache[timestep] != NULL) {
-    //   }
-    // }
-    OSPRayActor->MeshMTime.Modified();
-
-    // Compute we need to for color
-    this->Representation = OSPRayProperty->GetRepresentation();
-    this->Edges = OSPRayProperty->GetEdgeVisibility();
-
-    this->CellScalarColor = false;
-    if ((this->ScalarMode == VTK_SCALAR_MODE_USE_CELL_DATA ||
-                this->ScalarMode == VTK_SCALAR_MODE_USE_CELL_FIELD_DATA ||
-                this->ScalarMode == VTK_SCALAR_MODE_USE_FIELD_DATA ||
-                !input->GetPointData()->GetScalars()) &&
-            this->ScalarMode != VTK_SCALAR_MODE_USE_POINT_FIELD_DATA) {
-        this->CellScalarColor = true;
-    }
-
-    OSPMaterial ospMaterial = NULL;
-    vtkosp::Mesh *mesh = new vtkosp::Mesh();
-
-    // force create a new material every time this is called in case the renderer
-    // has changed
-    osp::Material *osmat = 0;
-    if (!osmat) {
-        OSPRayProperty->CreateOSPRayProperty();
-        ospMaterial = ((OSPMaterial)OSPRayProperty->GetOSPRayMaterial());
-    } else
-        ospMaterial = ((OSPMaterial)osmat);
-
-    if (!this->ScalarVisibility || (!this->Colors && !this->ColorCoordinates)) {
-
-    } else if (this->Colors) {
-        if (OSPRayProperty->GetInterpolation() == VTK_FLAT) {
-        } else {
-            if (OSPRayProperty->GetOpacity() < 1.0) {
-            } else {
-                if (OSPRayProperty->GetSpecular() == 0) {
-                } else {
-                }
-            }
-        }
-
-        for (int i = 0; i < this->Colors->GetNumberOfTuples(); i++) {
-            unsigned char *color = this->Colors->GetPointer(4 * i);
-            mesh->colors.push_back(vtkosp::Vec4(color[0] / 255.0, color[1] / 255.0,
-                        color[2] / 255.0, 1));
-        }
-
-    } else if (this->ColorCoordinates) {
-        osp::Texture2D *texture = this->InternalColorTexture->GetOSPRayTexture();
-        Assert(texture);
-        ospSetObject(ospMaterial, "map_Kd", ((OSPTexture2D)(texture)));
-        ospCommit(ospMaterial);
-
-        for (int i = 0; i < this->ColorCoordinates->GetNumberOfTuples(); i++) {
-            double *tcoord = this->ColorCoordinates->GetTuple(i);
-            if (tcoord[0] >= 1.0) tcoord[0] = 0.99999;  // avoid sampling texture at 1
-            mesh->texCoords.push_back(vtkosp::Vec2(tcoord[0], tcoord[1]));
-        }
-
-    } else if (input->GetPointData()->GetTCoords() && actor->GetTexture()) {
-        vtkOSPRayTexture *osprayTexture =
-            vtkOSPRayTexture::SafeDownCast(actor->GetTexture());
-        if (osprayTexture) {
-            ospSetObject(ospMaterial, "map_Kd",
-                    ((OSPTexture2D)(osprayTexture->GetOSPRayTexture())));
-            ospCommit(ospMaterial);
-        }
-
-        vtkDataArray *tcoords = input->GetPointData()->GetTCoords();
-        for (int i = 0; i < tcoords->GetNumberOfTuples(); i++) {
-            double *tcoord = tcoords->GetTuple(i);
-            if (tcoord[0] >= 1.0) tcoord[0] = 0.99999;  // avoid sampling texture at 1
-            mesh->texCoords.push_back(vtkosp::Vec2(tcoord[0], tcoord[1]));
-        }
-    }
-
-    // transform point coordinates according to actor's transformation matrix
-    vtkTransform *transform = vtkTransform::New();
-    transform->SetMatrix(actor->GetMatrix());
-    vtkPoints *points = vtkPoints::New();
-    transform->TransformPoints(input->GetPoints(), points);
-
-    // obtain the OpenGL-based point size and line width
-    // that are specified through vtkProperty
-    this->PointSize = OSPRayProperty->GetPointSize();
-    this->LineWidth = OSPRayProperty->GetLineWidth();
-    if (this->PointSize < 0.0) {
-        this->PointSize = 1.0;
-    }
-    if (this->LineWidth < 0.0) {
-        this->LineWidth = 1.0;
-    }
-    this->PointSize = sqrt(this->PointSize) * 0.010;
-    this->LineWidth = sqrt(this->LineWidth) * 0.005;
-
-    // convert VTK_VERTEX cells to OSPRay spheres
-    if (input->GetNumberOfVerts() > 0) {
-        vtkCellArray *ca = input->GetVerts();
-        ca->InitTraversal();
-        vtkIdType npts;
-        vtkIdType *pts;
-        vtkPoints *ptarray = points;
-        double coord[3];
-        vtkIdType cell;
-        vtkIdType point;
-        while ((cell = ca->GetNextCell(npts, pts)))
-        {
-            for (int p = 0; p < npts; p++)
-            {
-                point = pts[p];
-                ptarray->GetPoint(point, coord);
-                mesh->points_vertex.push_back
-                    (ospray::vec3f(coord[0], coord[1], coord[2]));
-            }
-        }
-    }
-
-    std::vector<ospray::vec3fa> slVertex;
-    std::vector<ospray::vec3fa> slColors;
-    std::vector<int> slIndex;
-    float slRadius;
-
-    // convert VTK_LINE type cells to OSPRay cylinders
-    if (input->GetNumberOfLines() > 0) {
-        vtkCellArray *ca = input->GetLines();
-        ca->InitTraversal();
-        vtkIdType npts;
-        vtkIdType *pts;
-        vtkPoints *ptarray = points;
-        std::vector<ospray::vec3fa> tmpColors;
-        int scalarSize = ptarray->GetNumberOfPoints();
-        double coord0[3];
-        vtkIdType cell;
-
-        vtkScalarsToColors *vstc = GetLookupTable();
-        vtkDataArray *scalar = input->GetPointData()->GetScalars(NULL);
-        if (scalar) {
-            int vectorSize = (scalar) ? scalar->GetNumberOfComponents() : 0;
-            unsigned char *output = new unsigned char[scalarSize * 4];
-            vstc->SetVectorModeToMagnitude();
-            vstc->MapVectorsThroughTable(scalar->GetVoidPointer(0), output,
-                    scalar->GetDataType(), scalarSize,
-                    vectorSize, VTK_RGBA);
-            for (int ii = 0; ii < scalarSize; ii++) {
-                double color[3];
-                for (int jj = 0; jj < 3; jj++) {
-                    color[jj] = float(output[ii * 4 + jj]) / 255.0;
-                }
-                tmpColors.push_back(ospray::vec3fa(color[0], color[1], color[2]));
-            }
-        } else if (vstc) {
-
-            if (this->ColorCoordinates) {
-                //std::cout << "Tex coords " << this->ColorCoordinates->GetSize() << std::endl;
-                double* minmax = vstc->GetRange();
-                //std::cout << "m: " << minmax[0] << " M:" << minmax[1] << std::endl;
-
-                double scale = minmax[1] - minmax[0];
-
-                for (int i = 0; i < scalarSize; i++) {
-                    double *tcoord = this->ColorCoordinates->GetTuple(i);
-                    double *color = vstc->GetColor((tcoord[0] * scale) + minmax[0]);
-                    tmpColors.push_back(ospray::vec3fa(color[0], color[1], color[2]));
-                }
-
-            } else {
-                double solidColor[3];
-                OSPRayProperty->GetDiffuseColor(solidColor);
-                for (int i = 0; i < scalarSize; i++) {
-                    tmpColors.push_back(
-                            ospray::vec3fa(solidColor[0], solidColor[1], solidColor[2]));
-                }
-            }
-        }
-
-        std::vector<ospray::vec3fa> tmpPoints;
-        for (int ii = 0; ii < ptarray->GetNumberOfPoints(); ii++) {
-            ptarray->GetPoint(ii, coord0);
-            tmpPoints.push_back(ospray::vec3fa(coord0[0], coord0[1], coord0[2]));
-        }
-
-        slRadius = this->LineWidth / 0.005;
-
-        while ((cell = ca->GetNextCell(npts, pts))) {
-            if (npts <= 2) continue;
-            slVertex.push_back(tmpPoints[pts[0]]);
-            slColors.push_back(tmpColors[pts[0]]);
-            for (vtkIdType i = 1; i < npts; i++) {
-                slIndex.push_back(slVertex.size() - 1);
-                slVertex.push_back(tmpPoints[pts[i]]);
-                slColors.push_back(tmpColors[pts[i]]);
-            }
-        }
-
-    }
-
-    // convert coordinates to OSPRay format
-    for (int i = 0; i < points->GetNumberOfPoints(); i++) {
-        double *pos = points->GetPoint(i);
-        bool wasNan = false;
-        int fixIndex = i - 1;
-        do {
-            wasNan = false;
-            for (int j = 0; j < 3; j++) {
-                if (std::isnan(pos[j])) {
-                    wasNan = true;
-                }
-            }
-            if (wasNan && fixIndex >= 0) pos = points->GetPoint(fixIndex--);
-        } while (wasNan == true && fixIndex >= 0);
-        mesh->vertices.push_back(vtkosp::Vec3(pos[0], pos[1], pos[2]));
-    }
-
-    // Do flat shading by not supplying vertex normals to OSPRay
-    if (OSPRayProperty->GetInterpolation() != VTK_FLAT) {
-        vtkPointData *pointData = input->GetPointData();
-        if (pointData->GetNormals()) {
-            vtkDataArray *normals = vtkFloatArray::New();
-            normals->SetNumberOfComponents(3);
-            transform->TransformNormals(pointData->GetNormals(), normals);
-            for (int i = 0; i < normals->GetNumberOfTuples(); i++) {
-                double *normal = normals->GetTuple(i);
-                mesh->vertexNormals.push_back(
-                        vtkosp::Vec3(normal[0], normal[1], normal[2]));
-            }
-            normals->Delete();
-        }
-    }
-
-
-    // convert polygons to OSPRay format
-    if (input->GetNumberOfPolys() > 0) {
-        this->DrawPolygons(input, points, mesh /*, sphereGroup, tubeGroup*/);
-    }
-
-    // convert triangle strips to OSPRay format
-    if (input->GetNumberOfStrips() > 0) {
-        this->DrawTStrips(input, points, mesh /*, sphereGroup, tubeGroup*/);
-    }
-
-    // delete transformed point coordinates
-    transform->Delete();
-    points->Delete();
-
-    if (mesh->size() ||
-            mesh->wireframe_vertex.size() ||
-            slVertex.size() ||
-            mesh->points_vertex.size()) {
-        //
-        // ospray
-        //
-        OSPRenderer renderer = ((OSPRenderer) this->OSPRayManager->OSPRayRenderer);
-        // OSPRayActor->OSPRayModel = ospNewModel();
-        //TODO: There should be a better way to clear geometries than to remake model
-        // printf("actor frame: %d renderer frame: %d\n", OSPRayActor->GetLastFrame(),OSPRayRenderer->GetFrame());
-        if (OSPRayActor->GetLastFrame() < OSPRayRenderer->GetFrame())
-        {
-            // printf("new actor model\n");
-            OSPRayActor->OSPRayModel = ospNewModel();
-            OSPRayActor->LastFrame = OSPRayRenderer->GetFrame();
-        }
-
-        if (mesh->size() && !mesh->points_vertex.size()) {
-
-            size_t numNormals = mesh->vertexNormals.size();
-            size_t numTexCoords = mesh->texCoords.size();
-            size_t numPositions = mesh->vertices.size();
-            size_t numTriangles = mesh->vertex_indices.size() / 3;
-
-            // printf("building mesh with numTriangles %d\n", numTriangles);
-
-
-            ospray::vec3fa *vertices = (ospray::vec3fa *)alignedMalloc(
-                    sizeof(ospray::vec3fa) * numPositions);
-            ospray::vec3i *triangles = (ospray::vec3i *)alignedMalloc(
-                    sizeof(ospray::vec3i) * numTriangles);
-            ospray::vec3fa *normals = (ospray::vec3fa *)alignedMalloc(
-                    sizeof(ospray::vec3fa) * numNormals);
-
-            for (size_t i = 0; i < numPositions; i++) {
-                vertices[i] =
-                    ospray::vec3fa(mesh->vertices[i].x(), mesh->vertices[i].y(),
-                            mesh->vertices[i].z());
-            }
-            for (size_t i = 0, mi = 0; i < numTriangles; i++, mi += 3) {
-                triangles[i] = embree::Vec3i(mesh->vertex_indices[mi + 0],
-                        mesh->vertex_indices[mi + 1],
-                        mesh->vertex_indices[mi + 2]);
-            }
-
-            for (size_t i = 0; i < numNormals; i++) {
-                normals[i] = ospray::vec3fa(mesh->vertexNormals[i].x(),
-                        mesh->vertexNormals[i].y(),
-                        mesh->vertexNormals[i].z());
-            }
-
-            OSPGeometry ospMesh = ospNewTriangleMesh();
-            OSPData position = ospNewData(numPositions, OSP_FLOAT3A, &vertices[0]);
-            ospSetData(ospMesh, "position", position);
-
-            if (!mesh->normal_indices.empty()) {
-                OSPData normal =
-                    ospNewData(mesh->vertexNormals.size(), OSP_FLOAT3A, &normals[0]);
-                ospSetData(ospMesh, "vertex.normal", normal);
-            }
-
-            OSPData index = ospNewData(numTriangles, OSP_INT3, &triangles[0]);
-            ospSetData(ospMesh, "index", index);
-
-            if (!mesh->texCoords.empty()) {
-                OSPData texcoord =
-                    ospNewData(mesh->texCoords.size(), OSP_FLOAT2, &mesh->texCoords[0]);
-                assert(mesh->texCoords.size() > 0);
-                ospSetData(ospMesh, "vertex.texcoord", texcoord);
-            }
-            if (!mesh->colors.empty()) {
-                // note: to share data use OSP_DATA_SHARED_BUFFER
-                OSPData colors =
-                    ospNewData(mesh->colors.size(), OSP_FLOAT4, &mesh->colors[0]);
-                ospSetData(ospMesh, "vertex.color", colors);
-            }
-
-            if (!ospMaterial) {
-                OSPRayProperty->CreateOSPRayProperty();
-                ospMaterial = ((OSPMaterial)OSPRayProperty->GetOSPRayMaterial());
-            }
-
-            ospSetMaterial(ospMesh, ospMaterial);
-            ospCommit(ospMesh);
-
-            ospAddGeometry(OSPRayActor->OSPRayModel, ospMesh);
-
-        }
-
-        if (mesh->points_vertex.size()) {
-            double Color[3];
-            OSPRayProperty->GetColor(Color);
-            OSPMaterial pointMat = ospNewMaterial(renderer, "default");
-            if (pointMat) {
-                ospSet3f(pointMat, "kd", Color[0], Color[1], Color[2]);
-                ospCommit(pointMat);
-            }
-            OSPGeometry ospMesh = ospNewGeometry("spheres");
-            OSPData vertex = ospNewData(mesh->points_vertex.size(), OSP_FLOAT3,
-                    &mesh->points_vertex[0]);
-            ospSetObject(ospMesh, "spheres", vertex);
-            ospSet1i(ospMesh, "bytes_per_sphere", 3*sizeof(float));
-            ospSet1i(ospMesh, "offset_center", 0*sizeof(float));
-            ospSet1i(ospMesh, "offset_radius", -1);//3*sizeof(float));
-            ospSet1f(ospMesh, "radius", this->PointSize);
-            ospSet1i(ospMesh, "offset_materialID", -1);
-            ospSet1i(ospMesh, "materialID", 0);
-            ospAddGeometry(OSPRayActor->OSPRayModel, ospMesh);
-            if (pointMat)
-            {
-                ospSetMaterial(ospMesh, pointMat);
-            }
-            ospCommit(vertex);
-            ospCommit(ospMesh);
-            ospRelease(vertex);
-            ospRelease(ospMesh);
-        }
-
-        if (mesh->wireframe_vertex.size()) {
-            double edgeColor[3];
-            OSPRayProperty->GetEdgeColor(edgeColor);
-            OSPMaterial wireMat = ospNewMaterial(renderer, "default");
-            if (wireMat) {
-                ospSet3f(wireMat, "kd", edgeColor[0], edgeColor[1], edgeColor[2]);
-                ospCommit(wireMat);
-            }
-            OSPGeometry wireGeometry = ospNewGeometry("streamlines");
-            Assert(wireGeometry);
-            OSPData vertex = ospNewData(mesh->wireframe_vertex.size(), OSP_FLOAT3A,
-                    &mesh->wireframe_vertex[0]);
-            OSPData index = ospNewData(mesh->wireframe_index.size(), OSP_INT,
-                    &mesh->wireframe_index[0]);
-            ospSetObject(wireGeometry, "vertex", vertex);
-            ospSetObject(wireGeometry, "index", index);
-            ospSet1f(wireGeometry, "radius", this->LineWidth);
-
-            if (wireMat) ospSetMaterial(wireGeometry, wireMat);
-
-            ospCommit(wireGeometry);
-            ospAddGeometry(OSPRayActor->OSPRayModel, wireGeometry);
-        }
-
-        if (slVertex.size()) {
-            double solidColor[3];
-            OSPGeometry slGeometry = ospNewGeometry("streamlines");
-            Assert(slGeometry);
-            OSPData vertex = ospNewData(slVertex.size(), OSP_FLOAT3A, &slVertex[0]);
-            OSPData color = ospNewData(slColors.size(), OSP_FLOAT3A, &slColors[0]);
-            OSPData index = ospNewData(slIndex.size(), OSP_INT, &slIndex[0]);
-            ospSetObject(slGeometry, "vertex", vertex);
-            ospSetObject(slGeometry, "vertex.color", color);
-            ospSetObject(slGeometry, "index", index);
-            ospSet1f(slGeometry, "radius", slRadius);
-            ospCommit(slGeometry);
-            ospAddGeometry(OSPRayActor->OSPRayModel, slGeometry);
-
-        }
-
-        ospCommit(OSPRayActor->OSPRayModel);
-        if (inputInfo && inputInfo->Has(vtkDataObject::DATA_TIME_STEP())) {
-            double time = inputInfo->Get(vtkDataObject::DATA_TIME_STEP());
-            OSPRayActor->cache[time] = OSPRayActor->OSPRayModel;
-        } else {
-            OSPRayActor->cache[timestep] = OSPRayActor->OSPRayModel;
-        }
-
-    } else {
-        delete mesh;
-    }
-
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.h
deleted file mode 100755
index 3678475ed..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayPolyDataMapper.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayPolyDataMapper -
-// .SECTION Description
-//
-// .NAME vtkOSPRayPolyDataMapper - a PolyDataMapper for the OSPRay library
-// .SECTION Description
-// vtkOSPRayPolyDataMapper is a subclass of vtkPolyDataMapper.
-// vtkOSPRayPolyDataMapper is a geometric PolyDataMapper for the OSPRay
-// Raytracer library.
-
-#ifndef __vtkOSPRayPolyDataMapper_h
-#define __vtkOSPRayPolyDataMapper_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkPolyDataMapper.h"
-#include "vtkOSPRayTexture.h"
-
-#include <map>
-
-class vtkSphereSource;
-class vtkGlyph3D;
-class vtkTubeFilter;
-class vtkAppendPolyData;
-
-//BTX
-namespace OSPRay {
-class Mesh;
-class Group;
-}
-//ETX
-class vtkCellArray;
-class vtkPoints;
-class vtkProperty;
-class vtkRenderWindow;
-class vtkOSPRayRenderer;
-class vtkOSPRayManager;
-
-namespace vtkosp
-{
-  class Mesh;
-}
-namespace osp
-{
-  class Model;
-}
-
-class VTKOSPRAY_EXPORT vtkOSPRayPolyDataMapper : public vtkPolyDataMapper
-{
-public:
-  static vtkOSPRayPolyDataMapper *New();
-  vtkTypeMacro(vtkOSPRayPolyDataMapper,vtkPolyDataMapper);
-
-  // Description:
-  // Implement superclass render method.
-  virtual void RenderPiece(vtkRenderer *ren, vtkActor *a);
-
-  // Description:
-  // Release any graphics resources that are being consumed by this mapper.
-  // The parameter window could be used to determine which graphic
-  // resources to release.
-  void ReleaseGraphicsResources(vtkWindow *);
-
-  // Description:
-  // Draw method for OSPRay.
-  virtual void Draw(vtkRenderer *ren, vtkActor *a);
-
-protected:
-  vtkOSPRayPolyDataMapper();
-  ~vtkOSPRayPolyDataMapper();
-
-  //BTX
-  void DrawPolygons(vtkPolyData *, vtkPoints *,
-                    vtkosp::Mesh * );
-  void DrawTStrips(vtkPolyData *, vtkPoints *,
-                    vtkosp::Mesh* );
-  //ETX
-
-private:
-  vtkOSPRayPolyDataMapper(const vtkOSPRayPolyDataMapper&); // Not implemented.
-  void operator=(const vtkOSPRayPolyDataMapper&); // Not implemented.
-
-  vtkOSPRayManager *OSPRayManager;
-
-  vtkOSPRayTexture* InternalColorTexture;
-  int Representation;
-  int Edges;
-  double PointSize;
-  double LineWidth;
-  std::map<int, osp::Model*> cache;
-  bool CellScalarColor;
-  static int timestep;
-//BTX
-  class Helper;
-  Helper *MyHelper;
-//ETX
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayProperty.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayProperty.cxx
deleted file mode 100755
index efd77e425..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayProperty.cxx
+++ /dev/null
@@ -1,138 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkOSPRayRenderer.h"
-
-#include "vtkObjectFactory.h"
-
-
-#include <cstring>
-
-
-
-
-vtkStandardNewMacro(vtkOSPRayProperty);
-
-//----------------------------------------------------------------------------
-vtkOSPRayProperty::vtkOSPRayProperty()
-{
-  this->MaterialType = NULL;
-  this->SetMaterialType("default");
-  this->OSPRayManager = NULL;
-  this->OSPRayMaterial= NULL;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayProperty::~vtkOSPRayProperty()
-{
-  if (this->OSPRayManager)
-  {
-    this->OSPRayManager->Delete();
-  }
-  delete[] this->MaterialType;
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayProperty::PrintSelf( ostream & os, vtkIndent indent )
-{
-  this->Superclass::PrintSelf( os, indent );
-}
-
-//------------------------------------------------------------------------------
-void vtkOSPRayProperty::ReleaseGraphicsResources(vtkWindow *win)
-{
-  this->Superclass::ReleaseGraphicsResources(win);
-  if (!this->OSPRayManager)
-  {
-    return;
-  }
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayProperty::Render( vtkActor *vtkNotUsed(anActor),
- vtkRenderer * ren)
-{
-  vtkOSPRayRenderer * OSPRayRenderer = vtkOSPRayRenderer::SafeDownCast( ren );
-  if (!OSPRayRenderer)
-  {
-    return;
-  }
-  if (!this->OSPRayManager)
-  {
-    this->OSPRayManager = OSPRayRenderer->GetOSPRayManager();
-    this->OSPRayManager->Register(this);
-  }
-
-  double * diffuse  = this->GetDiffuseColor();
-
-
-  if ( this->GetMTime() > this->OSPRayMaterialMTime )
-  {
-      CreateOSPRayProperty();
-    this->OSPRayMaterialMTime.Modified();
-  }
-
-}
-
-//----------------------------------------------------------------------------
-// Implement base class method.
-void vtkOSPRayProperty::BackfaceRender( vtkActor * vtkNotUsed( anActor ),
- vtkRenderer * vtkNotUsed( ren ) )
-{
-  cerr
-  << "vtkOSPRayProperty::BackfaceRender(), backface rendering "
-  << "is not supported by OSPRay"
-  << endl;
-}
-
-
-//----------------------------------------------------------------------------
-void vtkOSPRayProperty::CreateOSPRayProperty()
-{
-
-  double * diffuse  = this->GetDiffuseColor();
-  double * specular = this->GetSpecularColor();
-
-
-
-          OSPRenderer renderer = ((OSPRenderer)this->OSPRayManager->OSPRayRenderer);
-
-          this->OSPRayMaterial = ospNewMaterial(renderer,"OBJMaterial");
-          OSPMaterial oMaterial = (OSPMaterial)this->OSPRayMaterial;
-          Assert(oMaterial);
-          float diffusef[] = {(float)diffuse[0], (float)diffuse[1], (float)diffuse[2]};
-          float specularf[] = {(float)specular[0],(float)specular[1],(float)specular[2]};
-          ospSet3fv(oMaterial,"Kd",diffusef);
-          ospSet3fv(oMaterial,"Ks",specularf);
-          ospSet1f(oMaterial,"Ns",float(this->GetSpecularPower()*.5));
-          ospSet1f(oMaterial,"d", float(this->GetOpacity()));
-
-          ospCommit(oMaterial);
-
-
-
-  }
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayProperty.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayProperty.h
deleted file mode 100755
index 5ab2b76c3..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayProperty.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOpenProperty - OSPRay property
-// .SECTION Description
-// vtkOSPRayProperty is a concrete implementation of the abstract class
-// vtkProperty. vtkOSPRayProperty interfaces to the OSPRay Raytracer library.
-
-#ifndef __vtkOSPRayProperty_h
-#define __vtkOSPRayProperty_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkProperty.h"
-
-//BTX
-namespace OSPRay {
-  class Material;
-}
-//ETX
-
-namespace osp
-{
-  class Material;
-  class OSPTexture2D;
-}
-
-class vtkOSPRayRenderer;
-class vtkOSPRayManager;
-
-class VTKOSPRAY_EXPORT vtkOSPRayProperty : public vtkProperty
-{
-public:
-  static vtkOSPRayProperty *New();
-  vtkTypeMacro(vtkOSPRayProperty,vtkProperty) ;
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-
-  // Description:
-  // Implement base class method.
-  void Render(vtkActor *a, vtkRenderer *ren);
-
-  // Description:
-  // Implement base class method.
-  void BackfaceRender(vtkActor *a, vtkRenderer *ren);
-
-  // Description:
-  // Release any graphics resources that are being consumed by this
-  // property. The parameter window could be used to determine which graphic
-  // resources to release.
-  virtual void ReleaseGraphicsResources(vtkWindow *win);
-
-  // functions that change parameters of various materials
-  vtkSetStringMacro(MaterialType);
-  vtkGetStringMacro(MaterialType);
-  vtkSetMacro(Reflectance, float);
-  vtkGetMacro(Reflectance, float);
-  vtkSetMacro(Eta, float);
-  vtkGetMacro(Eta, float);
-  vtkSetMacro(Thickness, float);
-  vtkGetMacro(Thickness, float);
-  vtkSetMacro(N, float);
-  vtkGetMacro(N, float);
-  vtkSetMacro(Nt, float);
-  vtkGetMacro(Nt, float);
-    vtkSetMacro(OSPRayMaterial, osp::Material*);
-  vtkGetMacro(OSPRayMaterial, osp::Material*);
-
-  //Description:
-  //Internal callbacks for OSPRay thread use.
-  //Do not call them directly.
-  void CreateOSPRayProperty();
-
-protected:
-  vtkOSPRayProperty();
-  ~vtkOSPRayProperty();
-
-private:
-  vtkOSPRayProperty(const vtkOSPRayProperty&);  // Not implemented.
-  void operator=(const vtkOSPRayProperty&);  // Not implemented.
-
-  // the last time OSPRayMaterial is modified
-  vtkTimeStamp OSPRayMaterialMTime;
-
-  osp::OSPTexture2D* DiffuseTexture;
-
-  // type of material to use. possible values are: "lambertian", "phong",
-  // "transparent", "thindielectric", "dielectric", "metal", "orennayer"
-  char * MaterialType;
-
-  // amount of reflection to use. should be between 0.0 and 1.0
-  float Reflectance;
-
-  // the index of refraction for a material. used with the thin dielectric
-  // material
-  float Eta;
-
-  // how thick the material is. used with the thin dielectric material
-  float Thickness;
-
-  // index of refraction for outside material. used in dielectric material
-  float N;
-
-  // index of refraction for inside material (transmissive). used in
-  // dielectric material
-  float Nt;
-
-  vtkOSPRayManager *OSPRayManager;
-  osp::Material* OSPRayMaterial;
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderable.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderable.cxx
deleted file mode 100755
index 986e7d926..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderable.cxx
+++ /dev/null
@@ -1 +0,0 @@
-#include "vtkOSPRayRenderable.h"
\ No newline at end of file
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderable.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderable.h
deleted file mode 100755
index b7256129a..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderable.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* =======================================================================================
-Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-All rights reserved.
-
-Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-except in compliance with the License.
-A copy of the License is included with this software in the file LICENSE.
-If your copy does not contain the License, you may obtain a copy of the License at:
-
-http://opensource.org/licenses/BSD-3-Clause
-
-Unless required by applicable law or agreed to in writing, software distributed under
-the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-KIND, either express or implied.
-See the License for the specific language governing permissions and limitations under
-limitations under the License.
-
-pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-Copyright (c) 2007, Los Alamos National Security, LLC
-======================================================================================= */
-
-#ifndef __vtkOSPRayRenderable_h
-#define __vtkOSPRayRenderable_h
-
-#include "vtkOSPRay.h"
-
-
-class vtkOSPRayRenderable
-{
-public:
-vtkOSPRayRenderable(OSPModel model)
-: model(model)
-{
-instance = ospNewInstance(model, osp::affine3f(embree::one));
-}
-OSPGeometry instance;
-OSPModel model;
-};
-
-#endif
\ No newline at end of file
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderer.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderer.cxx
deleted file mode 100755
index 0062050b7..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderer.cxx
+++ /dev/null
@@ -1,721 +0,0 @@
-/* =======================================================================================
- Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
- All rights reserved.
-
- Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
- except in compliance with the License.
- A copy of the License is included with this software in the file LICENSE.
- If your copy does not contain the License, you may obtain a copy of the License at:
-
- http://opensource.org/licenses/BSD-3-Clause
-
- Unless required by applicable law or agreed to in writing, software distributed under
- the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- KIND, either express or implied.
- See the License for the specific language governing permissions and limitations under
- limitations under the License.
-
- pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
- Copyright (c) 2007, Los Alamos National Security, LLC
- ======================================================================================= */
-
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayCamera.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayRenderer.h"
-
-#include "vtkActor.h"
-#include "vtkCuller.h"
-#include "vtkLight.h"
-#include "vtkLightCollection.h"
-#include "vtkObjectFactory.h"
-#include "vtkRendererCollection.h"
-#include "vtkRenderWindow.h"
-#include "vtkTimerLog.h"
-
-#include "vtkImageData.h"
-#include "vtkPNGWriter.h"
-#include "vtkPolyDataMapper.h"
-#include "vtkPolyData.h"
-//#include "vtkMultiProcessController.h"
-
-#include <vtkSmartPointer.h>
-#include <vtkCommand.h>
-#include <vtkRenderer.h>
-#include <vtkRendererCollection.h>
-#include <vtkRenderWindow.h>
-#include <vtkRenderWindowInteractor.h>
-
-
-#include "vtkOSPRayActor.h"
-#include <DebugStream.h>
-
-//  VBOs
-//
-#if USE_VBOS
-#include <GL/glu.h>
-#include <assert.h>
-#endif
-
-
-#include <string>
-
-vtkStandardNewMacro(vtkOSPRayRenderer);
-
-class vtkTimerCallback : public vtkCommand
-{
-public:
-  static vtkTimerCallback *New()
-  {
-    vtkTimerCallback *cb = new vtkTimerCallback;
-    cb->TimerCount = 0;
-    return cb;
-  }
-
-  virtual void Execute(vtkObject *vtkNotUsed(caller), unsigned long eventId,
-                       void *vtkNotUsed(callData))
-  {
-    if (vtkCommand::TimerEvent == eventId)
-    {
-      ++this->TimerCount;
-    }
-  }
-
-private:
-  int TimerCount;
-
-};
-
-//----------------------------------------------------------------------------
-vtkOSPRayRenderer::vtkOSPRayRenderer()
-:
-prog_flag(false),
-Accumulate(false)
-{
-    debug5 << "ALOK: vtkOSPRayRenderer constructor" << endl;
-  Frame=0;
-  HasVolume= false;
-  ClearAccumFlag=false;
-  //ComputeDepth = vtkMultiProcessController::GetGlobalController()->GetNumberOfProcesses() > 1;
-  ComputeDepth = 0;
-
-  this->EngineInited=false;
-  this->NumberOfWorkers = 1;
-  this->EnableShadows = -1;
-  this->Samples = 1;
-  this->MaxDepth = 5;
-  this->EnableVolumeShading = 0;
-
-  this->ImageX = -1;
-  this->ImageY = -1;
-
-  this->backgroundRGB[0] = 0.0;
-  this->backgroundRGB[1] = 0.0;
-  this->backgroundRGB[2] = 0.0;
-  AccumCounter=0;
-  MaxAccum=1024;
-  this->SetAmbient( 0.1, 0.1, 0.1 );
-
-  this->OSPRayManager = vtkOSPRayManager::Singleton();
-
-  OSPModel oModel = (OSPModel)this->OSPRayManager->OSPRayModel;
-  OSPCamera oCamera = (OSPCamera)this->OSPRayManager->OSPRayCamera;
-  this->EnableAO=false;
-  bool ao = EnableAO;
-  EnableAO=-1;
-  SetEnableAO(ao);
-  OSPRenderer oRenderer = (OSPRenderer)this->OSPRayManager->OSPRayRenderer;
-  OSPRenderer vRenderer = (OSPRenderer)this->OSPRayManager->OSPRayVolumeRenderer;
-  ospSet3f(vRenderer, "bgColor", backgroundRGB[0], backgroundRGB[1], backgroundRGB[2]);
-  OSPModel vModel = (OSPModel)this->OSPRayManager->OSPRayVolumeModel;
-  SetEnableShadows(0);
-
-  ospSetObject(vRenderer,"world",vModel);
-  ospSetObject(vRenderer,"model",vModel);
-  ospSetObject(vRenderer,"camera",oCamera);
-  ospCommit(vRenderer);
-
-  Assert(oRenderer != NULL && "could not create renderer");
-  Assert(vRenderer != NULL && "could not create renderer");
-
-  ospSetObject(oRenderer,"world",oModel);
-  ospSetObject(oRenderer,"model",oModel);
-  ospSetObject(oRenderer,"camera",oCamera);
-  ospSet1i(oRenderer,"spp",Samples);
-  ospSet3f(oRenderer,"bgColor",1,1,1);
-  ospCommit(oModel);
-  ospCommit(oCamera);
-  ospCommit(oRenderer);
-
-  this->ColorBuffer = NULL;
-  this->DepthBuffer = NULL;
-  this->osp_framebuffer = NULL;
-
-  StatisticFramesPerOutput = 100;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayRenderer::~vtkOSPRayRenderer()
-{
-  if (this->osp_framebuffer)
-  {
-    ospFreeFrameBuffer(this->osp_framebuffer);
-    this->osp_framebuffer = NULL;
-  }
-
-  if (this->ColorBuffer)
-  {
-    delete[] this->ColorBuffer;
-    this->ColorBuffer = NULL;
-  }
-
-  if (this->DepthBuffer)
-  {
-    delete[] this->DepthBuffer;
-    this->DepthBuffer = NULL;
-  }
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::InitEngine()
-{
-  this->EngineInited = true;
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetBackground(double r, double g, double b)
-{
-  OSPRenderer oRenderer = (OSPRenderer)this->OSPRayManager->OSPRayRenderer;
-  OSPRenderer vRenderer = (OSPRenderer)this->OSPRayManager->OSPRayVolumeRenderer;
-  ospSet3f(oRenderer,"bgColor",r,g,b);
-  ospSet3f(vRenderer,"bgColor",r,g,b);
-
-  backgroundRGB[0] = r;
-  backgroundRGB[1] = g;
-  backgroundRGB[2] = b;
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::ClearLights(void)
-{
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::Clear()
-{
-}
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::ClearAccumulation()
-{
-  if (osp_framebuffer)
-    ospFrameBufferClear(osp_framebuffer, OSP_FB_ACCUM);
-  AccumCounter=0;
-}
-
-
-//----------------------------------------------------------------------------
-// Ask lights to load themselves into graphics pipeline.
-int vtkOSPRayRenderer::UpdateLights()
-{
-  OSPRenderer renderer = ((OSPRenderer)this->OSPRayManager->OSPRayRenderer);
-  OSPRenderer vRenderer = ((OSPRenderer)this->OSPRayManager->OSPRayVolumeRenderer);
-  std::vector<OSPLight> lights;
-
-
-  // convert VTK lights into OSPRay lights
-  vtkCollectionSimpleIterator sit;
-  this->Lights->InitTraversal( sit );
-
-  vtkLight *vLight = NULL;
-  bool noneOn = true;
-  for ( this->Lights->InitTraversal( sit );
-       ( vLight = this->Lights->GetNextLight( sit ) ) ; )
-  {
-    if ( vLight->GetSwitch() )
-    {
-      noneOn = false;
-    }
-    vtkLight* light = vLight;
-
-    double *color, *position, *focal, direction[3];
-
-    // OSPRay Lights only have one "color"
-    color    = light->GetDiffuseColor();
-    position = light->GetTransformedPosition();
-    focal    = light->GetTransformedFocalPoint();
-
-    if (light->GetPositional())
-    {
-      OSPLight ospLight = ospNewLight(renderer, "OBJPointLight");
-      ospSetString(ospLight, "name", "point" );
-      ospSet3f(ospLight, "color", color[0],color[1],color[2]);
-      ospSet3f(ospLight, "position", position[0],position[1],position[2]);
-      ospCommit(ospLight);
-      lights.push_back(ospLight);
-    }
-    else
-    {
-      direction[0] = position[0] - focal[0];
-      direction[1] = position[1] - focal[1];
-      direction[2] = position[2] - focal[2];
-      OSPLight ospLight = ospNewLight(renderer, "DirectionalLight");
-      ospSetString(ospLight, "name", "directional" );
-      float scale = 0.8;
-      ospSet3f(ospLight, "color", color[0]*scale,color[1]*scale,color[2]*scale);
-      osp::vec3f dir(-direction[0],-direction[1],-direction[2]);
-      dir = normalize(dir);
-      ospSet3f(ospLight, "direction", dir.x,dir.y,dir.z);
-      ospCommit(ospLight);
-      lights.push_back(ospLight);
-    }
-
-    if (noneOn)
-    {
-      {
-        cerr
-        << "No light defined, creating a headlight at camera position" << endl;
-      }
-    }
-    else
-    {
-    }
-  }
-  {
-
-  }
-  {
-  }
-
-  OSPData lightsArray = ospNewData(lights.size(), OSP_OBJECT, &lights[0], 0);
-  ospSetData(renderer, "lights",lightsArray);
-  ospSetData(vRenderer, "lights",lightsArray);
-  ospCommit(renderer);
-
-  return 0;
-}
-
-//----------------------------------------------------------------------------
-vtkCamera* vtkOSPRayRenderer::MakeCamera()
-{
-  return vtkOSPRayCamera::New();
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::UpdateSize()
-{
-}
-
-void vtkOSPRayRenderer::PreRender()
-{
-  if ((!prog_flag) || ClearAccumFlag)
-  {
-    if (osp_framebuffer)
-      ospFrameBufferClear(osp_framebuffer, OSP_FB_COLOR | (ComputeDepth ? OSP_FB_DEPTH : 0) | OSP_FB_ACCUM);
-    AccumCounter=0;
-    ClearAccumFlag=false;
-  }
-  else
-    prog_flag = false;
-
-  if (this->GetLayer() != 0 && this->GetActors()->GetNumberOfItems() == 0)
-  {
-    return;
-  }
-
-  vtkTimerLog::MarkStartEvent("OSPRay Dev Render");
-
-  if (!this->EngineInited )
-  {
-    this->InitEngine();
-  }
-
-  vtkTimerLog::MarkStartEvent("Geometry");
-
-  this->Clear();
-
-  this->UpdateSize();
-
-
-  HasVolume = false;
-  OSPRenderer oRenderer = (OSPRenderer)this->OSPRayManager->OSPRayRenderer;
-  this->OSPRayManager->OSPRayModel = ospNewModel();
-  this->OSPRayManager->OSPRayVolumeModel = this->OSPRayManager->OSPRayModel;  //TODO: the volume and geometry are now managed in the same model object, can remove volumemodel entirely
-  OSPModel oModel = (OSPModel)this->OSPRayManager->OSPRayModel;
-  OSPCamera oCamera = (OSPCamera)this->OSPRayManager->OSPRayCamera;
-  ospSetObject(oRenderer,"world",oModel);
-  ospSetObject(oRenderer,"model",oModel);
-  ospSetObject(oRenderer,"camera",oCamera);
-
-
-  ospCommit(this->OSPRayManager->OSPRayModel);
-  ospCommit(this->OSPRayManager->OSPRayRenderer);
-
-  this->UpdateCamera();
-
-
-  this->UpdateLightGeometry();
-  this->UpdateLights();
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::DeviceRender()
-{
-    debug5 << "ALOK: beginning of vtkOSPRayRenderer::DeviceRender()" << endl;
-  static vtkTimerLog* timer = vtkTimerLog::New();
-  timer->StartTimer();
-  PreRender();
-
-  this->UpdateGeometry();
-
-  vtkTimerLog::MarkEndEvent("Geometry");
-
-  vtkTimerLog::MarkStartEvent("Total LayerRender");
-  this->LayerRender();
-
-  vtkTimerLog::MarkEndEvent("Total LayerRender");
-
-  vtkTimerLog::MarkEndEvent("OSPRay Dev Render");
-  Frame++;
-  timer->StopTimer();
-  #if GATHER_STATS
-  Statistics.push(std::make_pair("DeviceRender", timer->GetElapsedTime()));
-  if ( (StatisticFramesPerOutput > 0) && ( (Frame % StatisticFramesPerOutput) == 0) )
-  {
-    while (!Statistics.empty())
-    {
-      std::cout << Statistics.front().first << " " << Statistics.front().second;
-      Statistics.pop();
-    }
-  }
-  #endif
-    debug5 << "ALOK: end of vtkOSPRayRenderer::DeviceRender()" << endl;
-}
-
-//----------------------------------------------------------------------------
-// let the renderer display itself appropriately based on its layer index
-void vtkOSPRayRenderer::LayerRender()
-{
-    debug5 << "ALOK: beginning of vtkOSPRayRenderer::Layereender()" << endl;
-  int     i, j;
-  int     rowLength,  OSPRaySize[2];
-  int     minWidth,   minHeight;
-  int     hOSPRayDiff, hRenderDiff;
-  int     renderPos[2];
-  int*    renderSize  = NULL;
-  int*    renWinSize  = NULL;
-  bool    stereoDumy;
-  float*  OSPRayBuffer = NULL;
-  double* renViewport = NULL;
-
-  // collect some useful info
-  renderSize = this->GetSize();
-  renWinSize = this->GetRenderWindow()->GetActualSize();
-  renViewport= this->GetViewport();
-  renderPos[0] = int( renViewport[0] * renWinSize[0] + 0.5f );
-  renderPos[1] = int( renViewport[1] * renWinSize[1] + 0.5f );
-  minWidth = renderSize[0];
-  minHeight =renderSize[1];
-  hOSPRayDiff = 0;
-  hRenderDiff = 0;
-  // memory allocation and acess to the OSPRay image
-  int size = renderSize[0]*renderSize[1];
-  if (this->ImageX != renderSize[0] || this->ImageY != renderSize[1])
-  {
-    this->ImageX = renderSize[0];
-    this->ImageY = renderSize[1];
-
-    if (this->ColorBuffer) delete[] this->ColorBuffer;
-    this->ColorBuffer = new float[ size ];
-
-    if (this->DepthBuffer) delete[] this->DepthBuffer;
-    this->DepthBuffer = new float[ size ];
-
-    if (this->osp_framebuffer) ospFreeFrameBuffer(this->osp_framebuffer);
-    this->osp_framebuffer = ospNewFrameBuffer(osp::vec2i(renderSize[0], renderSize[1]), OSP_RGBA_I8, OSP_FB_COLOR | (ComputeDepth ? OSP_FB_DEPTH : 0) | OSP_FB_ACCUM);
-    ospFrameBufferClear(osp_framebuffer, OSP_FB_ACCUM);
-    AccumCounter=0;
-  }
-  if (HasVolume && !EnableAO)
-  {
-    OSPRenderer vRenderer = (OSPRenderer)this->OSPRayManager->OSPRayVolumeRenderer;
-    OSPModel vModel = (OSPModel)this->OSPRayManager->OSPRayVolumeModel;
-    OSPCamera oCamera = (OSPCamera)this->OSPRayManager->OSPRayCamera;
-
-    ospSetObject(vRenderer,"world",vModel);
-    ospSetObject(vRenderer,"model",vModel);
-    ospSetObject(vRenderer,"camera",oCamera);
-
-    ospCommit(vModel);
-    ospCommit(vRenderer);
-
-
-    ospRenderFrame(this->osp_framebuffer,vRenderer,OSP_FB_COLOR|OSP_FB_ACCUM);
-    AccumCounter++;
-  }
-  else
-  {
-    OSPRenderer renderer = ((OSPRenderer)this->OSPRayManager->OSPRayRenderer);
-    OSPModel ospModel = ((OSPModel)this->OSPRayManager->OSPRayModel);
-
-    ospCommit(renderer);
-    ospCommit(ospModel);
-
-    ospRenderFrame(this->osp_framebuffer,renderer,OSP_FB_COLOR|OSP_FB_ACCUM);
-    AccumCounter++;
-  }
-
-  //
-  // Copy Depth Buffer
-  //
-  if (ComputeDepth)
-  {
-    double *clipValues = this->GetActiveCamera()->GetClippingRange();
-    double viewAngle = this->GetActiveCamera()->GetViewAngle();
-
-    // Closest point is center of near clipping plane - farthest is
-    // corner of far clipping plane
-    double clipMin = clipValues[0];
-    double clipMax = clipValues[1] / pow(cos(viewAngle / 2.0), 2.0);
-    double clipDiv = 1.0 / (clipMax - clipMin);
-
-    const void *b = ospMapFrameBuffer(this->osp_framebuffer, OSP_FB_DEPTH);
-
-    float *s = (float *)b;
-    float *d = this->DepthBuffer;
-    for (int i = 0; i < size; i++, s++, d++)
-      *d = std::isinf(*s) ? 1.0 : (*s - clipMin) * clipDiv;
-    ospUnmapFrameBuffer(b, this->osp_framebuffer);
-
-    this->GetRenderWindow()->MakeCurrent();
-    glDepthFunc(GL_ALWAYS);
-
-    this->GetRenderWindow()->SetZbufferData(renderPos[0], renderPos[1],
-                                            renderPos[0] + renderSize[0] - 1, renderPos[1] + renderSize[1] - 1, this->DepthBuffer);
-  }
-  //
-  // Copy RGBA Buffer
-  //
-
-  const void* rgba = ospMapFrameBuffer(this->osp_framebuffer);
-  // memcpy((void *)this->ColorBuffer, rgba, size*sizeof(float));
-  glDrawPixels(renderSize[0],renderSize[1],GL_RGBA,GL_UNSIGNED_BYTE,rgba);
-  ospUnmapFrameBuffer(rgba, this->osp_framebuffer);
-    debug5 << "ALOK: end of vtkOSPRayRenderer::LayerRender()" << endl;
-  return;
-  //ALOK: Nothing below this runs!
-
-  vtkTimerLog::MarkStartEvent("Image Conversion");
-
-  // let layer #0 initialize GL depth buffer
-  if ( this->GetLayer() == 0 )
-  {
-    this->GetRenderWindow()->
-    SetRGBACharPixelData( renderPos[0],  renderPos[1],
-                         renderPos[0] + renderSize[0] - 1,
-                         renderPos[1] + renderSize[1] - 1,
-                         (unsigned char*)this->ColorBuffer, 0, 0 );
-    glFinish();
-  }
-  else
-  {
-    //layers on top add the colors of their non background pixels
-    unsigned char*  GLbakBuffer = NULL;
-    GLbakBuffer = this->GetRenderWindow()->
-    GetRGBACharPixelData( renderPos[0],  renderPos[1],
-                         renderPos[0] + renderSize[0] - 1,
-                         renderPos[1] + renderSize[1] - 1, 0 );
-
-    bool anyhit = false;
-    unsigned char *optr = GLbakBuffer;
-    unsigned char *iptr = (unsigned char*)this->ColorBuffer;
-    float *zptr = this->DepthBuffer;
-    for ( j = 0; j < renderSize[1]; j++)
-    {
-      for ( i = 0; i < renderSize[0]; i++)
-      {
-        const float z = *zptr;
-        if (z > 0 && z < 1.0)
-        {
-          anyhit = true;
-          *(optr+0) = *(iptr+0);
-          *(optr+1) = *(iptr+1);
-          *(optr+2) = *(iptr+2);
-          *(optr+3) = *(iptr+3);
-        }
-        optr+=4;
-        iptr+=4;
-        zptr++;
-      }
-    }
-
-    if (anyhit)
-    {
-      // submit the modified RGB colors to GL BACK buffer
-      this->GetRenderWindow()->
-      SetRGBACharPixelData( renderPos[0],  renderPos[1],
-                           renderPos[0] + renderSize[0] - 1,
-                           renderPos[1] + renderSize[1] - 1,
-                           GLbakBuffer, 0, 0 );
-    }
-
-    delete [] GLbakBuffer;
-  }
-
-  vtkTimerLog::MarkEndEvent("Image Conversion");
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::PrintSelf( ostream& os, vtkIndent indent )
-{
-  this->Superclass::PrintSelf( os, indent );
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetNumberOfWorkers( int newval )
-{
-  if (this->NumberOfWorkers == newval)
-  {
-    return;
-  }
-}
-
-void vtkOSPRayRenderer::AddOSPRayRenderable(vtkOSPRayRenderable* inst)
-{
-  ospAddGeometry((OSPModel)this->OSPRayManager->OSPRayModel,inst->instance);
-  renderables.push_back(inst);
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetEnableShadows( int newval )
-{
-  if (this->EnableShadows == newval)
-  {
-    return;
-  }
-  this->EnableShadows = newval;
-
-  OSPRenderer renderer = ((OSPRenderer)this->OSPRayManager->OSPRayRenderer);
-  ospSet1i(renderer,"shadowsEnabled", this->EnableShadows);
-  ospCommit(renderer);
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetSamples( int newval )
-{
-  if (this->Samples == newval || newval < 1)
-  {
-    return;
-  }
-
-  this->Samples = newval;
-
-
-  OSPRenderer renderer = ((OSPRenderer)this->OSPRayManager->OSPRayRenderer);
-
-  Assert(renderer);
-
-  ospSet1i(renderer,"spp",Samples);
-  ospCommit(renderer);
-
-  OSPRenderer vRenderer = ((OSPRenderer)this->OSPRayManager->OSPRayVolumeRenderer);
-
-  Assert(vRenderer);
-
-  ospSet1i(vRenderer,"spp",Samples);
-  ospCommit(vRenderer);
-
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetEnableAO( int newval )
-{
-  if (this->EnableAO == newval)
-  {
-    return;
-  }
-
-  this->EnableAO = newval;
-
-  UpdateOSPRayRenderer();
-
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetEnablePathtracing( int newval )
-{
-  if (this->EnablePathtracing == newval)
-  {
-    return;
-  }
-
-  this->EnablePathtracing = newval;
-
-  UpdateOSPRayRenderer();
-
-}
-
-
-void vtkOSPRayRenderer::SetEnableVolumeShading( int newval )
-{
-  EnableVolumeShading = newval;
-}
-
-void vtkOSPRayRenderer::UpdateOSPRayRenderer()
-{
-  OSPModel oModel = (OSPModel)this->OSPRayManager->OSPRayModel;
-  OSPCamera oCamera = (OSPCamera)this->OSPRayManager->OSPRayCamera;
-
-  if (EnableAO != 0)
-  {
-    this->OSPRayManager->OSPRayRenderer = (osp::Renderer*)ospNewRenderer("ao4");
-  }
-  else if (EnablePathtracing != 0)
-  {
-    this->OSPRayManager->OSPRayRenderer = (osp::Renderer*)ospNewRenderer("pathtracer");
-  }
-  else
-  {
-    this->OSPRayManager->OSPRayRenderer = (osp::Renderer*)ospNewRenderer("raycast_volume_renderer");
-    // this->OSPRayManager->OSPRayRenderer = (osp::Renderer*)ospNewRenderer("obj");
-  }
-  OSPRenderer oRenderer = (OSPRenderer)this->OSPRayManager->OSPRayRenderer;
-
-  Assert(oRenderer != NULL && "could not create renderer");
-
-  ospSetObject(oRenderer,"dynamic_model",ospNewModel());
-  ospSetObject(oRenderer,"world",oModel);
-  ospSetObject(oRenderer,"model",oModel);
-  ospSetObject(oRenderer,"camera",oCamera);
-  ospCommit(oRenderer);
-
-  ospSet1i(oRenderer,"spp",Samples);
-  ospSet1f(oRenderer,"epsilon", 10e-2);
-  ospSet1i(oRenderer,"shadowsEnabled", this->EnableShadows);
-
-  ospCommit(oRenderer);
-  SetBackground(backgroundRGB[0],backgroundRGB[1],backgroundRGB[2]);
-
-  vtkActorCollection *actorList = this->GetActors();
-  actorList->InitTraversal();
-
-  int numActors = actorList->GetNumberOfItems();
-  for(int i=0; i<numActors; i++) {
-    vtkActor *a = actorList->GetNextActor();
-    a->Modified();
-  }
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayRenderer::SetMaxDepth( int newval )
-{
-  if (this->MaxDepth == newval)
-  {
-    return;
-  }
-
-  this->MaxDepth = newval;
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderer.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderer.h
deleted file mode 100755
index 36ca7b239..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayRenderer.h
+++ /dev/null
@@ -1,243 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayRenderer - Renderer that uses OSPRay ray tracer instead of GL.
-// .SECTION Description
-// vtkOSPRayRenderer is a concrete implementation of the abstract class
-// vtkRenderer. vtkOSPRayRenderer interfaces to the OSPRay graphics library.
-
-#ifndef __vtkOSPRayRenderer_h
-#define __vtkOSPRayRenderer_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkOpenGLRenderer.h"
-
-#include "vtkOSPRay.h"
-
-#include "vtkOSPRayRenderable.h"
-#include <queue>
-#include <utility>
-#include <string>
-
-
-//BTX
-namespace OSPRay {
-class OSPRayInterface;
-class Scene;
-class Group;
-class LightSet;
-class Factory;
-class Camera;
-class SyncDisplay;
-class Light;
-}
-//ETX
-
-class vtkOSPRayManager;
-
-class VTKOSPRAY_EXPORT vtkOSPRayRenderer : public vtkOpenGLRenderer
-{
-public:
-  static vtkOSPRayRenderer *New();
-  vtkTypeMacro(vtkOSPRayRenderer, vtkOpenGLRenderer);
-  void PrintSelf(ostream& os, vtkIndent indent);
-
-  //Description:
-  // Overridden to use OSPRay callbacks to do the work.
-  virtual void SetBackground(double rgb[3])
-    { this->Superclass::SetBackground(rgb); }
-  virtual void SetBackground(double r, double g, double b);
-
-  //Description:
-  //Changes the number of OSPRay rendering threads.
-  //More is faster.
-  //Default is 1.
-  void SetNumberOfWorkers(int);
-  vtkGetMacro(NumberOfWorkers, int);
-
-  //Description:
-  //Turns on or off shadow rendering.
-  //Default is off.
-  void SetEnableShadows(int);
-  vtkGetMacro(EnableShadows, int);
-
-    //Description:
-  //Turns on or off shadow rendering.
-  //Default is off.
-  void SetEnableAO(int);
-  vtkGetMacro(EnableAO, int);
-
-  //Description:
-  //Turns on or off shadow rendering.
-  //Default is off.
-  void SetEnablePathtracing(int);
-  vtkGetMacro(EnablePathtracing, int);
-  //Description:
-  //Turns on or off shadow rendering.
-  //Default is off.
-  void SetEnableVolumeShading(int);
-  vtkGetMacro(EnableVolumeShading, int);
-
-  //Description:
-  //Controls multisample (anitaliased) rendering.
-  //More looks better, but is slower.
-  //Default is 1.
-  void SetSamples(int);
-  vtkGetMacro(Samples, int);
-
-  vtkGetMacro(Accumulate, bool);
-  void SetAccumulate(bool st)
-  {
-    Accumulate = st;
-  }
-
-  //Description:
-  //Controls maximum ray bounce depth.
-  //More looks better, but is slower.
-  //Default is 5 meaning a couple of bounces.
-  void SetMaxDepth(int);
-  vtkGetMacro(MaxDepth, int);
-
-  // Description:
-  // Ask lights to load themselves into graphics pipeline.
-  int UpdateLights(void);
-
-  // Description:
-  // Turns off all lighting
-  void ClearLights(void);
-
-
-  void Clear();
-  void ClearAccumulation();
-
-  //Description:
-  //Access to the OSPRay rendered image
-  float * GetColorBuffer()
-  {
-    return this->ColorBuffer;
-  }
-  float * GetDepthBuffer()
-  {
-    return this->DepthBuffer;
-  }
-
-  //Setup ospray world, camera etc. before
-  // renders are called in the geometry
-  void PreRender();
-  // Description:
-  // Concrete render method. Do not call this directly. The pipeline calls
-  // it during Renderwindow::Render()
-  void DeviceRender();
-
-  void LayerRender();
-
-  //Description:
-  //All classes that make OSPRay calls should get hold of this and
-  //Register it so that the Manager, and thus the OSPRay engine
-  //outlive themselves, and thus guarantee that they can safely make
-  //OSPRay API calls whenever they need to.
-  vtkOSPRayManager* GetOSPRayManager()
-  {
-    return this->OSPRayManager;
-  }
-
-  void SetHasVolume(bool st) { HasVolume=st;}
-  void SetProgressiveRenderFlag() {prog_flag = true; }
-  void SetClearAccumFlag() {ClearAccumFlag = true; }
-  int GetAccumCounter() { return AccumCounter; }
-  int GetMaxAccumulation() { return MaxAccum; }
-  int GetFrame() { return Frame; }
-  vtkSetMacro(ComputeDepth, bool);
-
-  void AddOSPRayRenderable(vtkOSPRayRenderable* inst);
-
-protected:
-  vtkOSPRayRenderer();
-  ~vtkOSPRayRenderer();
-
-  //lets OSPRay engine know when viewport changes
-  void UpdateSize();
-
-  // OSPRay renderer does not support picking.
-  virtual void DevicePickRender() {};
-  virtual void StartPick(unsigned int vtkNotUsed(pickFromSizev)) {};
-  virtual void UpdatePickId() {};
-  virtual void DonePick() {};
-  virtual unsigned int GetPickedId() { return 0; };
-  virtual unsigned int GetNumPickedIds() { return 0; };
-  virtual int GetPickedIds( unsigned int vtkNotUsed(atMost), unsigned int * vtkNotUsed(callerBuffer) )
-  {
-    return 0;
-  };
-  virtual double GetPickedZ() { return 0.0f; };
-  //creates the internal OSPRay renderer object
-
-  void UpdateOSPRayRenderer();
-
-private:
-  vtkOSPRayRenderer(const vtkOSPRayRenderer&); // Not implemented.
-  void operator=(const vtkOSPRayRenderer&); // Not implemented.
-
-  void InitEngine();
-
-  //Description:
-  // Overriden to help ensure that a OSPRay compatible class is created.
-  vtkCamera * MakeCamera();
-  std::vector<vtkOSPRayRenderable*> renderables;
-
-  bool IsStereo;
-  bool EngineInited;
-  bool EngineStarted;
-
-  int ImageX;
-  int ImageY;
-  OSPFrameBuffer osp_framebuffer;
-
-  float *ColorBuffer;
-  float *DepthBuffer;
-
-
-  int ChannelId;
-
-  vtkOSPRayManager *OSPRayManager;
-
-  int NumberOfWorkers;
-  int EnableShadows;
-  int EnableAO;
-  int EnablePathtracing;
-  int EnableVolumeShading;
-  int Samples;
-  int MaxDepth;
-  bool Accumulate;
-  int AccumCounter;
-  int MaxAccum;
-  bool prog_flag;
-  int Frame;
-  bool ComputeDepth;
-  bool HasVolume;
-  bool ClearAccumFlag;
-
-  double backgroundRGB[3];
-  std::queue<std::pair<std::string, double> > Statistics;
-  int StatisticFramesPerOutput;
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTestSource.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTestSource.cxx
deleted file mode 100755
index 67bdc456b..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTestSource.cxx
+++ /dev/null
@@ -1,207 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayTestSource - produce triangles to benchmark OSPRay with
-
-#include "vtkOSPRayTestSource.h"
-#include "vtkObjectFactory.h"
-
-#include "vtkInformation.h"
-#include "vtkInformationVector.h"
-#include "vtkMath.h"
-#include "vtkStreamingDemandDrivenPipeline.h"
-#include "vtkIdTypeArray.h"
-#include "vtkCellArray.h"
-
-vtkStandardNewMacro(vtkOSPRayTestSource);
-
-//----------------------------------------------------------------------------
-vtkOSPRayTestSource::vtkOSPRayTestSource()
-{
-  this->SetNumberOfInputPorts(0);
-  this->Resolution = 100;
-
-  //Give it some geometric coherence
-  this->DriftFactor = 0.1;
-  //Give it some memory coherence
-  this->SlidingWindow = 0.01;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayTestSource::~vtkOSPRayTestSource()
-{
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayTestSource::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os,indent);
-
-  os << indent << "Resolution: " << this->Resolution << endl;
-  os << indent << "DriftFactor: " << this->DriftFactor << endl;
-  os << indent << "SlidingWindow: " << this->SlidingWindow << endl;
-}
-
-//----------------------------------------------------------------------------
-int vtkOSPRayTestSource::RequestInformation(
-  vtkInformation *vtkNotUsed(info),
-  vtkInformationVector **vtkNotUsed(inputV),
-  vtkInformationVector *output)
-{
-  return 1;
-}
-
-//----------------------------------------------------------------------------
-int vtkOSPRayTestSource::RequestData(vtkInformation *vtkNotUsed(info),
-                                    vtkInformationVector **vtkNotUsed(inputV),
-                                    vtkInformationVector *output)
-{
-  vtkInformation *outInfo = output->GetInformationObject(0);
-  int Rank = 0;
-  if (outInfo->Has(vtkStreamingDemandDrivenPipeline::UPDATE_PIECE_NUMBER()))
-    {
-    Rank =
-      outInfo->Get(
-        vtkStreamingDemandDrivenPipeline::UPDATE_PIECE_NUMBER());
-    }
-  int Processors = 1;
-  if (outInfo->Has(
-        vtkStreamingDemandDrivenPipeline::UPDATE_NUMBER_OF_PIECES()))
-    {
-    Processors =
-      outInfo->Get(
-        vtkStreamingDemandDrivenPipeline::UPDATE_NUMBER_OF_PIECES());
-    }
-
-
-  vtkPolyData *outPD =
-    vtkPolyData::SafeDownCast(outInfo->Get(vtkDataObject::DATA_OBJECT()));
-  if (!outPD)
-    {
-    return VTK_ERROR;
-    }
-
-  outPD->Initialize();
-  outPD->Allocate();
-
-  vtkIdType myStart = this->Resolution/Processors * Rank;
-  vtkIdType myEnd = this->Resolution/Processors * (Rank+1);
-
-  vtkIdType indices[3];
-  vtkIdType minIndex = this->Resolution;
-  vtkIdType maxIndex = 0;
-  for (vtkIdType i = 0; i < this->Resolution; i++)
-    {
-    double offset;
-    indices[0] = -1;
-    indices[1] = -2;
-    indices[2] = -3;
-
-    for (vtkIdType c = 0; c < 3; c++)
-      {
-      offset = vtkMath::Random()*this->SlidingWindow*this->Resolution -
-        (this->SlidingWindow*this->Resolution/2.0);
-      indices[c] = ((vtkIdType)((double)i+c + offset));
-      if (indices[c] < 0 || indices[c] >= this->Resolution)
-        {
-        indices[c] = ((vtkIdType)((double)i+c - offset));
-        }
-
-      if (indices[0] == indices[1] ||
-          indices[0] == indices[2] ||
-          indices[2] == indices[1])
-        {
-        c--;
-        }
-      }
-
-    if (i >= myStart && i < myEnd)
-      {
-      //remember index range for this slice so we can readjust
-      for (int c = 0; c < 3; c++)
-        {
-        if (indices[c] < minIndex)
-          {
-          minIndex = indices[c];
-          }
-        if (indices[c] > maxIndex)
-          {
-          maxIndex = indices[c];
-          }
-        }
-
-      outPD->InsertNextCell(VTK_TRIANGLE, 3, indices);
-      }
-    if (i % (this->Resolution/10) == 0)
-      {
-      double frac = (double)i/this->Resolution * 0.33;
-      this->UpdateProgress(frac);
-      }
-    }
-
-
-  //shift indices to 0, because each processor only produces local points
-  vtkCellArray *polys = outPD->GetPolys();
-  polys->InitTraversal();
-  vtkIdType npts;
-  vtkIdType *thePts;
-  vtkIdType i = 0;
-  vtkIdType nCells = polys->GetNumberOfCells();
-  while(polys->GetNextCell(npts, thePts))
-    {
-    for (vtkIdType c = 0; c < npts; c++)
-      {
-      thePts[c] = thePts[c] - minIndex;
-      }
-    i++;
-    if (i % (nCells/10) == 0)
-      {
-      double frac = (double)i/nCells * 0.33 + 0.33;
-      this->UpdateProgress(frac);
-      }
-    }
-
-  vtkPoints *pts = vtkPoints::New();
-  double X = vtkMath::Random();
-  double Y = vtkMath::Random();
-  double Z = vtkMath::Random();
-  for (i = 0; (i < this->Resolution || i <= maxIndex); i++)
-    {
-    X = X+vtkMath::Random() * this->DriftFactor - this->DriftFactor*0.5;
-    Y = Y+vtkMath::Random() * this->DriftFactor - this->DriftFactor*0.5;
-    Z = Z+vtkMath::Random() * this->DriftFactor - this->DriftFactor*0.5;
-    if (i >= minIndex && i <= maxIndex)
-      {
-      pts->InsertNextPoint(X, Y, Z);
-      }
-
-    if (i % (this->Resolution/10) == 0)
-      {
-      double frac = (double)i/this->Resolution * 0.33 + 0.66;
-      this->UpdateProgress(frac);
-      }
-    }
-  outPD->SetPoints(pts);
-  pts->Delete();
-
-
-  return 1;
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTestSource.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTestSource.h
deleted file mode 100755
index 690ccb020..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTestSource.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayTestSource - produce triangles to benchmark OSPRay with
-// .SECTION Description
-// This class produces polydata with a configurable number of triangles.
-// It respects parallelism, so that parallel scaling can be tested, and the
-// produced data is invariant with respect to the number of processors.
-// Configuration options change the charactersitics of the generated "scene"
-
-#ifndef __vtkOSPRayTestSource_h
-#define __vtkOSPRayTestSource_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkPolyDataAlgorithm.h"
-
-class VTKOSPRAY_EXPORT vtkOSPRayTestSource : public vtkPolyDataAlgorithm
-{
-public:
-  // Description:
-  // Create a new instance with (50,50,50) points in the (u-v-w) directions.
-  static vtkOSPRayTestSource *New();
-  vtkTypeMacro(vtkOSPRayTestSource,vtkPolyDataAlgorithm);
-  void PrintSelf(ostream& os, vtkIndent indent);
-
-  // Description:
-  // Set/Get the number of triangles to produce.
-  // Default is 100 triangles
-  vtkSetMacro(Resolution,vtkIdType);
-  vtkGetMacro(Resolution,vtkIdType);
-
-  // Description:
-  // Set/Get the spatial locality
-  // 0.0 behind infinite, 1.0 being none,
-  // this affects distance beteen sequential points
-  // Default is 0.1
-  vtkSetMacro(DriftFactor,double);
-  vtkGetMacro(DriftFactor,double);
-
-  // Description:
-  // Set/Get the memory locality
-  // 0.0 behind infinite (tri uses sequential pts),
-  // 1.0 being none (tri uses any point)
-  // Default is 0.01
-  vtkSetMacro(SlidingWindow,double);
-  vtkGetMacro(SlidingWindow,double);
-
-protected:
-  vtkOSPRayTestSource();
-  ~vtkOSPRayTestSource();
-
-  int RequestInformation(vtkInformation *info, vtkInformationVector **input,
-                         vtkInformationVector *output);
-
-  int RequestData(vtkInformation *info, vtkInformationVector **input,
-                  vtkInformationVector *output);
-
-  vtkIdType Resolution;
-  double DriftFactor;
-  double SlidingWindow;
-
-private:
-
-  vtkOSPRayTestSource(const vtkOSPRayTestSource&);  // Not implemented.
-  void operator=(const vtkOSPRayTestSource&);  // Not implemented.
-
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTexture.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTexture.cxx
deleted file mode 100755
index ba6c6f00f..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTexture.cxx
+++ /dev/null
@@ -1,219 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#include "vtkOSPRay.h"
-#include "vtkOSPRayManager.h"
-#include "vtkOSPRayRenderer.h"
-#include "vtkOSPRayTexture.h"
-
-#include "vtkHomogeneousTransform.h"
-#include "vtkImageData.h"
-#include "vtkLookupTable.h"
-#include "vtkObjectFactory.h"
-#include "vtkPointData.h"
-#include "vtkTransform.h"
-
-
-
-
-#include <math.h>
-
-
-vtkStandardNewMacro(vtkOSPRayTexture);
-
-//----------------------------------------------------------------------------
-// Initializes an instance, generates a unique index.
-vtkOSPRayTexture::vtkOSPRayTexture()
-: OSPRayTexture(NULL)
-{
-  this->OSPRayManager = NULL;
-  this->OSPRayTexture = NULL;
-}
-
-//----------------------------------------------------------------------------
-vtkOSPRayTexture::~vtkOSPRayTexture()
-{
-  if (this->OSPRayManager)
-  {
-    this->DeleteOSPRayTexture();
-
-    this->OSPRayManager->Delete();
-  }
-}
-
-//-----------------------------------------------------------------------------
-void vtkOSPRayTexture::DeleteOSPRayTexture()
-{
-  if (!this->OSPRayTexture)
-  {
-    return;
-  }
-
-  this->OSPRayTexture = NULL;
-
-}
-
-//-----------------------------------------------------------------------------
-// Release the graphics resources used by this texture.
-void vtkOSPRayTexture::ReleaseGraphicsResources(vtkWindow *win)
-{
-  this->Superclass::ReleaseGraphicsResources( win );
-  if (!this->OSPRayManager)
-  {
-    return;
-  }
-
-  this->DeleteOSPRayTexture();
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayTexture::Load(vtkRenderer *ren, bool nearest)
-{
-  vtkImageData *input = this->GetInput();
-
-  vtkOSPRayRenderer* renderer =
-  vtkOSPRayRenderer::SafeDownCast(ren);
-  if (!renderer)
-  {
-    return;
-  }
-  if (!this->OSPRayManager)
-  {
-    this->OSPRayManager = renderer->GetOSPRayManager();
-    this->OSPRayManager->Register(this);
-  }
-
-  if (this->GetMTime() > this->LoadTime.GetMTime() ||
-    input->GetMTime()> this->LoadTime.GetMTime() ||
-      (this->GetLookupTable() && this->GetLookupTable()->GetMTime() > this->LoadTime.GetMTime())
-      )
-      {
-        int bytesPerPixel=4;
-        int size[3];
-        vtkDataArray *scalars;
-        unsigned char *dataPtr;
-        int xsize, ysize;
-
-    // Get the scalars the user choose to color with.
-        scalars = this->GetInputArrayToProcess(0, input);
-    // make sure scalars are non null
-        if (!scalars)
-        {
-          vtkErrorMacro(<< "No scalar values found for texture input!");
-          return;
-        }
-
-    // get some info
-        input->GetDimensions(size);
-
-        if (input->GetNumberOfCells() == scalars->GetNumberOfTuples())
-        {
-      // we are using cell scalars. Adjust image size for cells.
-          for (int kk = 0; kk < 3; kk++)
-          {
-            if (size[kk] > 1)
-            {
-              size[kk]--;
-            }
-          }
-        }
-
-        bytesPerPixel = scalars->GetNumberOfComponents();
-
-    // make sure using unsigned char data of color scalars type
-        if (this->MapColorScalarsThroughLookupTable ||
-          scalars->GetDataType() != VTK_UNSIGNED_CHAR)
-        {
-          dataPtr = this->MapScalarsToColors(scalars);
-          bytesPerPixel = 4;
-        }
-        else
-        {
-          dataPtr = static_cast<vtkUnsignedCharArray *> (scalars)->GetPointer(0);
-        }
-
-    // we only support 2d texture maps right now
-    // so one of the three sizes must be 1, but it
-    // could be any of them, so lets find it
-        if (size[0] == 1)
-        {
-          xsize = size[1];
-          ysize = size[2];
-        }
-        else
-        {
-          xsize = size[0];
-          if (size[1] == 1)
-          {
-            ysize = size[2];
-          }
-          else
-          {
-            ysize = size[1];
-            if (size[2] != 1)
-            {
-              vtkErrorMacro(<< "3D texture maps currently are not supported!");
-              return;
-            }
-          }
-        }
-        pixels.resize(xsize*ysize*3);  //TODO: Carson: memory leak
-        for (int i=0; i < xsize*ysize; i++)
-        {
-            unsigned char *color = &dataPtr[(i)*bytesPerPixel];
-            pixels[i*3+0] = color[0];
-            pixels[i*3+1] = color[1];
-            pixels[i*3+2] = color[2];
-        }
-
-        OSPDataType type = OSP_VOID_PTR;
-
-        if (bytesPerPixel == 4)
-        {
-          type = OSP_UCHAR3;
-        }
-        else
-        {
-          printf("error! bytesperpixel !=4\n");
-          Assert(0);
-          type = OSP_UCHAR3;
-        }
-
-        this->OSPRayTexture = (osp::Texture2D*)ospNewTexture2D(xsize,
-         ysize,
-         type,
-         &pixels[0],
-         nearest ? OSP_TEXTURE_FILTER_NEAREST : 0);
-
-        ospCommit((OSPTexture2D)this->OSPRayTexture);
-
-        this->LoadTime.Modified();
-      }
-    }
-
-//----------------------------------------------------------------------------
-    void vtkOSPRayTexture::PrintSelf(ostream& os, vtkIndent indent)
-    {
-      this->Superclass::PrintSelf(os,indent);
-    }
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTexture.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTexture.h
deleted file mode 100755
index c44e7ec52..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayTexture.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* =======================================================================================
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin
-   All rights reserved.
-
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file
-   except in compliance with the License.
-   A copy of the License is included with this software in the file LICENSE.
-   If your copy does not contain the License, you may obtain a copy of the License at:
-
-       http://opensource.org/licenses/BSD-3-Clause
-
-   Unless required by applicable law or agreed to in writing, software distributed under
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-   KIND, either express or implied.
-   See the License for the specific language governing permissions and limitations under
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkOSPRayTexture -
-// .SECTION Description
-//
-
-#ifndef __vtkOSPRayTexture_h
-#define __vtkOSPRayTexture_h
-
-#include "vtkOSPRayModule.h"
-#include "vtkTexture.h"
-
-//BTX
-#include "vtkWeakPointer.h" // needed for vtkWeakPointer.
-//ETX
-#include <vector>
-
-//BTX
-namespace OSPRay {
-}
-//ETX
-namespace osp
-{
-  class Texture2D;
-}
-
-class vtkRenderWindow;
-class vtkOSPRayManager;
-
-class VTKOSPRAY_EXPORT vtkOSPRayTexture : public vtkTexture
-{
-public:
-  static vtkOSPRayTexture *New();
-  vtkTypeMacro(vtkOSPRayTexture,vtkTexture);
-  virtual void PrintSelf(ostream& os, vtkIndent indent);
-
-  // Description:
-  // Implement base class method.
-  void Load(vtkRenderer *ren, bool nearest = false);
-
-  // Description:
-  // Release any graphics resources that are being consumed by this texture.
-  // The parameter window could be used to determine which graphic
-  // resources to release. Using the same texture object in multiple
-  // render windows is NOT currently supported.
-  void ReleaseGraphicsResources(vtkWindow *);
-  //BTX
-  vtkSetMacro(OSPRayTexture, osp::Texture2D*);
-  vtkGetMacro(OSPRayTexture, osp::Texture2D*);
-  //ETX
-
-  //BTX
-protected:
-  vtkOSPRayTexture();
-  ~vtkOSPRayTexture();
-
-  vtkTimeStamp   LoadTime;
-
-private:
-  vtkOSPRayTexture(const vtkOSPRayTexture&);  // Not implemented.
-  void operator=(const vtkOSPRayTexture&);  // Not implemented.
-
-  void DeleteOSPRayTexture();
-
-  osp::Texture2D* OSPRayTexture;
-  std::vector<unsigned char> pixels;
-  //ETX
-
-  vtkOSPRayManager *OSPRayManager;
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.cxx
deleted file mode 100755
index ab3a7b9b6..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.cxx
+++ /dev/null
@@ -1,1363 +0,0 @@
-/*=========================================================================
-
-Program:   Visualization Toolkit
-Module:    vtkOSPRayVolumeRayCastMapper.cxx
-
-Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
-All rights reserved.
-See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
-
-This software is distributed WITHOUT ANY WARRANTY; without even
-the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-#include "vtkOSPRayVolumeRayCastMapper.h"
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-#include "ospray/volume/BlockBrickedVolume.h"
-
-#include "vtkCamera.h"
-#include "vtkDataArray.h"
-#include "vtkEncodedGradientEstimator.h"
-#include "vtkEncodedGradientShader.h"
-#include "vtkFiniteDifferenceGradientEstimator.h"
-#include "vtkGarbageCollector.h"
-#include "vtkGraphicsFactory.h"
-#include "vtkImageData.h"
-#include "vtkMath.h"
-#include "vtkMultiThreader.h"
-#include "vtkObjectFactory.h"
-#include "vtkPlaneCollection.h"
-#include "vtkPointData.h"
-#include "vtkRenderWindow.h"
-#include "vtkRenderer.h"
-#include "vtkTimerLog.h"
-#include "vtkTransform.h"
-#include "vtkVolumeProperty.h"
-#include "vtkVolumeRayCastFunction.h"
-#include "vtkRayCastImageDisplayHelper.h"
-#include "vtkStreamingDemandDrivenPipeline.h"
-#include "vtkColorTransferFunction.h"
-#include "vtkPiecewiseFunction.h"
-#include "vtkTimerLog.h"
-#include "vtkInformation.h"
-#include "vtkInformationVector.h"
-#include "vtkInformation.h"
-#include "vtkInformationDoubleKey.h"
-#include "vtkInformationDoubleVectorKey.h"
-
-#include "vtkOSPRayRenderer.h"
-#include "vtkOSPRayManager.h"
-
-#include <math.h>
-
-#include <DebugStream.h>
-
-vtkStandardNewMacro(vtkOSPRayVolumeRayCastMapper);
-
-vtkCxxSetObjectMacro(vtkOSPRayVolumeRayCastMapper,VolumeRayCastFunction,
-        vtkVolumeRayCastFunction );
-
-// A tolerance for bounds, historically equal to 2^(-23) and used
-// to counter a small numerical precision issue with the old
-// QuickFloor() function.  It should not be needed anymore.
-// #define VTK_RAYCAST_FLOOR_TOL 1.1920928955078125e-07
-#define VTK_RAYCAST_FLOOR_TOL 0
-
-#define vtkVRCMultiplyPointMacro( A, B, M ) \
-    B[0] = A[0]*M[0]  + A[1]*M[1]  + A[2]*M[2]  + M[3]; \
-B[1] = A[0]*M[4]  + A[1]*M[5]  + A[2]*M[6]  + M[7]; \
-B[2] = A[0]*M[8]  + A[1]*M[9]  + A[2]*M[10] + M[11]; \
-B[3] = A[0]*M[12] + A[1]*M[13] + A[2]*M[14] + M[15]; \
-if ( B[3] != 1.0 ) { B[0] /= B[3]; B[1] /= B[3]; B[2] /= B[3]; }
-
-#define vtkVRCMultiplyNormalMacro( A, B, M ) \
-    B[0] = A[0]*M[0]  + A[1]*M[4]  + A[2]*M[8]; \
-B[1] = A[0]*M[1]  + A[1]*M[5]  + A[2]*M[9]; \
-B[2] = A[0]*M[2]  + A[1]*M[6]  + A[2]*M[10]
-
-// Construct a new vtkOSPRayVolumeRayCastMapper with default values
-vtkOSPRayVolumeRayCastMapper::vtkOSPRayVolumeRayCastMapper()
-{
-    this->VolumeAdded=false;
-    this->NumColors = 128;
-    this->SampleDistance             =  1.0;
-    this->ImageSampleDistance        =  1.0;
-    this->MinimumImageSampleDistance =  1.0;
-    this->MaximumImageSampleDistance = 10.0;
-    this->AutoAdjustSampleDistances  =  1;
-    this->VolumeRayCastFunction      = NULL;
-
-    this->GradientEstimator  = vtkFiniteDifferenceGradientEstimator::New();
-    this->GradientShader     = vtkEncodedGradientShader::New();
-
-    this->PerspectiveMatrix      = vtkMatrix4x4::New();
-    this->ViewToWorldMatrix      = vtkMatrix4x4::New();
-    this->ViewToVoxelsMatrix     = vtkMatrix4x4::New();
-    this->VoxelsToViewMatrix     = vtkMatrix4x4::New();
-    this->WorldToVoxelsMatrix    = vtkMatrix4x4::New();
-    this->VoxelsToWorldMatrix    = vtkMatrix4x4::New();
-
-    this->VolumeMatrix           = vtkMatrix4x4::New();
-
-    this->PerspectiveTransform   = vtkTransform::New();
-    this->VoxelsTransform        = vtkTransform::New();
-    this->VoxelsToViewTransform  = vtkTransform::New();
-
-
-    this->ImageMemorySize[0]     = 0;
-    this->ImageMemorySize[1]     = 0;
-
-    this->Threader               = vtkMultiThreader::New();
-
-    this->Image                  = NULL;
-    this->RowBounds              = NULL;
-    this->OldRowBounds           = NULL;
-
-    this->RenderTimeTable        = NULL;
-    this->RenderVolumeTable      = NULL;
-    this->RenderRendererTable    = NULL;
-    this->RenderTableSize        = 0;
-    this->RenderTableEntries     = 0;
-
-    this->ZBuffer                = NULL;
-    this->ZBufferSize[0]         = 0;
-    this->ZBufferSize[1]         = 0;
-    this->ZBufferOrigin[0]       = 0;
-    this->ZBufferOrigin[1]       = 0;
-
-    this->ImageDisplayHelper     = vtkRayCastImageDisplayHelper::New();
-
-    this->IntermixIntersectingGeometry = 1;
-
-    this->OSPRayManager = vtkOSPRayManager::Singleton();
-
-    this->SharedData = false;
-    if (SharedData)
-        OSPRayVolume = ospNewVolume("shared_structured_volume");
-    else
-        OSPRayVolume = ospNewVolume("block_bricked_volume");
-    transferFunction = ospNewTransferFunction("piecewise_linear");
-    ospCommit(transferFunction);
-    SamplingRate=0.25;
-}
-
-// Destruct a vtkOSPRayVolumeRayCastMapper - clean up any memory used
-vtkOSPRayVolumeRayCastMapper::~vtkOSPRayVolumeRayCastMapper()
-{
-    if ( this->GradientEstimator )
-    {
-        this->GradientEstimator->UnRegister(this);
-        this->GradientEstimator = NULL;
-    }
-
-    this->GradientShader->Delete();
-
-    this->SetVolumeRayCastFunction(NULL);
-
-    this->PerspectiveMatrix->Delete();
-    this->ViewToWorldMatrix->Delete();
-    this->ViewToVoxelsMatrix->Delete();
-    this->VoxelsToViewMatrix->Delete();
-    this->WorldToVoxelsMatrix->Delete();
-    this->VoxelsToWorldMatrix->Delete();
-
-    this->VolumeMatrix->Delete();
-
-    this->VoxelsTransform->Delete();
-    this->VoxelsToViewTransform->Delete();
-    this->PerspectiveTransform->Delete();
-
-    this->ImageDisplayHelper->Delete();
-
-    this->Threader->Delete();
-
-    if ( this->Image )
-    {
-        delete [] this->Image;
-    }
-
-    if ( this->RenderTableSize )
-    {
-        delete [] this->RenderTimeTable;
-        delete [] this->RenderVolumeTable;
-        delete [] this->RenderRendererTable;
-    }
-
-    if ( this->RowBounds )
-    {
-        delete [] this->RowBounds;
-        delete [] this->OldRowBounds;
-    }
-}
-
-float vtkOSPRayVolumeRayCastMapper::RetrieveRenderTime( vtkRenderer *ren,
-        vtkVolume   *vol )
-{
-    int i;
-
-    for ( i = 0; i < this->RenderTableEntries; i++ )
-    {
-        if ( this->RenderVolumeTable[i] == vol &&
-                this->RenderRendererTable[i] == ren )
-        {
-            return this->RenderTimeTable[i];
-        }
-    }
-
-    return 0.0;
-}
-
-void vtkOSPRayVolumeRayCastMapper::StoreRenderTime( vtkRenderer *ren,
-        vtkVolume   *vol,
-        float       time )
-{
-    int i;
-    for ( i = 0; i < this->RenderTableEntries; i++ )
-    {
-        if ( this->RenderVolumeTable[i] == vol &&
-                this->RenderRendererTable[i] == ren )
-        {
-            this->RenderTimeTable[i] = time;
-            return;
-        }
-    }
-
-
-    // Need to increase size
-    if ( this->RenderTableEntries >= this->RenderTableSize )
-    {
-        if ( this->RenderTableSize == 0 )
-        {
-            this->RenderTableSize = 10;
-        }
-        else
-        {
-            this->RenderTableSize *= 2;
-        }
-
-        float       *oldTimePtr     = this->RenderTimeTable;
-        vtkVolume   **oldVolumePtr   = this->RenderVolumeTable;
-        vtkRenderer **oldRendererPtr = this->RenderRendererTable;
-
-        this->RenderTimeTable     = new float [this->RenderTableSize];
-        this->RenderVolumeTable   = new vtkVolume *[this->RenderTableSize];
-        this->RenderRendererTable = new vtkRenderer *[this->RenderTableSize];
-
-        for (i = 0; i < this->RenderTableEntries; i++ )
-        {
-            this->RenderTimeTable[i] = oldTimePtr[i];
-            this->RenderVolumeTable[i] = oldVolumePtr[i];
-            this->RenderRendererTable[i] = oldRendererPtr[i];
-        }
-
-        delete [] oldTimePtr;
-        delete [] oldVolumePtr;
-        delete [] oldRendererPtr;
-    }
-
-    this->RenderTimeTable[this->RenderTableEntries] = time;
-    this->RenderVolumeTable[this->RenderTableEntries] = vol;
-    this->RenderRendererTable[this->RenderTableEntries] = ren;
-
-    this->RenderTableEntries++;
-}
-
-void vtkOSPRayVolumeRayCastMapper::SetNumberOfThreads( int num )
-{
-    this->Threader->SetNumberOfThreads( num );
-}
-
-int vtkOSPRayVolumeRayCastMapper::GetNumberOfThreads()
-{
-    if (this->Threader)
-    {
-        return this->Threader->GetNumberOfThreads();
-    }
-    return 0;
-}
-
-void vtkOSPRayVolumeRayCastMapper::SetGradientEstimator(
-        vtkEncodedGradientEstimator *gradest )
-{
-
-    // If we are setting it to its current value, don't do anything
-    if ( this->GradientEstimator == gradest )
-    {
-        return;
-    }
-
-    // If we already have a gradient estimator, unregister it.
-    if ( this->GradientEstimator )
-    {
-        this->GradientEstimator->UnRegister(this);
-        this->GradientEstimator = NULL;
-    }
-
-    // If we are passing in a non-NULL estimator, register it
-    if ( gradest )
-    {
-        gradest->Register( this );
-    }
-
-    // Actually set the estimator, and consider the object Modified
-    this->GradientEstimator = gradest;
-    this->Modified();
-}
-
-float vtkOSPRayVolumeRayCastMapper::GetGradientMagnitudeScale()
-{
-    if ( !this->GradientEstimator )
-    {
-        vtkErrorMacro( "You must have a gradient estimator set to get the scale" );
-        return 1.0;
-    }
-
-    return this->GradientEstimator->GetGradientMagnitudeScale();
-}
-
-float vtkOSPRayVolumeRayCastMapper::GetGradientMagnitudeBias()
-{
-    if ( !this->GradientEstimator )
-    {
-        vtkErrorMacro( "You must have a gradient estimator set to get the bias" );
-        return 1.0;
-    }
-
-    return this->GradientEstimator->GetGradientMagnitudeBias();
-}
-
-void vtkOSPRayVolumeRayCastMapper::ReleaseGraphicsResources(vtkWindow *)
-{
-}
-
-void vtkOSPRayVolumeRayCastMapper::Render( vtkRenderer *ren, vtkVolume *vol )
-{
-    debug5 << "ALOK: beginning of vtkOSPRayVolumeRayCastMapper::Render" << endl;
-    // make sure that we have scalar input and update the scalar input
-    if ( this->GetInput() == NULL )
-    {
-        vtkErrorMacro(<< "No Input!");
-        return;
-    }
-    else
-    {
-        this->GetInputAlgorithm()->UpdateInformation();
-        vtkStreamingDemandDrivenPipeline::SetUpdateExtentToWholeExtent(
-                this->GetInputInformation());
-        this->GetInputAlgorithm()->Update();
-    }
-    // vol->UpdateTransferFunctions( ren );
-
-    //
-    // OSPRay
-    //
-
-    vtkOSPRayRenderer* OSPRayRenderer =
-        vtkOSPRayRenderer::SafeDownCast(ren);
-    if (!OSPRayRenderer)
-    {
-        debug5 << "ALOK: vtkOSPRayVolumeRayCastMapper::Render(): no OSPRayRenderer" << endl;
-        return;
-    }
-    debug5 << "ALOK: vtkOSPRayVolumeRayCastMapper::Render(): this->OSPRayManager=" << this->OSPRayManager << endl;
-    OSPRayModel = this->OSPRayManager->OSPRayVolumeModel;
-
-    OSPRenderer renderer = this->OSPRayManager->OSPRayVolumeRenderer;
-
-    vtkImageData *data = this->GetInput();
-    vtkDataArray * scalars = this->GetScalars(data, this->ScalarMode,
-            this->ArrayAccessMode, this->ArrayId, this->ArrayName, this->CellFlag);
-
-    void* ScalarDataPointer =
-        this->GetInput()->GetPointData()->GetScalars()->GetVoidPointer(0);
-    int ScalarDataType =
-        this->GetInput()->GetPointData()->GetScalars()->GetDataType();
-
-    int dim[3];
-    data->GetDimensions(dim);
-
-    //
-    // Cache timesteps
-    //
-    double timestep=-1;
-    vtkInformation *inputInfo = this->GetInput()->GetInformation();
-    // // std::cout << __PRETTY_FUNCTION__ << " (" << this << ") " << "actor: (" <<
-    // // OSPRayActor << ") mode: (" << OSPRayActor->OSPRayModel << ") " << std::endl;
-    if (inputInfo && inputInfo->Has(vtkDataObject::DATA_TIME_STEP()))
-    {
-        std::cerr << "has timestep\n";
-        timestep = inputInfo->Get(vtkDataObject::DATA_TIME_STEP());
-        std::cerr << "timestep time: " << timestep << std::endl;
-    }
-    vtkOSPRayVolumeCacheEntry* cacheEntry = Cache[vol][timestep];
-    if (!cacheEntry)
-    {
-        cacheEntry = new vtkOSPRayVolumeCacheEntry();
-        if (SharedData)
-            OSPRayVolume = ospNewVolume("shared_structured_volume");
-        else
-            OSPRayVolume = ospNewVolume("block_bricked_volume");
-        cacheEntry->Volume = OSPRayVolume;
-        Cache[vol][timestep] = cacheEntry;
-
-        //
-        // Send Volumetric data to OSPRay
-        //
-
-        char* buffer = NULL;
-        size_t sizeBytes =  (ScalarDataType == VTK_FLOAT) ? dim[0]*dim[1]*dim[2] *sizeof(float) : dim[0]*dim[1]*dim[2] *sizeof(char);
-
-        buffer = (char*)ScalarDataPointer;
-
-        ospSet3i(OSPRayVolume, "dimensions", dim[0], dim[1], dim[2]);
-        double origin[3];
-        vol->GetOrigin(origin);
-        double *bds = data->GetBounds();
-        origin[0] = bds[0];
-        origin[1] = bds[2];
-        origin[2] = bds[4];
-
-        double spacing[3];
-        data->GetSpacing(spacing);
-        ospSet3f(OSPRayVolume, "gridOrigin", origin[0], origin[1], origin[2]);
-        ospSet3f(OSPRayVolume, "gridSpacing", spacing[0],spacing[1],spacing[2]);
-        ospSetString(OSPRayVolume, "voxelType", (ScalarDataType == VTK_FLOAT) ? "float" : "uchar");
-        if (SharedData)
-        {
-            OSPData voxelData = ospNewData(sizeBytes, OSP_UCHAR, ScalarDataPointer, OSP_DATA_SHARED_BUFFER);
-            ospSetData(OSPRayVolume, "voxelData", voxelData);
-        }
-        else
-        {
-            ospSetRegion(OSPRayVolume, ScalarDataPointer, osp::vec3i(0,0,0), osp::vec3i(dim[0],dim[1],dim[2]));
-        }
-    }
-    OSPRayVolume = cacheEntry->Volume;
-
-    // test for modifications to volume properties
-    if (vol->GetProperty()->GetMTime() > PropertyTime)
-    {
-        OSPRayRenderer->SetClearAccumFlag();
-        vtkVolumeProperty* volProperty = vol->GetProperty();
-        vtkColorTransferFunction* colorTF = volProperty->GetRGBTransferFunction(0);
-        vtkPiecewiseFunction *scalarTF = volProperty->GetScalarOpacity(0);
-        int numNodes = colorTF->GetSize();
-        double* tfData = colorTF->GetDataPointer();
-
-        TFVals.resize(NumColors*3);
-        TFOVals.resize(NumColors);
-        scalarTF->GetTable(data->GetScalarRange()[0],data->GetScalarRange()[1], NumColors, &TFOVals[0]);
-        colorTF->GetTable(data->GetScalarRange()[0],data->GetScalarRange()[1], NumColors, &TFVals[0]);
-
-        OSPData colorData = ospNewData(NumColors, OSP_FLOAT3, &TFVals[0]);// TODO: memory leak?  does ospray manage this>
-        ospSetData(transferFunction, "colors", colorData);
-        OSPData tfAlphaData = ospNewData(NumColors, OSP_FLOAT, &TFOVals[0]);
-        ospSetData(transferFunction, "opacities", tfAlphaData);
-        ospCommit(transferFunction);
-        // this->SamplingRate = volProperty->GetSamplingRate();
-        ospSet1i(OSPRayVolume, "gradientShadingEnabled", volProperty->GetShade());
-        // std::cerr << "samplingRate: " << SamplingRate << std::endl;
-        // OSPRayRenderer->SetSamples(volProperty->GetSamples());
-        PropertyTime.Modified();
-    }
-
-    // test for modifications to input
-    if (this->GetInput()->GetMTime() > this->BuildTime)
-    {
-        // if (VolumeAdded)
-        // {
-        //   VolumeAdded=false;
-        // }
-        //! Create an OSPRay transfer function.
-
-        std::vector<float> isoValues;
-        if (this->GetInput()->GetPointData()->GetScalars("ospIsoValues"))
-        {
-            int num = this->GetInput()->GetPointData()->GetScalars("ospIsoValues")->GetComponent(0,0);
-            for( int i=0; i < num; i++)
-            {
-                float isoValue = this->GetInput()->GetPointData()->GetScalars("ospIsoValues")->GetComponent(0,i+1);
-                isoValues.push_back(isoValue);
-            }
-        }
-
-        if (isoValues.size())
-        {
-            OSPData isovaluesData = ospNewData(isoValues.size(), OSP_FLOAT, &isoValues[0]);
-            ospSetData(OSPRayVolume, "isovalues", isovaluesData);
-        }
-
-        if (this->GetInput()->GetPointData()->GetScalars("ospClipValues"))
-        {
-            float clipValue = this->GetInput()->GetPointData()->GetScalars("ospClipValues")->GetComponent(0,0);
-            int clipAxis = this->GetInput()->GetPointData()->GetScalars("ospClipValues")->GetComponent(0,1);
-
-            std::cout << "clipValue: " << clipValue << std::endl;
-            std::cout << "clipAxis: " << clipAxis << std::endl;
-            osp::vec3f upper(dim[0],dim[1],dim[2]);
-            if (clipAxis == 0)
-                upper.x = clipValue;
-            else if (clipAxis == 1)
-                upper.y = clipValue;
-            else if (clipAxis == 2)
-                upper.z = clipValue;
-            osp::box3f value(osp::vec3f(0,0,0), upper);
-            ospSet3fv(OSPRayVolume, "volumeClippingBoxLower", &value.lower.x);
-            ospSet3fv(OSPRayVolume, "volumeClippingBoxUpper", &value.upper.x);
-        }
-
-        ospSet2f(transferFunction, "valueRange", data->GetScalarRange()[0], data->GetScalarRange()[1]);
-
-        //! Commit the transfer function only after the initial colors and alphas have been set (workaround for Qt signalling issue).
-        ospCommit(transferFunction);
-
-        //TODO: manage memory
-
-        ospSetObject((OSPObject)OSPRayVolume, "transferFunction", transferFunction);
-        this->BuildTime.Modified();
-    }
-    ospSet1f(OSPRayVolume, "samplingRate", SamplingRate);
-    ospCommit(OSPRayVolume);
-    ospAddVolume(OSPRayModel,(OSPVolume)OSPRayVolume);
-    // if (!VolumeAdded)
-    // VolumeAdded = true;
-    ospCommit(OSPRayModel);
-    ospSetObject(renderer, "model", OSPRayModel);
-    ospCommit(renderer);
-    this->OSPRayManager->OSPRayVolumeModel = OSPRayModel;
-
-    OSPRayRenderer->SetHasVolume(true);
-    debug5 << "ALOK: end of vtkOSPRayVolumeRayCastMapper::Render" << endl;
-}
-
-double vtkOSPRayVolumeRayCastMapper::GetZBufferValue(int x, int y)
-{
-    int xPos, yPos;
-
-    xPos = static_cast<int>(static_cast<float>(x) * this->ImageSampleDistance);
-    yPos = static_cast<int>(static_cast<float>(y) * this->ImageSampleDistance);
-
-    xPos = (xPos >= this->ZBufferSize[0])?(this->ZBufferSize[0]-1):(xPos);
-    yPos = (yPos >= this->ZBufferSize[1])?(this->ZBufferSize[1]-1):(yPos);
-
-    return *(this->ZBuffer + yPos*this->ZBufferSize[0] + xPos);
-}
-
-int vtkOSPRayVolumeRayCastMapper::ComputeRowBounds(vtkVolume   *vol,
-        vtkRenderer *ren)
-{
-    float voxelPoint[3];
-    float viewPoint[8][4];
-    int i, j, k;
-    unsigned char *ucptr;
-    float minX, minY, maxX, maxY, minZ, maxZ;
-
-    minX =  1.0;
-    minY =  1.0;
-    maxX = -1.0;
-    maxY = -1.0;
-    minZ =  1.0;
-    maxZ =  0.0;
-
-    float bounds[6];
-    int dim[3];
-
-    this->GetInput()->GetDimensions(dim);
-    bounds[0] = bounds[2] = bounds[4] = 0.0;
-    bounds[1] = static_cast<float>(dim[0]-1) - VTK_RAYCAST_FLOOR_TOL;
-    bounds[3] = static_cast<float>(dim[1]-1) - VTK_RAYCAST_FLOOR_TOL;
-    bounds[5] = static_cast<float>(dim[2]-1) - VTK_RAYCAST_FLOOR_TOL;
-
-    double camPos[3];
-    double worldBounds[6];
-    vol->GetBounds( worldBounds );
-    int insideFlag = 0;
-    ren->GetActiveCamera()->GetPosition( camPos );
-    if ( camPos[0] >= worldBounds[0] &&
-            camPos[0] <= worldBounds[1] &&
-            camPos[1] >= worldBounds[2] &&
-            camPos[1] <= worldBounds[3] &&
-            camPos[2] >= worldBounds[4] &&
-            camPos[2] <= worldBounds[5] )
-    {
-        insideFlag = 1;
-    }
-
-
-    // If we have a simple crop box then we can tighten the bounds
-    // See prior explanation of RoundingTieBreaker
-    if ( this->Cropping && this->CroppingRegionFlags == 0x2000 )
-    {
-        bounds[0] = this->VoxelCroppingRegionPlanes[0];
-        bounds[1] = this->VoxelCroppingRegionPlanes[1] - VTK_RAYCAST_FLOOR_TOL;
-        bounds[2] = this->VoxelCroppingRegionPlanes[2];
-        bounds[3] = this->VoxelCroppingRegionPlanes[3] - VTK_RAYCAST_FLOOR_TOL;
-        bounds[4] = this->VoxelCroppingRegionPlanes[4];
-        bounds[5] = this->VoxelCroppingRegionPlanes[5] - VTK_RAYCAST_FLOOR_TOL;
-    }
-
-
-    // Copy the voxelsToView matrix to 16 floats
-    float voxelsToViewMatrix[16];
-    for ( j = 0; j < 4; j++ )
-    {
-        for ( i = 0; i < 4; i++ )
-        {
-            voxelsToViewMatrix[j*4+i] =
-                static_cast<float>(this->VoxelsToViewMatrix->GetElement(j,i));
-        }
-    }
-
-    // Convert the voxel bounds to view coordinates to find out the
-    // size and location of the image we need to generate.
-    int idx = 0;
-    if ( insideFlag )
-    {
-        minX = -1.0;
-        maxX =  1.0;
-        minY = -1.0;
-        maxY =  1.0;
-        minZ =  0.001;
-        maxZ =  0.001;
-    }
-    else
-    {
-        for ( k = 0; k < 2; k++ )
-        {
-            voxelPoint[2] = bounds[4+k];
-            for ( j = 0; j < 2; j++ )
-            {
-                voxelPoint[1] = bounds[2+j];
-                for ( i = 0; i < 2; i++ )
-                {
-                    voxelPoint[0] = bounds[i];
-                    vtkVRCMultiplyPointMacro( voxelPoint, viewPoint[idx],
-                            voxelsToViewMatrix );
-
-                    minX = (viewPoint[idx][0]<minX)?(viewPoint[idx][0]):(minX);
-                    minY = (viewPoint[idx][1]<minY)?(viewPoint[idx][1]):(minY);
-                    maxX = (viewPoint[idx][0]>maxX)?(viewPoint[idx][0]):(maxX);
-                    maxY = (viewPoint[idx][1]>maxY)?(viewPoint[idx][1]):(maxY);
-                    minZ = (viewPoint[idx][2]<minZ)?(viewPoint[idx][2]):(minZ);
-                    maxZ = (viewPoint[idx][2]>maxZ)?(viewPoint[idx][2]):(maxZ);
-                    idx++;
-                }
-            }
-        }
-    }
-
-    if ( minZ < 0.001 || maxZ > 0.9999 )
-    {
-        minX = -1.0;
-        maxX =  1.0;
-        minY = -1.0;
-        maxY =  1.0;
-        insideFlag = 1;
-    }
-
-    this->MinimumViewDistance =
-        (minZ<0.001)?(0.001):((minZ>0.999)?(0.999):(minZ));
-
-    // We have min/max values from -1.0 to 1.0 now - we want to convert
-    // these to pixel locations. Give a couple of pixels of breathing room
-    // on each side if possible
-    minX = ( minX + 1.0 ) * 0.5 * this->ImageViewportSize[0] - 2;
-    minY = ( minY + 1.0 ) * 0.5 * this->ImageViewportSize[1] - 2;
-    maxX = ( maxX + 1.0 ) * 0.5 * this->ImageViewportSize[0] + 2;
-    maxY = ( maxY + 1.0 ) * 0.5 * this->ImageViewportSize[1] + 2;
-
-    // If we are outside the view frustum return 0 - there is no need
-    // to render anything
-    if ( ( minX < 0 && maxX < 0 ) ||
-            ( minY < 0 && maxY < 0 ) ||
-            ( minX > this->ImageViewportSize[0]-1 &&
-              maxX > this->ImageViewportSize[0]-1 ) ||
-            ( minY > this->ImageViewportSize[1]-1 &&
-              maxY > this->ImageViewportSize[1]-1 ) )
-    {
-        return 0;
-    }
-
-    int oldImageMemorySize[2];
-    oldImageMemorySize[0] = this->ImageMemorySize[0];
-    oldImageMemorySize[1] = this->ImageMemorySize[1];
-
-    // Swap the row bounds
-    int *tmpptr;
-    tmpptr = this->RowBounds;
-    this->RowBounds = this->OldRowBounds;
-    this->OldRowBounds = tmpptr;
-
-
-    // Check the bounds - the volume might project outside of the
-    // viewing box / frustum so clip it if necessary
-    minX = (minX<0)?(0):(minX);
-    minY = (minY<0)?(0):(minY);
-    maxX = (maxX>this->ImageViewportSize[0]-1)?
-        (this->ImageViewportSize[0]-1):(maxX);
-    maxY = (maxY>this->ImageViewportSize[1]-1)?
-        (this->ImageViewportSize[1]-1):(maxY);
-
-    // Create the new image, and set its size and position
-    this->ImageInUseSize[0] = static_cast<int>(maxX - minX + 1.0);
-    this->ImageInUseSize[1] = static_cast<int>(maxY - minY + 1.0);
-
-    // What is a power of 2 size big enough to fit this image?
-    this->ImageMemorySize[0] = 32;
-    this->ImageMemorySize[1] = 32;
-    while ( this->ImageMemorySize[0] < this->ImageInUseSize[0] )
-    {
-        this->ImageMemorySize[0] *= 2;
-    }
-    while ( this->ImageMemorySize[1] < this->ImageInUseSize[1] )
-    {
-        this->ImageMemorySize[1] *= 2;
-    }
-
-    this->ImageOrigin[0] = static_cast<int>(minX);
-    this->ImageOrigin[1] = static_cast<int>(minY);
-
-    // If the old image size is much too big (more than twice in
-    // either direction) then set the old width to 0 which will
-    // cause the image to be recreated
-    if ( oldImageMemorySize[0] > 2*this->ImageMemorySize[0] ||
-            oldImageMemorySize[1] > 2*this->ImageMemorySize[1] )
-    {
-        oldImageMemorySize[0] = 0;
-    }
-
-    // If the old image is big enough (but not too big - we handled
-    // that above) then we'll bump up our required size to the
-    // previous one. This will keep us from thrashing.
-    if ( oldImageMemorySize[0] >= this->ImageMemorySize[0] &&
-            oldImageMemorySize[1] >= this->ImageMemorySize[1] )
-    {
-        this->ImageMemorySize[0] = oldImageMemorySize[0];
-        this->ImageMemorySize[1] = oldImageMemorySize[1];
-    }
-
-    // Do we already have a texture big enough? If not, create a new one and
-    // clear it.
-    if ( !this->Image ||
-            this->ImageMemorySize[0] > oldImageMemorySize[0] ||
-            this->ImageMemorySize[1] > oldImageMemorySize[1] )
-    {
-        // If there is an image there must be row bounds
-        if ( this->Image )
-        {
-            delete [] this->Image;
-            delete [] this->RowBounds;
-            delete [] this->OldRowBounds;
-        }
-
-        this->Image = new unsigned char[(this->ImageMemorySize[0] *
-                this->ImageMemorySize[1] * 4)];
-
-        // Create the row bounds array. This will store the start / stop pixel
-        // for each row. This helps eleminate work in areas outside the bounding
-        // hexahedron since a bounding box is not very tight. We keep the old ones
-        // too to help with only clearing where required
-        this->RowBounds = new int [2*this->ImageMemorySize[1]];
-        this->OldRowBounds = new int [2*this->ImageMemorySize[1]];
-
-        for ( i = 0; i < this->ImageMemorySize[1]; i++ )
-        {
-            this->RowBounds[i*2]      = this->ImageMemorySize[0];
-            this->RowBounds[i*2+1]    = -1;
-            this->OldRowBounds[i*2]   = this->ImageMemorySize[0];
-            this->OldRowBounds[i*2+1] = -1;
-        }
-
-        ucptr = this->Image;
-
-        for ( i = 0; i < this->ImageMemorySize[0]*this->ImageMemorySize[1]; i++ )
-        {
-            *(ucptr++) = 0;
-            *(ucptr++) = 0;
-            *(ucptr++) = 0;
-            *(ucptr++) = 0;
-        }
-    }
-
-    // If we are inside the volume our row bounds indicate every ray must be
-    // cast - we don't need to intersect with the 12 lines
-    if ( insideFlag )
-    {
-        for ( j = 0; j < this->ImageInUseSize[1]; j++ )
-        {
-            this->RowBounds[j*2] = 0;
-            this->RowBounds[j*2+1] = this->ImageInUseSize[0] - 1;
-        }
-    }
-    else
-    {
-        // create an array of lines where the y value of the first vertex is less
-        // than or equal to the y value of the second vertex. There are 12 lines,
-        // each containing x1, y1, x2, y2 values.
-        float lines[12][4];
-        float x1, y1, x2, y2;
-        int xlow, xhigh;
-        int lineIndex[12][2] = {{0,1}, {2,3}, {4,5}, {6,7},
-            {0,2}, {1,3} ,{4,6}, {5,7},
-            {0,4}, {1,5}, {2,6}, {3,7}};
-
-        for ( i = 0; i < 12; i++ )
-        {
-            x1 = (viewPoint[lineIndex[i][0]][0]+1.0) *
-                0.5*this->ImageViewportSize[0] - this->ImageOrigin[0];
-
-            y1 = (viewPoint[lineIndex[i][0]][1]+1.0) *
-                0.5*this->ImageViewportSize[1] - this->ImageOrigin[1];
-
-            x2 = (viewPoint[lineIndex[i][1]][0]+1.0) *
-                0.5*this->ImageViewportSize[0] - this->ImageOrigin[0];
-
-            y2 = (viewPoint[lineIndex[i][1]][1]+1.0) *
-                0.5*this->ImageViewportSize[1] - this->ImageOrigin[1];
-
-            if ( y1 < y2 )
-            {
-                lines[i][0] = x1;
-                lines[i][1] = y1;
-                lines[i][2] = x2;
-                lines[i][3] = y2;
-            }
-            else
-            {
-                lines[i][0] = x2;
-                lines[i][1] = y2;
-                lines[i][2] = x1;
-                lines[i][3] = y1;
-            }
-        }
-
-        // Now for each row in the image, find out the start / stop pixel
-        // If min > max, then no intersection occurred
-        for ( j = 0; j < this->ImageInUseSize[1]; j++ )
-        {
-            this->RowBounds[j*2] = this->ImageMemorySize[0];
-            this->RowBounds[j*2+1] = -1;
-            for ( i = 0; i < 12; i++ )
-            {
-                if ( j >= lines[i][1] && j <= lines[i][3] &&
-                        ( lines[i][1] != lines[i][3] ) )
-                {
-                    x1 = lines[i][0] +
-                        (static_cast<float>(j) - lines[i][1])/(lines[i][3] - lines[i][1]) *
-                        (lines[i][2] - lines[i][0] );
-
-                    xlow  = static_cast<int>(x1 + 1.5);
-                    xhigh = static_cast<int>(x1 - 1.0);
-
-                    xlow = (xlow<0)?(0):(xlow);
-                    xlow = (xlow>this->ImageInUseSize[0]-1)?
-                        (this->ImageInUseSize[0]-1):(xlow);
-
-                    xhigh = (xhigh<0)?(0):(xhigh);
-                    xhigh = (xhigh>this->ImageInUseSize[0]-1)?(
-                            this->ImageInUseSize[0]-1):(xhigh);
-
-                    if ( xlow < this->RowBounds[j*2] )
-                    {
-                        this->RowBounds[j*2] = xlow;
-                    }
-                    if ( xhigh > this->RowBounds[j*2+1] )
-                    {
-                        this->RowBounds[j*2+1] = xhigh;
-                    }
-                }
-            }
-            // If they are the same this is either a point on the cube or
-            // all lines were out of bounds (all on one side or the other)
-            // It is safe to ignore the point (since the ray isn't likely
-            // to travel through it enough to actually take a sample) and it
-            // must be ignored in the case where all lines are out of range
-            if ( this->RowBounds[j*2] == this->RowBounds[j*2+1] )
-            {
-                this->RowBounds[j*2] = this->ImageMemorySize[0];
-                this->RowBounds[j*2+1] = -1;
-            }
-        }
-    }
-
-    for ( j = this->ImageInUseSize[1]; j < this->ImageMemorySize[1]; j++ )
-    {
-        this->RowBounds[j*2] = this->ImageMemorySize[0];
-        this->RowBounds[j*2+1] = -1;
-    }
-
-    for ( j = 0; j < this->ImageMemorySize[1]; j++ )
-    {
-        // New bounds are not overlapping with old bounds - clear between
-        // old bounds only
-        if ( this->RowBounds[j*2+1] < this->OldRowBounds[j*2] ||
-                this->RowBounds[j*2]   > this->OldRowBounds[j*2+1] )
-        {
-            ucptr = this->Image + 4*( j*this->ImageMemorySize[0] +
-                    this->OldRowBounds[j*2] );
-            for ( i = 0;
-                    i <= (this->OldRowBounds[j*2+1] - this->OldRowBounds[j*2]);
-                    i++ )
-            {
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-            }
-        }
-        // New bounds do overlap with old bounds
-        else
-        {
-            // Clear from old min to new min
-            ucptr = this->Image + 4*( j*this->ImageMemorySize[0] +
-                    this->OldRowBounds[j*2] );
-            for ( i = 0;
-                    i < (this->RowBounds[j*2] - this->OldRowBounds[j*2]);
-                    i++ )
-            {
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-            }
-
-            // Clear from new max to old max
-            ucptr = this->Image + 4*( j*this->ImageMemorySize[0] +
-                    this->RowBounds[j*2+1]+1 );
-            for ( i = 0;
-                    i < (this->OldRowBounds[j*2+1] - this->RowBounds[j*2+1]);
-                    i++ )
-            {
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-                *(ucptr++) = 0;
-            }
-
-        }
-    }
-
-    return 1;
-}
-
-
-void vtkOSPRayVolumeRayCastMapper::ComputeMatrices( vtkImageData *data,
-        vtkVolume *vol )
-{
-    // Get the data spacing. This scaling is not accounted for in
-    // the volume's matrix, so we must add it in.
-    double volumeSpacing[3];
-    data->GetSpacing( volumeSpacing );
-
-    // Get the origin of the data.  This translation is not accounted for in
-    // the volume's matrix, so we must add it in.
-    float volumeOrigin[3];
-    double *bds = data->GetBounds();
-    volumeOrigin[0] = bds[0];
-    volumeOrigin[1] = bds[2];
-    volumeOrigin[2] = bds[4];
-
-    // Get the dimensions of the data.
-    int volumeDimensions[3];
-    data->GetDimensions( volumeDimensions );
-
-    vtkTransform *voxelsTransform = this->VoxelsTransform;
-    vtkTransform *voxelsToViewTransform = this->VoxelsToViewTransform;
-
-    // Get the volume matrix. This is a volume to world matrix right now.
-    // We'll need to invert it, translate by the origin and scale by the
-    // spacing to change it to a world to voxels matrix.
-    this->VolumeMatrix->DeepCopy( vol->GetMatrix() );
-    voxelsToViewTransform->SetMatrix( VolumeMatrix );
-
-    // Create a transform that will account for the scaling and translation of
-    // the scalar data. The is the volume to voxels matrix.
-    voxelsTransform->Identity();
-    voxelsTransform->Translate(volumeOrigin[0],
-            volumeOrigin[1],
-            volumeOrigin[2] );
-
-    voxelsTransform->Scale( volumeSpacing[0],
-            volumeSpacing[1],
-            volumeSpacing[2] );
-
-    // Now concatenate the volume's matrix with this scalar data matrix
-    voxelsToViewTransform->PreMultiply();
-    voxelsToViewTransform->Concatenate( voxelsTransform->GetMatrix() );
-
-    // Now we actually have the world to voxels matrix - copy it out
-    this->WorldToVoxelsMatrix->DeepCopy( voxelsToViewTransform->GetMatrix() );
-    this->WorldToVoxelsMatrix->Invert();
-
-    // We also want to invert this to get voxels to world
-    this->VoxelsToWorldMatrix->DeepCopy( voxelsToViewTransform->GetMatrix() );
-
-    // Compute the voxels to view transform by concatenating the
-    // voxels to world matrix with the projection matrix (world to view)
-    voxelsToViewTransform->PostMultiply();
-    voxelsToViewTransform->Concatenate( this->PerspectiveMatrix );
-
-    this->VoxelsToViewMatrix->DeepCopy( voxelsToViewTransform->GetMatrix() );
-
-    this->ViewToVoxelsMatrix->DeepCopy( this->VoxelsToViewMatrix );
-    this->ViewToVoxelsMatrix->Invert();
-}
-
-void vtkOSPRayVolumeRayCastMapper::InitializeClippingPlanes(
-        vtkVolumeRayCastStaticInfo *staticInfo,
-        vtkPlaneCollection *planes )
-{
-    vtkPlane *onePlane;
-    double    worldNormal[3], worldOrigin[3];
-    double    volumeOrigin[4];
-    int      i;
-    float    *worldToVoxelsMatrix;
-    float    *voxelsToWorldMatrix;
-    int      count;
-    float    *clippingPlane;
-    float    t;
-
-    count = planes->GetNumberOfItems();
-    staticInfo->NumberOfClippingPlanes = count;
-
-    if ( !count )
-    {
-        return;
-    }
-
-    worldToVoxelsMatrix = staticInfo->WorldToVoxelsMatrix;
-    voxelsToWorldMatrix = staticInfo->VoxelsToWorldMatrix;
-
-    staticInfo->ClippingPlane = new float [4*count];
-
-    // loop through all the clipping planes
-    for ( i = 0; i < count; i++ )
-    {
-        onePlane = static_cast<vtkPlane *>(planes->GetItemAsObject(i));
-        onePlane->GetNormal(worldNormal);
-        onePlane->GetOrigin(worldOrigin);
-        clippingPlane = staticInfo->ClippingPlane + 4*i;
-        vtkVRCMultiplyNormalMacro( worldNormal,
-                clippingPlane,
-                voxelsToWorldMatrix );
-        vtkVRCMultiplyPointMacro( worldOrigin, volumeOrigin,
-                worldToVoxelsMatrix );
-
-        t = sqrt( clippingPlane[0]*clippingPlane[0] +
-                clippingPlane[1]*clippingPlane[1] +
-                clippingPlane[2]*clippingPlane[2] );
-        if ( t )
-        {
-            clippingPlane[0] /= t;
-            clippingPlane[1] /= t;
-            clippingPlane[2] /= t;
-        }
-
-        clippingPlane[3] = -(clippingPlane[0]*volumeOrigin[0] +
-                clippingPlane[1]*volumeOrigin[1] +
-                clippingPlane[2]*volumeOrigin[2]);
-    }
-}
-
-
-int vtkOSPRayVolumeRayCastMapper::ClipRayAgainstClippingPlanes(
-        vtkVolumeRayCastDynamicInfo *dynamicInfo,
-        vtkVolumeRayCastStaticInfo *staticInfo )
-{
-    float    *clippingPlane;
-    int      i;
-    float    rayDir[3];
-    float    t, point[3], dp;
-    float    *rayStart, *rayEnd;
-
-    rayStart = dynamicInfo->TransformedStart;
-    rayEnd = dynamicInfo->TransformedEnd;
-
-    rayDir[0] = rayEnd[0] - rayStart[0];
-    rayDir[1] = rayEnd[1] - rayStart[1];
-    rayDir[2] = rayEnd[2] - rayStart[2];
-
-    // loop through all the clipping planes
-    for ( i = 0; i < staticInfo->NumberOfClippingPlanes; i++ )
-    {
-        clippingPlane = staticInfo->ClippingPlane + 4*i;
-
-        dp =
-            clippingPlane[0]*rayDir[0] +
-            clippingPlane[1]*rayDir[1] +
-            clippingPlane[2]*rayDir[2];
-
-        if ( dp != 0.0 )
-        {
-            t =
-                -( clippingPlane[0]*rayStart[0] +
-                        clippingPlane[1]*rayStart[1] +
-                        clippingPlane[2]*rayStart[2] + clippingPlane[3]) / dp;
-
-            if ( t > 0.0 && t < 1.0 )
-            {
-                point[0] = rayStart[0] + t*rayDir[0];
-                point[1] = rayStart[1] + t*rayDir[1];
-                point[2] = rayStart[2] + t*rayDir[2];
-
-                if ( dp > 0.0 )
-                {
-                    rayStart[0] = point[0];
-                    rayStart[1] = point[1];
-                    rayStart[2] = point[2];
-                }
-                else
-                {
-                    rayEnd[0] = point[0];
-                    rayEnd[1] = point[1];
-                    rayEnd[2] = point[2];
-                }
-
-                rayDir[0] = rayEnd[0] - rayStart[0];
-                rayDir[1] = rayEnd[1] - rayStart[1];
-                rayDir[2] = rayEnd[2] - rayStart[2];
-
-            }
-            // If the clipping plane is outside the ray segment, then
-            // figure out if that means the ray segment goes to zero (if so
-            // return 0) or doesn't affect it (if so do nothing)
-            else
-            {
-                if ( dp >= 0.0 && t >= 1.0 )
-                {
-                    return 0;
-                }
-                if ( dp <= 0.0 && t <= 0.0 )
-                {
-                    return 0;
-                }
-            }
-        }
-    }
-
-    return 1;
-}
-
-int vtkOSPRayVolumeRayCastMapper::ClipRayAgainstVolume(
-        vtkVolumeRayCastDynamicInfo *dynamicInfo,
-        float bounds[6] )
-{
-    int    loop;
-    float  diff;
-    float  t;
-    float  *rayStart, *rayEnd, *rayDirection;
-
-    rayStart     = dynamicInfo->TransformedStart;
-    rayEnd       = dynamicInfo->TransformedEnd;
-    rayDirection = dynamicInfo->TransformedDirection;
-
-    if ( rayStart[0] >= bounds[1] ||
-            rayStart[1] >= bounds[3] ||
-            rayStart[2] >= bounds[5] ||
-            rayStart[0] < bounds[0] ||
-            rayStart[1] < bounds[2] ||
-            rayStart[2] < bounds[4] )
-    {
-        for ( loop = 0; loop < 3; loop++ )
-        {
-            diff = 0;
-
-            if ( rayStart[loop] < (bounds[2*loop]+0.01) )
-            {
-                diff = (bounds[2*loop]+0.01) - rayStart[loop];
-            }
-            else if ( rayStart[loop] > (bounds[2*loop+1]-0.01) )
-            {
-                diff = (bounds[2*loop+1]-0.01) - rayStart[loop];
-            }
-
-            if ( diff )
-            {
-                if ( rayDirection[loop] != 0.0 )
-                {
-                    t = diff / rayDirection[loop];
-                }
-                else
-                {
-                    t = -1.0;
-                }
-
-                if ( t > 0.0 )
-                {
-                    rayStart[0] += rayDirection[0] * t;
-                    rayStart[1] += rayDirection[1] * t;
-                    rayStart[2] += rayDirection[2] * t;
-                }
-            }
-        }
-    }
-
-    // If the voxel still isn't inside the volume, then this ray
-    // doesn't really intersect the volume
-
-    if ( rayStart[0] >= bounds[1] ||
-            rayStart[1] >= bounds[3] ||
-            rayStart[2] >= bounds[5] ||
-            rayStart[0] < bounds[0] ||
-            rayStart[1] < bounds[2] ||
-            rayStart[2] < bounds[4] )
-    {
-        return 0;
-    }
-
-    // The ray does intersect the volume, and we have a starting
-    // position that is inside the volume
-    if ( rayEnd[0] >= bounds[1] ||
-            rayEnd[1] >= bounds[3] ||
-            rayEnd[2] >= bounds[5] ||
-            rayEnd[0] < bounds[0] ||
-            rayEnd[1] < bounds[2] ||
-            rayEnd[2] < bounds[4] )
-    {
-        for ( loop = 0; loop < 3; loop++ )
-        {
-            diff = 0;
-
-            if ( rayEnd[loop] < (bounds[2*loop]+0.01) )
-            {
-                diff = (bounds[2*loop]+0.01) - rayEnd[loop];
-            }
-            else if ( rayEnd[loop] > (bounds[2*loop+1]-0.01) )
-            {
-                diff = (bounds[2*loop+1]-0.01) - rayEnd[loop];
-            }
-
-            if ( diff )
-            {
-                if ( rayDirection[loop] != 0.0 )
-                {
-                    t = diff / rayDirection[loop];
-                }
-                else
-                {
-                    t = 1.0;
-                }
-
-                if ( t < 0.0 )
-                {
-                    rayEnd[0] += rayDirection[0] * t;
-                    rayEnd[1] += rayDirection[1] * t;
-                    rayEnd[2] += rayDirection[2] * t;
-                }
-            }
-        }
-    }
-
-    // To be absolutely certain our ray remains inside the volume,
-    // recompute the ray direction (since it has changed - it is not
-    // normalized and therefore changes when start/end change) and move
-    // the start/end points in by 1/1000th of the distance.
-    float offset;
-    offset = (rayEnd[0] - rayStart[0])*0.001;
-    rayStart[0] += offset;
-    rayEnd[0]   -= offset;
-
-    offset = (rayEnd[1] - rayStart[1])*0.001;
-    rayStart[1] += offset;
-    rayEnd[1]   -= offset;
-
-    offset = (rayEnd[2] - rayStart[2])*0.001;
-    rayStart[2] += offset;
-    rayEnd[2]   -= offset;
-
-    if ( rayEnd[0] >= bounds[1] ||
-            rayEnd[1] >= bounds[3] ||
-            rayEnd[2] >= bounds[5] ||
-            rayEnd[0] < bounds[0] ||
-            rayEnd[1] < bounds[2] ||
-            rayEnd[2] < bounds[4] )
-    {
-        return 0;
-    }
-
-    return 1;
-}
-
-void vtkOSPRayVolumeRayCastMapper::UpdateShadingTables( vtkRenderer *ren,
-        vtkVolume *vol )
-{
-    int                   shading;
-    vtkVolumeProperty     *volume_property;
-
-    volume_property = vol->GetProperty();
-
-    shading = volume_property->GetShade();
-
-    this->GradientEstimator->SetInputData( this->GetInput() );
-
-    if ( shading )
-    {
-        this->GradientShader->UpdateShadingTable( ren, vol,
-                this->GradientEstimator );
-    }
-}
-
-float vtkOSPRayVolumeRayCastMapper::GetZeroOpacityThreshold( vtkVolume *vol )
-{
-    return( this->VolumeRayCastFunction->GetZeroOpacityThreshold( vol ) );
-}
-
-// Print method for vtkOSPRayVolumeRayCastMapper
-void vtkOSPRayVolumeRayCastMapper::PrintSelf(ostream& os, vtkIndent indent)
-{
-    this->Superclass::PrintSelf(os,indent);
-
-    os << indent << "Sample Distance: " << this->SampleDistance << "\n";
-    os << indent << "Image Sample Distance: "
-        << this->ImageSampleDistance << "\n";
-    os << indent << "Minimum Image Sample Distance: "
-        << this->MinimumImageSampleDistance << "\n";
-    os << indent << "Maximum Image Sample Distance: "
-        << this->MaximumImageSampleDistance << "\n";
-    os << indent << "Auto Adjust Sample Distances: "
-        << this->AutoAdjustSampleDistances << "\n";
-    os << indent << "Intermix Intersecting Geometry: "
-        << (this->IntermixIntersectingGeometry ? "On\n" : "Off\n");
-
-    if ( this->VolumeRayCastFunction )
-    {
-        os << indent << "Ray Cast Function: " << this->VolumeRayCastFunction<<"\n";
-    }
-    else
-    {
-        os << indent << "Ray Cast Function: (none)\n";
-    }
-
-    if ( this->GradientEstimator )
-    {
-        os << indent << "Gradient Estimator: " << (this->GradientEstimator) <<
-            endl;
-    }
-    else
-    {
-        os << indent << "Gradient Estimator: (none)" << endl;
-    }
-
-    if ( this->GradientShader )
-    {
-        os << indent << "Gradient Shader: " << (this->GradientShader) << endl;
-    }
-    else
-    {
-        os << indent << "Gradient Shader: (none)" << endl;
-    }
-
-}
-
-//----------------------------------------------------------------------------
-void vtkOSPRayVolumeRayCastMapper::ReportReferences(vtkGarbageCollector* collector)
-{
-    this->Superclass::ReportReferences(collector);
-    // These filters share our input and are therefore involved in a
-    // reference loop.
-    vtkGarbageCollectorReport(collector, this->GradientEstimator,
-            "GradientEstimator");
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.h
deleted file mode 100755
index 00b1a3998..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkOSPRayVolumeRayCastMapper.h
+++ /dev/null
@@ -1,315 +0,0 @@
-/*=========================================================================
-
-  Program:   Visualization Toolkit
-  Module:    vtkOSPRayVolumeRayCastMapper.h
-
-  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
-  All rights reserved.
-  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-
-// .NAME vtkOSPRayVolumeRayCastMapper - A slow but accurate mapper for rendering volumes
-// .SECTION Description
-// This is a software ray caster for rendering volumes in vtkImageData.
-
-// .SECTION see also
-// vtkVolumeMapper
-
- //
- // Carson: 6/18/2015: note that for Paraview 4.3 I had to modify
- //   ParaViewCore/VTKExtensions/Rendering/vtkPVLODVolume.h to not check
- //  for valid scalars before rendering volumetric data.
- //
-
-#ifndef __vtkOSPRayVolumeRayCastMapper_h
-#define __vtkOSPRayVolumeRayCastMapper_h
-
-// #include "vtkRenderingVolumeModule.h" // For export macro
-#include "vtkVolumeMapper.h"
-#include "vtkVolumeRayCastFunction.h" // For vtkVolumeRayCastStaticInfo
-                                      // and vtkVolumeRayCastDynamicInfo
-#include "vtkOSPRayModule.h"
-#include <vector>
-#include <map>
-
-
-
-namespace osp
-{
-  class Volume;
-  class Model;
-  class TransferFunction;
-}
-
-class vtkEncodedGradientEstimator;
-class vtkEncodedGradientShader;
-class vtkMatrix4x4;
-class vtkMultiThreader;
-class vtkPlaneCollection;
-class vtkRenderer;
-class vtkTimerLog;
-class vtkVolume;
-class vtkVolumeRayCastFunction;
-class vtkVolumeTransform;
-class vtkTransform;
-class vtkRayCastImageDisplayHelper;
-
-
-class vtkOSPRayManager;
-
-struct vtkOSPRayVolumeCacheEntry
-{
-  osp::Volume* Volume;
-  vtkTimeStamp BuildTime;
-};
-
-
-// Macro for tri-linear interpolation - do four linear interpolations on
-// edges, two linear interpolations between pairs of edges, then a final
-// interpolation between faces
-#define vtkTrilinFuncMacro(v,x,y,z,a,b,c,d,e,f,g,h)         \
-        t00 =   a + (x)*(b-a);      \
-        t01 =   c + (x)*(d-c);      \
-        t10 =   e + (x)*(f-e);      \
-        t11 =   g + (x)*(h-g);      \
-        t0  = t00 + (y)*(t01-t00);  \
-        t1  = t10 + (y)*(t11-t10);  \
-        v   =  t0 + (z)*(t1-t0);
-
-// Forward declaration needed for use by friend declaration below.
-VTK_THREAD_RETURN_TYPE OSPRayVolumeRayCastMapper_CastRays( void *arg );
-
-class VTKRENDERINGVOLUME_EXPORT vtkOSPRayVolumeRayCastMapper : public vtkVolumeMapper
-{
-public:
-  static vtkOSPRayVolumeRayCastMapper *New();
-  vtkTypeMacro(vtkOSPRayVolumeRayCastMapper,vtkVolumeMapper);
-  void PrintSelf( ostream& os, vtkIndent indent );
-
-  // Description:
-  // Set/Get the distance between samples.  This variable is only
-  // used for sampling ray casting methods.  Methods that compute
-  // a ray value by stepping cell-by-cell are not affected by this
-  // value.
-  vtkSetMacro( SampleDistance, double );
-  vtkGetMacro( SampleDistance, double );
-
-  // Description:
-  // Get / Set the volume ray cast function. This is used to process
-  // values found along the ray to compute a final pixel value.
-  virtual void SetVolumeRayCastFunction(vtkVolumeRayCastFunction*);
-  vtkGetObjectMacro( VolumeRayCastFunction, vtkVolumeRayCastFunction );
-
-  // Description:
-  // Set / Get the gradient estimator used to estimate normals
-  virtual void SetGradientEstimator(vtkEncodedGradientEstimator *gradest);
-  vtkGetObjectMacro( GradientEstimator, vtkEncodedGradientEstimator );
-
-  // Description:
-  // Get the gradient shader.
-  vtkGetObjectMacro( GradientShader, vtkEncodedGradientShader );
-
-  // Description:
-  // Sampling distance in the XY image dimensions. Default value of 1 meaning
-  // 1 ray cast per pixel. If set to 0.5, 4 rays will be cast per pixel. If
-  // set to 2.0, 1 ray will be cast for every 4 (2 by 2) pixels.
-  vtkSetClampMacro( ImageSampleDistance, double, 0.1, 100.0 );
-  vtkGetMacro( ImageSampleDistance, double );
-
-  // Description:
-  // This is the minimum image sample distance allow when the image
-  // sample distance is being automatically adjusted
-  vtkSetClampMacro( MinimumImageSampleDistance, double, 0.1, 100.0 );
-  vtkGetMacro( MinimumImageSampleDistance, double );
-
-  // Description:
-  // This is the maximum image sample distance allow when the image
-  // sample distance is being automatically adjusted
-  vtkSetClampMacro( MaximumImageSampleDistance, double, 0.1, 100.0 );
-  vtkGetMacro( MaximumImageSampleDistance, double );
-
-  // Description:
-  // If AutoAdjustSampleDistances is on, the the ImageSampleDistance
-  // will be varied to achieve the allocated render time of this
-  // prop (controlled by the desired update rate and any culling in
-  // use).
-  vtkSetClampMacro( AutoAdjustSampleDistances, int, 0, 1 );
-  vtkGetMacro( AutoAdjustSampleDistances, int );
-  vtkBooleanMacro( AutoAdjustSampleDistances, int );
-
-  // Description:
-  // Set/Get the number of threads to use. This by default is equal to
-  // the number of available processors detected.
-  void SetNumberOfThreads( int num );
-  int GetNumberOfThreads();
-  vtkSetMacro(SamplingRate, double);
-  vtkGetMacro(SamplingRate, double);
-
-  // Description:
-  // If IntermixIntersectingGeometry is turned on, the zbuffer will be
-  // captured and used to limit the traversal of the rays.
-  vtkSetClampMacro( IntermixIntersectingGeometry, int, 0, 1 );
-  vtkGetMacro( IntermixIntersectingGeometry, int );
-  vtkBooleanMacro( IntermixIntersectingGeometry, int );
-
-//BTX
-  // Description:
-  // WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE
-  // Initialize rendering for this volume.
-  void Render( vtkRenderer *, vtkVolume * );
-
-  // Description:
-  // WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE
-  // Release any graphics resources that are being consumed by this mapper.
-  // The parameter window could be used to determine which graphic
-  // resources to release.
-  void ReleaseGraphicsResources(vtkWindow *);
-
-  // Description:
-  // WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE
-  // Return the scalar value below which all opacities are zero
-  float GetZeroOpacityThreshold( vtkVolume *vol );
-
-  // Description:
-  // WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE
-  // Values needed by the volume
-  virtual float GetGradientMagnitudeScale();
-  virtual float GetGradientMagnitudeBias();
-  virtual float GetGradientMagnitudeScale(int)
-    {return this->GetGradientMagnitudeScale();};
-  virtual float GetGradientMagnitudeBias(int)
-    {return this->GetGradientMagnitudeBias();};
-
-//ETX
-
-protected:
-  vtkOSPRayVolumeRayCastMapper();
-  ~vtkOSPRayVolumeRayCastMapper();
-
-  vtkVolumeRayCastFunction     *VolumeRayCastFunction;
-  vtkEncodedGradientEstimator  *GradientEstimator;
-  vtkEncodedGradientShader     *GradientShader;
-  vtkRayCastImageDisplayHelper *ImageDisplayHelper;
-
-  virtual void ReportReferences(vtkGarbageCollector*);
-
-  // The distance between sample points along the ray
-  int CellFlag;
-  double                       SampleDistance;
-  double                       ImageSampleDistance;
-  double                       MinimumImageSampleDistance;
-  double                       MaximumImageSampleDistance;
-  int                          AutoAdjustSampleDistances;
-
-  double                       WorldSampleDistance;
-  int                          ScalarDataType;
-  void                         *ScalarDataPointer;
-
-  void                         UpdateShadingTables( vtkRenderer *ren,
-                                                    vtkVolume *vol );
-
-  void ComputeMatrices( vtkImageData *data, vtkVolume *vol );
-  int ComputeRowBounds( vtkVolume *vol, vtkRenderer *ren );
-
-  friend VTK_THREAD_RETURN_TYPE OSPRayVolumeRayCastMapper_CastRays( void *arg );
-
-  vtkMultiThreader  *Threader;
-
-  vtkMatrix4x4 *PerspectiveMatrix;
-  vtkMatrix4x4 *ViewToWorldMatrix;
-  vtkMatrix4x4 *ViewToVoxelsMatrix;
-  vtkMatrix4x4 *VoxelsToViewMatrix;
-  vtkMatrix4x4 *WorldToVoxelsMatrix;
-  vtkMatrix4x4 *VoxelsToWorldMatrix;
-
-  vtkMatrix4x4 *VolumeMatrix;
-
-  vtkTransform *PerspectiveTransform;
-  vtkTransform *VoxelsTransform;
-  vtkTransform *VoxelsToViewTransform;
-
-  // This is how big the image would be if it covered the entire viewport
-  int            ImageViewportSize[2];
-
-  // This is how big the allocated memory for image is. This may be bigger
-  // or smaller than ImageFullSize - it will be bigger if necessary to
-  // ensure a power of 2, it will be smaller if the volume only covers a
-  // small region of the viewport
-  int            ImageMemorySize[2];
-
-  // This is the size of subregion in ImageSize image that we are using for
-  // the current image. Since ImageSize is a power of 2, there is likely
-  // wasted space in it. This number will be used for things such as clearing
-  // the image if necessary.
-  int            ImageInUseSize[2];
-
-  // This is the location in ImageFullSize image where our ImageSize image
-  // is located.
-  int            ImageOrigin[2];
-
-  // This is the allocated image
-  unsigned char *Image;
-
-  int  *RowBounds;
-  int  *OldRowBounds;
-
-  float        *RenderTimeTable;
-  vtkVolume   **RenderVolumeTable;
-  vtkRenderer **RenderRendererTable;
-  int           RenderTableSize;
-  int           RenderTableEntries;
-
-  void StoreRenderTime( vtkRenderer *ren, vtkVolume *vol, float t );
-  float RetrieveRenderTime( vtkRenderer *ren, vtkVolume *vol );
-
-  int           IntermixIntersectingGeometry;
-
-  float        *ZBuffer;
-  int           ZBufferSize[2];
-  int           ZBufferOrigin[2];
-
-  float         MinimumViewDistance;
-
-  int           ClipRayAgainstVolume( vtkVolumeRayCastDynamicInfo *dynamicInfo,
-                                      float bounds[6] );
-
-  void          InitializeClippingPlanes( vtkVolumeRayCastStaticInfo *staticInfo,
-                                          vtkPlaneCollection *planes );
-
-  int           ClipRayAgainstClippingPlanes( vtkVolumeRayCastDynamicInfo *dynamicInfo,
-                                              vtkVolumeRayCastStaticInfo *staticInfo);
-
-  // Get the ZBuffer value corresponding to location (x,y) where (x,y)
-  // are indexing into the ImageInUse image. This must be converted to
-  // the zbuffer image coordinates. Nearest neighbor value is returned.
-  double         GetZBufferValue( int x, int y );
-
-//
-//OSPRay
-//
-
-
-  vtkOSPRayManager *OSPRayManager;
-  osp::Volume* OSPRayVolume;
-  osp::Model* OSPRayModel;
-  vtkTimeStamp  BuildTime,PropertyTime;
-  osp::TransferFunction* transferFunction;
-  int NumColors;
-  std::vector<float> TFVals, TFOVals;
-  bool SharedData;
-  bool VolumeAdded;
-  double SamplingRate;
-  std::map< vtkVolume*, std::map< double, vtkOSPRayVolumeCacheEntry* > > Cache;
-
-
-private:
-  vtkOSPRayVolumeRayCastMapper(const vtkOSPRayVolumeRayCastMapper&);  // Not implemented.
-  void operator=(const vtkOSPRayVolumeRayCastMapper&);  // Not implemented.
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayImageVolumeRepresentation.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayImageVolumeRepresentation.cxx
deleted file mode 100755
index 23dbe7ea0..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayImageVolumeRepresentation.cxx
+++ /dev/null
@@ -1,421 +0,0 @@
-/*=========================================================================
-
-Program:   ParaView
-Module:    vtkPVOSPRayImageVolumeRepresentation.cxx
-
-Copyright (c) Kitware, Inc.
-All rights reserved.
-See Copyright.txt or http://www.paraview.org/HTML/Copyright.html for details.
-
- This software is distributed WITHOUT ANY WARRANTY; without even
- the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-#include "vtkPVOSPRayImageVolumeRepresentation.h"
-
-#include "vtkAlgorithmOutput.h"
-#include "vtkCommand.h"
-#include "vtkExtentTranslator.h"
-#include "vtkImageData.h"
-#include "vtkInformation.h"
-#include "vtkInformationVector.h"
-#include "vtkMath.h"
-#include "vtkObjectFactory.h"
-#include "vtkOutlineSource.h"
-#include "vtkPolyDataMapper.h"
-#include "vtkPVCacheKeeper.h"
-#include "vtkPVLODVolume.h"
-#include "vtkPVRenderView.h"
-#include "vtkRenderer.h"
-#include "vtkSmartPointer.h"
-#include "vtkSmartVolumeMapper.h"
-#include "vtkStreamingDemandDrivenPipeline.h"
-#include "vtkVolumeProperty.h"
-#include "vtkAbstractVolumeMapper.h"
-#include "vtkPExtentTranslator.h"
-
-#include "vtkOSPRayVolumeRayCastMapper.h"
-#include "vtkOSPRayCompositeMapper.h"
-#include "vtkOSPRayLODActor.h"
-#include "vtkOSPRayActor.h"
-#include "vtkOSPRayPolyDataMapper.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkObjectFactory.h"
-#include "vtkVolumeProperty.h"
-#include "vtkPiecewiseFunction.h"
-#include "vtkOSPRayPVLODVolume.h"
-
-#include <map>
-#include <string>
-
-
-
- vtkStandardNewMacro(vtkPVOSPRayImageVolumeRepresentation);
-//----------------------------------------------------------------------------
- vtkPVOSPRayImageVolumeRepresentation::vtkPVOSPRayImageVolumeRepresentation()
- {
-  this->VolumeMapper = vtkOSPRayVolumeRayCastMapper::New();
-
-  this->Property = vtkVolumeProperty::New();
-
-  this->Actor = vtkOSPRayPVLODVolume::New();
-  this->Actor->SetProperty(this->Property);
-
-  this->CacheKeeper = vtkPVCacheKeeper::New();
-
-  this->OutlineSource = vtkOutlineSource::New();
-  this->OutlineMapper = vtkPolyDataMapper::New();
-
-  this->Cache = vtkImageData::New();
-
-  this->CacheKeeper->SetInputData(this->Cache);
-
-  vtkMath::UninitializeBounds(this->DataBounds);
-  this->DataSize = 0;
-
-  this->ColorArrayName = 0;
-  this->ColorAttributeType = POINT_DATA;
-}
-
-//----------------------------------------------------------------------------
-vtkPVOSPRayImageVolumeRepresentation::~vtkPVOSPRayImageVolumeRepresentation()
-{
-  this->VolumeMapper->Delete();
-  this->Property->Delete();
-  this->Actor->Delete();
-  this->OutlineSource->Delete();
-  this->OutlineMapper->Delete();
-  this->CacheKeeper->Delete();
-
-  this->Cache->Delete();
-}
-
-//----------------------------------------------------------------------------
-int vtkPVOSPRayImageVolumeRepresentation::FillInputPortInformation(
-  int, vtkInformation* info)
-{
-  info->Set(vtkAlgorithm::INPUT_REQUIRED_DATA_TYPE(), "vtkImageData");
-  info->Set(vtkAlgorithm::INPUT_IS_OPTIONAL(), 1);
-  return 1;
-}
-
-//----------------------------------------------------------------------------
-int vtkPVOSPRayImageVolumeRepresentation::ProcessViewRequest(
-  vtkInformationRequestKey* request_type,
-  vtkInformation* inInfo, vtkInformation* outInfo)
-{
-  if (!this->Superclass::ProcessViewRequest(request_type, inInfo, outInfo))
-  {
-    return 0;
-  }
-  if (request_type == vtkPVView::REQUEST_UPDATE())
-  {
-    vtkPVRenderView::SetPiece(inInfo, this,
-      this->OutlineSource->GetOutputDataObject(0),
-      this->DataSize);
-    outInfo->Set(vtkPVRenderView::NEED_ORDERED_COMPOSITING(), 1);
-
-    vtkPVRenderView::SetGeometryBounds(inInfo, this->DataBounds);
-
-    vtkPVOSPRayImageVolumeRepresentation::PassOrderedCompositingInformation(
-      this, inInfo);
-
-    vtkPVRenderView::SetRequiresDistributedRendering(inInfo, this, true);
-  }
-  else if (request_type == vtkPVView::REQUEST_UPDATE_LOD())
-  {
-    vtkPVRenderView::SetRequiresDistributedRenderingLOD(inInfo, this, true);
-  }
-  else if (request_type == vtkPVView::REQUEST_RENDER())
-  {
-    this->UpdateMapperParameters();
-
-    vtkAlgorithmOutput* producerPort = vtkPVRenderView::GetPieceProducer(inInfo, this);
-    if (producerPort)
-    {
-      this->OutlineMapper->SetInputConnection(producerPort);
-    }
-  }
-  return 1;
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::PassOrderedCompositingInformation(
-  vtkPVDataRepresentation* self, vtkInformation* inInfo)
-{
-  (void)inInfo;
-  if (self->GetNumberOfInputConnections(0) == 1)
-  {
-    vtkAlgorithmOutput* connection = self->GetInputConnection(0, 0);
-    vtkAlgorithm* inputAlgo = connection->GetProducer();
-    vtkStreamingDemandDrivenPipeline* sddp =
-    vtkStreamingDemandDrivenPipeline::SafeDownCast(inputAlgo->GetExecutive());
-
-    int extent[6] = {1, -1, 1, -1, 1, -1};
-    sddp->GetWholeExtent(sddp->GetOutputInformation(connection->GetIndex()),
-      extent);
-    double origin[3], spacing[3];
-    vtkImageData* image = vtkImageData::SafeDownCast(
-      inputAlgo->GetOutputDataObject(connection->GetIndex()));
-    if (!image)
-    {
-      std::cerr << "expected image data in vtkPVOSPRayImageVolumeRepresentation\n";
-      return;
-    }
-    image->GetOrigin(origin);
-    image->GetSpacing(spacing);
-
-    vtkNew<vtkPExtentTranslator> translator;
-    translator->GatherExtents(image);
-    vtkPVRenderView::SetOrderedCompositingInformation(
-      inInfo, self, translator.GetPointer(), extent, origin, spacing);
-  }
-}
-
-//----------------------------------------------------------------------------
-int vtkPVOSPRayImageVolumeRepresentation::RequestData(vtkInformation* request,
-  vtkInformationVector** inputVector, vtkInformationVector* outputVector)
-{
-  vtkMath::UninitializeBounds(this->DataBounds);
-  this->DataSize = 0;
-
-// Pass caching information to the cache keeper.
-  this->CacheKeeper->SetCachingEnabled(this->GetUseCache());
-  this->CacheKeeper->SetCacheTime(this->GetCacheKey());
-
-  if (inputVector[0]->GetNumberOfInformationObjects()==1)
-  {
-    vtkImageData* input = vtkImageData::GetData(inputVector[0], 0);
-    if (!this->GetUsingCacheForUpdate())
-    {
-      this->Cache->ShallowCopy(input);
-    }
-    this->CacheKeeper->Update();
-
-    this->Actor->SetEnableLOD(0);
-    this->VolumeMapper->SetInputConnection(
-      this->CacheKeeper->GetOutputPort());
-
-    this->OutlineSource->SetBounds(vtkImageData::SafeDownCast(
-      this->CacheKeeper->GetOutputDataObject(0))->GetBounds());
-    this->OutlineSource->GetBounds(this->DataBounds);
-    this->OutlineSource->Update();
-
-    this->DataSize = this->CacheKeeper->GetOutputDataObject(0)->GetActualMemorySize();
-  }
-  else
-  {
-// when no input is present, it implies that this processes is on a node
-// without the data input i.e. either client or render-server, in which case
-// we show only the outline.
-    this->VolumeMapper->RemoveAllInputs();
-//    this->Actor->SetEnableLOD(1);
-  }
-
-  return this->Superclass::RequestData(request, inputVector, outputVector);
-}
-
-//----------------------------------------------------------------------------
-bool vtkPVOSPRayImageVolumeRepresentation::IsCached(double cache_key)
-{
-  return this->CacheKeeper->IsCached(cache_key);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::MarkModified()
-{
-  if (!this->GetUseCache())
-  {
-// Cleanup caches when not using cache.
-    this->CacheKeeper->RemoveAllCaches();
-  }
-  this->Superclass::MarkModified();
-}
-
-//----------------------------------------------------------------------------
-bool vtkPVOSPRayImageVolumeRepresentation::AddToView(vtkView* view)
-{
-  vtkPVRenderView* rview = vtkPVRenderView::SafeDownCast(view);
-  if (rview)
-  {
-    rview->GetRenderer()->AddActor(this->Actor);
-    return true;
-  }
-  return false;
-}
-
-//----------------------------------------------------------------------------
-bool vtkPVOSPRayImageVolumeRepresentation::RemoveFromView(vtkView* view)
-{
-  vtkPVRenderView* rview = vtkPVRenderView::SafeDownCast(view);
-  if (rview)
-  {
-    rview->GetRenderer()->RemoveActor(this->Actor);
-    return true;
-  }
-  return false;
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::UpdateMapperParameters()
-{
-  const char* colorArrayName = NULL;
-  int fieldAssociation = vtkDataObject::FIELD_ASSOCIATION_POINTS;
-
-  vtkInformation *info = this->GetInputArrayInformation(0);
-  if (info &&
-    info->Has(vtkDataObject::FIELD_ASSOCIATION()) &&
-    info->Has(vtkDataObject::FIELD_NAME()))
-  {
-    colorArrayName = info->Get(vtkDataObject::FIELD_NAME());
-    fieldAssociation = info->Get(vtkDataObject::FIELD_ASSOCIATION());
-  }
-
-  this->VolumeMapper->SelectScalarArray(colorArrayName);
-  switch (fieldAssociation)
-  {
-    case vtkDataObject::FIELD_ASSOCIATION_CELLS:
-    this->VolumeMapper->SetScalarMode(VTK_SCALAR_MODE_USE_CELL_FIELD_DATA);
-    break;
-
-    case vtkDataObject::FIELD_ASSOCIATION_NONE:
-    this->VolumeMapper->SetScalarMode(VTK_SCALAR_MODE_USE_FIELD_DATA);
-    break;
-
-    case vtkDataObject::FIELD_ASSOCIATION_POINTS:
-    default:
-    this->VolumeMapper->SetScalarMode(VTK_SCALAR_MODE_USE_POINT_FIELD_DATA);
-    break;
-  }
-
-  vtkOSPRayVolumeRayCastMapper* ospMapper = vtkOSPRayVolumeRayCastMapper::SafeDownCast(this->VolumeMapper);
-  this->Actor->SetMapper(this->VolumeMapper);
-  this->Actor->SetVisibility(colorArrayName != NULL && colorArrayName[0] != 0);
-  this->Actor->SetVisibility(1);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os, indent);
-}
-
-
-//***************************************************************************
-// Forwarded to Actor.
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetOrientation(double x, double y, double z)
-{
-  this->Actor->SetOrientation(x, y, z);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetOrigin(double x, double y, double z)
-{
-  this->Actor->SetOrigin(x, y, z);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetPickable(int val)
-{
-  this->Actor->SetPickable(val);
-}
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetPosition(double x , double y, double z)
-{
-  this->Actor->SetPosition(x, y, z);
-}
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetScale(double x, double y, double z)
-{
-  this->Actor->SetScale(x, y, z);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetVisibility(bool val)
-{
-  this->Superclass::SetVisibility(val);
-  this->Actor->SetVisibility(val? 1 : 0);
-}
-
-//***************************************************************************
-// Forwarded to vtkVolumeProperty.
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetInterpolationType(int val)
-{
-  this->Property->SetInterpolationType(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetColor(vtkColorTransferFunction* lut)
-{
-  this->Property->SetColor(lut);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetScalarOpacity(vtkPiecewiseFunction* pwf)
-{
-  this->Property->SetScalarOpacity(pwf);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetScalarOpacity2(vtkPiecewiseFunction* pwf)
-{
-  this->Property->SetScalarOpacity(pwf);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetScalarOpacityUnitDistance(double val)
-{
-  this->Property->SetScalarOpacityUnitDistance(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetAmbient(double val)
-{
-  this->Property->SetAmbient(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetDiffuse(double val)
-{
-  this->Property->SetDiffuse(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetSpecular(double val)
-{
-  this->Property->SetSpecular(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetSpecularPower(double val)
-{
-  this->Property->SetSpecularPower(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetShade(bool val)
-{
-  this->Property->SetShade(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetIndependantComponents(bool val)
-{
-  this->Property->SetIndependentComponents(val);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayImageVolumeRepresentation::SetRequestedRenderMode(int mode)
-{
-}
-
-void vtkPVOSPRayImageVolumeRepresentation::SetSamplingRate(double sr)
-{
-  SamplingRate=sr;
-  vtkOSPRayVolumeRayCastMapper* ospMapper = vtkOSPRayVolumeRayCastMapper::SafeDownCast(this->VolumeMapper);
-  ospMapper->SetSamplingRate(sr);
-}
\ No newline at end of file
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayImageVolumeRepresentation.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayImageVolumeRepresentation.h
deleted file mode 100755
index 5a50a5764..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayImageVolumeRepresentation.h
+++ /dev/null
@@ -1,191 +0,0 @@
-/*=========================================================================
-
-  Program:   ParaView
-  Module:    vtkPVOSPRayImageVolumeRepresentation.h
-
-  Copyright (c) Kitware, Inc.
-  All rights reserved.
-  See Copyright.txt or http://www.paraview.org/HTML/Copyright.html for details.
-
-     This software is distributed WITHOUT ANY WARRANTY; without even
-     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-     PURPOSE.  See the above copyright notice for more information.
-
-=========================================================================*/
-// .NAME vtkPVOSPRayImageVolumeRepresentation - representation for showing image
-// datasets as a volume.
-// .SECTION Description
-// vtkPVOSPRayImageVolumeRepresentation is a representation for volume rendering
-// vtkImageData. Unlike other data-representations used by ParaView, this
-// representation does not support delivery to client (or render server) nodes.
-// In those configurations, it merely delivers a outline for the image to the
-// client and render-server and those nodes simply render the outline.
-
-#ifndef __vtkPVOSPRayImageVolumeRepresentation_h
-#define __vtkPVOSPRayImageVolumeRepresentation_h
-
-#include "vtkPVClientServerCoreRenderingModule.h" //needed for exports
-
-#include "vtkGeometryRepresentationWithFaces.h"
-#include "vtkPVDataRepresentation.h"
-
-class vtkColorTransferFunction;
-class vtkFixedPointVolumeRayCastMapper;
-class vtkImageData;
-class vtkOutlineSource;
-class vtkPiecewiseFunction;
-class vtkPolyDataMapper;
-class vtkPVCacheKeeper;
-class vtkPVLODVolume;
-class vtkAbstractVolumeMapper;
-class vtkSmartVolumeMapper;
-class vtkVolumeProperty;
-class vtkOSPRayPVLODVolume;
-
-
-class VTKPVCLIENTSERVERCORERENDERING_EXPORT vtkPVOSPRayImageVolumeRepresentation : public 
-vtkPVDataRepresentation
-{
-public:
-  static vtkPVOSPRayImageVolumeRepresentation* New();
-  vtkTypeMacro(vtkPVOSPRayImageVolumeRepresentation, vtkPVDataRepresentation);
-  void PrintSelf(ostream& os, vtkIndent indent);
-
-  // This is same a vtkDataObject::FieldAssociation types so you can use those
-  // as well.
-  enum AttributeTypes
-    {
-    POINT_DATA=0,
-    CELL_DATA=1
-    };
-
-  // Description:
-  // Methods to control scalar coloring. ColorAttributeType defines the
-  // attribute type.
-  vtkSetMacro(ColorAttributeType, int);
-  vtkGetMacro(ColorAttributeType, int);
-
-  // Description:
-  // Pick the array to color with.
-  vtkSetStringMacro(ColorArrayName);
-  vtkGetStringMacro(ColorArrayName);
-
-  virtual void SetRepresentation(const char*) {}
-
-  // Description:
-  // vtkAlgorithm::ProcessRequest() equivalent for rendering passes. This is
-  // typically called by the vtkView to request meta-data from the
-  // representations or ask them to perform certain tasks e.g.
-  // PrepareForRendering.
-  virtual int ProcessViewRequest(vtkInformationRequestKey* request_type,
-    vtkInformation* inInfo, vtkInformation* outInfo);
-
-  // Description:
-  // This needs to be called on all instances of vtkGeometryRepresentation when
-  // the input is modified. This is essential since the geometry filter does not
-  // have any real-input on the client side which messes with the Update
-  // requests.
-  virtual void MarkModified();
-
-  // Description:
-  // Get/Set the visibility for this representation. When the visibility of
-  // representation of false, all view passes are ignored.
-  virtual void SetVisibility(bool val);
-
-  //***************************************************************************
-  // Forwarded to Actor.
-  void SetOrientation(double, double, double);
-  void SetOrigin(double, double, double);
-  void SetPickable(int val);
-  void SetPosition(double, double, double);
-  void SetScale(double, double, double);
-
-  //***************************************************************************
-  // Forwarded to vtkVolumeProperty.
-  void SetInterpolationType(int val);
-  void SetColor(vtkColorTransferFunction* lut);
-  void SetScalarOpacity(vtkPiecewiseFunction* pwf);
-  void SetScalarOpacity2(vtkPiecewiseFunction* pwf);
-  void SetScalarOpacityUnitDistance(double val);
-  void SetAmbient(double);
-  void SetDiffuse(double);
-  void SetSpecular(double);
-  void SetSpecularPower(double);
-  void SetShade(bool);
-  void SetIndependantComponents(bool);
-
-  //***************************************************************************
-  // Forwarded to vtkSmartVolumeMapper.
-  void SetRequestedRenderMode(int);
-
-  // Description:
-  // Provides access to the actor used by this representation.
-  vtkOSPRayPVLODVolume* GetActor() { return this->Actor; }
-
-  // Description:
-  // Helper method to pass input image extent information to the view to use in
-  // determining the cuts for ordered compositing.
-  static void PassOrderedCompositingInformation(
-    vtkPVDataRepresentation* self, vtkInformation* inInfo);
-
-
-  //OSPRay specific values
-  void SetSamplingRate(double sr);
-  vtkGetMacro(SamplingRate,double);
-
-//BTX
-protected:
-  vtkPVOSPRayImageVolumeRepresentation();
-  ~vtkPVOSPRayImageVolumeRepresentation();
-
-  // Description:
-  // Fill input port information.
-  virtual int FillInputPortInformation(int port, vtkInformation* info);
-
-  // Description:
-  virtual int RequestData(vtkInformation*,
-    vtkInformationVector**, vtkInformationVector*);
-
-  // Description:
-  // Adds the representation to the view.  This is called from
-  // vtkView::AddRepresentation().  Subclasses should override this method.
-  // Returns true if the addition succeeds.
-  virtual bool AddToView(vtkView* view);
-
-  // Description:
-  // Removes the representation to the view.  This is called from
-  // vtkView::RemoveRepresentation().  Subclasses should override this method.
-  // Returns true if the removal succeeds.
-  virtual bool RemoveFromView(vtkView* view);
-
-  // Description:
-  // Overridden to check with the vtkPVCacheKeeper to see if the key is cached.
-  virtual bool IsCached(double cache_key);
-
-  // Description:
-  // Passes on parameters to the active volume mapper
-  virtual void UpdateMapperParameters();
-
-  vtkImageData* Cache;
-  vtkPVCacheKeeper* CacheKeeper;
-  vtkAbstractVolumeMapper* VolumeMapper;
-  vtkVolumeProperty* Property;
-  vtkOSPRayPVLODVolume* Actor;
-
-  vtkOutlineSource* OutlineSource;
-  vtkPolyDataMapper* OutlineMapper;;
-
-  int ColorAttributeType;
-  char* ColorArrayName;
-  unsigned long DataSize;
-  double DataBounds[6];
-  double SamplingRate;
-
-private:
-  vtkPVOSPRayImageVolumeRepresentation(const vtkPVOSPRayImageVolumeRepresentation&); // Not implemented
-  void operator=(const vtkPVOSPRayImageVolumeRepresentation&); // Not implemented
-
-//ETX
-};
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayOutlineRepresentation.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayOutlineRepresentation.cxx
deleted file mode 100755
index 7d0583949..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayOutlineRepresentation.cxx
+++ /dev/null
@@ -1,69 +0,0 @@
-/* ======================================================================================= 
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  
-   All rights reserved.
-                                                                                           
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     
-   except in compliance with the License.                                                  
-   A copy of the License is included with this software in the file LICENSE.               
-   If your copy does not contain the License, you may obtain a copy of the License at:     
-                                                                                           
-       http://opensource.org/licenses/BSD-3-Clause                                         
-                                                                                           
-   Unless required by applicable law or agreed to in writing, software distributed under   
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
-   KIND, either express or implied.                                                        
-   See the License for the specific language governing permissions and limitations under   
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "vtkPVOSPRayOutlineRepresentation.h"
-
-#include "vtkCompositePolyDataMapper2.h"
-#include "vtkInformation.h"
-#include "vtkOSPRayCompositeMapper.h"
-#include "vtkOSPRayLODActor.h"
-#include "vtkOSPRayPolyDataMapper.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkObjectFactory.h"
-
-#include "vtkOutlineRepresentation.h"
-
-#include "vtkObjectFactory.h"
-#include "vtkPVGeometryFilter.h"
-
-//-----------------------------------------------------------------------------
-vtkStandardNewMacro(vtkPVOSPRayOutlineRepresentation);
-
-
-//-----------------------------------------------------------------------------
-vtkPVOSPRayOutlineRepresentation::vtkPVOSPRayOutlineRepresentation()
-: vtkPVOSPRayRepresentation()
-{
-
-    this->SetUseOutline(1);
-
-
-  this->SetAmbient(1);
-  this->SetDiffuse(0);
-  this->SetSpecular(0);
-
-  // you cannot select the outline!
-  this->SetPickable(0);
-
-  this->SetSuppressLOD(1);
-  this->SetRepresentation(WIREFRAME);
-}
-
-//-----------------------------------------------------------------------------
-vtkPVOSPRayOutlineRepresentation::~vtkPVOSPRayOutlineRepresentation()
-{
-}
-
-//-----------------------------------------------------------------------------
-void vtkPVOSPRayOutlineRepresentation::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os, indent);
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayOutlineRepresentation.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayOutlineRepresentation.h
deleted file mode 100755
index 4c42cbd1a..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayOutlineRepresentation.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/* ======================================================================================= 
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  
-   All rights reserved.
-                                                                                           
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     
-   except in compliance with the License.                                                  
-   A copy of the License is included with this software in the file LICENSE.               
-   If your copy does not contain the License, you may obtain a copy of the License at:     
-                                                                                           
-       http://opensource.org/licenses/BSD-3-Clause                                         
-                                                                                           
-   Unless required by applicable law or agreed to in writing, software distributed under   
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
-   KIND, either express or implied.                                                        
-   See the License for the specific language governing permissions and limitations under   
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkPVOSPRayOutlineRepresentation - representation for OSPRay views
-// .SECTION Description
-// This replaces the GL mapper, actor and property for a display pipline
-// with the OSPRay versions of those so that the object can be drawn
-// in an OSPRay renderer within a pvOSPRay view
-
-#ifndef __vtkPVOSPRayOutlineRepresentation_h
-#define __vtkPVOSPRayOutlineRepresentation_h
-
-#include "vtkPVOSPRayRepresentation.h"
-#include "vtkGeometryRepresentationWithFaces.h"
-#include "vtkOSPRayModule.h"
-
-class VTKOSPRAY_EXPORT vtkPVOSPRayOutlineRepresentation :
-  public vtkPVOSPRayRepresentation
-{
-public:
-  static vtkPVOSPRayOutlineRepresentation* New();
-  vtkTypeMacro(vtkPVOSPRayOutlineRepresentation, vtkPVOSPRayRepresentation);
-  void PrintSelf(ostream& os, vtkIndent indent);
-
-  virtual void SetRepresentation(const char*)
-    { this->Superclass::SetRepresentation("Wireframe"); }
-  virtual void SetUseOutline(int)
-    { this->Superclass::SetUseOutline(1); }
-  virtual void SetSuppressLOD(bool)
-    { this->Superclass::SetSuppressLOD(true); }
-  virtual void SetPickable(int)
-    { this->Superclass::SetPickable(0); }
-
-
-//BTX
-protected:
-  vtkPVOSPRayOutlineRepresentation();
-  ~vtkPVOSPRayOutlineRepresentation();
-
-    virtual void SetRepresentation(int)
-    { this->Superclass::SetRepresentation(WIREFRAME); }
-
-private:
-
-  vtkPVOSPRayOutlineRepresentation(const vtkPVOSPRayOutlineRepresentation&); // Not implemented.
-  void operator=(const vtkPVOSPRayOutlineRepresentation&); // Not implemented.
-
-//ETX
-};
-
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayRepresentation.cxx b/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayRepresentation.cxx
deleted file mode 100755
index abfbe6a11..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayRepresentation.cxx
+++ /dev/null
@@ -1,156 +0,0 @@
-/* ======================================================================================= 
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  
-   All rights reserved.
-                                                                                           
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     
-   except in compliance with the License.                                                  
-   A copy of the License is included with this software in the file LICENSE.               
-   If your copy does not contain the License, you may obtain a copy of the License at:     
-                                                                                           
-       http://opensource.org/licenses/BSD-3-Clause                                         
-                                                                                           
-   Unless required by applicable law or agreed to in writing, software distributed under   
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
-   KIND, either express or implied.                                                        
-   See the License for the specific language governing permissions and limitations under   
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-#include "vtkPVOSPRayRepresentation.h"
-
-#include "vtkCompositePolyDataMapper2.h"
-#include "vtkInformation.h"
-#include "vtkOSPRayCompositeMapper.h"
-#include "vtkOSPRayLODActor.h"
-#include "vtkOSPRayPolyDataMapper.h"
-#include "vtkOSPRayProperty.h"
-#include "vtkOSPRayManager.h"
-#include "vtkObjectFactory.h"
-
-//-----------------------------------------------------------------------------
-vtkStandardNewMacro(vtkPVOSPRayRepresentation);
-
-
-//-----------------------------------------------------------------------------
-vtkPVOSPRayRepresentation::vtkPVOSPRayRepresentation()
-{
-  vtkOSPRayManager::Singleton();
-  this->Mapper->Delete();
-  this->Mapper = vtkOSPRayCompositeMapper::New();
-  this->LODMapper->Delete();
-  this->LODMapper = vtkOSPRayCompositeMapper::New();
-
-  this->Actor->Delete();
-  this->Actor = vtkOSPRayLODActor::New();
-  this->Property->Delete();
-  this->Property = vtkOSPRayProperty::New();
-
-  this->Actor->SetMapper(this->Mapper);
-  this->Actor->SetLODMapper(this->LODMapper);
-  this->Actor->SetProperty(this->Property);
-
-  vtkInformation* keys = vtkInformation::New();
-  this->Actor->SetPropertyKeys(keys);
-  keys->Delete();
-
-  this->SetSuppressLOD(true);
-  this->SuppressLOD = true;
-}
-
-//-----------------------------------------------------------------------------
-vtkPVOSPRayRepresentation::~vtkPVOSPRayRepresentation()
-{
-}
-
-//-----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::PrintSelf(ostream& os, vtkIndent indent)
-{
-  this->Superclass::PrintSelf(os, indent);
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::SetMaterialType(char *newval)
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  OSPRayProperty->SetMaterialType(newval);
-}
-
-//----------------------------------------------------------------------------
-char * vtkPVOSPRayRepresentation::GetMaterialType()
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  return OSPRayProperty->GetMaterialType();
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::SetReflectance(double newval)
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  OSPRayProperty->SetReflectance(newval);
-}
-
-//----------------------------------------------------------------------------
-double vtkPVOSPRayRepresentation::GetReflectance()
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  return OSPRayProperty->GetReflectance();
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::SetThickness(double newval)
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  OSPRayProperty->SetThickness(newval);
-}
-
-//----------------------------------------------------------------------------
-double vtkPVOSPRayRepresentation::GetThickness()
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  return OSPRayProperty->GetThickness();
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::SetEta(double newval)
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  OSPRayProperty->SetEta(newval);
-}
-
-//----------------------------------------------------------------------------
-double vtkPVOSPRayRepresentation::GetEta()
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  return OSPRayProperty->GetEta();
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::SetN(double newval)
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  OSPRayProperty->SetN(newval);
-}
-
-//----------------------------------------------------------------------------
-double vtkPVOSPRayRepresentation::GetN()
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  return OSPRayProperty->GetN();
-}
-
-//----------------------------------------------------------------------------
-void vtkPVOSPRayRepresentation::SetNt(double newval)
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  OSPRayProperty->SetNt(newval);
-}
-
-//----------------------------------------------------------------------------
-double vtkPVOSPRayRepresentation::GetNt()
-{
-  vtkOSPRayProperty *OSPRayProperty = vtkOSPRayProperty::SafeDownCast(this->Property);
-  return OSPRayProperty->GetNt();
-}
diff --git a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayRepresentation.h b/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayRepresentation.h
deleted file mode 100755
index b16a3a007..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRay/vtkPVOSPRayRepresentation.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/* ======================================================================================= 
-   Copyright 2014-2015 Texas Advanced Computing Center, The University of Texas at Austin  
-   All rights reserved.
-                                                                                           
-   Licensed under the BSD 3-Clause License, (the "License"); you may not use this file     
-   except in compliance with the License.                                                  
-   A copy of the License is included with this software in the file LICENSE.               
-   If your copy does not contain the License, you may obtain a copy of the License at:     
-                                                                                           
-       http://opensource.org/licenses/BSD-3-Clause                                         
-                                                                                           
-   Unless required by applicable law or agreed to in writing, software distributed under   
-   the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
-   KIND, either express or implied.                                                        
-   See the License for the specific language governing permissions and limitations under   
-   limitations under the License.
-
-   pvOSPRay is derived from VTK/ParaView Los Alamos National Laboratory Modules (PVLANL)
-   Copyright (c) 2007, Los Alamos National Security, LLC
-   ======================================================================================= */
-
-// .NAME vtkPVOSPRayRepresentation - representation for OSPRay views
-// .SECTION Description
-// This replaces the GL mapper, actor and property for a display pipline
-// with the OSPRay versions of those so that the object can be drawn
-// in an OSPRay renderer within a pvOSPRay view
-
-#ifndef __vtkPVOSPRayRepresentation_h
-#define __vtkPVOSPRayRepresentation_h
-
-#include "vtkGeometryRepresentationWithFaces.h"
-#include "vtkOSPRayModule.h"
-
-class VTKOSPRAY_EXPORT vtkPVOSPRayRepresentation :
-  public vtkGeometryRepresentationWithFaces
-{
-public:
-  static vtkPVOSPRayRepresentation* New();
-  vtkTypeMacro(vtkPVOSPRayRepresentation, vtkGeometryRepresentationWithFaces);
-  void PrintSelf(ostream& os, vtkIndent indent);
-
-  // Description:
-  // control that ray traced rendering characteristics of this object
-  void SetMaterialType(char *);
-  char *GetMaterialType();
-  void SetReflectance(double );
-  double GetReflectance();
-  void SetThickness(double );
-  double GetThickness();
-  void SetEta(double);
-  double GetEta();
-  void SetN(double);
-  double GetN();
-  void SetNt(double);
-  double GetNt();
-  void SetOSPSuppressLOD(bool st) { this->SuppressLOD = st; }
-  bool GetOSPSuppressLOD() { return this->SuppressLOD; }
-
-
-//BTX
-protected:
-  vtkPVOSPRayRepresentation();
-  ~vtkPVOSPRayRepresentation();
-
-private:
-
-  vtkPVOSPRayRepresentation(const vtkPVOSPRayRepresentation&); // Not implemented.
-  void operator=(const vtkPVOSPRayRepresentation&); // Not implemented.
-
-//ETX
-};
-
-
-#endif
diff --git a/avt/Plotter/OSPRay/vtkOSPRayModule.h b/avt/Plotter/OSPRay/vtkOSPRayModule.h
deleted file mode 100644
index b1b3a97dc..000000000
--- a/avt/Plotter/OSPRay/vtkOSPRayModule.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#ifndef VTKOSPRAYMODULE_H
-#define VTKOSPRAYMODULE_H
-
-#define VTKOSPRAY_EXPORT 
-
-#include "ospray/ospray.h"
-#include "ospray/common/OSPCommon.h"
-
-#endif
